<!DOCTYPE html>
<html lang="en">
	<head>
        <meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="../../examples/main.css">
		<title>test</title>
	</head>
	<body>
		<div id="container"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "../examples/jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import Stats from 'three/addons/libs/stats.module.js';
			import { estimateBytesUsed } from 'three/addons/utils/BufferGeometryUtils.js';

            let renderer, scene, camera, controls, stats;
            let isDirty = true;

			const width = window.innerWidth;
            const height = window.innerHeight;

			init();
			render();

			function init() {
                initViewer();
                initObjects();
			}

            function initViewer() {
                // camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
                camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 1, 1000);
                camera.position.set( 0, 20, 300 );

                scene = new THREE.Scene();
                scene.matrixAutoUpdate = false;

                const axes = new THREE.AxesHelper(20);
                axes.matrixAutoUpdate = false;
                scene.add(axes);

                renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.setClearColor(0x333333);
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( width, height );
                renderer.domElement.style.touchAction = 'none';
                document.body.appendChild( renderer.domElement );

                controls = new OrbitControls( camera, renderer.domElement );
                controls.target.set( 0, 0, 0 );
                // controls.update();

                stats = new Stats();
                document.body.appendChild(stats.dom);

                controls.addEventListener( 'change', () => isDirty = true );
                window.addEventListener( 'resize', onWindowResize, false );
            }

            function initObjects() {
                const positions = [
                    -100, -100,
                    -100,  100,
                    -100,  100,
                     100,  100,
                     100,  100,
                     100, -100,
                     100, -100,
                    -100, -100,
                ];
                const geometry = new THREE.BufferGeometry();
                // 测试vec2是否正常通过shader编译
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 2));

                const material = new THREE.ShaderMaterial({
                    vertexShader: `
                        void main() {
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        void main() {
                            gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);
                        }
                    `
                });

				const line = new THREE.Line( geometry, material );
                line.position.x = 50;
                line.frustumCulled = false;
                line.matrixAutoUpdate = false;
                line.updateMatrix();
				scene.add( line );

                const mem = estimateBytesUsed(line.geometry);
                console.log(mem + ' bytes');
            }
            
			function onWindowResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                // camera.aspect = w / h;
                camera.left = -w / 2;
                camera.right = w / 2;
                camera.top = h / 2;
                camera.bottom = -h / 2;
                camera.updateProjectionMatrix();
                renderer.setSize( w, h );
                isDirty = true;
			}

			function render() {
                requestAnimationFrame(render);

                stats.begin();
                if (isDirty) {
                    isDirty = false;
                    renderer.render(scene, camera);
                }
                stats.end();
            }
		</script>
	</body>
</html>

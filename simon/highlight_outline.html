<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link type="text/css" rel="stylesheet" href="../../examples/main.css">
    <title>高亮</title>
</head>
<body>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <!-- <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script> -->

    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/plugins/": "../examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/plugins/controls/OrbitControls.js';
        import { GUI } from 'three/plugins/libs/lil-gui.module.min.js';
        import Stats from 'three/plugins/libs/stats.module.js';
        import { EffectComposer } from 'three/plugins/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/plugins/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/plugins/postprocessing/ShaderPass.js';
        import { FXAAShader } from 'three/plugins/shaders/FXAAShader.js';
        import defined from './common/defined.js';
        import { gpuPickId } from './common/picking.js';

        const vs = `
            attribute float id;
            uniform vec4 color;
            uniform bool enablePick;
            varying vec4 vColor;

            vec4 id2color(const float value) {
                int num = int(value);
                int r = num & 255;
                int g = (num >> 8) & 255;
                int b = (num >> 16) & 255;
                int a = (num >> 24) & 255;
                return vec4(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0, float(a) / 255.0);
            }

            void main() {
                if (enablePick) {
                    vColor = id2color(id);
                } else {
                    vColor = color;
                }
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const fs = `
            varying vec4 vColor;

            void main() {
                gl_FragColor = vColor;
            }
        `;

        const OutlineShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'pickIdTexture': { value: null }, //拾取pickId时的renderTarget.texture
                'pickIdColor': { value: new THREE.Vector4(0, 0, 0, 0) }, //当前拾取id对应的颜色
                'outlineColor': { value: new THREE.Vector4() },
                'resolution': { value: new THREE.Vector2(1 / 1024, 1 / 512) }
            },

            vertexShader: `
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,

            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform sampler2D pickIdTexture;
                uniform vec4 pickIdColor;
                uniform vec4 outlineColor;
                uniform vec2 resolution;
                varying vec2 vUv;

                bool selected(vec2 offset) {
                    // 注意要乘以255.0（将0~1转换到0~255进行比较）
                    vec4 idColor = texture2D(pickIdTexture, vUv + offset) * vec4(255.0);
                    return any(notEqual(pickIdColor, vec4(0.0))) && all(equal(pickIdColor, idColor));
                }
                
                void main() {
                    // 判断当前拾取像素与周围的8个像素
                    if (
                        !selected(vec2(0.0)) &&
                        (selected(resolution * vec2(-1.0, -1.0)) ||
                        selected(resolution * vec2(-1.0, 0.0)) ||
                        selected(resolution * vec2(-1.0, 1.0)) ||
                        selected(resolution * vec2(0.0, -1.0)) ||
                        selected(resolution * vec2(0.0, 1.0)) ||
                        selected(resolution * vec2(1.0, -1.0)) ||
                        selected(resolution * vec2(1.0, 0.0)) ||
                        selected(resolution * vec2(1.0, 1.0)))
                    ) {
                        gl_FragColor = outlineColor;
                    } else {
                        gl_FragColor = texture2D(tDiffuse, vUv);
                    }
                }
            `
        };

        let renderer, scene, camera, controls, stats;
        let composer, outlinePass, fxaaPass;
        let gui, guiData;
        let line;
        let isDirty = true;

        const pickIdRenderTarget = new THREE.WebGLRenderTarget();

        const selectObjects = [];

        const width = window.innerWidth;
        const height = window.innerHeight;

        init();
        render();

        function init() {
            initViewer();
            initObjects();
            initPostProcessing();
            initGUI();
        }

        function initViewer() {
            const aspect = width / height;
            // camera = new THREE.PerspectiveCamera( 45, aspect, 1, 1000 );
            const frustumSize = 300;
            camera = new THREE.OrthographicCamera(frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000);
            camera.position.set( 0, 20, 300 );

            scene = new THREE.Scene();
            scene.add(new THREE.AxesHelper(20));

            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setClearColor(0x333333);
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( width, height );
            renderer.domElement.style.touchAction = 'none';
            document.body.appendChild( renderer.domElement );

            controls = new OrbitControls( camera, renderer.domElement );
            controls.target.set( 0, 0, 0 );
            // controls.update();

            stats = new Stats();
            document.body.appendChild(stats.dom);

            controls.addEventListener( 'change', () => isDirty = true );
            window.addEventListener( 'resize', onWindowResize, false );
        }
        
        function initObjects() {
            // 最小id从1开始，排除0
            const vertexBuffer = new Float32Array([
                // x, y, z, id
                -100, -100, 0, 1,
                -100,  100, 0, 1,
                -100,  100, 0, 2,
                 100,  100, 0, 2,
                 100,  100, 0, 3,
                 100, -100, 0, 3,
                 100, -100, 0, 4,
                -100, -100, 0, 4,
            ]);

            const interleavedBuffer = new THREE.InterleavedBuffer(vertexBuffer, 4);
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.InterleavedBufferAttribute(interleavedBuffer, 3, 0));
            geometry.setAttribute('id', new THREE.InterleavedBufferAttribute(interleavedBuffer, 1, 3));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Vector4(1, 1, 1, 1) },
                    enablePick: { value: false }
                },
                vertexShader: vs,
                fragmentShader: fs,
            });

            line = new THREE.Line(geometry, material);
            scene.add(line);
        }

        function initPostProcessing() {
            composer = new EffectComposer(renderer);

            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            outlinePass = new ShaderPass(OutlineShader);
            outlinePass.uniforms.outlineColor.value.set(0.14, 0.65, 0.88, 0.6);
            outlinePass.uniforms.resolution.value.set(1 / width, 1 / height);
            composer.addPass(outlinePass);

            fxaaPass = new ShaderPass(FXAAShader);
            fxaaPass.uniforms.resolution.value.set(1 / width, 1 / height);
            // composer.addPass(fxaaPass);
        }

        function initGUI() {
            gui = new GUI();
            guiData = {
                pick: false,
            };
            gui.add(guiData, 'pick').onChange((value) => {
                if (value) {
                    renderer.domElement.addEventListener('pointermove', onPointerMove);
                    renderer.domElement.style.cursor = 'pointer';
                } else {
                    renderer.domElement.removeEventListener('pointermove', onPointerMove);
                    renderer.domElement.style.cursor = 'default';
                }
            });
        }

        function onWindowResize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize( w, h );
            composer.setSize( w, h );
            outlinePass.uniforms.resolution.value.set(1 / w, 1 / h);
            fxaaPass.uniforms.resolution.value.set(1 / w, 1 / h);
            isDirty = true;
        }

        function onPointerMove(event) {
            line.material.uniforms.enablePick.value = true;
            const { pickId, pickIdColor } = gpuPickId({
                camera,
                renderer,
                selectObject: scene,
                x: event.clientX,
                y: event.clientY,
                pickSize: 5,
                pickRenderTarget: pickIdRenderTarget
            });
            console.log(pickId);
            line.material.uniforms.enablePick.value = false;

            outlinePass.uniforms.pickIdTexture.value = pickIdRenderTarget.texture;
            outlinePass.uniforms.pickIdColor.value.fromArray(pickIdColor);
            isDirty = true;
        }

        function render() {
            requestAnimationFrame(render);

            stats.begin();
            if (isDirty) {
                isDirty = false;
                // renderer.render( scene, camera );
                composer.render();
            }
            stats.end();
        }

        window.renderer = renderer;
    </script>
</body>
</html>
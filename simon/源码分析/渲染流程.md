# WebGPU普通渲染API调用流程

* new WebGPURenderer() ->
    * new WebGPUBackend() ->
        * new WebGPUUtils()
        * new WebGPUAttributeUtils()
        * new WebGPUBindingUtils()
        * new WebGPUPipelineUtils()
        * new WebGPUTextureUtils()
    * super() ->
        * new NodeLibrary()
        * new Lighting()
        * new QuadMesh(new NodeMaterial())
    * new StandardNodeLibrary()

* Renderer.setAnimationLoop() ->
    * await Renderer.init() ->
        * await WebGPUBackend.init() ->
            * await GPU.requestAdapter()
            * await GPUAdapter.requestDevice()
            * canvas.getContext('webgpu')
            * GPU.getPreferredCanvasFormat()
            * GPUCanvasContext.configure()
            * GPUDevice.createTexture()
        * new Nodes()
        * new Animation()
        * new Attributes()
        * new Background()
        * new Geometries()
        * new Textures()
        * new Pipelines()
        * new Bindings()
        * new RenderObjects()
        * new RenderLists()
        * new RenderBundles()
        * new RenderContexts()
        * Animation.start() ->
            * requestAnimationFrame()
            * this._animationLoop?.()
    * Animation.setAnimationLoop()

* Renderer.render() -> Renderer._renderScene() ->
    * RenderList.begin()
    * Renderer._projectObject()
        * if (isLOD) -> LOD.update()
        * else if (isLight) -> RenderList.pushLight()
        * else if (isMesh || isLine || isPoints) -> RenderList.push()
        * if (isBundleGroup) RenderList.pushBundle()
    * RenderList.finish()
    * if (Renderer.sortObjects) -> RenderList.sort()
    * Textures.updateRenderTarget() -> Textures.updateTexture() ->
        * WebGPUTextureUtils.createSampler() -> GPUDevice.createSampler()
        * WebGPUTextureUtils.createTexture() -> GPUDevice.createTexture()
        * WebGPUTextureUtils.updateTexture() ->
            * GPUQueue.writeTexture()
            * GPUQueue.copyExternalImageToTexture()
            * if (flipY) -> WebGPUTexturePassUtils.flipY() ->
                * GPUDevice.createRenderPipeline()
                * GPUTexture.createView()
                * GPUDevice.createCommandEncoder()
                * GPURenderPipeline.getBindGroupLayout()
                * GPUDevice.createBindGroup()
                * GPUCommandEncoder.beginRenderPass()
                * GPURenderPassEncoder.setPipeline()
                * GPURenderPassEncoder.setBindGroup()
                * GPURenderPassEncoder.draw()
                * GPURenderPassEncoder.end()
                * GPUQueue.submit([GPUCommandEncoder.finish()])
        * WebGPUTextureUtils.generateMipmaps() ->
            * if (needsMipmaps) -> WebGPUTexturePassUtils.generateMipmaps() ->
                * for () ->
                    * GPUDevice.createRenderPipeline()
                    * GPURenderPipeline.getBindGroupLayout()
                    * GPUTexture.createView()
                    * GPUDevice.createBindGroup()
                    * GPUDevice.createRenderBundleEncoder()
                    * GPURenderBundleEncoder.setPipeline()
                    * GPURenderBundleEncoder.setBindGroup()
                    * GPURenderBundleEncoder.draw()
                    * GPURenderBundleEncoder.finish()
                * GPUDevice.createCommandEncoder()
                * for () ->
                    * GPUCommandEncoder.beginRenderPass()
                    * GPURenderPassEncoder.executeBundles()
                    * GPURenderPassEncoder.end()
                * GPUQueue.submit([GPUCommandEncoder.finish()])
    * Nodes.updateScene() ->
        * Nodes.updateEnvironment()
        * Nodes.updateFog()
        * Nodes.updateBackground()
    * Background.update() ->
        * Nodes.getBackgroundNode()
        * if (background.isNode) -> RenderList.unshift()
    * WebGPUBackend.beginRender() ->
        * GPUDevice.createQuerySet()
        * GPUDevice.createCommandEncoder()
        * GPUCommandEncoder.beginRenderPass()
        * GPURenderPassEncoder.setViewport()
        * GPURenderPassEncoder.setScissorRect()
    * if (bundles.length > 0) -> Renderer._renderBundles() -> Renderer._renderBundle() ->
        * if (renderBundleNeedsUpdate) ->
            * WebGPUBackend.beginBundle() ->
            * Renderer._renderObjects() ->
            * WebGPUBackend.finishBundle() ->
        * else -> if (Nodes.needsRefresh()) ->
            * Nodes.updateBefore() ->
            * Nodes.updateForRender() ->
            * Bindings.updateForRender() ->
            * Nodes.updateAfter() ->
        * WebGPUBackend.addBundle() ->
    * Renderer._renderObjects() -> Renderer.renderObject() -> Renderer._renderObjectDirect() ->
        * const needsRefresh = Nodes.needsRefresh() ->
            * RenderObject.getMonitor() -> RenderObject.getNodeBuilderState() ->
                * Nodes.getForRender() ->
                    * new WGSLNodeBuilder()
                    * NodeBuilder.buile() ->
                        * NodeLibrary.fromMaterial();
                        * NodeMaterial.build() -> NodeMaterial.setup() ->
        * if (needsRefresh) ->
            * Nodes.updateBefore() ->
            * Geometries.updateForRender() ->
                * Geometries.initGeometry()
                * Geometries.updateAttributes() -> Geometries.updateAttribute() ->
                    * Attributes.update() ->
                        * WebGPUAttributeUtils.createAttribute() ->
                            * GPUDevice.createBuffer()
                            * GPUBuffer.getMappedRange()
                            * GPUBuffer.unmap()
                        * WebGPUAttributeUtils.updateAttribute() ->
                            * GPUQueue.writeBuffer()
                            * BufferAttribute.clearUpdateRanges()
            * Nodes.updateForRender() ->
            * Bindings.updateForRender() ->
                * if (isSampledTexture) -> Textures.updateTexture() ->
                * if (isStorageBuffer) Attributes.update() ->
                * WebGPUBindingUtils.createBindings() ->
                    * GPUDevice.createBindGroupLayout()
                    * if (isUniformBuffer) -> GPUDevice.createBuffer()
                    * if (isSampledTexture) ->
                        * if (externalTexture) -> GPUDevice.importExternalTexture()
                        * else -> GPUTexture.createView()
                    * GPUDevice.createBindGroup()
                * if (isNodeUniformsGroup) -> Nodes.updateGroup() ->
                * if (isUniformBuffer) -> WebGPUBindingUtils.updateBinding() ->
                    * GPUQueue.writeBuffer()
                * if (isSampledTexture) ->
                    * Textures.updateTexture() ->
                    * if (isStorageTexture && !store) -> WebGPUTextureUtils.generateMipmaps() ->
        * Pipelines.updateForRender() ->
            * WebGPUBackend.createProgram() ->
                * GPUDevice.createShaderModule()
            * WebGPUPipelineUtils.createRenderPipeline() ->
                * GPUDevice.createPipelineLayout()
                * GPUDevice.createRenderPipeline()
                * GPUDevice.createRenderPipelineAsync()
        * WebGPUBackend.draw() ->
            * GPURenderPassEncoder.setPipeline()
            * GPURenderPassEncoder.setBindGroup()
            * GPURenderPassEncoder.setIndexBuffer()
            * GPURenderPassEncoder.setVertexBuffer()
            * GPURenderPassEncoder.endOcclusionQuery()
            * GPURenderPassEncoder.beginOcclusionQuery()
            * GPURenderPassEncoder.drawIndexed()
            * GPURenderPassEncoder.drawIndexedIndirect()
            * GPURenderPassEncoder.drawIndirect()
            * GPURenderPassEncoder.draw()
            * Info.update() ->
        * if (needsRefresh) ->
            * Nodes.updateAfter() ->
    * WebGPUBackend.finishRender() ->
        * GPURenderPassEncoder.executeBundles()
        * GPURenderPassEncoder.endOcclusionQuery()
        * GPURenderPassEncoder.end()
        * if (occlusionQueryCount > 0) ->
            * GPUDevice.createBuffer()
            * GPUCommandEncoder.resolveQuerySet()
            * GPUCommandEncoder.copyBufferToBuffer()
            * GPUBuffer.mapAsync()
            * GPUBuffer.getMappedRange()
            * GPUBuffer.destroy()
        * if (trackTimestamp) ->
            * GPUDevice.createBuffer()
            * GPUCommandEncoder.resolveQuerySet()
            * GPUCommandEncoder.copyBufferToBuffer()
        * GPUQueue.submit([GPUCommandEncoder.finish()])
        * WebGPUTextureUtils.generateMipmaps() ->
    * if (frameBufferTarget) ->
        * if (Nodes.hasOutputChange()) -> Nodes.getOutputNode() ->
        * Renderer._renderScene() ->

<!DOCTYPE html>
<html lang="en">
	<head>
        <meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="../examples/main.css">
		<title>gltf</title>
	</head>
	<body>
		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "../examples/jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import Stats from 'three/addons/libs/stats.module.js';
			import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { estimateBytesUsed } from 'three/addons/utils/BufferGeometryUtils.js';

            let renderer, scene, camera, controls, stats;
            let isDirty = true;

			const width = window.innerWidth;
            const height = window.innerHeight;

			init();
			render();

			function init() {
                initViewer();
                initObjects();
			}

            function initViewer() {
                // camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
                camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 1, 1000000);
                camera.position.set( 0, 20, 300000 );

                scene = new THREE.Scene();
                scene.matrixAutoUpdate = false;

                const axes = new THREE.AxesHelper(20);
                axes.matrixAutoUpdate = false;
                scene.add(axes);

                renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.setClearColor(0x333333);
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( width, height );
                renderer.domElement.style.touchAction = 'none';
                document.body.appendChild( renderer.domElement );

                controls = new OrbitControls( camera, renderer.domElement );
                controls.target.set( 0, 0, 0 );
                controls.enableRotate = false;
                // controls.update();

                stats = new Stats();
                document.body.appendChild(stats.dom);

                controls.addEventListener( 'change', () => isDirty = true );
                window.addEventListener( 'resize', onWindowResize, false );

                window.renderer = renderer;
            }

            async function initObjects() {
                // const rgbeLoader = new RGBELoader().setPath('../examples/textures/equirectangular/')
                // const envMap = await rgbeLoader.loadAsync('royal_esplanade_1k.hdr');
                // envMap.mapping = THREE.EquirectangularReflectionMapping;
                // scene.background = envMap;
				// scene.environment = envMap;

                // const gltfLoader = new GLTFLoader().setPath('../examples/models/gltf/DamagedHelmet/glTF/');
                // const gltf = await gltfLoader.loadAsync('DamagedHelmet.gltf');
                // gltf.scene.scale.setScalar(50);
                // scene.add(gltf.scene);
                // isDirty = true;

                const gltfLoader = new GLTFLoader().setPath('models/gltf/drawing_test1/');
                const gltf = await gltfLoader.loadAsync('drawing.gltf');
                console.log(gltf)
                scene.add(gltf.scene);
                isDirty = true;

                // const mem = estimateBytesUsed(line.geometry);
                // console.log(mem + ' bytes');
            }
            
			function onWindowResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                if (camera.isOrthographicCamera) {
                    camera.left = -w / 2;
                    camera.right = w / 2;
                    camera.top = h / 2;
                    camera.bottom = -h / 2;
                } else {
                    camera.aspect = w / h;
                }
                camera.updateProjectionMatrix();
                renderer.setSize( w, h );
                isDirty = true;
			}

			function render() {
                requestAnimationFrame(render);

                stats.begin();
                if (isDirty) {
                    isDirty = false;
                    renderer.render(scene, camera);
                }
                stats.end();
            }
		</script>
	</body>
</html>

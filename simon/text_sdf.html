<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link type="text/css" rel="stylesheet" href="../../examples/main.css">
    <title>SDF文字</title>
    <style>
        #toolbar {
            position: absolute;
            left: 50%;
            top: 10px;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <button id="screenshot">screenshot</button>
    </div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "troika": "../build/troika.module.js",
                "three/plugins/": "../examples/jsm/"
            }
        }
    </script>

    <!-- 参考：https://www.npmjs.com/package/troika-three-text -->

    <script type="module">
        import * as THREE from 'three';
        import { preloadFont, Text, getCaretAtPoint, getSelectionRects } from 'troika';
        import { OrbitControls } from 'three/plugins/controls/OrbitControls.js';
        import { GUI } from 'three/plugins/libs/lil-gui.module.min.js';
        import Stats from 'three/plugins/libs/stats.module.js';
        import screenshot from './common/screenshot.js';

        let renderer, scene, camera, controls, stats;
        let gui, guiData;
        let textMesh;
        let isDirty = false;

        // const fontUrl = './fonts/msyhl_mini.ttf' // 微软雅黑细体
        // const fontUrl = './fonts/simfang_min.woff'
        const fontUrl = './fonts/FZFSJW_min.woff'

        init();
        render();

        function init() {
            const aspect = window.innerWidth / window.innerHeight;
            // camera = new THREE.PerspectiveCamera( 45, aspect, 1, 1000 );
            const frustumSize = 200;
            camera = new THREE.OrthographicCamera(frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000);
            camera.position.set( 0, 20, 200 );

            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xf0f0f0 );
            scene.add(new THREE.AxesHelper(20));

            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            controls = new OrbitControls( camera, renderer.domElement );
            controls.target.set( 0, 0, 0 );
            // controls.update();

            stats = new Stats();
            document.body.appendChild(stats.dom);

            controls.addEventListener( 'change', () => isDirty = true );
            window.addEventListener( 'resize', onWindowResize );

            initGUI();
            initText();
        }

        function initGUI() {
            gui = new GUI();
            guiData = {
                text: '12340',
                anchorY: 'bottom-baseline'
            };

            gui.add(guiData, 'text', {
                'test0': '12340', // 注意：要与上面的文字一样
                'test1': '测量标注文字：面积周长m²°12340.0000',
                'test2': '此处图元缺失',
                'test3': `多文字测试多文字测试多文字测试多文字测试多文字测试多文字测试多文字测试多文字测试多文字测试`
            }).name('切换文字').onChange(updateText);

            gui.add(guiData, 'anchorY', [
                'bottom-baseline',
                'middle'
            ]).name('垂直位置').onChange(updateTextAnchorY);
        }

        function initText() {
            // 方式一：默认方式
            // createText(guiData.text);

            // 方式二：指定字体
            createText(guiData.text, fontUrl);

            // 方式三：预处理。参考：https://discourse.threejs.org/t/how-to-preloadfont-in-troika-three-text/22500
            // preloadFont({
            //     font: fontUrl,
            //     // characters: guiData.text
            // }, (payload) => {
            //     // createText(guiData.text, payload.parameters.font);
            //     createText(guiData.text, fontUrl);
            // });
        }

        function createText(text, fontUrl = undefined) {
            textMesh = new Text();
            scene.add(textMesh);
            if (fontUrl) {
                textMesh.font = fontUrl;
            }
            textMesh.text = text;
            textMesh.fontSize = 6; // default is 0.1
            textMesh.color = 0x00ffff;
            textMesh.anchorX = 'center';
            textMesh.anchorY = 'bottom-baseline';
            // textMesh.outlineWidth = 0.01;
            textMesh.strokeWidth = 0.01;
            textMesh.material.side = THREE.FrontSide;
            // textMesh.sync(() => {
            //     // const info = textMesh.textRenderInfo; 
            //     // console.log(info);
            //     // console.log(getCaretAtPoint(info, 10, 10));
            //     // console.log(getSelectionRects(info, 0, 7));
            //     isDirty = true;
            // });
            textMesh.sync();
            // 每次调用sync()会触发synccomplete事件
            textMesh.addEventListener('synccomplete', () => {
                console.log('text sync');
                isDirty = true;
            });
        }

        function updateText(text) {
            textMesh.text = text;
            textMesh.sync();
        }

        function updateTextAnchorY(value) {
            textMesh.anchorY = value;
            textMesh.sync();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            isDirty = true;
        }

        function render() {
            requestAnimationFrame(render);

            stats.begin();
            if (isDirty) {
                isDirty = false;
                renderer.render( scene, camera );
            }
            stats.end();
        }

        document.getElementById('screenshot').onclick = () => {
            renderer.render( scene, camera );
            screenshot({ renderer });
        };

        window.renderer = renderer;
    </script>
</body>
</html>
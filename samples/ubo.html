<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>ubo sample</title>
	<link type="text/css" rel="stylesheet" href="../examples/main.css">
</head>
<body>
	<script type="importmap">
		{
			"imports": {
				"three": "../src/Three.js",
				"three/addons/": "../examples/jsm/"
			}
		}
	</script>

	<script type="module">
		import {
			// OrthographicCamera,
			PerspectiveCamera,
			Scene,
			WebGLRenderer,
			Uniform,
			UniformsGroup,
			AxesHelper,
			BoxGeometry,
			RawShaderMaterial,
			Mesh,
			Color,
			Vector3,
			GLSL3,
			TextureLoader,
			SRGBColorSpace
		} from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import Stats from 'three/addons/libs/stats.module.js';

		let renderer, scene, camera, controls, stats;
		let mesh;
		let isDirty = true;
		let lastTime = performance.now();
		let shininessUniform;

		const width = window.innerWidth;
		const height = window.innerHeight;

		init();
		render();

		function init() {

			initViewer();
			initObjects();
			initGUI();
		
		}

		function initViewer() {

			camera = new PerspectiveCamera( 45, width / height, 0.1, 1000 );
			// camera = new OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, 0.1, 1000 );
			camera.position.set( 0, 1, 3 );

			scene = new Scene();
			scene.matrixAutoUpdate = false;
			/* NOTE: 场景中的所有物体需要手动调用 updateMatrixWorld() */
			scene.matrixWorldAutoUpdate = false;

			const axes = new AxesHelper( 10 );
			axes.matrixAutoUpdate = false;
			// scene.add( axes );

			renderer = new WebGLRenderer( { antialias: true } );
			renderer.setClearColor( 0x333333 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( width, height );
			renderer.domElement.style.touchAction = 'none';
			document.body.appendChild( renderer.domElement );

			controls = new OrbitControls( camera, renderer.domElement );
			controls.target.set( 0, 0, 0 );
			// controls.update();

			stats = new Stats();
			document.body.appendChild( stats.dom );

			controls.addEventListener( 'change', () => isDirty = true );
			window.addEventListener( 'resize', onWindowResize, false );

		}

		function initObjects() {

			// ubo. 相机和光照相关数据是使用UBO的完美例子，只需存储一次数据便可以在所有着色器程序中共享

			const cameraUniformsGroup = new UniformsGroup();
			cameraUniformsGroup.setName( 'ViewData' );
			cameraUniformsGroup.add( new Uniform( camera.projectionMatrix ) );
			cameraUniformsGroup.add( new Uniform( camera.matrixWorldInverse ) ); // viewMatrix

			const lightingUniformsGroup = new UniformsGroup();
			lightingUniformsGroup.setName( 'LightingData' );
			lightingUniformsGroup.add( new Uniform( new Vector3( 0, 0, 10 ) ) ); // light position
			lightingUniformsGroup.add( new Uniform( new Color( 0x7c7c7c ) ) ); // ambient color
			lightingUniformsGroup.add( new Uniform( new Color( 0xd5d5d5 ) ) ); // diffuse color
			lightingUniformsGroup.add( new Uniform( new Color( 0xe7e7e7 ) ) ); // specular color
			shininessUniform = new Uniform( 64 );
			lightingUniformsGroup.add( shininessUniform ); // shininess

			//
		
			const material = new RawShaderMaterial( {
				glslVersion: GLSL3,
				uniformsGroups: [ cameraUniformsGroup, lightingUniformsGroup ],
				/* NOTE: 先定义后赋值 */
				uniforms: {
					modelMatrix: { value: null },
					normalMatrix: { value: null },
					color: { value: null }
				},
				vertexShader: `
precision highp float;

/**
 * NOTE: 如果没有实例化(即没有指定MVP), 通过program获取的激活的uniform会包含projectionMatrix, viewMatrix
 * 如果指定了MVP, 通过program获取的激活的uniform只有ViewData
 * 
 * 可以不指定layout(std140)
 */
layout(std140) uniform ViewData {
	mat4 projectionMatrix;
	mat4 viewMatrix;
} MVP;

uniform mat4 modelMatrix;
uniform mat3 normalMatrix;

in vec3 position;
in vec3 normal;

out vec3 vPositionEye;
out vec3 vNormalEye;

void main() {
	vec4 positionEye = MVP.viewMatrix * modelMatrix * vec4( position, 1.0 );
	vPositionEye = positionEye.xyz;
	vNormalEye = normalMatrix * normal;
	gl_Position = MVP.projectionMatrix * positionEye;
}
				`,
				fragmentShader: `
precision highp float;

vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

layout(std140) uniform LightingData {
	vec3 position;
	vec3 ambientColor;
	vec3 diffuseColor;
	vec3 specularColor;
	float shininess;
} Light;

uniform vec3 color;

in vec3 vPositionEye;
in vec3 vNormalEye;

out vec4 fragColor;

void main() {
	// Phong reflection model

	vec3 l = normalize( Light.position - vPositionEye );
	vec3 n = normalize( vNormalEye );
	vec3 e = - normalize( vPositionEye );
	vec3 r = normalize( reflect( - l, n ) );

	float diffuseLightWeighting = max( dot( n, l ), 0.0 );
	float specularLightWeighting = max( dot( r, e ), 0.0 );
	specularLightWeighting = pow( specularLightWeighting, Light.shininess );

	vec3 lightWeighting = Light.ambientColor +
		Light.diffuseColor * diffuseLightWeighting +
		Light.specularColor * specularLightWeighting;

	fragColor = vec4( color.rgb * lightWeighting.rgb, 1.0 );
	fragColor = LinearTosRGB( fragColor );
}
				`,
			} );

			const geometry = new BoxGeometry();

			mesh = new Mesh( geometry, material );
			mesh.name = 'mesh';
			mesh.matrixAutoUpdate = false;

			mesh.material.uniforms.modelMatrix.value = mesh.matrixWorld; // 引用，后续只需要更新mesh.mtrixWorld即可
			mesh.material.uniforms.normalMatrix.value = mesh.normalMatrix; // 引用
			mesh.material.uniforms.color.value = new Color( 0x009999 );

			scene.add( mesh );

			const material2 = new RawShaderMaterial( {
				glslVersion: GLSL3,
				uniformsGroups: [ cameraUniformsGroup, lightingUniformsGroup ],
				/* NOTE: 先定义后赋值 */
				uniforms: {
					modelMatrix: { value: null },
					normalMatrix: { value: null },
					diffuseMap: { value: null }
				},
				vertexShader: `
precision highp float;

/**
 * NOTE: 如果没有实例化(即没有指定MVP), 通过program获取的激活的uniform会包含projectionMatrix, viewMatrix
 * 如果指定了MVP, 通过program获取的激活的uniform只有ViewData
 * 
 * 可以不指定layout(std140)
 */
layout(std140) uniform ViewData {
	mat4 projectionMatrix;
	mat4 viewMatrix;
} MVP;

uniform mat4 modelMatrix;
uniform mat3 normalMatrix;

in vec3 position;
in vec3 normal;
in vec2 uv;

out vec3 vPositionEye;
out vec3 vNormalEye;
out vec2 vUv;

void main() {
	vec4 positionEye = MVP.viewMatrix * modelMatrix * vec4( position, 1.0 );
	vPositionEye = positionEye.xyz;
	vNormalEye = normalMatrix * normal;
	vUv = uv;
	gl_Position = MVP.projectionMatrix * positionEye;
}
				`,
				fragmentShader: `
precision highp float;

vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

layout(std140) uniform LightingData {
	vec3 position;
	vec3 ambientColor;
	vec3 diffuseColor;
	vec3 specularColor;
	float shininess;
} Light;

uniform sampler2D diffuseMap;

in vec3 vPositionEye;
in vec3 vNormalEye;
in vec2 vUv;

out vec4 fragColor;

void main() {
	// Phong reflection model

	vec3 l = normalize( Light.position - vPositionEye );
	vec3 n = normalize( vNormalEye );
	vec3 e = - normalize( vPositionEye );
	vec3 r = normalize( reflect( - l, n ) );

	float diffuseLightWeighting = max( dot( n, l ), 0.0 );
	float specularLightWeighting = max( dot( r, e ), 0.0 );
	specularLightWeighting = pow( specularLightWeighting, Light.shininess );

	vec3 lightWeighting = Light.ambientColor +
		Light.diffuseColor * diffuseLightWeighting +
		Light.specularColor * specularLightWeighting;

	fragColor = vec4( texture( diffuseMap, vUv ).rgb * lightWeighting.rgb, 1.0 );
	fragColor = LinearTosRGB( fragColor );
}
				`,
			} );

			const mesh2 = new Mesh( geometry, material2 );
			mesh2.name = 'mesh2';
			mesh2.matrixAutoUpdate = false;
			mesh2.position.x = - 2;
			mesh2.updateMatrix();
			/* NOTE: 由于scene.matrixWorldAutoUpdate为false，需要手动更新世界矩阵 */
			mesh2.updateMatrixWorld();

			mesh2.material.uniforms.modelMatrix.value = mesh2.matrixWorld; // 引用，后续只需要更新mesh.mtrixWorld即可
			mesh2.material.uniforms.normalMatrix.value = mesh2.normalMatrix; // 引用

			const texture = new TextureLoader().load( '../examples/textures/crate.gif', () => isDirty = true );
			texture.colorSpace = SRGBColorSpace;
			mesh2.material.uniforms.diffuseMap.value = texture;

			scene.add( mesh2 );

		}

		function initGUI() {

			const gui = new GUI();
			const gui_options = {
				'translate': () => {

					mesh.position.x += 1;
					mesh.updateMatrix();
					/* NOTE: 由于scene.matrixWorldAutoUpdate为false，需要手动更新世界矩阵 */
					mesh.updateMatrixWorld();
					isDirty = true;

				},
				'shininess': 64
			};
			gui.add( gui_options, 'translate' );
			gui.add( gui_options, 'shininess', 0, 256 ).step( 10 ).onChange( ( value ) => {

				shininessUniform.value = value;
				isDirty = value;

			} );

		}

		function onWindowResize() {

			const w = window.innerWidth;
			const h = window.innerHeight;
			camera.aspect = w / h;
			// camera.left = - w / 2;
			// camera.right = w / 2;
			// camera.top = h / 2;
			// camera.bottom = - h / 2;
			camera.updateProjectionMatrix();
			renderer.setSize( w, h );
			isDirty = true;
		
		}

		function render() {
		
			requestAnimationFrame( render );

			const now = performance.now();
			if ( now - lastTime < 10 ) return;
			lastTime = now;

			stats.begin();
		
			if ( isDirty ) {

				isDirty = false;
				renderer.render( scene, camera );

			}

			stats.end();

		}

		window.renderer = renderer;
		window.scene = scene;
	</script>
</body>
</html>

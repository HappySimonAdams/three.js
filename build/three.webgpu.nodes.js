/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
import { Color, Vector2, Vector3, Vector4, Matrix3, Matrix4, EventDispatcher, MathUtils, ColorManagement, SRGBTransfer, NoToneMapping, StaticDrawUsage, InterleavedBuffer, DynamicDrawUsage, InterleavedBufferAttribute, NoColorSpace, UnsignedIntType, IntType, WebGLCoordinateSystem, BackSide, CubeReflectionMapping, CubeRefractionMapping, WebGPUCoordinateSystem, TangentSpaceNormalMap, ObjectSpaceNormalMap, InstancedInterleavedBuffer, InstancedBufferAttribute, DataArrayTexture, FloatType, FramebufferTexture, LinearMipmapLinearFilter, DepthTexture, Material, NormalBlending, PointsMaterial, LineBasicMaterial, LineDashedMaterial, NoBlending, MeshNormalMaterial, WebGLCubeRenderTarget, BoxGeometry, Mesh, Scene, LinearFilter, CubeCamera, CubeTexture, EquirectangularReflectionMapping, EquirectangularRefractionMapping, AddOperation, MixOperation, MultiplyOperation, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, Texture, MeshStandardMaterial, MeshPhysicalMaterial, MeshToonMaterial, MeshMatcapMaterial, SpriteMaterial, ShadowMaterial, Uint32BufferAttribute, Uint16BufferAttribute, DoubleSide, DepthStencilFormat, DepthFormat, UnsignedInt248Type, UnsignedByteType, RenderTarget, Plane, Object3D, HalfFloatType, LinearMipMapLinearFilter, OrthographicCamera, BufferGeometry, Float32BufferAttribute, BufferAttribute, UVMapping, Euler, LinearSRGBColorSpace, LessCompare, VSMShadowMap, RGFormat, BasicShadowMap, SphereGeometry, CubeUVReflectionMapping, PerspectiveCamera, RGBAFormat, LinearMipmapNearestFilter, NearestMipmapLinearFilter, Float16BufferAttribute, REVISION, SRGBColorSpace, PCFShadowMap, FrontSide, Frustum, DataTexture, RedIntegerFormat, RedFormat, RGIntegerFormat, RGBIntegerFormat, RGBFormat, RGBAIntegerFormat, UnsignedShortType, ByteType, ShortType, createCanvasElement, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, SrcAlphaFactor, SrcAlphaSaturateFactor, DstColorFactor, DstAlphaFactor, OneMinusSrcColorFactor, OneMinusSrcAlphaFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor, CullFaceNone, CullFaceBack, CullFaceFront, CustomBlending, MultiplyBlending, SubtractiveBlending, AdditiveBlending, NotEqualDepth, GreaterDepth, GreaterEqualDepth, EqualDepth, LessEqualDepth, LessDepth, AlwaysDepth, NeverDepth, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt5999Type, AlphaFormat, LuminanceFormat, LuminanceAlphaFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NeverCompare, AlwaysCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare, warnOnce, NotEqualStencilFunc, GreaterStencilFunc, GreaterEqualStencilFunc, EqualStencilFunc, LessEqualStencilFunc, LessStencilFunc, AlwaysStencilFunc, NeverStencilFunc, DecrementWrapStencilOp, IncrementWrapStencilOp, DecrementStencilOp, IncrementStencilOp, InvertStencilOp, ReplaceStencilOp, ZeroStencilOp, KeepStencilOp, MaxEquation, MinEquation, SpotLight, PointLight, DirectionalLight, RectAreaLight, AmbientLight, HemisphereLight, LightProbe, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, AgXToneMapping, NeutralToneMapping, Group, Loader, FileLoader, MaterialLoader, ObjectLoader } from './three.core.js';
export { AdditiveAnimationBlendMode, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BasicDepthPacking, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxHelper, BufferGeometryLoader, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CircleGeometry, Clock, ColorKeyframeTrack, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeTextureLoader, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceFrontBack, Curve, CurvePath, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataTextureLoader, DataUtils, DefaultLoadingManager, DetachedBindMode, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DynamicCopyUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, ExtrudeGeometry, Fog, FogExp2, GLBufferAttribute, GLSL1, GLSL3, GridHelper, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, InstancedBufferGeometry, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, KeyframeTrack, LOD, LatheGeometry, Layers, Light, Line, Line3, LineCurve, LineCurve3, LineLoop, LineSegments, LinearInterpolant, LinearMipMapNearestFilter, LinearTransfer, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, Matrix2, MeshDepthMaterial, MeshDistanceMaterial, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NormalAnimationBlendMode, NumberKeyframeTrack, OctahedronGeometry, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, PCFSoftShadowMap, Path, PlaneGeometry, PlaneHelper, PointLightHelper, Points, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RGBADepthPacking, RGBDepthPacking, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGDepthPacking, RawShaderMaterial, Ray, Raycaster, RingGeometry, ShaderMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, Spherical, SphericalHarmonics3, SplineCurve, SpotLightHelper, Sprite, StaticCopyUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, TOUCH, TetrahedronGeometry, TextureLoader, TextureUtils, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding } from './three.core.js';

const refreshUniforms = [
	'alphaMap',
	'alphaTest',
	'anisotropy',
	'anisotropyMap',
	'anisotropyRotation',
	'aoMap',
	'attenuationColor',
	'attenuationDistance',
	'bumpMap',
	'clearcoat',
	'clearcoatMap',
	'clearcoatNormalMap',
	'clearcoatNormalScale',
	'clearcoatRoughness',
	'color',
	'dispersion',
	'displacementMap',
	'emissive',
	'emissiveMap',
	'envMap',
	'gradientMap',
	'ior',
	'iridescence',
	'iridescenceIOR',
	'iridescenceMap',
	'iridescenceThicknessMap',
	'lightMap',
	'map',
	'matcap',
	'metalness',
	'metalnessMap',
	'normalMap',
	'normalScale',
	'opacity',
	'roughness',
	'roughnessMap',
	'sheen',
	'sheenColor',
	'sheenColorMap',
	'sheenRoughnessMap',
	'shininess',
	'specular',
	'specularColor',
	'specularColorMap',
	'specularIntensity',
	'specularIntensityMap',
	'specularMap',
	'thickness',
	'transmission',
	'transmissionMap'
];

class NodeMaterialObserver {

	constructor( builder ) {

		this.renderObjects = new WeakMap();
		this.hasNode = this.containsNode( builder );
		this.hasAnimation = builder.object.isSkinnedMesh === true;
		this.refreshUniforms = refreshUniforms;
		this.renderId = 0;

	}

	firstInitialization( renderObject ) {

		const hasInitialized = this.renderObjects.has( renderObject );

		if ( hasInitialized === false ) {

			this.getRenderObjectData( renderObject );

			return true;

		}

		return false;

	}

	getRenderObjectData( renderObject ) {

		let data = this.renderObjects.get( renderObject );

		if ( data === undefined ) {

			const { geometry, material, object } = renderObject;

			data = {
				material: this.getMaterialData( material ),
				geometry: {
					attributes: this.getAttributesData( geometry.attributes ),
					indexVersion: geometry.index ? geometry.index.version : null,
					drawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }
				},
				worldMatrix: object.matrixWorld.clone()
			};

			if ( object.center ) {

				data.center = object.center.clone();

			}

			if ( object.morphTargetInfluences ) {

				data.morphTargetInfluences = object.morphTargetInfluences.slice();

			}

			if ( renderObject.bundle !== null ) {

				data.version = renderObject.bundle.version;

			}

			if ( data.material.transmission > 0 ) {

				const { width, height } = renderObject.context;

				data.bufferWidth = width;
				data.bufferHeight = height;

			}

			this.renderObjects.set( renderObject, data );

		}

		return data;

	}

	getAttributesData( attributes ) {

		const attributesData = {};

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			attributesData[ name ] = {
				version: attribute.version
			};

		}

		return attributesData;

	}

	containsNode( builder ) {

		const material = builder.material;

		for ( const property in material ) {

			if ( material[ property ] && material[ property ].isNode )
				return true;

		}

		if ( builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null )
			return true;

		return false;

	}

	getMaterialData( material ) {

		const data = {};

		for ( const property of this.refreshUniforms ) {

			const value = material[ property ];

			if ( value === null || value === undefined ) continue;

			if ( typeof value === 'object' && value.clone !== undefined ) {

				if ( value.isTexture === true ) {

					data[ property ] = { id: value.id, version: value.version };

				} else {

					data[ property ] = value.clone();

				}

			} else {

				data[ property ] = value;

			}

		}

		return data;

	}

	equals( renderObject ) {

		const { object, material, geometry } = renderObject;

		const renderObjectData = this.getRenderObjectData( renderObject );

		// world matrix

		if ( renderObjectData.worldMatrix.equals( object.matrixWorld ) !== true ) {

			renderObjectData.worldMatrix.copy( object.matrixWorld );

			return false;

		}

		// material

		const materialData = renderObjectData.material;

		for ( const property in materialData ) {

			const value = materialData[ property ];
			const mtlValue = material[ property ];

			if ( value.equals !== undefined ) {

				if ( value.equals( mtlValue ) === false ) {

					value.copy( mtlValue );

					return false;

				}

			} else if ( mtlValue.isTexture === true ) {

				if ( value.id !== mtlValue.id || value.version !== mtlValue.version ) {

					value.id = mtlValue.id;
					value.version = mtlValue.version;

					return false;

				}

			} else if ( value !== mtlValue ) {

				materialData[ property ] = mtlValue;

				return false;

			}

		}

		if ( materialData.transmission > 0 ) {

			const { width, height } = renderObject.context;

			if ( renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height ) {

				renderObjectData.bufferWidth = width;
				renderObjectData.bufferHeight = height;

				return false;

			}

		}

		// geometry

		const storedGeometryData = renderObjectData.geometry;
		const attributes = geometry.attributes;
		const storedAttributes = storedGeometryData.attributes;

		const storedAttributeNames = Object.keys( storedAttributes );
		const currentAttributeNames = Object.keys( attributes );

		if ( storedAttributeNames.length !== currentAttributeNames.length ) {

			renderObjectData.geometry.attributes = this.getAttributesData( attributes );
			return false;

		}

		// compare each attribute

		for ( const name of storedAttributeNames ) {

			const storedAttributeData = storedAttributes[ name ];
			const attribute = attributes[ name ];

			if ( attribute === undefined ) {

				// attribute was removed
				delete storedAttributes[ name ];
				return false;

			}

			if ( storedAttributeData.version !== attribute.version ) {

				storedAttributeData.version = attribute.version;
				return false;

			}

		}

		// check index

		const index = geometry.index;
		const storedIndexVersion = storedGeometryData.indexVersion;
		const currentIndexVersion = index ? index.version : null;

		if ( storedIndexVersion !== currentIndexVersion ) {

			storedGeometryData.indexVersion = currentIndexVersion;
			return false;

		}

		// check drawRange

		if ( storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count ) {

			storedGeometryData.drawRange.start = geometry.drawRange.start;
			storedGeometryData.drawRange.count = geometry.drawRange.count;
			return false;

		}

		// morph targets

		if ( renderObjectData.morphTargetInfluences ) {

			let morphChanged = false;

			for ( let i = 0; i < renderObjectData.morphTargetInfluences.length; i ++ ) {

				if ( renderObjectData.morphTargetInfluences[ i ] !== object.morphTargetInfluences[ i ] ) {

					morphChanged = true;

				}

			}

			if ( morphChanged ) return true;

		}

		// center

		if ( renderObjectData.center ) {

			if ( renderObjectData.center.equals( object.center ) === false ) {

				renderObjectData.center.copy( object.center );

				return true;

			}

		}

		// bundle

		if ( renderObject.bundle !== null ) {

			renderObjectData.version = renderObject.bundle.version;

		}

		return true;

	}

	needsRefresh( renderObject, nodeFrame ) {

		if ( this.hasNode || this.hasAnimation || this.firstInitialization( renderObject ) )
			return true;

		const { renderId } = nodeFrame;

		if ( this.renderId !== renderId ) {

			this.renderId = renderId;

			return true;

		}

		const isStatic = renderObject.object.static === true;
		const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData( renderObject ).version === renderObject.bundle.version;

		if ( isStatic || isBundle )
			return false;

		const notEqual = this.equals( renderObject ) !== true;

		return notEqual;

	}

}

// cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.
// A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.
// Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
// See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480
// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
function cyrb53( value, seed = 0 ) {

	let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;

	if ( value instanceof Array ) {

		for ( let i = 0, val; i < value.length; i ++ ) {

			val = value[ i ];
			h1 = Math.imul( h1 ^ val, 2654435761 );
			h2 = Math.imul( h2 ^ val, 1597334677 );

		}

	} else {

		for ( let i = 0, ch; i < value.length; i ++ ) {

			ch = value.charCodeAt( i );
			h1 = Math.imul( h1 ^ ch, 2654435761 );
			h2 = Math.imul( h2 ^ ch, 1597334677 );

		}

	}

	h1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 );
	h1 ^= Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 );
	h2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 );
	h2 ^= Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 );

	return 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 );

}

const hashString = ( str ) => cyrb53( str );
const hashArray = ( array ) => cyrb53( array );
const hash$1 = ( ...params ) => cyrb53( params );

function getCacheKey$1( object, force = false ) {

	const values = [];

	if ( object.isNode === true ) {

		values.push( object.id );
		object = object.getSelf();

	}

	for ( const { property, childNode } of getNodeChildren( object ) ) {

		values.push( values, cyrb53( property.slice( 0, - 4 ) ), childNode.getCacheKey( force ) );

	}

	return cyrb53( values );

}

function* getNodeChildren( node, toJSON = false ) {

	for ( const property in node ) {

		// Ignore private properties.
		if ( property.startsWith( '_' ) === true ) continue;

		const object = node[ property ];

		if ( Array.isArray( object ) === true ) {

			for ( let i = 0; i < object.length; i ++ ) {

				const child = object[ i ];

				if ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {

					yield { property, index: i, childNode: child };

				}

			}

		} else if ( object && object.isNode === true ) {

			yield { property, childNode: object };

		} else if ( typeof object === 'object' ) {

			for ( const subProperty in object ) {

				const child = object[ subProperty ];

				if ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {

					yield { property, index: subProperty, childNode: child };

				}

			}

		}

	}

}

const typeFromLength = /*@__PURE__*/ new Map( [
	[ 1, 'float' ],
	[ 2, 'vec2' ],
	[ 3, 'vec3' ],
	[ 4, 'vec4' ],
	[ 9, 'mat3' ],
	[ 16, 'mat4' ]
] );

function getTypeFromLength( length ) {

	return typeFromLength.get( length );

}

function getLengthFromType( type ) {

	if ( /float|int|uint/.test( type ) ) return 1;
	if ( /vec2/.test( type ) ) return 2;
	if ( /vec3/.test( type ) ) return 3;
	if ( /vec4/.test( type ) ) return 4;
	if ( /mat3/.test( type ) ) return 9;
	if ( /mat4/.test( type ) ) return 16;

	console.error( 'THREE.TSL: Unsupported type:', type );

}

function getValueType( value ) {

	if ( value === undefined || value === null ) return null;

	const typeOf = typeof value;

	if ( value.isNode === true ) {

		return 'node';

	} else if ( typeOf === 'number' ) {

		return 'float';

	} else if ( typeOf === 'boolean' ) {

		return 'bool';

	} else if ( typeOf === 'string' ) {

		return 'string';

	} else if ( typeOf === 'function' ) {

		return 'shader';

	} else if ( value.isVector2 === true ) {

		return 'vec2';

	} else if ( value.isVector3 === true ) {

		return 'vec3';

	} else if ( value.isVector4 === true ) {

		return 'vec4';

	} else if ( value.isMatrix3 === true ) {

		return 'mat3';

	} else if ( value.isMatrix4 === true ) {

		return 'mat4';

	} else if ( value.isColor === true ) {

		return 'color';

	} else if ( value instanceof ArrayBuffer ) {

		return 'ArrayBuffer';

	}

	return null;

}

function getValueFromType( type, ...params ) {

	const last4 = type ? type.slice( - 4 ) : undefined;

	if ( params.length === 1 ) { // ensure same behaviour as in NodeBuilder.format()

		if ( last4 === 'vec2' ) params = [ params[ 0 ], params[ 0 ] ];
		else if ( last4 === 'vec3' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ] ];
		else if ( last4 === 'vec4' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ], params[ 0 ] ];

	}

	if ( type === 'color' ) {

		return new Color( ...params );

	} else if ( last4 === 'vec2' ) {

		return new Vector2( ...params );

	} else if ( last4 === 'vec3' ) {

		return new Vector3( ...params );

	} else if ( last4 === 'vec4' ) {

		return new Vector4( ...params );

	} else if ( last4 === 'mat3' ) {

		return new Matrix3( ...params );

	} else if ( last4 === 'mat4' ) {

		return new Matrix4( ...params );

	} else if ( type === 'bool' ) {

		return params[ 0 ] || false;

	} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {

		return params[ 0 ] || 0;

	} else if ( type === 'string' ) {

		return params[ 0 ] || '';

	} else if ( type === 'ArrayBuffer' ) {

		return base64ToArrayBuffer( params[ 0 ] );

	}

	return null;

}

function arrayBufferToBase64( arrayBuffer ) {

	let chars = '';

	const array = new Uint8Array( arrayBuffer );

	for ( let i = 0; i < array.length; i ++ ) {

		chars += String.fromCharCode( array[ i ] );

	}

	return btoa( chars );

}

function base64ToArrayBuffer( base64 ) {

	return Uint8Array.from( atob( base64 ), c => c.charCodeAt( 0 ) ).buffer;

}

var NodeUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	arrayBufferToBase64: arrayBufferToBase64,
	base64ToArrayBuffer: base64ToArrayBuffer,
	getCacheKey: getCacheKey$1,
	getLengthFromType: getLengthFromType,
	getNodeChildren: getNodeChildren,
	getTypeFromLength: getTypeFromLength,
	getValueFromType: getValueFromType,
	getValueType: getValueType,
	hash: hash$1,
	hashArray: hashArray,
	hashString: hashString
});

const NodeShaderStage = {
	VERTEX: 'vertex',
	FRAGMENT: 'fragment'
};

const NodeUpdateType = {
	NONE: 'none',
	FRAME: 'frame',
	RENDER: 'render',
	OBJECT: 'object'
};

const NodeType = {
	BOOLEAN: 'bool',
	INTEGER: 'int',
	FLOAT: 'float',
	VECTOR2: 'vec2',
	VECTOR3: 'vec3',
	VECTOR4: 'vec4',
	MATRIX2: 'mat2',
	MATRIX3: 'mat3',
	MATRIX4: 'mat4'
};

const NodeAccess = {
	READ_ONLY: 'readOnly',
	WRITE_ONLY: 'writeOnly',
	READ_WRITE: 'readWrite',
};

const defaultShaderStages = [ 'fragment', 'vertex' ];
const defaultBuildStages = [ 'setup', 'analyze', 'generate' ];
const shaderStages = [ ...defaultShaderStages, 'compute' ];
const vectorComponents = [ 'x', 'y', 'z', 'w' ];

let _nodeId = 0;

class Node extends EventDispatcher {

	static get type() {

		return 'Node';

	}

	constructor( nodeType = null ) {

		super();

		this.nodeType = nodeType;

		this.updateType = NodeUpdateType.NONE;
		this.updateBeforeType = NodeUpdateType.NONE;
		this.updateAfterType = NodeUpdateType.NONE;

		this.uuid = MathUtils.generateUUID();

		this.version = 0;

		this._cacheKey = null;
		this._cacheKeyVersion = 0;

		this.global = false;

		this.isNode = true;

		Object.defineProperty( this, 'id', { value: _nodeId ++ } );

	}

	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;

		}

	}

	get type() {

		return this.constructor.type;

	}

	onUpdate( callback, updateType ) {

		this.updateType = updateType;
		this.update = callback.bind( this.getSelf() );

		return this;

	}

	onFrameUpdate( callback ) {

		return this.onUpdate( callback, NodeUpdateType.FRAME );

	}

	onRenderUpdate( callback ) {

		return this.onUpdate( callback, NodeUpdateType.RENDER );

	}

	onObjectUpdate( callback ) {

		return this.onUpdate( callback, NodeUpdateType.OBJECT );

	}

	onReference( callback ) {

		this.updateReference = callback.bind( this.getSelf() );

		return this;

	}

	getSelf() {

		// Returns non-node object.

		return this.self || this;

	}

	updateReference( /*state*/ ) {

		return this;

	}

	isGlobal( /*builder*/ ) {

		return this.global;

	}

	* getChildren() {

		for ( const { childNode } of getNodeChildren( this ) ) {

			yield childNode;

		}

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	traverse( callback ) {

		callback( this );

		for ( const childNode of this.getChildren() ) {

			childNode.traverse( callback );

		}

	}

	getCacheKey( force = false ) {

		force = force || this.version !== this._cacheKeyVersion;

		if ( force === true || this._cacheKey === null ) {

			this._cacheKey = getCacheKey$1( this, force );
			this._cacheKeyVersion = this.version;

		}

		return this._cacheKey;

	}

	getScope() {

		return this;

	}

	getHash( /*builder*/ ) {

		return this.uuid;

	}

	getUpdateType() {

		return this.updateType;

	}

	getUpdateBeforeType() {

		return this.updateBeforeType;

	}

	getUpdateAfterType() {

		return this.updateAfterType;

	}

	getElementType( builder ) {

		const type = this.getNodeType( builder );
		const elementType = builder.getElementType( type );

		return elementType;

	}

	getNodeType( builder ) {

		const nodeProperties = builder.getNodeProperties( this );

		if ( nodeProperties.outputNode ) {

			return nodeProperties.outputNode.getNodeType( builder );

		}

		return this.nodeType;

	}

	getShared( builder ) {

		const hash = this.getHash( builder );
		const nodeFromHash = builder.getNodeFromHash( hash );

		return nodeFromHash || this;

	}

	setup( builder ) {

		const nodeProperties = builder.getNodeProperties( this );

		let index = 0;

		for ( const childNode of this.getChildren() ) {

			nodeProperties[ 'node' + index ++ ] = childNode;

		}

		// return a outputNode if exists
		return null;

	}

	analyze( builder ) {

		const usageCount = builder.increaseUsage( this );

		if ( usageCount === 1 ) {

			// node flow children

			const nodeProperties = builder.getNodeProperties( this );

			for ( const childNode of Object.values( nodeProperties ) ) {

				if ( childNode && childNode.isNode === true ) {

					childNode.build( builder );

				}

			}

		}

	}

	generate( builder, output ) {

		const { outputNode } = builder.getNodeProperties( this );

		if ( outputNode && outputNode.isNode === true ) {

			return outputNode.build( builder, output );

		}

	}

	updateBefore( /*frame*/ ) {

		console.warn( 'Abstract function.' );

	}

	updateAfter( /*frame*/ ) {

		console.warn( 'Abstract function.' );

	}

	update( /*frame*/ ) {

		console.warn( 'Abstract function.' );

	}

	build( builder, output = null ) {

		const refNode = this.getShared( builder );

		if ( this !== refNode ) {

			return refNode.build( builder, output );

		}

		builder.addNode( this );
		builder.addChain( this );

		/* Build stages expected results:
			- "setup"		-> Node
			- "analyze"		-> null
			- "generate"	-> String
		*/
		let result = null;

		const buildStage = builder.getBuildStage();

		if ( buildStage === 'setup' ) {

			this.updateReference( builder );

			const properties = builder.getNodeProperties( this );

			if ( properties.initialized !== true ) {

				const stackNodesBeforeSetup = builder.stack.nodes.length;

				properties.initialized = true;
				properties.outputNode = this.setup( builder );

				if ( properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup ) ;

				for ( const childNode of Object.values( properties ) ) {

					if ( childNode && childNode.isNode === true ) {

						childNode.build( builder );

					}

				}

			}

		} else if ( buildStage === 'analyze' ) {

			this.analyze( builder );

		} else if ( buildStage === 'generate' ) {

			const isGenerateOnce = this.generate.length === 1;

			if ( isGenerateOnce ) {

				const type = this.getNodeType( builder );
				const nodeData = builder.getDataFromNode( this );

				result = nodeData.snippet;

				if ( result === undefined ) {

					result = this.generate( builder ) || '';

					nodeData.snippet = result;

				} else if ( nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined ) {

					builder.addFlowCodeHierarchy( this, builder.context.nodeBlock );

				}

				result = builder.format( result, type, output );

			} else {

				result = this.generate( builder, output ) || '';

			}

		}

		builder.removeChain( this );
		builder.addSequentialNode( this );

		return result;

	}

	getSerializeChildren() {

		return getNodeChildren( this );

	}

	serialize( json ) {

		const nodeChildren = this.getSerializeChildren();

		const inputNodes = {};

		for ( const { property, index, childNode } of nodeChildren ) {

			if ( index !== undefined ) {

				if ( inputNodes[ property ] === undefined ) {

					inputNodes[ property ] = Number.isInteger( index ) ? [] : {};

				}

				inputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;

			} else {

				inputNodes[ property ] = childNode.toJSON( json.meta ).uuid;

			}

		}

		if ( Object.keys( inputNodes ).length > 0 ) {

			json.inputNodes = inputNodes;

		}

	}

	deserialize( json ) {

		if ( json.inputNodes !== undefined ) {

			const nodes = json.meta.nodes;

			for ( const property in json.inputNodes ) {

				if ( Array.isArray( json.inputNodes[ property ] ) ) {

					const inputArray = [];

					for ( const uuid of json.inputNodes[ property ] ) {

						inputArray.push( nodes[ uuid ] );

					}

					this[ property ] = inputArray;

				} else if ( typeof json.inputNodes[ property ] === 'object' ) {

					const inputObject = {};

					for ( const subProperty in json.inputNodes[ property ] ) {

						const uuid = json.inputNodes[ property ][ subProperty ];

						inputObject[ subProperty ] = nodes[ uuid ];

					}

					this[ property ] = inputObject;

				} else {

					const uuid = json.inputNodes[ property ];

					this[ property ] = nodes[ uuid ];

				}

			}

		}

	}

	toJSON( meta ) {

		const { uuid, type } = this;
		const isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {},
				nodes: {}
			};

		}

		// serialize

		let data = meta.nodes[ uuid ];

		if ( data === undefined ) {

			data = {
				uuid,
				type,
				meta,
				metadata: {
					version: 4.6,
					type: 'Node',
					generator: 'Node.toJSON'
				}
			};

			if ( isRoot !== true ) meta.nodes[ data.uuid ] = data;

			this.serialize( data );

			delete data.meta;

		}

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const nodes = extractFromCache( meta.nodes );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;
			if ( nodes.length > 0 ) data.nodes = nodes;

		}

		return data;

	}

}

class ArrayElementNode extends Node {

	static get type() {

		return 'ArrayElementNode';

	} // @TODO: If extending from TempNode it breaks webgpu_compute

	constructor( node, indexNode ) {

		super();

		this.node = node;
		this.indexNode = indexNode;

		this.isArrayElementNode = true;

	}

	getNodeType( builder ) {

		return this.node.getElementType( builder );

	}

	generate( builder ) {

		const nodeSnippet = this.node.build( builder );
		const indexSnippet = this.indexNode.build( builder, 'uint' );

		return `${nodeSnippet}[ ${indexSnippet} ]`;

	}

}

class ConvertNode extends Node {

	static get type() {

		return 'ConvertNode';

	}

	constructor( node, convertTo ) {

		super();

		this.node = node;
		this.convertTo = convertTo;

	}

	getNodeType( builder ) {

		const requestType = this.node.getNodeType( builder );

		let convertTo = null;

		for ( const overloadingType of this.convertTo.split( '|' ) ) {

			if ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {

				convertTo = overloadingType;

			}

		}

		return convertTo;

	}

	serialize( data ) {

		super.serialize( data );

		data.convertTo = this.convertTo;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.convertTo = data.convertTo;

	}

	generate( builder, output ) {

		const node = this.node;
		const type = this.getNodeType( builder );

		const snippet = node.build( builder, type );

		return builder.format( snippet, type, output );

	}

}

class TempNode extends Node {

	static get type() {

		return 'TempNode';

	}

	constructor( type ) {

		super( type );

		this.isTempNode = true;

	}

	hasDependencies( builder ) {

		return builder.getDataFromNode( this ).usageCount > 1;

	}

	build( builder, output ) {

		const buildStage = builder.getBuildStage();

		if ( buildStage === 'generate' ) {

			const type = builder.getVectorType( this.getNodeType( builder, output ) );
			const nodeData = builder.getDataFromNode( this );

			if ( nodeData.propertyName !== undefined ) {

				return builder.format( nodeData.propertyName, type, output );

			} else if ( type !== 'void' && output !== 'void' && this.hasDependencies( builder ) ) {

				const snippet = super.build( builder, type );

				const nodeVar = builder.getVarFromNode( this, null, type );
				const propertyName = builder.getPropertyName( nodeVar );

				builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

				nodeData.snippet = snippet;
				nodeData.propertyName = propertyName;

				return builder.format( nodeData.propertyName, type, output );

			}

		}

		return super.build( builder, output );

	}

}

class JoinNode extends TempNode {

	static get type() {

		return 'JoinNode';

	}

	constructor( nodes = [], nodeType = null ) {

		super( nodeType );

		this.nodes = nodes;

	}

	getNodeType( builder ) {

		if ( this.nodeType !== null ) {

			return builder.getVectorType( this.nodeType );

		}

		return builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );
		const nodes = this.nodes;

		const primitiveType = builder.getComponentType( type );

		const snippetValues = [];

		for ( const input of nodes ) {

			let inputSnippet = input.build( builder );

			const inputPrimitiveType = builder.getComponentType( input.getNodeType( builder ) );

			if ( inputPrimitiveType !== primitiveType ) {

				inputSnippet = builder.format( inputSnippet, inputPrimitiveType, primitiveType );

			}

			snippetValues.push( inputSnippet );

		}

		const snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;

		return builder.format( snippet, type, output );

	}

}

const stringVectorComponents = vectorComponents.join( '' );

class SplitNode extends Node {

	static get type() {

		return 'SplitNode';

	}

	constructor( node, components = 'x' ) {

		super();

		this.node = node;
		this.components = components;

		this.isSplitNode = true;

	}

	getVectorLength() {

		let vectorLength = this.components.length;

		for ( const c of this.components ) {

			vectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );

		}

		return vectorLength;

	}

	getComponentType( builder ) {

		return builder.getComponentType( this.node.getNodeType( builder ) );

	}

	getNodeType( builder ) {

		return builder.getTypeFromLength( this.components.length, this.getComponentType( builder ) );

	}

	generate( builder, output ) {

		const node = this.node;
		const nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );

		let snippet = null;

		if ( nodeTypeLength > 1 ) {

			let type = null;

			const componentsLength = this.getVectorLength();

			if ( componentsLength >= nodeTypeLength ) {

				// needed expand the input node

				type = builder.getTypeFromLength( this.getVectorLength(), this.getComponentType( builder ) );

			}

			const nodeSnippet = node.build( builder, type );

			if ( this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice( 0, this.components.length ) ) {

				// unnecessary swizzle

				snippet = builder.format( nodeSnippet, type, output );

			} else {

				snippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );

			}

		} else {

			// ignore .components if .node returns float/integer

			snippet = node.build( builder, output );

		}

		return snippet;

	}

	serialize( data ) {

		super.serialize( data );

		data.components = this.components;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.components = data.components;

	}

}

class SetNode extends TempNode {

	static get type() {

		return 'SetNode';

	}

	constructor( sourceNode, components, targetNode ) {

		super();

		this.sourceNode = sourceNode;
		this.components = components;
		this.targetNode = targetNode;

	}

	getNodeType( builder ) {

		return this.sourceNode.getNodeType( builder );

	}

	generate( builder ) {

		const { sourceNode, components, targetNode } = this;

		const sourceType = this.getNodeType( builder );
		const targetType = builder.getTypeFromLength( components.length, targetNode.getNodeType( builder ) );

		const targetSnippet = targetNode.build( builder, targetType );
		const sourceSnippet = sourceNode.build( builder, sourceType );

		const length = builder.getTypeLength( sourceType );
		const snippetValues = [];

		for ( let i = 0; i < length; i ++ ) {

			const component = vectorComponents[ i ];

			if ( component === components[ 0 ] ) {

				snippetValues.push( targetSnippet );

				i += components.length - 1;

			} else {

				snippetValues.push( sourceSnippet + '.' + component );

			}

		}

		return `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;

	}

}

class FlipNode extends TempNode {

	static get type() {

		return 'FlipNode';

	}

	constructor( sourceNode, components ) {

		super();

		this.sourceNode = sourceNode;
		this.components = components;

	}

	getNodeType( builder ) {

		return this.sourceNode.getNodeType( builder );

	}

	generate( builder ) {

		const { components, sourceNode } = this;

		const sourceType = this.getNodeType( builder );
		const sourceSnippet = sourceNode.build( builder );

		const sourceCache = builder.getVarFromNode( this );
		const sourceProperty = builder.getPropertyName( sourceCache );

		builder.addLineFlowCode( sourceProperty + ' = ' + sourceSnippet, this );

		const length = builder.getTypeLength( sourceType );
		const snippetValues = [];

		let componentIndex = 0;

		for ( let i = 0; i < length; i ++ ) {

			const component = vectorComponents[ i ];

			if ( component === components[ componentIndex ] ) {

				snippetValues.push( '1.0 - ' + ( sourceProperty + '.' + component ) );

				componentIndex ++;

			} else {

				snippetValues.push( sourceProperty + '.' + component );

			}

		}

		return `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;

	}

}

class InputNode extends Node {

	static get type() {

		return 'InputNode';

	}

	constructor( value, nodeType = null ) {

		super( nodeType );

		this.isInputNode = true;

		this.value = value;
		this.precision = null;

	}

	getNodeType( /*builder*/ ) {

		if ( this.nodeType === null ) {

			return getValueType( this.value );

		}

		return this.nodeType;

	}

	getInputType( builder ) {

		return this.getNodeType( builder );

	}

	setPrecision( precision ) {

		this.precision = precision;

		return this;

	}

	serialize( data ) {

		super.serialize( data );

		data.value = this.value;

		if ( this.value && this.value.toArray ) data.value = this.value.toArray();

		data.valueType = getValueType( this.value );
		data.nodeType = this.nodeType;

		if ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );

		data.precision = this.precision;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.nodeType = data.nodeType;
		this.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;

		this.precision = data.precision || null;

		if ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );

	}

	generate( /*builder, output*/ ) {

		console.warn( 'Abstract function.' );

	}

}

class ConstNode extends InputNode {

	static get type() {

		return 'ConstNode';

	}

	constructor( value, nodeType = null ) {

		super( value, nodeType );

		this.isConstNode = true;

	}

	generateConst( builder ) {

		return builder.generateConst( this.getNodeType( builder ), this.value );

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );

		return builder.format( this.generateConst( builder ), type, output );

	}

}

//

let currentStack = null;

const NodeElements = new Map();

function addMethodChaining( name, nodeElement ) {

	if ( NodeElements.has( name ) ) {

		console.warn( `Redefinition of method chaining ${ name }` );
		return;

	}

	if ( typeof nodeElement !== 'function' ) throw new Error( `Node element ${ name } is not a function` );

	NodeElements.set( name, nodeElement );

}

const parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );
const parseSwizzleAndSort = ( props ) => parseSwizzle( props ).split( '' ).sort().join( '' );

const shaderNodeHandler = {

	setup( NodeClosure, params ) {

		const inputs = params.shift();

		return NodeClosure( nodeObjects( inputs ), ...params );

	},

	get( node, prop, nodeObj ) {

		if ( typeof prop === 'string' && node[ prop ] === undefined ) {

			if ( node.isStackNode !== true && prop === 'assign' ) {

				return ( ...params ) => {

					currentStack.assign( nodeObj, ...params );

					return nodeObj;

				};

			} else if ( NodeElements.has( prop ) ) {

				const nodeElement = NodeElements.get( prop );

				return node.isStackNode ? ( ...params ) => nodeObj.add( nodeElement( ...params ) ) : ( ...params ) => nodeElement( nodeObj, ...params );

			} else if ( prop === 'self' ) {

				return node;

			} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {

				const nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );

				return node.isStackNode ? ( ...params ) => nodeObj.assign( params[ 0 ], nodeElement( ...params ) ) : ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );

			} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {

				// accessing properties ( swizzle )

				prop = parseSwizzle( prop );

				return nodeObject( new SplitNode( nodeObj, prop ) );

			} else if ( /^set[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {

				// set properties ( swizzle ) and sort to xyzw sequence

				prop = parseSwizzleAndSort( prop.slice( 3 ).toLowerCase() );

				return ( value ) => nodeObject( new SetNode( node, prop, value ) );

			} else if ( /^flip[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {

				// set properties ( swizzle ) and sort to xyzw sequence

				prop = parseSwizzleAndSort( prop.slice( 4 ).toLowerCase() );

				return () => nodeObject( new FlipNode( nodeObject( node ), prop ) );

			} else if ( prop === 'width' || prop === 'height' || prop === 'depth' ) {

				// accessing property

				if ( prop === 'width' ) prop = 'x';
				else if ( prop === 'height' ) prop = 'y';
				else if ( prop === 'depth' ) prop = 'z';

				return nodeObject( new SplitNode( node, prop ) );

			} else if ( /^\d+$/.test( prop ) === true ) {

				// accessing array

				return nodeObject( new ArrayElementNode( nodeObj, new ConstNode( Number( prop ), 'uint' ) ) );

			}

		}

		return Reflect.get( node, prop, nodeObj );

	},

	set( node, prop, value, nodeObj ) {

		if ( typeof prop === 'string' && node[ prop ] === undefined ) {

			// setting properties

			if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\d+$/.test( prop ) === true ) {

				nodeObj[ prop ].assign( value );

				return true;

			}

		}

		return Reflect.set( node, prop, value, nodeObj );

	}

};

const nodeObjectsCacheMap = new WeakMap();
const nodeBuilderFunctionsCacheMap = new WeakMap();

const ShaderNodeObject = function ( obj, altType = null ) {

	const type = getValueType( obj );

	if ( type === 'node' ) {

		let nodeObject = nodeObjectsCacheMap.get( obj );

		if ( nodeObject === undefined ) {

			nodeObject = new Proxy( obj, shaderNodeHandler );

			nodeObjectsCacheMap.set( obj, nodeObject );
			nodeObjectsCacheMap.set( nodeObject, nodeObject );

		}

		return nodeObject;

	} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {

		return nodeObject( getConstNode( obj, altType ) );

	} else if ( type === 'shader' ) {

		return Fn( obj );

	}

	return obj;

};

const ShaderNodeObjects = function ( objects, altType = null ) {

	for ( const name in objects ) {

		objects[ name ] = nodeObject( objects[ name ], altType );

	}

	return objects;

};

const ShaderNodeArray = function ( array, altType = null ) {

	const len = array.length;

	for ( let i = 0; i < len; i ++ ) {

		array[ i ] = nodeObject( array[ i ], altType );

	}

	return array;

};

const ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {

	const assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );

	if ( scope === null ) {

		return ( ...params ) => {

			return assignNode( new NodeClass( ...nodeArray( params ) ) );

		};

	} else if ( factor !== null ) {

		factor = nodeObject( factor );

		return ( ...params ) => {

			return assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );

		};

	} else {

		return ( ...params ) => {

			return assignNode( new NodeClass( scope, ...nodeArray( params ) ) );

		};

	}

};

const ShaderNodeImmutable = function ( NodeClass, ...params ) {

	return nodeObject( new NodeClass( ...nodeArray( params ) ) );

};

class ShaderCallNodeInternal extends Node {

	constructor( shaderNode, inputNodes ) {

		super();

		this.shaderNode = shaderNode;
		this.inputNodes = inputNodes;

	}

	getNodeType( builder ) {

		return this.shaderNode.nodeType || this.getOutputNode( builder ).getNodeType( builder );

	}

	call( builder ) {

		const { shaderNode, inputNodes } = this;

		const properties = builder.getNodeProperties( shaderNode );
		if ( properties.onceOutput ) return properties.onceOutput;

		//

		let result = null;

		if ( shaderNode.layout ) {

			let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );

			if ( functionNodesCacheMap === undefined ) {

				functionNodesCacheMap = new WeakMap();

				nodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );

			}

			let functionNode = functionNodesCacheMap.get( shaderNode );

			if ( functionNode === undefined ) {

				functionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );

				functionNodesCacheMap.set( shaderNode, functionNode );

			}

			if ( builder.currentFunctionNode !== null ) {

				builder.currentFunctionNode.includes.push( functionNode );

			}

			result = nodeObject( functionNode.call( inputNodes ) );

		} else {

			const jsFunc = shaderNode.jsFunc;
			const outputNode = inputNodes !== null ? jsFunc( inputNodes, builder ) : jsFunc( builder );

			result = nodeObject( outputNode );

		}

		if ( shaderNode.once ) {

			properties.onceOutput = result;

		}

		return result;

	}

	getOutputNode( builder ) {

		const properties = builder.getNodeProperties( this );

		if ( properties.outputNode === null ) {

			properties.outputNode = this.setupOutput( builder );

		}

		return properties.outputNode;

	}

	setup( builder ) {

		return this.getOutputNode( builder );

	}

	setupOutput( builder ) {

		builder.addStack();

		builder.stack.outputNode = this.call( builder );

		return builder.removeStack();

	}

	generate( builder, output ) {

		const outputNode = this.getOutputNode( builder );

		return outputNode.build( builder, output );

	}

}

class ShaderNodeInternal extends Node {

	constructor( jsFunc, nodeType ) {

		super( nodeType );

		this.jsFunc = jsFunc;
		this.layout = null;

		this.global = true;

		this.once = false;

	}

	setLayout( layout ) {

		this.layout = layout;

		return this;

	}

	call( inputs = null ) {

		nodeObjects( inputs );

		return nodeObject( new ShaderCallNodeInternal( this, inputs ) );

	}

	setup() {

		return this.call();

	}

}

const bools = [ false, true ];
const uints = [ 0, 1, 2, 3 ];
const ints = [ - 1, - 2 ];
const floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];

const boolsCacheMap = new Map();
for ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );

const uintsCacheMap = new Map();
for ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );

const intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );
for ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );

const floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );
for ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );
for ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );

const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };

const constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );

const getConstNode = ( value, type ) => {

	if ( constNodesCacheMap.has( value ) ) {

		return constNodesCacheMap.get( value );

	} else if ( value.isNode === true ) {

		return value;

	} else {

		return new ConstNode( value, type );

	}

};

const safeGetNodeType = ( node ) => {

	try {

		return node.getNodeType();

	} catch ( _ ) {

		return undefined;

	}

};

const ConvertType = function ( type, cacheMap = null ) {

	return ( ...params ) => {

		if ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {

			params = [ getValueFromType( type, ...params ) ];

		}

		if ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {

			return nodeObject( cacheMap.get( params[ 0 ] ) );

		}

		if ( params.length === 1 ) {

			const node = getConstNode( params[ 0 ], type );
			if ( safeGetNodeType( node ) === type ) return nodeObject( node );
			return nodeObject( new ConvertNode( node, type ) );

		}

		const nodes = params.map( param => getConstNode( param ) );
		return nodeObject( new JoinNode( nodes, type ) );

	};

};

// exports

const defined = ( v ) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function

// utils

const getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;

// shader node base

function ShaderNode( jsFunc, nodeType ) {

	return new Proxy( new ShaderNodeInternal( jsFunc, nodeType ), shaderNodeHandler );

}

const nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );
const nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );
const nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );
const nodeProxy = ( ...params ) => new ShaderNodeProxy( ...params );
const nodeImmutable = ( ...params ) => new ShaderNodeImmutable( ...params );

const Fn = ( jsFunc, nodeType ) => {

	const shaderNode = new ShaderNode( jsFunc, nodeType );

	const fn = ( ...params ) => {

		let inputs;

		nodeObjects( params );

		if ( params[ 0 ] && params[ 0 ].isNode ) {

			inputs = [ ...params ];

		} else {

			inputs = params[ 0 ];

		}

		return shaderNode.call( inputs );

	};

	fn.shaderNode = shaderNode;

	fn.setLayout = ( layout ) => {

		shaderNode.setLayout( layout );

		return fn;

	};

	fn.once = () => {

		shaderNode.once = true;

		return fn;

	};

	return fn;

};

const tslFn = ( ...params ) => { // @deprecated, r168

	console.warn( 'TSL.ShaderNode: tslFn() has been renamed to Fn().' );
	return Fn( ...params );

};

//

addMethodChaining( 'toGlobal', ( node ) => {

	node.global = true;

	return node;

} );

//

const setCurrentStack = ( stack ) => {

	currentStack = stack;

};

const getCurrentStack = () => currentStack;

const If = ( ...params ) => currentStack.If( ...params );

function append( node ) {

	if ( currentStack ) currentStack.add( node );

	return node;

}

addMethodChaining( 'append', append );

// types

const color = new ConvertType( 'color' );

const float = new ConvertType( 'float', cacheMaps.float );
const int = new ConvertType( 'int', cacheMaps.ints );
const uint = new ConvertType( 'uint', cacheMaps.uint );
const bool = new ConvertType( 'bool', cacheMaps.bool );

const vec2 = new ConvertType( 'vec2' );
const ivec2 = new ConvertType( 'ivec2' );
const uvec2 = new ConvertType( 'uvec2' );
const bvec2 = new ConvertType( 'bvec2' );

const vec3 = new ConvertType( 'vec3' );
const ivec3 = new ConvertType( 'ivec3' );
const uvec3 = new ConvertType( 'uvec3' );
const bvec3 = new ConvertType( 'bvec3' );

const vec4 = new ConvertType( 'vec4' );
const ivec4 = new ConvertType( 'ivec4' );
const uvec4 = new ConvertType( 'uvec4' );
const bvec4 = new ConvertType( 'bvec4' );

const mat2 = new ConvertType( 'mat2' );
const mat3 = new ConvertType( 'mat3' );
const mat4 = new ConvertType( 'mat4' );

const string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );
const arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );

addMethodChaining( 'toColor', color );
addMethodChaining( 'toFloat', float );
addMethodChaining( 'toInt', int );
addMethodChaining( 'toUint', uint );
addMethodChaining( 'toBool', bool );
addMethodChaining( 'toVec2', vec2 );
addMethodChaining( 'toIVec2', ivec2 );
addMethodChaining( 'toUVec2', uvec2 );
addMethodChaining( 'toBVec2', bvec2 );
addMethodChaining( 'toVec3', vec3 );
addMethodChaining( 'toIVec3', ivec3 );
addMethodChaining( 'toUVec3', uvec3 );
addMethodChaining( 'toBVec3', bvec3 );
addMethodChaining( 'toVec4', vec4 );
addMethodChaining( 'toIVec4', ivec4 );
addMethodChaining( 'toUVec4', uvec4 );
addMethodChaining( 'toBVec4', bvec4 );
addMethodChaining( 'toMat2', mat2 );
addMethodChaining( 'toMat3', mat3 );
addMethodChaining( 'toMat4', mat4 );

// basic nodes

const element = /*@__PURE__*/ nodeProxy( ArrayElementNode );
const convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );
const split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );

addMethodChaining( 'element', element );
addMethodChaining( 'convert', convert );

class UniformGroupNode extends Node {

	static get type() {

		return 'UniformGroupNode';

	}

	constructor( name, shared = false, order = 1 ) {

		super( 'string' );

		this.name = name;
		this.version = 0;

		this.shared = shared;
		this.order = order;
		this.isUniformGroup = true;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	serialize( data ) {

		super.serialize( data );

		data.name = this.name;
		data.version = this.version;
		data.shared = this.shared;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.name = data.name;
		this.version = data.version;
		this.shared = data.shared;

	}

}

const uniformGroup = ( name ) => new UniformGroupNode( name );
const sharedUniformGroup = ( name, order = 0 ) => new UniformGroupNode( name, true, order );

const frameGroup = /*@__PURE__*/ sharedUniformGroup( 'frame' );
const renderGroup = /*@__PURE__*/ sharedUniformGroup( 'render' );
const objectGroup = /*@__PURE__*/ uniformGroup( 'object' );

class UniformNode extends InputNode {

	static get type() {

		return 'UniformNode';

	}

	constructor( value, nodeType = null ) {

		super( value, nodeType );

		this.isUniformNode = true;

		this.name = '';
		this.groupNode = objectGroup;

	}

	label( name ) {

		this.name = name;

		return this;

	}

	setGroup( group ) {

		this.groupNode = group;

		return this;

	}

	getGroup() {

		return this.groupNode;

	}

	getUniformHash( builder ) {

		return this.getHash( builder );

	}

	onUpdate( callback, updateType ) {

		const self = this.getSelf();

		callback = callback.bind( self );

		return super.onUpdate( ( frame ) => {

			const value = callback( frame, self );

			if ( value !== undefined ) {

				this.value = value;

			}

	 	}, updateType );

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );

		const hash = this.getUniformHash( builder );

		let sharedNode = builder.getNodeFromHash( hash );

		if ( sharedNode === undefined ) {

			builder.setHashNode( this, hash );

			sharedNode = this;

		}

		const sharedNodeType = sharedNode.getInputType( builder );

		const nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label );
		const propertyName = builder.getPropertyName( nodeUniform );

		if ( builder.context.label !== undefined ) delete builder.context.label;

		return builder.format( propertyName, type, output );

	}

}

const uniform = ( arg1, arg2 ) => {

	const nodeType = getConstNodeType( arg2 || arg1 );

	// @TODO: get ConstNode from .traverse() in the future
	const value = ( arg1 && arg1.isNode === true ) ? ( arg1.node && arg1.node.value ) || arg1.value : arg1;

	return nodeObject( new UniformNode( value, nodeType ) );

};

class PropertyNode extends Node {

	static get type() {

		return 'PropertyNode';

	}

	constructor( nodeType, name = null, varying = false ) {

		super( nodeType );

		this.name = name;
		this.varying = varying;

		this.isPropertyNode = true;

	}

	getHash( builder ) {

		return this.name || super.getHash( builder );

	}

	isGlobal( /*builder*/ ) {

		return true;

	}

	generate( builder ) {

		let nodeVar;

		if ( this.varying === true ) {

			nodeVar = builder.getVaryingFromNode( this, this.name );
			nodeVar.needsInterpolation = true;

		} else {

			nodeVar = builder.getVarFromNode( this, this.name );

		}

		return builder.getPropertyName( nodeVar );

	}

}

const property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );
const varyingProperty = ( type, name ) => nodeObject( new PropertyNode( type, name, true ) );

const diffuseColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );
const emissive = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'EmissiveColor' );
const roughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Roughness' );
const metalness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Metalness' );
const clearcoat = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Clearcoat' );
const clearcoatRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );
const sheen = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'Sheen' );
const sheenRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );
const iridescence = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Iridescence' );
const iridescenceIOR = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );
const iridescenceThickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );
const alphaT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AlphaT' );
const anisotropy = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Anisotropy' );
const anisotropyT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyT' );
const anisotropyB = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyB' );
const specularColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'SpecularColor' );
const specularF90 = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SpecularF90' );
const shininess = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Shininess' );
const output = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'Output' );
const dashSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'dashSize' );
const gapSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'gapSize' );
const pointWidth = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'pointWidth' );
const ior = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IOR' );
const transmission = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Transmission' );
const thickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Thickness' );
const attenuationDistance = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AttenuationDistance' );
const attenuationColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'AttenuationColor' );
const dispersion = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Dispersion' );

class AssignNode extends TempNode {

	static get type() {

		return 'AssignNode';

	}

	constructor( targetNode, sourceNode ) {

		super();

		this.targetNode = targetNode;
		this.sourceNode = sourceNode;

	}

	hasDependencies() {

		return false;

	}

	getNodeType( builder, output ) {

		return output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';

	}

	needsSplitAssign( builder ) {

		const { targetNode } = this;

		if ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {

			const targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );
			const assignDiferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;

			return assignDiferentVector;

		}

		return false;

	}

	generate( builder, output ) {

		const { targetNode, sourceNode } = this;

		const needsSplitAssign = this.needsSplitAssign( builder );

		const targetType = targetNode.getNodeType( builder );

		const target = targetNode.context( { assign: true } ).build( builder );
		const source = sourceNode.build( builder, targetType );

		const sourceType = sourceNode.getNodeType( builder );

		const nodeData = builder.getDataFromNode( this );

		//

		let snippet;

		if ( nodeData.initialized === true ) {

			if ( output !== 'void' ) {

				snippet = target;

			}

		} else if ( needsSplitAssign ) {

			const sourceVar = builder.getVarFromNode( this, null, targetType );
			const sourceProperty = builder.getPropertyName( sourceVar );

			builder.addLineFlowCode( `${ sourceProperty } = ${ source }`, this );

			const targetRoot = targetNode.node.context( { assign: true } ).build( builder );

			for ( let i = 0; i < targetNode.components.length; i ++ ) {

				const component = targetNode.components[ i ];

				builder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]`, this );

			}

			if ( output !== 'void' ) {

				snippet = target;

			}

		} else {

			snippet = `${ target } = ${ source }`;

			if ( output === 'void' || sourceType === 'void' ) {

				builder.addLineFlowCode( snippet, this );

				if ( output !== 'void' ) {

					snippet = target;

				}

			}

		}

		nodeData.initialized = true;

		return builder.format( snippet, targetType, output );

	}

}

const assign = /*@__PURE__*/ nodeProxy( AssignNode );

addMethodChaining( 'assign', assign );

class FunctionCallNode extends TempNode {

	static get type() {

		return 'FunctionCallNode';

	}

	constructor( functionNode = null, parameters = {} ) {

		super();

		this.functionNode = functionNode;
		this.parameters = parameters;

	}

	setParameters( parameters ) {

		this.parameters = parameters;

		return this;

	}

	getParameters() {

		return this.parameters;

	}

	getNodeType( builder ) {

		return this.functionNode.getNodeType( builder );

	}

	generate( builder ) {

		const params = [];

		const functionNode = this.functionNode;

		const inputs = functionNode.getInputs( builder );
		const parameters = this.parameters;

		const generateInput = ( node, inputNode ) => {

			const type = inputNode.type;
			const pointer = type === 'pointer';

			let output;

			if ( pointer ) output = '&' + node.build( builder );
			else output = node.build( builder, type );

			return output;

		};

		if ( Array.isArray( parameters ) ) {

			for ( let i = 0; i < parameters.length; i ++ ) {

				params.push( generateInput( parameters[ i ], inputs[ i ] ) );

			}

		} else {

			for ( const inputNode of inputs ) {

				const node = parameters[ inputNode.name ];

				if ( node !== undefined ) {

					params.push( generateInput( node, inputNode ) );

				} else {

					throw new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );

				}

			}

		}

		const functionName = functionNode.build( builder, 'property' );

		return `${functionName}( ${params.join( ', ' )} )`;

	}

}

const call = ( func, ...params ) => {

	params = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );

	return nodeObject( new FunctionCallNode( nodeObject( func ), params ) );

};

addMethodChaining( 'call', call );

class OperatorNode extends TempNode {

	static get type() {

		return 'OperatorNode';

	}

	constructor( op, aNode, bNode, ...params ) {

		super();

		if ( params.length > 0 ) {

			let finalOp = new OperatorNode( op, aNode, bNode );

			for ( let i = 0; i < params.length - 1; i ++ ) {

				finalOp = new OperatorNode( op, finalOp, params[ i ] );

			}

			aNode = finalOp;
			bNode = params[ params.length - 1 ];

		}

		this.op = op;
		this.aNode = aNode;
		this.bNode = bNode;

	}

	getNodeType( builder, output ) {

		const op = this.op;

		const aNode = this.aNode;
		const bNode = this.bNode;

		const typeA = aNode.getNodeType( builder );
		const typeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;

		if ( typeA === 'void' || typeB === 'void' ) {

			return 'void';

		} else if ( op === '%' ) {

			return typeA;

		} else if ( op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {

			return builder.getIntegerType( typeA );

		} else if ( op === '!' || op === '==' || op === '&&' || op === '||' || op === '^^' ) {

			return 'bool';

		} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {

			const typeLength = output ? builder.getTypeLength( output ) : Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );

			return typeLength > 1 ? `bvec${ typeLength }` : 'bool';

		} else {

			if ( typeA === 'float' && builder.isMatrix( typeB ) ) {

				return typeB;

			} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {

				// matrix x vector

				return builder.getVectorFromMatrix( typeA );

			} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {

				// vector x matrix

				return builder.getVectorFromMatrix( typeB );

			} else if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {

				// anytype x anytype: use the greater length vector

				return typeB;

			}

			return typeA;

		}

	}

	generate( builder, output ) {

		const op = this.op;

		const aNode = this.aNode;
		const bNode = this.bNode;

		const type = this.getNodeType( builder, output );

		let typeA = null;
		let typeB = null;

		if ( type !== 'void' ) {

			typeA = aNode.getNodeType( builder );
			typeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;

			if ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' ) {

				if ( builder.isVector( typeA ) ) {

					typeB = typeA;

				} else if ( typeA !== typeB ) {

					typeA = typeB = 'float';

				}

			} else if ( op === '>>' || op === '<<' ) {

				typeA = type;
				typeB = builder.changeComponentType( typeB, 'uint' );

			} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {

				// matrix x vector

				typeB = builder.getVectorFromMatrix( typeA );

			} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {

				// vector x matrix

				typeA = builder.getVectorFromMatrix( typeB );

			} else {

				// anytype x anytype

				typeA = typeB = type;

			}

		} else {

			typeA = typeB = type;

		}

		const a = aNode.build( builder, typeA );
		const b = typeof bNode !== 'undefined' ? bNode.build( builder, typeB ) : null;

		const outputLength = builder.getTypeLength( output );
		const fnOpSnippet = builder.getFunctionOperator( op );

		if ( output !== 'void' ) {

			if ( op === '<' && outputLength > 1 ) {

				if ( builder.useComparisonMethod ) {

					return builder.format( `${ builder.getMethod( 'lessThan', output ) }( ${ a }, ${ b } )`, type, output );

				} else {

					return builder.format( `( ${ a } < ${ b } )`, type, output );

				}

			} else if ( op === '<=' && outputLength > 1 ) {

				if ( builder.useComparisonMethod ) {

					return builder.format( `${ builder.getMethod( 'lessThanEqual', output ) }( ${ a }, ${ b } )`, type, output );

				} else {

					return builder.format( `( ${ a } <= ${ b } )`, type, output );

				}

			} else if ( op === '>' && outputLength > 1 ) {

				if ( builder.useComparisonMethod ) {

					return builder.format( `${ builder.getMethod( 'greaterThan', output ) }( ${ a }, ${ b } )`, type, output );

				} else {

					return builder.format( `( ${ a } > ${ b } )`, type, output );

				}

			} else if ( op === '>=' && outputLength > 1 ) {

				if ( builder.useComparisonMethod ) {

					return builder.format( `${ builder.getMethod( 'greaterThanEqual', output ) }( ${ a }, ${ b } )`, type, output );

				} else {

					return builder.format( `( ${ a } >= ${ b } )`, type, output );

				}

			} else if ( op === '!' || op === '~' ) {

				return builder.format( `(${op}${a})`, typeA, output );

			} else if ( fnOpSnippet ) {

				return builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );

			} else {

				return builder.format( `( ${ a } ${ op } ${ b } )`, type, output );

			}

		} else if ( typeA !== 'void' ) {

			if ( fnOpSnippet ) {

				return builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );

			} else {

				return builder.format( `${ a } ${ op } ${ b }`, type, output );

			}

		}

	}

	serialize( data ) {

		super.serialize( data );

		data.op = this.op;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.op = data.op;

	}

}

const add = /*@__PURE__*/ nodeProxy( OperatorNode, '+' );
const sub = /*@__PURE__*/ nodeProxy( OperatorNode, '-' );
const mul = /*@__PURE__*/ nodeProxy( OperatorNode, '*' );
const div = /*@__PURE__*/ nodeProxy( OperatorNode, '/' );
const modInt = /*@__PURE__*/ nodeProxy( OperatorNode, '%' );
const equal = /*@__PURE__*/ nodeProxy( OperatorNode, '==' );
const notEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '!=' );
const lessThan = /*@__PURE__*/ nodeProxy( OperatorNode, '<' );
const greaterThan = /*@__PURE__*/ nodeProxy( OperatorNode, '>' );
const lessThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '<=' );
const greaterThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '>=' );
const and = /*@__PURE__*/ nodeProxy( OperatorNode, '&&' );
const or = /*@__PURE__*/ nodeProxy( OperatorNode, '||' );
const not = /*@__PURE__*/ nodeProxy( OperatorNode, '!' );
const xor = /*@__PURE__*/ nodeProxy( OperatorNode, '^^' );
const bitAnd = /*@__PURE__*/ nodeProxy( OperatorNode, '&' );
const bitNot = /*@__PURE__*/ nodeProxy( OperatorNode, '~' );
const bitOr = /*@__PURE__*/ nodeProxy( OperatorNode, '|' );
const bitXor = /*@__PURE__*/ nodeProxy( OperatorNode, '^' );
const shiftLeft = /*@__PURE__*/ nodeProxy( OperatorNode, '<<' );
const shiftRight = /*@__PURE__*/ nodeProxy( OperatorNode, '>>' );

addMethodChaining( 'add', add );
addMethodChaining( 'sub', sub );
addMethodChaining( 'mul', mul );
addMethodChaining( 'div', div );
addMethodChaining( 'modInt', modInt );
addMethodChaining( 'equal', equal );
addMethodChaining( 'notEqual', notEqual );
addMethodChaining( 'lessThan', lessThan );
addMethodChaining( 'greaterThan', greaterThan );
addMethodChaining( 'lessThanEqual', lessThanEqual );
addMethodChaining( 'greaterThanEqual', greaterThanEqual );
addMethodChaining( 'and', and );
addMethodChaining( 'or', or );
addMethodChaining( 'not', not );
addMethodChaining( 'xor', xor );
addMethodChaining( 'bitAnd', bitAnd );
addMethodChaining( 'bitNot', bitNot );
addMethodChaining( 'bitOr', bitOr );
addMethodChaining( 'bitXor', bitXor );
addMethodChaining( 'shiftLeft', shiftLeft );
addMethodChaining( 'shiftRight', shiftRight );


const remainder = ( ...params ) => { // @deprecated, r168

	console.warn( 'TSL.OperatorNode: .remainder() has been renamed to .modInt().' );
	return modInt( ...params );

};

addMethodChaining( 'remainder', remainder );

class MathNode extends TempNode {

	static get type() {

		return 'MathNode';

	}

	constructor( method, aNode, bNode = null, cNode = null ) {

		super();

		this.method = method;

		this.aNode = aNode;
		this.bNode = bNode;
		this.cNode = cNode;

	}

	getInputType( builder ) {

		const aType = this.aNode.getNodeType( builder );
		const bType = this.bNode ? this.bNode.getNodeType( builder ) : null;
		const cType = this.cNode ? this.cNode.getNodeType( builder ) : null;

		const aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );
		const bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );
		const cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );

		if ( aLen > bLen && aLen > cLen ) {

			return aType;

		} else if ( bLen > cLen ) {

			return bType;

		} else if ( cLen > aLen ) {

			return cType;

		}

		return aType;

	}

	getNodeType( builder ) {

		const method = this.method;

		if ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {

			return 'float';

		} else if ( method === MathNode.CROSS ) {

			return 'vec3';

		} else if ( method === MathNode.ALL ) {

			return 'bool';

		} else if ( method === MathNode.EQUALS ) {

			return builder.changeComponentType( this.aNode.getNodeType( builder ), 'bool' );

		} else if ( method === MathNode.MOD ) {

			return this.aNode.getNodeType( builder );

		} else {

			return this.getInputType( builder );

		}

	}

	generate( builder, output ) {

		const method = this.method;

		const type = this.getNodeType( builder );
		const inputType = this.getInputType( builder );

		const a = this.aNode;
		const b = this.bNode;
		const c = this.cNode;

		const isWebGL = builder.renderer.isWebGLRenderer === true;

		if ( method === MathNode.TRANSFORM_DIRECTION ) {

			// dir can be either a direction vector or a normal vector
			// upper-left 3x3 of matrix is assumed to be orthogonal

			let tA = a;
			let tB = b;

			if ( builder.isMatrix( tA.getNodeType( builder ) ) ) {

				tB = vec4( vec3( tB ), 0.0 );

			} else {

				tA = vec4( vec3( tA ), 0.0 );

			}

			const mulNode = mul( tA, tB ).xyz;

			return normalize( mulNode ).build( builder, output );

		} else if ( method === MathNode.NEGATE ) {

			return builder.format( '( - ' + a.build( builder, inputType ) + ' )', type, output );

		} else if ( method === MathNode.ONE_MINUS ) {

			return sub( 1.0, a ).build( builder, output );

		} else if ( method === MathNode.RECIPROCAL ) {

			return div( 1.0, a ).build( builder, output );

		} else if ( method === MathNode.DIFFERENCE ) {

			return abs( sub( a, b ) ).build( builder, output );

		} else {

			const params = [];

			if ( method === MathNode.CROSS || method === MathNode.MOD ) {

				params.push(
					a.build( builder, type ),
					b.build( builder, type )
				);

			} else if ( isWebGL && method === MathNode.STEP ) {

				params.push(
					a.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),
					b.build( builder, inputType )
				);

			} else if ( ( isWebGL && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {

				params.push(
					a.build( builder, inputType ),
					b.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )
				);

			} else if ( method === MathNode.REFRACT ) {

				params.push(
					a.build( builder, inputType ),
					b.build( builder, inputType ),
					c.build( builder, 'float' )
				);

			} else if ( method === MathNode.MIX ) {

				params.push(
					a.build( builder, inputType ),
					b.build( builder, inputType ),
					c.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )
				);

			} else {

				params.push( a.build( builder, inputType ) );
				if ( b !== null ) params.push( b.build( builder, inputType ) );
				if ( c !== null ) params.push( c.build( builder, inputType ) );

			}

			return builder.format( `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`, type, output );

		}

	}

	serialize( data ) {

		super.serialize( data );

		data.method = this.method;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.method = data.method;

	}

}

// 1 input

MathNode.ALL = 'all';
MathNode.ANY = 'any';
MathNode.EQUALS = 'equals';

MathNode.RADIANS = 'radians';
MathNode.DEGREES = 'degrees';
MathNode.EXP = 'exp';
MathNode.EXP2 = 'exp2';
MathNode.LOG = 'log';
MathNode.LOG2 = 'log2';
MathNode.SQRT = 'sqrt';
MathNode.INVERSE_SQRT = 'inversesqrt';
MathNode.FLOOR = 'floor';
MathNode.CEIL = 'ceil';
MathNode.NORMALIZE = 'normalize';
MathNode.FRACT = 'fract';
MathNode.SIN = 'sin';
MathNode.COS = 'cos';
MathNode.TAN = 'tan';
MathNode.ASIN = 'asin';
MathNode.ACOS = 'acos';
MathNode.ATAN = 'atan';
MathNode.ABS = 'abs';
MathNode.SIGN = 'sign';
MathNode.LENGTH = 'length';
MathNode.NEGATE = 'negate';
MathNode.ONE_MINUS = 'oneMinus';
MathNode.DFDX = 'dFdx';
MathNode.DFDY = 'dFdy';
MathNode.ROUND = 'round';
MathNode.RECIPROCAL = 'reciprocal';
MathNode.TRUNC = 'trunc';
MathNode.FWIDTH = 'fwidth';
MathNode.BITCAST = 'bitcast';
MathNode.TRANSPOSE = 'transpose';

// 2 inputs

MathNode.ATAN2 = 'atan2';
MathNode.MIN = 'min';
MathNode.MAX = 'max';
MathNode.MOD = 'mod';
MathNode.STEP = 'step';
MathNode.REFLECT = 'reflect';
MathNode.DISTANCE = 'distance';
MathNode.DIFFERENCE = 'difference';
MathNode.DOT = 'dot';
MathNode.CROSS = 'cross';
MathNode.POW = 'pow';
MathNode.TRANSFORM_DIRECTION = 'transformDirection';

// 3 inputs

MathNode.MIX = 'mix';
MathNode.CLAMP = 'clamp';
MathNode.REFRACT = 'refract';
MathNode.SMOOTHSTEP = 'smoothstep';
MathNode.FACEFORWARD = 'faceforward';

const EPSILON = /*@__PURE__*/ float( 1e-6 );
const INFINITY = /*@__PURE__*/ float( 1e6 );
const PI = /*@__PURE__*/ float( Math.PI );
const PI2 = /*@__PURE__*/ float( Math.PI * 2 );

const all = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ALL );
const any = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ANY );
const equals = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EQUALS );

const radians = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RADIANS );
const degrees = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DEGREES );
const exp = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP );
const exp2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP2 );
const log = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG );
const log2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG2 );
const sqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SQRT );
const inverseSqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.INVERSE_SQRT );
const floor = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FLOOR );
const ceil = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CEIL );
const normalize = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NORMALIZE );
const fract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FRACT );
const sin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIN );
const cos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.COS );
const tan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TAN );
const asin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ASIN );
const acos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ACOS );
const atan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN );
const abs = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ABS );
const sign = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIGN );
const length = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LENGTH );
const negate = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NEGATE );
const oneMinus = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ONE_MINUS );
const dFdx = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDX );
const dFdy = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDY );
const round = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ROUND );
const reciprocal = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RECIPROCAL );
const trunc = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRUNC );
const fwidth = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FWIDTH );
const bitcast = /*@__PURE__*/ nodeProxy( MathNode, MathNode.BITCAST );
const transpose = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSPOSE );

const atan2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN2 );
const min$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIN );
const max$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MAX );
const mod = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MOD );
const step = /*@__PURE__*/ nodeProxy( MathNode, MathNode.STEP );
const reflect = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFLECT );
const distance = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DISTANCE );
const difference = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DIFFERENCE );
const dot = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DOT );
const cross = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CROSS );
const pow = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW );
const pow2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 2 );
const pow3 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 3 );
const pow4 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 4 );
const transformDirection = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION );

const cbrt = ( a ) => mul( sign( a ), pow( abs( a ), 1.0 / 3.0 ) );
const lengthSq = ( a ) => dot( a, a );
const mix = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIX );
const clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );
const saturate = ( value ) => clamp( value );
const refract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFRACT );
const smoothstep = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SMOOTHSTEP );
const faceForward = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FACEFORWARD );

const rand = /*@__PURE__*/ Fn( ( [ uv ] ) => {

	const a = 12.9898, b = 78.233, c = 43758.5453;
	const dt = dot( uv.xy, vec2( a, b ) ), sn = mod( dt, PI );

	return fract( sin( sn ).mul( c ) );

} );

const mixElement = ( t, e1, e2 ) => mix( e1, e2, t );
const smoothstepElement = ( x, low, high ) => smoothstep( low, high, x );

addMethodChaining( 'all', all );
addMethodChaining( 'any', any );
addMethodChaining( 'equals', equals );

addMethodChaining( 'radians', radians );
addMethodChaining( 'degrees', degrees );
addMethodChaining( 'exp', exp );
addMethodChaining( 'exp2', exp2 );
addMethodChaining( 'log', log );
addMethodChaining( 'log2', log2 );
addMethodChaining( 'sqrt', sqrt );
addMethodChaining( 'inverseSqrt', inverseSqrt );
addMethodChaining( 'floor', floor );
addMethodChaining( 'ceil', ceil );
addMethodChaining( 'normalize', normalize );
addMethodChaining( 'fract', fract );
addMethodChaining( 'sin', sin );
addMethodChaining( 'cos', cos );
addMethodChaining( 'tan', tan );
addMethodChaining( 'asin', asin );
addMethodChaining( 'acos', acos );
addMethodChaining( 'atan', atan );
addMethodChaining( 'abs', abs );
addMethodChaining( 'sign', sign );
addMethodChaining( 'length', length );
addMethodChaining( 'lengthSq', lengthSq );
addMethodChaining( 'negate', negate );
addMethodChaining( 'oneMinus', oneMinus );
addMethodChaining( 'dFdx', dFdx );
addMethodChaining( 'dFdy', dFdy );
addMethodChaining( 'round', round );
addMethodChaining( 'reciprocal', reciprocal );
addMethodChaining( 'trunc', trunc );
addMethodChaining( 'fwidth', fwidth );
addMethodChaining( 'atan2', atan2 );
addMethodChaining( 'min', min$1 );
addMethodChaining( 'max', max$1 );
addMethodChaining( 'mod', mod );
addMethodChaining( 'step', step );
addMethodChaining( 'reflect', reflect );
addMethodChaining( 'distance', distance );
addMethodChaining( 'dot', dot );
addMethodChaining( 'cross', cross );
addMethodChaining( 'pow', pow );
addMethodChaining( 'pow2', pow2 );
addMethodChaining( 'pow3', pow3 );
addMethodChaining( 'pow4', pow4 );
addMethodChaining( 'transformDirection', transformDirection );
addMethodChaining( 'mix', mixElement );
addMethodChaining( 'clamp', clamp );
addMethodChaining( 'refract', refract );
addMethodChaining( 'smoothstep', smoothstepElement );
addMethodChaining( 'faceForward', faceForward );
addMethodChaining( 'difference', difference );
addMethodChaining( 'saturate', saturate );
addMethodChaining( 'cbrt', cbrt );
addMethodChaining( 'transpose', transpose );
addMethodChaining( 'rand', rand );

class ConditionalNode extends Node {

	static get type() {

		return 'ConditionalNode';

	}

	constructor( condNode, ifNode, elseNode = null ) {

		super();

		this.condNode = condNode;

		this.ifNode = ifNode;
		this.elseNode = elseNode;

	}

	getNodeType( builder ) {

		const ifType = this.ifNode.getNodeType( builder );

		if ( this.elseNode !== null ) {

			const elseType = this.elseNode.getNodeType( builder );

			if ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {

				return elseType;

			}

		}

		return ifType;

	}

	setup( builder ) {

		const condNode = this.condNode.cache();
		const ifNode = this.ifNode.cache();
		const elseNode = this.elseNode ? this.elseNode.cache() : null;

		//

		const currentNodeBlock = builder.context.nodeBlock;

		builder.getDataFromNode( ifNode ).parentNodeBlock = currentNodeBlock;
		if ( elseNode !== null ) builder.getDataFromNode( elseNode ).parentNodeBlock = currentNodeBlock;

		//

		const properties = builder.getNodeProperties( this );
		properties.condNode = condNode;
		properties.ifNode = ifNode.context( { nodeBlock: ifNode } );
		properties.elseNode = elseNode ? elseNode.context( { nodeBlock: elseNode } ) : null;

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );

		const nodeData = builder.getDataFromNode( this );

		if ( nodeData.nodeProperty !== undefined ) {

			return nodeData.nodeProperty;

		}

		const { condNode, ifNode, elseNode } = builder.getNodeProperties( this );

		const needsOutput = output !== 'void';
		const nodeProperty = needsOutput ? property( type ).build( builder ) : '';

		nodeData.nodeProperty = nodeProperty;

		const nodeSnippet = condNode.build( builder, 'bool' );

		builder.addFlowCode( `\n${ builder.tab }if ( ${ nodeSnippet } ) {\n\n` ).addFlowTab();

		let ifSnippet = ifNode.build( builder, type );

		if ( ifSnippet ) {

			if ( needsOutput ) {

				ifSnippet = nodeProperty + ' = ' + ifSnippet + ';';

			} else {

				ifSnippet = 'return ' + ifSnippet + ';';

			}

		}

		builder.removeFlowTab().addFlowCode( builder.tab + '\t' + ifSnippet + '\n\n' + builder.tab + '}' );

		if ( elseNode !== null ) {

			builder.addFlowCode( ' else {\n\n' ).addFlowTab();

			let elseSnippet = elseNode.build( builder, type );

			if ( elseSnippet ) {

				if ( needsOutput ) {

					elseSnippet = nodeProperty + ' = ' + elseSnippet + ';';

				} else {

					elseSnippet = 'return ' + elseSnippet + ';';

				}

			}

			builder.removeFlowTab().addFlowCode( builder.tab + '\t' + elseSnippet + '\n\n' + builder.tab + '}\n\n' );

		} else {

			builder.addFlowCode( '\n\n' );

		}

		return builder.format( nodeProperty, type, output );

	}

}

const select = /*@__PURE__*/ nodeProxy( ConditionalNode );

addMethodChaining( 'select', select );

//

const cond = ( ...params ) => { // @deprecated, r168

	console.warn( 'TSL.ConditionalNode: cond() has been renamed to select().' );
	return select( ...params );

};

addMethodChaining( 'cond', cond );

class ContextNode extends Node {

	static get type() {

		return 'ContextNode';

	}

	constructor( node, value = {} ) {

		super();

		this.isContextNode = true;

		this.node = node;
		this.value = value;

	}

	getScope() {

		return this.node.getScope();

	}

	getNodeType( builder ) {

		return this.node.getNodeType( builder );

	}

	analyze( builder ) {

		this.node.build( builder );

	}

	setup( builder ) {

		const previousContext = builder.getContext();

		builder.setContext( { ...builder.context, ...this.value } );

		const node = this.node.build( builder );

		builder.setContext( previousContext );

		return node;

	}

	generate( builder, output ) {

		const previousContext = builder.getContext();

		builder.setContext( { ...builder.context, ...this.value } );

		const snippet = this.node.build( builder, output );

		builder.setContext( previousContext );

		return snippet;

	}

}

const context = /*@__PURE__*/ nodeProxy( ContextNode );
const label = ( node, name ) => context( node, { label: name } );

addMethodChaining( 'context', context );
addMethodChaining( 'label', label );

class VarNode extends Node {

	static get type() {

		return 'VarNode';

	}

	constructor( node, name = null ) {

		super();

		this.node = node;
		this.name = name;

		this.global = true;

		this.isVarNode = true;

	}

	getHash( builder ) {

		return this.name || super.getHash( builder );

	}

	getNodeType( builder ) {

		return this.node.getNodeType( builder );

	}

	generate( builder ) {

		const { node, name } = this;

		const nodeVar = builder.getVarFromNode( this, name, builder.getVectorType( this.getNodeType( builder ) ) );

		const propertyName = builder.getPropertyName( nodeVar );

		const snippet = node.build( builder, nodeVar.type );

		builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

		return propertyName;

	}

}

const createVar = /*@__PURE__*/ nodeProxy( VarNode );

addMethodChaining( 'toVar', ( ...params ) => createVar( ...params ).append() );

// Deprecated

const temp = ( node ) => { // @deprecated, r170

	console.warn( 'TSL: "temp" is deprecated. Use ".toVar()" instead.' );

	return createVar( node );

};

addMethodChaining( 'temp', temp );

class VaryingNode extends Node {

	static get type() {

		return 'VaryingNode';

	}

	constructor( node, name = null ) {

		super();

		this.node = node;
		this.name = name;

		this.isVaryingNode = true;

	}

	isGlobal() {

		return true;

	}

	getHash( builder ) {

		return this.name || super.getHash( builder );

	}

	getNodeType( builder ) {

		// VaryingNode is auto type

		return this.node.getNodeType( builder );

	}

	setupVarying( builder ) {

		const properties = builder.getNodeProperties( this );

		let varying = properties.varying;

		if ( varying === undefined ) {

			const name = this.name;
			const type = this.getNodeType( builder );

			properties.varying = varying = builder.getVaryingFromNode( this, name, type );
			properties.node = this.node;

		}

		// this property can be used to check if the varying can be optimized for a variable
		varying.needsInterpolation || ( varying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );

		return varying;

	}

	setup( builder ) {

		this.setupVarying( builder );

	}

	analyze( builder ) {

		this.setupVarying( builder );

		return this.node.analyze( builder );

	}

	generate( builder ) {

		const properties = builder.getNodeProperties( this );
		const varying = this.setupVarying( builder );

		if ( properties.propertyName === undefined ) {

			const type = this.getNodeType( builder );
			const propertyName = builder.getPropertyName( varying, NodeShaderStage.VERTEX );

			// force node run in vertex stage
			builder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node, type, propertyName );

			properties.propertyName = propertyName;

		}

		return builder.getPropertyName( varying );

	}

}

const varying = /*@__PURE__*/ nodeProxy( VaryingNode );

addMethodChaining( 'varying', varying );

const sRGBTransferEOTF = /*@__PURE__*/ Fn( ( [ color ] ) => {

	const a = color.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );
	const b = color.mul( 0.0773993808 );
	const factor = color.lessThanEqual( 0.04045 );

	const rgbResult = mix( a, b, factor );

	return rgbResult;

} ).setLayout( {
	name: 'sRGBTransferEOTF',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' }
	]
} );

const sRGBTransferOETF = /*@__PURE__*/ Fn( ( [ color ] ) => {

	const a = color.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );
	const b = color.mul( 12.92 );
	const factor = color.lessThanEqual( 0.0031308 );

	const rgbResult = mix( a, b, factor );

	return rgbResult;

} ).setLayout( {
	name: 'sRGBTransferOETF',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' }
	]
} );

const WORKING_COLOR_SPACE = 'WorkingColorSpace';
const OUTPUT_COLOR_SPACE = 'OutputColorSpace';

class ColorSpaceNode extends TempNode {

	static get type() {

		return 'ColorSpaceNode';

	}

	constructor( colorNode, source, target ) {

		super( 'vec4' );

		this.colorNode = colorNode;
		this.source = source;
		this.target = target;

	}

	resolveColorSpace( builder, colorSpace ) {

		if ( colorSpace === WORKING_COLOR_SPACE ) {

			return ColorManagement.workingColorSpace;

		} else if ( colorSpace === OUTPUT_COLOR_SPACE ) {

			return builder.context.outputColorSpace || builder.renderer.outputColorSpace;

		}

		return colorSpace;

	}

	setup( builder ) {

		const { colorNode } = this;

		const source = this.resolveColorSpace( builder, this.source );
		const target = this.resolveColorSpace( builder, this.target );

		let outputNode = colorNode;

		if ( ColorManagement.enabled === false || source === target || ! source || ! target ) {

			return outputNode;

		}

		if ( ColorManagement.getTransfer( source ) === SRGBTransfer ) {

			outputNode = vec4( sRGBTransferEOTF( outputNode.rgb ), outputNode.a );

		}

		if ( ColorManagement.getPrimaries( source ) !== ColorManagement.getPrimaries( target ) ) {

			outputNode = vec4(
				mat3( ColorManagement._getMatrix( new Matrix3(), source, target ) ).mul( outputNode.rgb ),
				outputNode.a
			);

		}

		if ( ColorManagement.getTransfer( target ) === SRGBTransfer ) {

			outputNode = vec4( sRGBTransferOETF( outputNode.rgb ), outputNode.a );

		}

		return outputNode;

	}

}

const toOutputColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE ) );
const toWorkingColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE ) );

const workingToColorSpace = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, colorSpace ) );
const colorSpaceToWorking = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), colorSpace, WORKING_COLOR_SPACE ) );

const convertColorSpace = ( node, sourceColorSpace, targetColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), sourceColorSpace, targetColorSpace ) );

addMethodChaining( 'toOutputColorSpace', toOutputColorSpace );
addMethodChaining( 'toWorkingColorSpace', toWorkingColorSpace );

addMethodChaining( 'workingToColorSpace', workingToColorSpace );
addMethodChaining( 'colorSpaceToWorking', colorSpaceToWorking );

let ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {

	static get type() {

		return 'ReferenceElementNode';

	}

	constructor( referenceNode, indexNode ) {

		super( referenceNode, indexNode );

		this.referenceNode = referenceNode;

		this.isReferenceElementNode = true;

	}

	getNodeType() {

		return this.referenceNode.uniformType;

	}

	generate( builder ) {

		const snippet = super.generate( builder );
		const arrayType = this.referenceNode.getNodeType();
		const elementType = this.getNodeType();

		return builder.format( snippet, arrayType, elementType );

	}

};

class ReferenceBaseNode extends Node {

	static get type() {

		return 'ReferenceBaseNode';

	}

	constructor( property, uniformType, object = null, count = null ) {

		super();

		this.property = property;
		this.uniformType = uniformType;
		this.object = object;
		this.count = count;

		this.properties = property.split( '.' );
		this.reference = object;
		this.node = null;
		this.group = null;

		this.updateType = NodeUpdateType.OBJECT;

	}

	setGroup( group ) {

		this.group = group;

		return this;

	}

	element( indexNode ) {

		return nodeObject( new ReferenceElementNode$1( this, nodeObject( indexNode ) ) );

	}

	setNodeType( uniformType ) {

		const node = uniform( null, uniformType ).getSelf();

		if ( this.group !== null ) {

			node.setGroup( this.group );

		}

		this.node = node;

	}

	getNodeType( builder ) {

		if ( this.node === null ) {

			this.updateReference( builder );
			this.updateValue();

		}

		return this.node.getNodeType( builder );

	}

	getValueFromReference( object = this.reference ) {

		const { properties } = this;

		let value = object[ properties[ 0 ] ];

		for ( let i = 1; i < properties.length; i ++ ) {

			value = value[ properties[ i ] ];

		}

		return value;

	}

	updateReference( state ) {

		this.reference = this.object !== null ? this.object : state.object;

		return this.reference;

	}

	setup() {

		this.updateValue();

		return this.node;

	}

	update( /*frame*/ ) {

		this.updateValue();

	}

	updateValue() {

		if ( this.node === null ) this.setNodeType( this.uniformType );

		const value = this.getValueFromReference();

		if ( Array.isArray( value ) ) {

			this.node.array = value;

		} else {

			this.node.value = value;

		}

	}

}

const reference$1 = ( name, type, object ) => nodeObject( new ReferenceBaseNode( name, type, object ) );

class RendererReferenceNode extends ReferenceBaseNode {

	static get type() {

		return 'RendererReferenceNode';

	}

	constructor( property, inputType, renderer = null ) {

		super( property, inputType, renderer );

		this.renderer = renderer;

		this.setGroup( renderGroup );

	}

	updateReference( state ) {

		this.reference = this.renderer !== null ? this.renderer : state.renderer;

		return this.reference;

	}

}

const rendererReference = ( name, type, renderer ) => nodeObject( new RendererReferenceNode( name, type, renderer ) );

class ToneMappingNode extends TempNode {

	static get type() {

		return 'ToneMappingNode';

	}

	constructor( toneMapping, exposureNode = toneMappingExposure, colorNode = null ) {

		super( 'vec3' );

		this.toneMapping = toneMapping;

		this.exposureNode = exposureNode;
		this.colorNode = colorNode;

	}

	getCacheKey() {

		return hash$1( super.getCacheKey(), this.toneMapping );

	}

	setup( builder ) {

		const colorNode = this.colorNode || builder.context.color;
		const toneMapping = this.toneMapping;

		if ( toneMapping === NoToneMapping ) return colorNode;

		let outputNode = null;

		const toneMappingFn = builder.renderer.library.getToneMappingFunction( toneMapping );

		if ( toneMappingFn !== null ) {

			outputNode = vec4( toneMappingFn( colorNode.rgb, this.exposureNode ), colorNode.a );

		} else {

			console.error( 'ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping );

			outputNode = colorNode;

		}

		return outputNode;

	}

}

const toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );
const toneMappingExposure = /*@__PURE__*/ rendererReference( 'toneMappingExposure', 'float' );

addMethodChaining( 'toneMapping', ( color, mapping, exposure ) => toneMapping( mapping, exposure, color ) );

class BufferAttributeNode extends InputNode {

	static get type() {

		return 'BufferAttributeNode';

	}

	constructor( value, bufferType = null, bufferStride = 0, bufferOffset = 0 ) {

		super( value, bufferType );

		this.isBufferNode = true;

		this.bufferType = bufferType;
		this.bufferStride = bufferStride;
		this.bufferOffset = bufferOffset;

		this.usage = StaticDrawUsage;
		this.instanced = false;

		this.attribute = null;

		this.global = true;

		if ( value && value.isBufferAttribute === true ) {

			this.attribute = value;
			this.usage = value.usage;
			this.instanced = value.isInstancedBufferAttribute;

		}

	}

	getHash( builder ) {

		if ( this.bufferStride === 0 && this.bufferOffset === 0 ) {

			let bufferData = builder.globalCache.getData( this.value );

			if ( bufferData === undefined ) {

				bufferData = {
					node: this
				};

				builder.globalCache.setData( this.value, bufferData );

			}

			return bufferData.node.uuid;

		}

		return this.uuid;

	}

	getNodeType( builder ) {

		if ( this.bufferType === null ) {

			this.bufferType = builder.getTypeFromAttribute( this.attribute );

		}

		return this.bufferType;

	}

	setup( builder ) {

		if ( this.attribute !== null ) return;

		const type = this.getNodeType( builder );
		const array = this.value;
		const itemSize = builder.getTypeLength( type );
		const stride = this.bufferStride || itemSize;
		const offset = this.bufferOffset;

		const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );
		const bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );

		buffer.setUsage( this.usage );

		this.attribute = bufferAttribute;
		this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute

	}

	generate( builder ) {

		const nodeType = this.getNodeType( builder );

		const nodeAttribute = builder.getBufferAttributeFromNode( this, nodeType );
		const propertyName = builder.getPropertyName( nodeAttribute );

		let output = null;

		if ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {

			this.name = propertyName;

			output = propertyName;

		} else {

			const nodeVarying = varying( this );

			output = nodeVarying.build( builder, nodeType );

		}

		return output;

	}

	getInputType( /*builder*/ ) {

		return 'bufferAttribute';

	}

	setUsage( value ) {

		this.usage = value;

		if ( this.attribute && this.attribute.isBufferAttribute === true ) {

			this.attribute.usage = value;

		}

		return this;

	}

	setInstanced( value ) {

		this.instanced = value;

		return this;

	}

}

const bufferAttribute = ( array, type, stride, offset ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );
const dynamicBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );

const instancedBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );
const instancedDynamicBufferAttribute = ( array, type, stride, offset ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );

addMethodChaining( 'toAttribute', ( bufferNode ) => bufferAttribute( bufferNode.value ) );

class ComputeNode extends Node {

	static get type() {

		return 'ComputeNode';

	}

	constructor( computeNode, count, workgroupSize = [ 64 ] ) {

		super( 'void' );

		this.isComputeNode = true;

		this.computeNode = computeNode;

		this.count = count;
		this.workgroupSize = workgroupSize;
		this.dispatchCount = 0;

		this.version = 1;
		this.updateBeforeType = NodeUpdateType.OBJECT;

		this.onInitFunction = null;

		this.updateDispatchCount();

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	updateDispatchCount() {

		const { count, workgroupSize } = this;

		let size = workgroupSize[ 0 ];

		for ( let i = 1; i < workgroupSize.length; i ++ )
			size *= workgroupSize[ i ];

		this.dispatchCount = Math.ceil( count / size );

	}

	onInit( callback ) {

		this.onInitFunction = callback;

		return this;

	}

	updateBefore( { renderer } ) {

		renderer.compute( this );

	}

	generate( builder ) {

		const { shaderStage } = builder;

		if ( shaderStage === 'compute' ) {

			const snippet = this.computeNode.build( builder, 'void' );

			if ( snippet !== '' ) {

				builder.addLineFlowCode( snippet, this );

			}

		}

	}

}

const compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );

addMethodChaining( 'compute', compute );

class CacheNode extends Node {

	static get type() {

		return 'CacheNode';

	}

	constructor( node, parent = true ) {

		super();

		this.node = node;
		this.parent = parent;

		this.isCacheNode = true;

	}

	getNodeType( builder ) {

		return this.node.getNodeType( builder );

	}

	build( builder, ...params ) {

		const previousCache = builder.getCache();
		const cache = builder.getCacheFromNode( this, this.parent );

		builder.setCache( cache );

		const data = this.node.build( builder, ...params );

		builder.setCache( previousCache );

		return data;

	}

}

const cache = ( node, ...params ) => nodeObject( new CacheNode( nodeObject( node ), ...params ) );

addMethodChaining( 'cache', cache );

class BypassNode extends Node {

	static get type() {

		return 'BypassNode';

	}

	constructor( returnNode, callNode ) {

		super();

		this.isBypassNode = true;

		this.outputNode = returnNode;
		this.callNode = callNode;

	}

	getNodeType( builder ) {

		return this.outputNode.getNodeType( builder );

	}

	generate( builder ) {

		const snippet = this.callNode.build( builder, 'void' );

		if ( snippet !== '' ) {

			builder.addLineFlowCode( snippet, this );

		}

		return this.outputNode.build( builder );

	}

}

const bypass = /*@__PURE__*/ nodeProxy( BypassNode );

addMethodChaining( 'bypass', bypass );

class RemapNode extends Node {

	static get type() {

		return 'RemapNode';

	}

	constructor( node, inLowNode, inHighNode, outLowNode = float( 0 ), outHighNode = float( 1 ) ) {

		super();

		this.node = node;
		this.inLowNode = inLowNode;
		this.inHighNode = inHighNode;
		this.outLowNode = outLowNode;
		this.outHighNode = outHighNode;

		this.doClamp = true;

	}

	setup() {

		const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;

		let t = node.sub( inLowNode ).div( inHighNode.sub( inLowNode ) );

		if ( doClamp === true ) t = t.clamp();

		return t.mul( outHighNode.sub( outLowNode ) ).add( outLowNode );

	}

}

const remap = /*@__PURE__*/ nodeProxy( RemapNode, null, null, { doClamp: false } );
const remapClamp = /*@__PURE__*/ nodeProxy( RemapNode );

addMethodChaining( 'remap', remap );
addMethodChaining( 'remapClamp', remapClamp );

class ExpressionNode extends Node {

	static get type() {

		return 'ExpressionNode';

	}

	constructor( snippet = '', nodeType = 'void' ) {

		super( nodeType );

		this.snippet = snippet;

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );
		const snippet = this.snippet;

		if ( type === 'void' ) {

			builder.addLineFlowCode( snippet, this );

		} else {

			return builder.format( `( ${ snippet } )`, type, output );

		}

	}

}

const expression = /*@__PURE__*/ nodeProxy( ExpressionNode );

const Discard = ( conditional ) => ( conditional ? select( conditional, expression( 'discard' ) ) : expression( 'discard' ) ).append();
const Return = () => expression( 'return' ).append();

addMethodChaining( 'discard', Discard );

class RenderOutputNode extends TempNode {

	static get type() {

		return 'RenderOutputNode';

	}

	constructor( colorNode, toneMapping, outputColorSpace ) {

		super( 'vec4' );

		this.colorNode = colorNode;
		this.toneMapping = toneMapping;
		this.outputColorSpace = outputColorSpace;

		this.isRenderOutput = true;

	}

	setup( { context } ) {

		let outputNode = this.colorNode || context.color;

		// tone mapping

		const toneMapping = ( this.toneMapping !== null ? this.toneMapping : context.toneMapping ) || NoToneMapping;
		const outputColorSpace = ( this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace ) || NoColorSpace;

		if ( toneMapping !== NoToneMapping ) {

			outputNode = outputNode.toneMapping( toneMapping );

		}

		// working to output color space

		if ( outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace ) {

			outputNode = outputNode.workingToColorSpace( outputColorSpace );

		}

		return outputNode;

	}

}

const renderOutput = ( color, toneMapping = null, outputColorSpace = null ) => nodeObject( new RenderOutputNode( nodeObject( color ), toneMapping, outputColorSpace ) );

addMethodChaining( 'renderOutput', renderOutput );

// Non-PURE exports list, side-effects are required here.
// TSL Base Syntax


function addNodeElement( name/*, nodeElement*/ ) {

	console.warn( 'THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add', name );

}

class AttributeNode extends Node {

	static get type() {

		return 'AttributeNode';

	}

	constructor( attributeName, nodeType = null ) {

		super( nodeType );

		this.global = true;

		this._attributeName = attributeName;

	}

	getHash( builder ) {

		return this.getAttributeName( builder );

	}

	getNodeType( builder ) {

		let nodeType = this.nodeType;

		if ( nodeType === null ) {

			const attributeName = this.getAttributeName( builder );

			if ( builder.hasGeometryAttribute( attributeName ) ) {

				const attribute = builder.geometry.getAttribute( attributeName );

				nodeType = builder.getTypeFromAttribute( attribute );

			} else {

				nodeType = 'float';

			}

		}

		return nodeType;

	}

	setAttributeName( attributeName ) {

		this._attributeName = attributeName;

		return this;

	}

	getAttributeName( /*builder*/ ) {

		return this._attributeName;

	}

	generate( builder ) {

		const attributeName = this.getAttributeName( builder );
		const nodeType = this.getNodeType( builder );
		const geometryAttribute = builder.hasGeometryAttribute( attributeName );

		if ( geometryAttribute === true ) {

			const attribute = builder.geometry.getAttribute( attributeName );
			const attributeType = builder.getTypeFromAttribute( attribute );

			const nodeAttribute = builder.getAttribute( attributeName, attributeType );

			if ( builder.shaderStage === 'vertex' ) {

				return builder.format( nodeAttribute.name, attributeType, nodeType );

			} else {

				const nodeVarying = varying( this );

				return nodeVarying.build( builder, nodeType );

			}

		} else {

			console.warn( `AttributeNode: Vertex attribute "${ attributeName }" not found on geometry.` );

			return builder.generateConst( nodeType );

		}

	}

	serialize( data ) {

		super.serialize( data );

		data.global = this.global;
		data._attributeName = this._attributeName;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.global = data.global;
		this._attributeName = data._attributeName;

	}

}

const attribute = ( name, nodeType ) => nodeObject( new AttributeNode( name, nodeType ) );

const uv = ( index ) => attribute( 'uv' + ( index > 0 ? index : '' ), 'vec2' );

class TextureSizeNode extends Node {

	static get type() {

		return 'TextureSizeNode';

	}

	constructor( textureNode, levelNode = null ) {

		super( 'uvec2' );

		this.isTextureSizeNode = true;

		this.textureNode = textureNode;
		this.levelNode = levelNode;

	}

	generate( builder, output ) {

		const textureProperty = this.textureNode.build( builder, 'property' );
		const level = this.levelNode === null ? '0' : this.levelNode.build( builder, 'int' );

		return builder.format( `${ builder.getMethod( 'textureDimensions' ) }( ${ textureProperty }, ${ level } )`, this.getNodeType( builder ), output );

	}

}

const textureSize = /*@__PURE__*/ nodeProxy( TextureSizeNode );

class MaxMipLevelNode extends UniformNode {

	static get type() {

		return 'MaxMipLevelNode';

	}

	constructor( textureNode ) {

		super( 0 );

		this._textureNode = textureNode;

		this.updateType = NodeUpdateType.FRAME;

	}

	get textureNode() {

		return this._textureNode;

	}

	get texture() {

		return this._textureNode.value;

	}

	update() {

		const texture = this.texture;
		const images = texture.images;
		const image = ( images && images.length > 0 ) ? ( ( images[ 0 ] && images[ 0 ].image ) || images[ 0 ] ) : texture.image;

		if ( image && image.width !== undefined ) {

			const { width, height } = image;

			this.value = Math.log2( Math.max( width, height ) );

		}

	}

}

const maxMipLevel = /*@__PURE__*/ nodeProxy( MaxMipLevelNode );

class TextureNode extends UniformNode {

	static get type() {

		return 'TextureNode';

	}

	constructor( value, uvNode = null, levelNode = null, biasNode = null ) {

		super( value );

		this.isTextureNode = true;

		this.uvNode = uvNode;
		this.levelNode = levelNode;
		this.biasNode = biasNode;
		this.compareNode = null;
		this.depthNode = null;
		this.gradNode = null;

		this.sampler = true;
		this.updateMatrix = false;
		this.updateType = NodeUpdateType.NONE;

		this.referenceNode = null;

		this._value = value;
		this._matrixUniform = null;

		this.setUpdateMatrix( uvNode === null );

	}

	set value( value ) {

		if ( this.referenceNode ) {

			this.referenceNode.value = value;

		} else {

			this._value = value;

		}

	}

	get value() {

		return this.referenceNode ? this.referenceNode.value : this._value;

	}

	getUniformHash( /*builder*/ ) {

		return this.value.uuid;

	}

	getNodeType( /*builder*/ ) {

		if ( this.value.isDepthTexture === true ) return 'float';

		if ( this.value.type === UnsignedIntType ) {

			return 'uvec4';

		} else if ( this.value.type === IntType ) {

			return 'ivec4';

		}

		return 'vec4';

	}

	getInputType( /*builder*/ ) {

		return 'texture';

	}

	getDefaultUV() {

		return uv( this.value.channel );

	}

	updateReference( /*state*/ ) {

		return this.value;

	}

	getTransformedUV( uvNode ) {

		if ( this._matrixUniform === null ) this._matrixUniform = uniform( this.value.matrix );

		return this._matrixUniform.mul( vec3( uvNode, 1 ) ).xy;

	}

	setUpdateMatrix( value ) {

		this.updateMatrix = value;
		this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;

		return this;

	}

	setupUV( builder, uvNode ) {

		const texture = this.value;

		if ( builder.isFlipY() && ( ( texture.image instanceof ImageBitmap && texture.flipY === true ) || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {

			if ( this.sampler ) {

				uvNode = uvNode.flipY();

			} else {

				uvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );

			}

		}

		return uvNode;

	}

	setup( builder ) {

		const properties = builder.getNodeProperties( this );
		properties.referenceNode = this.referenceNode;

		//

		let uvNode = this.uvNode;

		if ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {

			uvNode = builder.context.getUV( this );

		}

		if ( ! uvNode ) uvNode = this.getDefaultUV();

		if ( this.updateMatrix === true ) {

			uvNode = this.getTransformedUV( uvNode );

		}

		uvNode = this.setupUV( builder, uvNode );

		//

		let levelNode = this.levelNode;

		if ( levelNode === null && builder.context.getTextureLevel ) {

			levelNode = builder.context.getTextureLevel( this );

		}

		//

		properties.uvNode = uvNode;
		properties.levelNode = levelNode;
		properties.biasNode = this.biasNode;
		properties.compareNode = this.compareNode;
		properties.gradNode = this.gradNode;
		properties.depthNode = this.depthNode;

	}

	generateUV( builder, uvNode ) {

		return uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );

	}

	generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet ) {

		const texture = this.value;

		let snippet;

		if ( levelSnippet ) {

			snippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );

		} else if ( biasSnippet ) {

			snippet = builder.generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet );

		} else if ( gradSnippet ) {

			snippet = builder.generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet );

		} else if ( compareSnippet ) {

			snippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );

		} else if ( this.sampler === false ) {

			snippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );

		} else {

			snippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );

		}

		return snippet;

	}

	generate( builder, output ) {

		const properties = builder.getNodeProperties( this );

		const texture = this.value;

		if ( ! texture || texture.isTexture !== true ) {

			throw new Error( 'TextureNode: Need a three.js texture.' );

		}

		const textureProperty = super.generate( builder, 'property' );

		if ( output === 'sampler' ) {

			return textureProperty + '_sampler';

		} else if ( builder.isReference( output ) ) {

			return textureProperty;

		} else {

			const nodeData = builder.getDataFromNode( this );

			let propertyName = nodeData.propertyName;

			if ( propertyName === undefined ) {

				const { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode } = properties;

				const uvSnippet = this.generateUV( builder, uvNode );
				const levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;
				const biasSnippet = biasNode ? biasNode.build( builder, 'float' ) : null;
				const depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;
				const compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;
				const gradSnippet = gradNode ? [ gradNode[ 0 ].build( builder, 'vec2' ), gradNode[ 1 ].build( builder, 'vec2' ) ] : null;

				const nodeVar = builder.getVarFromNode( this );

				propertyName = builder.getPropertyName( nodeVar );

				const snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet );

				builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

				nodeData.snippet = snippet;
				nodeData.propertyName = propertyName;

			}

			let snippet = propertyName;
			const nodeType = this.getNodeType( builder );

			if ( builder.needsToWorkingColorSpace( texture ) ) {

				snippet = colorSpaceToWorking( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );

			}

			return builder.format( snippet, nodeType, output );

		}

	}

	setSampler( value ) {

		this.sampler = value;

		return this;

	}

	getSampler() {

		return this.sampler;

	}

	// @TODO: Move to TSL

	uv( uvNode ) {

		const textureNode = this.clone();
		textureNode.uvNode = nodeObject( uvNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	blur( amountNode ) {

		const textureNode = this.clone();
		textureNode.biasNode = nodeObject( amountNode ).mul( maxMipLevel( textureNode ) );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	level( levelNode ) {

		const textureNode = this.clone();
		textureNode.levelNode = nodeObject( levelNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	size( levelNode ) {

		return textureSize( this, levelNode );

	}

	bias( biasNode ) {

		const textureNode = this.clone();
		textureNode.biasNode = nodeObject( biasNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	compare( compareNode ) {

		const textureNode = this.clone();
		textureNode.compareNode = nodeObject( compareNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	grad( gradNodeX, gradNodeY ) {

		const textureNode = this.clone();
		textureNode.gradNode = [ nodeObject( gradNodeX ), nodeObject( gradNodeY ) ];
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	depth( depthNode ) {

		const textureNode = this.clone();
		textureNode.depthNode = nodeObject( depthNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	// --

	serialize( data ) {

		super.serialize( data );

		data.value = this.value.toJSON( data.meta ).uuid;
		data.sampler = this.sampler;
		data.updateMatrix = this.updateMatrix;
		data.updateType = this.updateType;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.value = data.meta.textures[ data.value ];
		this.sampler = data.sampler;
		this.updateMatrix = data.updateMatrix;
		this.updateType = data.updateType;

	}

	update() {

		const texture = this.value;
		const matrixUniform = this._matrixUniform;

		if ( matrixUniform !== null ) matrixUniform.value = texture.matrix;

		if ( texture.matrixAutoUpdate === true ) {

			texture.updateMatrix();

		}

	}

	clone() {

		const newNode = new this.constructor( this.value, this.uvNode, this.levelNode, this.biasNode );
		newNode.sampler = this.sampler;

		return newNode;

	}

}

const texture = /*@__PURE__*/ nodeProxy( TextureNode );
const textureLoad = ( ...params ) => texture( ...params ).setSampler( false );

//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );

const sampler = ( aTexture ) => ( aTexture.isNode === true ? aTexture : texture( aTexture ) ).convert( 'sampler' );

const cameraNear = /*@__PURE__*/ uniform( 'float' ).label( 'cameraNear' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.near );
const cameraFar = /*@__PURE__*/ uniform( 'float' ).label( 'cameraFar' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.far );
const cameraProjectionMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraProjectionMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrix );
const cameraProjectionMatrixInverse = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraProjectionMatrixInverse' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrixInverse );
const cameraViewMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraViewMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorldInverse );
const cameraWorldMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraWorldMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorld );
const cameraNormalMatrix = /*@__PURE__*/ uniform( 'mat3' ).label( 'cameraNormalMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.normalMatrix );
const cameraPosition = /*@__PURE__*/ uniform( new Vector3() ).label( 'cameraPosition' ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => self.value.setFromMatrixPosition( camera.matrixWorld ) );

class Object3DNode extends Node {

	static get type() {

		return 'Object3DNode';

	}

	constructor( scope, object3d = null ) {

		super();

		this.scope = scope;
		this.object3d = object3d;

		this.updateType = NodeUpdateType.OBJECT;

		this._uniformNode = new UniformNode( null );

	}

	getNodeType() {

		const scope = this.scope;

		if ( scope === Object3DNode.WORLD_MATRIX ) {

			return 'mat4';

		} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {

			return 'vec3';

		}

	}

	update( frame ) {

		const object = this.object3d;
		const uniformNode = this._uniformNode;
		const scope = this.scope;

		if ( scope === Object3DNode.WORLD_MATRIX ) {

			uniformNode.value = object.matrixWorld;

		} else if ( scope === Object3DNode.POSITION ) {

			uniformNode.value = uniformNode.value || new Vector3();

			uniformNode.value.setFromMatrixPosition( object.matrixWorld );

		} else if ( scope === Object3DNode.SCALE ) {

			uniformNode.value = uniformNode.value || new Vector3();

			uniformNode.value.setFromMatrixScale( object.matrixWorld );

		} else if ( scope === Object3DNode.DIRECTION ) {

			uniformNode.value = uniformNode.value || new Vector3();

			object.getWorldDirection( uniformNode.value );

		} else if ( scope === Object3DNode.VIEW_POSITION ) {

			const camera = frame.camera;

			uniformNode.value = uniformNode.value || new Vector3();
			uniformNode.value.setFromMatrixPosition( object.matrixWorld );

			uniformNode.value.applyMatrix4( camera.matrixWorldInverse );

		}

	}

	generate( builder ) {

		const scope = this.scope;

		if ( scope === Object3DNode.WORLD_MATRIX ) {

			this._uniformNode.nodeType = 'mat4';

		} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {

			this._uniformNode.nodeType = 'vec3';

		}

		return this._uniformNode.build( builder );

	}

	serialize( data ) {

		super.serialize( data );

		data.scope = this.scope;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.scope = data.scope;

	}

}

Object3DNode.WORLD_MATRIX = 'worldMatrix';
Object3DNode.POSITION = 'position';
Object3DNode.SCALE = 'scale';
Object3DNode.VIEW_POSITION = 'viewPosition';
Object3DNode.DIRECTION = 'direction';

const objectDirection = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.DIRECTION );
const objectWorldMatrix = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX );
const objectPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.POSITION );
const objectScale = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.SCALE );
const objectViewPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION );

class ModelNode extends Object3DNode {

	static get type() {

		return 'ModelNode';

	}

	constructor( scope ) {

		super( scope );

	}

	update( frame ) {

		this.object3d = frame.object;

		super.update( frame );

	}

}

const modelDirection = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.DIRECTION );
const modelWorldMatrix = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );
const modelPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.POSITION );
const modelScale = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.SCALE );
const modelViewPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );
const modelNormalMatrix = /*@__PURE__*/ uniform( new Matrix3() ).onObjectUpdate( ( { object }, self ) => self.value.getNormalMatrix( object.matrixWorld ) );
const modelWorldMatrixInverse = /*@__PURE__*/ uniform( new Matrix4() ).onObjectUpdate( ( { object }, self ) => self.value.copy( object.matrixWorld ).invert() );
const modelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul( modelWorldMatrix ).toVar( 'modelViewMatrix' );

const highPrecisionModelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {

	builder.context.isHighPrecisionModelViewMatrix = true;

	return uniform( 'mat4' ).onObjectUpdate( ( { object, camera } ) => {

		return object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

	} );

} ).once() )().toVar( 'highPrecisionModelViewMatrix' );

const highPrecisionModelNormalViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {

	const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;

	return uniform( 'mat3' ).onObjectUpdate( ( { object, camera } ) => {

		if ( isHighPrecisionModelViewMatrix !== true ) {

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

		}

		return object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

	} );

} ).once() )().toVar( 'highPrecisionModelNormalMatrix' );

const positionGeometry = /*@__PURE__*/ attribute( 'position', 'vec3' );
const positionLocal = /*@__PURE__*/ positionGeometry.varying( 'positionLocal' );
const positionPrevious = /*@__PURE__*/ positionGeometry.varying( 'positionPrevious' );
const positionWorld = /*@__PURE__*/ modelWorldMatrix.mul( positionLocal ).xyz.varying( 'v_positionWorld' );
const positionWorldDirection = /*@__PURE__*/ positionLocal.transformDirection( modelWorldMatrix ).varying( 'v_positionWorldDirection' ).normalize().toVar( 'positionWorldDirection' );
const positionView = /*@__PURE__*/ modelViewMatrix.mul( positionLocal ).xyz.varying( 'v_positionView' );
const positionViewDirection = /*@__PURE__*/ positionView.negate().varying( 'v_positionViewDirection' ).normalize().toVar( 'positionViewDirection' );

class FrontFacingNode extends Node {

	static get type() {

		return 'FrontFacingNode';

	}

	constructor() {

		super( 'bool' );

		this.isFrontFacingNode = true;

	}

	generate( builder ) {

		const { renderer, material } = builder;

		if ( renderer.coordinateSystem === WebGLCoordinateSystem ) {

			if ( material.side === BackSide ) {

				return 'false';

			}

		}

		return builder.getFrontFacing();

	}

}

const frontFacing = /*@__PURE__*/ nodeImmutable( FrontFacingNode );
const faceDirection = /*@__PURE__*/ float( frontFacing ).mul( 2.0 ).sub( 1.0 );

const normalGeometry = /*@__PURE__*/ attribute( 'normal', 'vec3' );

const normalLocal = /*@__PURE__*/ ( Fn( ( builder ) => {

	if ( builder.geometry.hasAttribute( 'normal' ) === false ) {

		console.warn( 'TSL.NormalNode: Vertex attribute "normal" not found on geometry.' );

		return vec3( 0, 1, 0 );

	}

	return normalGeometry;

}, 'vec3' ).once() )().toVar( 'normalLocal' );

const normalFlat = /*@__PURE__*/ positionView.dFdx().cross( positionView.dFdy() ).normalize().toVar( 'normalFlat' );

const normalView = /*@__PURE__*/ ( Fn( ( builder ) => {

	let node;

	if ( builder.material.flatShading === true ) {

		node = normalFlat;

	} else {

		node = varying( transformNormalToView( normalLocal ), 'v_normalView' ).normalize();

	}

	return node;

}, 'vec3' ).once() )().toVar( 'normalView' );

const normalWorld = /*@__PURE__*/ varying( normalView.transformDirection( cameraViewMatrix ), 'v_normalWorld' ).normalize().toVar( 'normalWorld' );

const transformedNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {

	return builder.context.setupNormal();

}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedNormalView' );


const transformedNormalWorld = /*@__PURE__*/ transformedNormalView.transformDirection( cameraViewMatrix ).toVar( 'transformedNormalWorld' );

const transformedClearcoatNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {

	return builder.context.setupClearcoatNormal();

}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedClearcoatNormalView' );

const transformNormal = /*@__PURE__*/ Fn( ( [ normal, matrix = modelWorldMatrix ] ) => {

	const m = mat3( matrix );

	const transformedNormal = normal.div( vec3( m[ 0 ].dot( m[ 0 ] ), m[ 1 ].dot( m[ 1 ] ), m[ 2 ].dot( m[ 2 ] ) ) );

	return m.mul( transformedNormal ).xyz;

} );

const transformNormalToView = /*@__PURE__*/ Fn( ( [ normal ], builder ) => {

	const modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;

	if ( modelNormalViewMatrix !== null ) {

		return modelNormalViewMatrix.transformDirection( normal );

	}

	//

	const transformedNormal = modelNormalMatrix.mul( normal );

	return cameraViewMatrix.transformDirection( transformedNormal );

} );

const materialRefractionRatio = /*@__PURE__*/ uniform( 0 ).onReference( ( { material } ) => material ).onRenderUpdate( ( { material } ) => material.refractionRatio );

const reflectView = /*@__PURE__*/ positionViewDirection.negate().reflect( transformedNormalView );
const refractView = /*@__PURE__*/ positionViewDirection.negate().refract( transformedNormalView, materialRefractionRatio );

const reflectVector = /*@__PURE__*/ reflectView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );
const refractVector = /*@__PURE__*/ refractView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );

class CubeTextureNode extends TextureNode {

	static get type() {

		return 'CubeTextureNode';

	}

	constructor( value, uvNode = null, levelNode = null, biasNode = null ) {

		super( value, uvNode, levelNode, biasNode );

		this.isCubeTextureNode = true;

	}

	getInputType( /*builder*/ ) {

		return 'cubeTexture';

	}

	getDefaultUV() {

		const texture = this.value;

		if ( texture.mapping === CubeReflectionMapping ) {

			return reflectVector;

		} else if ( texture.mapping === CubeRefractionMapping ) {

			return refractVector;

		} else {

			console.error( 'THREE.CubeTextureNode: Mapping "%s" not supported.', texture.mapping );

			return vec3( 0, 0, 0 );

		}

	}

	setUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for CubeTextureNode

	setupUV( builder, uvNode ) {

		const texture = this.value;

		if ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem || ! texture.isRenderTargetTexture ) {

			return vec3( uvNode.x.negate(), uvNode.yz );

		} else {

			return uvNode;

		}

	}

	generateUV( builder, cubeUV ) {

		return cubeUV.build( builder, 'vec3' );

	}

}

const cubeTexture = /*@__PURE__*/ nodeProxy( CubeTextureNode );

class BufferNode extends UniformNode {

	static get type() {

		return 'BufferNode';

	}

	constructor( value, bufferType, bufferCount = 0 ) {

		super( value, bufferType );

		this.isBufferNode = true;

		this.bufferType = bufferType;
		this.bufferCount = bufferCount;

	}

	getElementType( builder ) {

		return this.getNodeType( builder );

	}

	getInputType( /*builder*/ ) {

		return 'buffer';

	}

}

const buffer = ( value, type, count ) => nodeObject( new BufferNode( value, type, count ) );

class UniformArrayElementNode extends ArrayElementNode {

	static get type() {

		return 'UniformArrayElementNode';

	}

	constructor( arrayBuffer, indexNode ) {

		super( arrayBuffer, indexNode );

		this.isArrayBufferElementNode = true;

	}

	generate( builder ) {

		const snippet = super.generate( builder );
		const type = this.getNodeType();

		return builder.format( snippet, 'vec4', type );

	}

}

class UniformArrayNode extends BufferNode {

	static get type() {

		return 'UniformArrayNode';

	}

	constructor( value, elementType = null ) {

		super( null, 'vec4' );

		this.array = value;
		this.elementType = elementType;

		this._elementType = null;
		this._elementLength = 0;

		this.updateType = NodeUpdateType.RENDER;

		this.isArrayBufferNode = true;

	}

	getElementType() {

		return this.elementType || this._elementType;

	}

	getElementLength() {

		return this._elementLength;

	}

	update( /*frame*/ ) {

		const { array, value } = this;

		const elementLength = this.getElementLength();
		const elementType = this.getElementType();

		if ( elementLength === 1 ) {

			for ( let i = 0; i < array.length; i ++ ) {

				const index = i * 4;

				value[ index ] = array[ i ];

			}

		} else if ( elementType === 'color' ) {

			for ( let i = 0; i < array.length; i ++ ) {

				const index = i * 4;
				const vector = array[ i ];

				value[ index ] = vector.r;
				value[ index + 1 ] = vector.g;
				value[ index + 2 ] = vector.b || 0;
				//value[ index + 3 ] = vector.a || 0;

			}

		} else {

			for ( let i = 0; i < array.length; i ++ ) {

				const index = i * 4;
				const vector = array[ i ];

				value[ index ] = vector.x;
				value[ index + 1 ] = vector.y;
				value[ index + 2 ] = vector.z || 0;
				value[ index + 3 ] = vector.w || 0;

			}

		}

	}

	setup( builder ) {

		const length = this.array.length;

		this._elementType = this.elementType === null ? getValueType( this.array[ 0 ] ) : this.elementType;
		this._elementLength = builder.getTypeLength( this._elementType );

		let arrayType = Float32Array;

		if ( this._elementType.charAt( 0 ) === 'i' ) arrayType = Int32Array;
		else if ( this._elementType.charAt( 0 ) === 'u' ) arrayType = Uint32Array;

		this.value = new arrayType( length * 4 );
		this.bufferCount = length;
		this.bufferType = builder.changeComponentType( 'vec4', builder.getComponentType( this._elementType ) );

		return super.setup( builder );

	}

	element( indexNode ) {

		return nodeObject( new UniformArrayElementNode( this, nodeObject( indexNode ) ) );

	}

}

const uniformArray = ( values, nodeType ) => nodeObject( new UniformArrayNode( values, nodeType ) );

//

const uniforms = ( values, nodeType ) => { // @deprecated, r168

	console.warn( 'TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().' );
	return nodeObject( new UniformArrayNode( values, nodeType ) );

};

class ReferenceElementNode extends ArrayElementNode {

	static get type() {

		return 'ReferenceElementNode';

	}

	constructor( referenceNode, indexNode ) {

		super( referenceNode, indexNode );

		this.referenceNode = referenceNode;

		this.isReferenceElementNode = true;

	}

	getNodeType() {

		return this.referenceNode.uniformType;

	}

	generate( builder ) {

		const snippet = super.generate( builder );
		const arrayType = this.referenceNode.getNodeType();
		const elementType = this.getNodeType();

		return builder.format( snippet, arrayType, elementType );

	}

}

// TODO: Extends this from ReferenceBaseNode
class ReferenceNode extends Node {

	static get type() {

		return 'ReferenceNode';

	}

	constructor( property, uniformType, object = null, count = null ) {

		super();

		this.property = property;
		this.uniformType = uniformType;
		this.object = object;
		this.count = count;

		this.properties = property.split( '.' );
		this.reference = object;
		this.node = null;
		this.group = null;
		this.name = null;

		this.updateType = NodeUpdateType.OBJECT;

	}

	element( indexNode ) {

		return nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );

	}

	setGroup( group ) {

		this.group = group;

		return this;

	}

	label( name ) {

		this.name = name;

		return this;

	}

	setNodeType( uniformType ) {

		let node = null;

		if ( this.count !== null ) {

			node = buffer( null, uniformType, this.count );

		} else if ( Array.isArray( this.getValueFromReference() ) ) {

			node = uniformArray( null, uniformType );

		} else if ( uniformType === 'texture' ) {

			node = texture( null );

		} else if ( uniformType === 'cubeTexture' ) {

			node = cubeTexture( null );

		} else {

			node = uniform( null, uniformType );

		}

		if ( this.group !== null ) {

			node.setGroup( this.group );

		}

		if ( this.name !== null ) node.label( this.name );

		this.node = node.getSelf();

	}

	getNodeType( builder ) {

		if ( this.node === null ) {

			this.updateReference( builder );
			this.updateValue();

		}

		return this.node.getNodeType( builder );

	}

	getValueFromReference( object = this.reference ) {

		const { properties } = this;

		let value = object[ properties[ 0 ] ];

		for ( let i = 1; i < properties.length; i ++ ) {

			value = value[ properties[ i ] ];

		}

		return value;

	}

	updateReference( state ) {

		this.reference = this.object !== null ? this.object : state.object;

		return this.reference;

	}

	setup() {

		this.updateValue();

		return this.node;

	}

	update( /*frame*/ ) {

		this.updateValue();

	}

	updateValue() {

		if ( this.node === null ) this.setNodeType( this.uniformType );

		const value = this.getValueFromReference();

		if ( Array.isArray( value ) ) {

			this.node.array = value;

		} else {

			this.node.value = value;

		}

	}

}

const reference = ( name, type, object ) => nodeObject( new ReferenceNode( name, type, object ) );
const referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceNode( name, type, object, count ) );

class MaterialReferenceNode extends ReferenceNode {

	static get type() {

		return 'MaterialReferenceNode';

	}

	constructor( property, inputType, material = null ) {

		super( property, inputType, material );

		this.material = material;

		//this.updateType = NodeUpdateType.RENDER;

		this.isMaterialReferenceNode = true;

	}

	/*setNodeType( node ) {

		super.setNodeType( node );

		this.node.groupNode = renderGroup;

	}*/

	updateReference( state ) {

		this.reference = this.material !== null ? this.material : state.material;

		return this.reference;

	}

}

const materialReference = ( name, type, material ) => nodeObject( new MaterialReferenceNode( name, type, material ) );

const tangentGeometry = /*@__PURE__*/ Fn( ( builder ) => {

	if ( builder.geometry.hasAttribute( 'tangent' ) === false ) {

		builder.geometry.computeTangents();

	}

	return attribute( 'tangent', 'vec4' );

} )();

const tangentLocal = /*@__PURE__*/ tangentGeometry.xyz.toVar( 'tangentLocal' );
const tangentView = /*@__PURE__*/ modelViewMatrix.mul( vec4( tangentLocal, 0 ) ).xyz.varying( 'v_tangentView' ).normalize().toVar( 'tangentView' );
const tangentWorld = /*@__PURE__*/ tangentView.transformDirection( cameraViewMatrix ).varying( 'v_tangentWorld' ).normalize().toVar( 'tangentWorld' );
const transformedTangentView = /*@__PURE__*/ tangentView.toVar( 'transformedTangentView' );
const transformedTangentWorld = /*@__PURE__*/ transformedTangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedTangentWorld' );

const getBitangent = ( crossNormalTangent ) => crossNormalTangent.mul( tangentGeometry.w ).xyz;

const bitangentGeometry = /*@__PURE__*/ varying( getBitangent( normalGeometry.cross( tangentGeometry ) ), 'v_bitangentGeometry' ).normalize().toVar( 'bitangentGeometry' );
const bitangentLocal = /*@__PURE__*/ varying( getBitangent( normalLocal.cross( tangentLocal ) ), 'v_bitangentLocal' ).normalize().toVar( 'bitangentLocal' );
const bitangentView = /*@__PURE__*/ varying( getBitangent( normalView.cross( tangentView ) ), 'v_bitangentView' ).normalize().toVar( 'bitangentView' );
const bitangentWorld = /*@__PURE__*/ varying( getBitangent( normalWorld.cross( tangentWorld ) ), 'v_bitangentWorld' ).normalize().toVar( 'bitangentWorld' );
const transformedBitangentView = /*@__PURE__*/ getBitangent( transformedNormalView.cross( transformedTangentView ) ).normalize().toVar( 'transformedBitangentView' );
const transformedBitangentWorld = /*@__PURE__*/ transformedBitangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedBitangentWorld' );

const TBNViewMatrix = /*@__PURE__*/ mat3( tangentView, bitangentView, normalView );

const parallaxDirection = /*@__PURE__*/ positionViewDirection.mul( TBNViewMatrix )/*.normalize()*/;
const parallaxUV = ( uv, scale ) => uv.sub( parallaxDirection.mul( scale ) );

const transformedBentNormalView = /*@__PURE__*/ ( () => {

	// https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy

	let bentNormal = anisotropyB.cross( positionViewDirection );
	bentNormal = bentNormal.cross( anisotropyB ).normalize();
	bentNormal = mix( bentNormal, transformedNormalView, anisotropy.mul( roughness.oneMinus() ).oneMinus().pow2().pow2() ).normalize();

	return bentNormal;


} )();

// Normal Mapping Without Precomputed Tangents
// http://www.thetenthplanet.de/archives/1180

const perturbNormal2Arb = /*@__PURE__*/ Fn( ( inputs ) => {

	const { eye_pos, surf_norm, mapN, uv } = inputs;

	const q0 = eye_pos.dFdx();
	const q1 = eye_pos.dFdy();
	const st0 = uv.dFdx();
	const st1 = uv.dFdy();

	const N = surf_norm; // normalized

	const q1perp = q1.cross( N );
	const q0perp = N.cross( q0 );

	const T = q1perp.mul( st0.x ).add( q0perp.mul( st1.x ) );
	const B = q1perp.mul( st0.y ).add( q0perp.mul( st1.y ) );

	const det = T.dot( T ).max( B.dot( B ) );
	const scale = faceDirection.mul( det.inverseSqrt() );

	return add( T.mul( mapN.x, scale ), B.mul( mapN.y, scale ), N.mul( mapN.z ) ).normalize();

} );

class NormalMapNode extends TempNode {

	static get type() {

		return 'NormalMapNode';

	}

	constructor( node, scaleNode = null ) {

		super( 'vec3' );

		this.node = node;
		this.scaleNode = scaleNode;

		this.normalMapType = TangentSpaceNormalMap;

	}

	setup( builder ) {

		const { normalMapType, scaleNode } = this;

		let normalMap = this.node.mul( 2.0 ).sub( 1.0 );

		if ( scaleNode !== null ) {

			normalMap = vec3( normalMap.xy.mul( scaleNode ), normalMap.z );

		}

		let outputNode = null;

		if ( normalMapType === ObjectSpaceNormalMap ) {

			outputNode = transformNormalToView( normalMap );

		} else if ( normalMapType === TangentSpaceNormalMap ) {

			const tangent = builder.hasGeometryAttribute( 'tangent' );

			if ( tangent === true ) {

				outputNode = TBNViewMatrix.mul( normalMap ).normalize();

			} else {

				outputNode = perturbNormal2Arb( {
					eye_pos: positionView,
					surf_norm: normalView,
					mapN: normalMap,
					uv: uv()
				} );

			}

		}

		return outputNode;

	}

}

const normalMap = /*@__PURE__*/ nodeProxy( NormalMapNode );

// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

const dHdxy_fwd = Fn( ( { textureNode, bumpScale } ) => {

	// It's used to preserve the same TextureNode instance
	const sampleTexture = ( callback ) => textureNode.cache().context( { getUV: ( texNode ) => callback( texNode.uvNode || uv() ), forceUVContext: true } );

	const Hll = float( sampleTexture( ( uvNode ) => uvNode ) );

	return vec2(
		float( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdx() ) ) ).sub( Hll ),
		float( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdy() ) ) ).sub( Hll )
	).mul( bumpScale );

} );

// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

const perturbNormalArb = Fn( ( inputs ) => {

	const { surf_pos, surf_norm, dHdxy } = inputs;

	// normalize is done to ensure that the bump map looks the same regardless of the texture's scale
	const vSigmaX = surf_pos.dFdx().normalize();
	const vSigmaY = surf_pos.dFdy().normalize();
	const vN = surf_norm; // normalized

	const R1 = vSigmaY.cross( vN );
	const R2 = vN.cross( vSigmaX );

	const fDet = vSigmaX.dot( R1 ).mul( faceDirection );

	const vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );

	return fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();

} );

class BumpMapNode extends TempNode {

	static get type() {

		return 'BumpMapNode';

	}

	constructor( textureNode, scaleNode = null ) {

		super( 'vec3' );

		this.textureNode = textureNode;
		this.scaleNode = scaleNode;

	}

	setup() {

		const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
		const dHdxy = dHdxy_fwd( { textureNode: this.textureNode, bumpScale } );

		return perturbNormalArb( {
			surf_pos: positionView,
			surf_norm: normalView,
			dHdxy
		} );

	}

}

const bumpMap = /*@__PURE__*/ nodeProxy( BumpMapNode );

const _propertyCache = new Map();

class MaterialNode extends Node {

	static get type() {

		return 'MaterialNode';

	}

	constructor( scope ) {

		super();

		this.scope = scope;

	}

	getCache( property, type ) {

		let node = _propertyCache.get( property );

		if ( node === undefined ) {

			node = materialReference( property, type );

			_propertyCache.set( property, node );

		}

		return node;

	}

	getFloat( property ) {

		return this.getCache( property, 'float' );

	}

	getColor( property ) {

		return this.getCache( property, 'color' );

	}

	getTexture( property ) {

		return this.getCache( property === 'map' ? 'map' : property + 'Map', 'texture' );

	}

	setup( builder ) {

		const material = builder.context.material;
		const scope = this.scope;

		let node = null;

		if ( scope === MaterialNode.COLOR ) {

			const colorNode = material.color !== undefined ? this.getColor( scope ) : vec3();

			if ( material.map && material.map.isTexture === true ) {

				node = colorNode.mul( this.getTexture( 'map' ) );

			} else {

				node = colorNode;

			}

		} else if ( scope === MaterialNode.OPACITY ) {

			const opacityNode = this.getFloat( scope );

			if ( material.alphaMap && material.alphaMap.isTexture === true ) {

				node = opacityNode.mul( this.getTexture( 'alpha' ) );

			} else {

				node = opacityNode;

			}

		} else if ( scope === MaterialNode.SPECULAR_STRENGTH ) {

			if ( material.specularMap && material.specularMap.isTexture === true ) {

				node = this.getTexture( 'specular' ).r;

			} else {

				node = float( 1 );

			}

		} else if ( scope === MaterialNode.SPECULAR_INTENSITY ) {

			const specularIntensity = this.getFloat( scope );

			if ( material.specularMap ) {

				node = specularIntensity.mul( this.getTexture( scope ).a );

			} else {

				node = specularIntensity;

			}

		} else if ( scope === MaterialNode.SPECULAR_COLOR ) {

			const specularColorNode = this.getColor( scope );

			if ( material.specularColorMap && material.specularColorMap.isTexture === true ) {

				node = specularColorNode.mul( this.getTexture( scope ).rgb );

			} else {

				node = specularColorNode;

			}

		} else if ( scope === MaterialNode.ROUGHNESS ) { // TODO: cleanup similar branches

			const roughnessNode = this.getFloat( scope );

			if ( material.roughnessMap && material.roughnessMap.isTexture === true ) {

				node = roughnessNode.mul( this.getTexture( scope ).g );

			} else {

				node = roughnessNode;

			}

		} else if ( scope === MaterialNode.METALNESS ) {

			const metalnessNode = this.getFloat( scope );

			if ( material.metalnessMap && material.metalnessMap.isTexture === true ) {

				node = metalnessNode.mul( this.getTexture( scope ).b );

			} else {

				node = metalnessNode;

			}

		} else if ( scope === MaterialNode.EMISSIVE ) {

			const emissiveIntensityNode = this.getFloat( 'emissiveIntensity' );
			const emissiveNode = this.getColor( scope ).mul( emissiveIntensityNode );

			if ( material.emissiveMap && material.emissiveMap.isTexture === true ) {

				node = emissiveNode.mul( this.getTexture( scope ) );

			} else {

				node = emissiveNode;

			}

		} else if ( scope === MaterialNode.NORMAL ) {

			if ( material.normalMap ) {

				node = normalMap( this.getTexture( 'normal' ), this.getCache( 'normalScale', 'vec2' ) );
				node.normalMapType = material.normalMapType;

			} else if ( material.bumpMap ) {

				node = bumpMap( this.getTexture( 'bump' ).r, this.getFloat( 'bumpScale' ) );

			} else {

				node = normalView;

			}

		} else if ( scope === MaterialNode.CLEARCOAT ) {

			const clearcoatNode = this.getFloat( scope );

			if ( material.clearcoatMap && material.clearcoatMap.isTexture === true ) {

				node = clearcoatNode.mul( this.getTexture( scope ).r );

			} else {

				node = clearcoatNode;

			}

		} else if ( scope === MaterialNode.CLEARCOAT_ROUGHNESS ) {

			const clearcoatRoughnessNode = this.getFloat( scope );

			if ( material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true ) {

				node = clearcoatRoughnessNode.mul( this.getTexture( scope ).r );

			} else {

				node = clearcoatRoughnessNode;

			}

		} else if ( scope === MaterialNode.CLEARCOAT_NORMAL ) {

			if ( material.clearcoatNormalMap ) {

				node = normalMap( this.getTexture( scope ), this.getCache( scope + 'Scale', 'vec2' ) );

			} else {

				node = normalView;

			}

		} else if ( scope === MaterialNode.SHEEN ) {

			const sheenNode = this.getColor( 'sheenColor' ).mul( this.getFloat( 'sheen' ) ); // Move this mul() to CPU

			if ( material.sheenColorMap && material.sheenColorMap.isTexture === true ) {

				node = sheenNode.mul( this.getTexture( 'sheenColor' ).rgb );

			} else {

				node = sheenNode;

			}

		} else if ( scope === MaterialNode.SHEEN_ROUGHNESS ) {

			const sheenRoughnessNode = this.getFloat( scope );

			if ( material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true ) {

				node = sheenRoughnessNode.mul( this.getTexture( scope ).a );

			} else {

				node = sheenRoughnessNode;

			}

			node = node.clamp( 0.07, 1.0 );

		} else if ( scope === MaterialNode.ANISOTROPY ) {

			if ( material.anisotropyMap && material.anisotropyMap.isTexture === true ) {

				const anisotropyPolar = this.getTexture( scope );
				const anisotropyMat = mat2( materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x );

				node = anisotropyMat.mul( anisotropyPolar.rg.mul( 2.0 ).sub( vec2( 1.0 ) ).normalize().mul( anisotropyPolar.b ) );

			} else {

				node = materialAnisotropyVector;

			}

		} else if ( scope === MaterialNode.IRIDESCENCE_THICKNESS ) {

			const iridescenceThicknessMaximum = reference( '1', 'float', material.iridescenceThicknessRange );

			if ( material.iridescenceThicknessMap ) {

				const iridescenceThicknessMinimum = reference( '0', 'float', material.iridescenceThicknessRange );

				node = iridescenceThicknessMaximum.sub( iridescenceThicknessMinimum ).mul( this.getTexture( scope ).g ).add( iridescenceThicknessMinimum );

			} else {

				node = iridescenceThicknessMaximum;

			}

		} else if ( scope === MaterialNode.TRANSMISSION ) {

			const transmissionNode = this.getFloat( scope );

			if ( material.transmissionMap ) {

				node = transmissionNode.mul( this.getTexture( scope ).r );

			} else {

				node = transmissionNode;

			}

		} else if ( scope === MaterialNode.THICKNESS ) {

			const thicknessNode = this.getFloat( scope );

			if ( material.thicknessMap ) {

				node = thicknessNode.mul( this.getTexture( scope ).g );

			} else {

				node = thicknessNode;

			}

		} else if ( scope === MaterialNode.IOR ) {

			node = this.getFloat( scope );

		} else if ( scope === MaterialNode.LIGHT_MAP ) {

			node = this.getTexture( scope ).rgb.mul( this.getFloat( 'lightMapIntensity' ) );

		} else if ( scope === MaterialNode.AO_MAP ) {

			node = this.getTexture( scope ).r.sub( 1.0 ).mul( this.getFloat( 'aoMapIntensity' ) ).add( 1.0 );

		} else {

			const outputType = this.getNodeType( builder );

			node = this.getCache( scope, outputType );

		}

		return node;

	}

}

MaterialNode.ALPHA_TEST = 'alphaTest';
MaterialNode.COLOR = 'color';
MaterialNode.OPACITY = 'opacity';
MaterialNode.SHININESS = 'shininess';
MaterialNode.SPECULAR = 'specular';
MaterialNode.SPECULAR_STRENGTH = 'specularStrength';
MaterialNode.SPECULAR_INTENSITY = 'specularIntensity';
MaterialNode.SPECULAR_COLOR = 'specularColor';
MaterialNode.REFLECTIVITY = 'reflectivity';
MaterialNode.ROUGHNESS = 'roughness';
MaterialNode.METALNESS = 'metalness';
MaterialNode.NORMAL = 'normal';
MaterialNode.CLEARCOAT = 'clearcoat';
MaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';
MaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';
MaterialNode.EMISSIVE = 'emissive';
MaterialNode.ROTATION = 'rotation';
MaterialNode.SHEEN = 'sheen';
MaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';
MaterialNode.ANISOTROPY = 'anisotropy';
MaterialNode.IRIDESCENCE = 'iridescence';
MaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';
MaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';
MaterialNode.IOR = 'ior';
MaterialNode.TRANSMISSION = 'transmission';
MaterialNode.THICKNESS = 'thickness';
MaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';
MaterialNode.ATTENUATION_COLOR = 'attenuationColor';
MaterialNode.LINE_SCALE = 'scale';
MaterialNode.LINE_DASH_SIZE = 'dashSize';
MaterialNode.LINE_GAP_SIZE = 'gapSize';
MaterialNode.LINE_WIDTH = 'linewidth';
MaterialNode.LINE_DASH_OFFSET = 'dashOffset';
MaterialNode.POINT_WIDTH = 'pointWidth';
MaterialNode.DISPERSION = 'dispersion';
MaterialNode.LIGHT_MAP = 'light';
MaterialNode.AO_MAP = 'ao';

const materialAlphaTest = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );
const materialColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.COLOR );
const materialShininess = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHININESS );
const materialEmissive = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );
const materialOpacity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.OPACITY );
const materialSpecular = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR );

const materialSpecularIntensity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_INTENSITY );
const materialSpecularColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_COLOR );

const materialSpecularStrength = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_STRENGTH );
const materialReflectivity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.REFLECTIVITY );
const materialRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );
const materialMetalness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.METALNESS );
const materialNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.NORMAL ).context( { getUV: null } );
const materialClearcoat = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT );
const materialClearcoatRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS );
const materialClearcoatNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_NORMAL ).context( { getUV: null } );
const materialRotation = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROTATION );
const materialSheen = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN );
const materialSheenRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN_ROUGHNESS );
const materialAnisotropy = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ANISOTROPY );
const materialIridescence = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE );
const materialIridescenceIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_IOR );
const materialIridescenceThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS );
const materialTransmission = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.TRANSMISSION );
const materialThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.THICKNESS );
const materialIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IOR );
const materialAttenuationDistance = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_DISTANCE );
const materialAttenuationColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_COLOR );
const materialLineScale = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_SCALE );
const materialLineDashSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_SIZE );
const materialLineGapSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_GAP_SIZE );
const materialLineWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_WIDTH );
const materialLineDashOffset = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_OFFSET );
const materialPointWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.POINT_WIDTH );
const materialDispersion = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.DISPERSION );
const materialLightMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LIGHT_MAP );
const materialAOMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.AO_MAP );
const materialAnisotropyVector = /*@__PURE__*/ uniform( new Vector2() ).onReference( function ( frame ) {

	return frame.material;

} ).onRenderUpdate( function ( { material } ) {

	this.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

} );

class ModelViewProjectionNode extends TempNode {

	static get type() {

		return 'ModelViewProjectionNode';

	}

	constructor( positionNode = null ) {

		super( 'vec4' );

		this.positionNode = positionNode;

	}

	setup( builder ) {

		if ( builder.shaderStage === 'fragment' ) {

			return varying( builder.context.mvp );

		}

		const position = this.positionNode || positionLocal;
		const viewMatrix = builder.renderer.nodes.modelViewMatrix || modelViewMatrix;

		return cameraProjectionMatrix.mul( viewMatrix ).mul( position );

	}

}

const modelViewProjection = /*@__PURE__*/ nodeProxy( ModelViewProjectionNode );

class IndexNode extends Node {

	static get type() {

		return 'IndexNode';

	}

	constructor( scope ) {

		super( 'uint' );

		this.scope = scope;

		this.isInstanceIndexNode = true;

	}

	generate( builder ) {

		const nodeType = this.getNodeType( builder );
		const scope = this.scope;

		let propertyName;

		if ( scope === IndexNode.VERTEX ) {

			// The index of a vertex within a mesh.
			propertyName = builder.getVertexIndex();

		} else if ( scope === IndexNode.INSTANCE ) {

			// The index of either a mesh instance or an invocation of a compute shader.
			propertyName = builder.getInstanceIndex();

		} else if ( scope === IndexNode.DRAW ) {

			// The index of a draw call.
			propertyName = builder.getDrawIndex();

		} else if ( scope === IndexNode.INVOCATION_LOCAL ) {

			// The index of a compute invocation within the scope of a workgroup load.
			propertyName = builder.getInvocationLocalIndex();

		} else if ( scope === IndexNode.INVOCATION_SUBGROUP ) {

			// The index of a compute invocation within the scope of a subgroup.
			propertyName = builder.getInvocationSubgroupIndex();

		} else if ( scope === IndexNode.SUBGROUP ) {

			// The index of the subgroup the current compute invocation belongs to.
			propertyName = builder.getSubgroupIndex();

		} else {

			throw new Error( 'THREE.IndexNode: Unknown scope: ' + scope );

		}

		let output;

		if ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {

			output = propertyName;

		} else {

			const nodeVarying = varying( this );

			output = nodeVarying.build( builder, nodeType );

		}

		return output;

	}

}

IndexNode.VERTEX = 'vertex';
IndexNode.INSTANCE = 'instance';
IndexNode.SUBGROUP = 'subgroup';
IndexNode.INVOCATION_LOCAL = 'invocationLocal';
IndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';
IndexNode.DRAW = 'draw';

const vertexIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.VERTEX );
const instanceIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INSTANCE );
const subgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.SUBGROUP );
const invocationSubgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_SUBGROUP );
const invocationLocalIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_LOCAL );
const drawIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.DRAW );

class InstanceNode extends Node {

	static get type() {

		return 'InstanceNode';

	}

	constructor( count, instanceMatrix, instanceColor ) {

		super( 'void' );

		this.count = count;
		this.instanceMatrix = instanceMatrix;
		this.instanceColor = instanceColor;

		this.instanceMatrixNode = null;

		this.instanceColorNode = null;

		this.updateType = NodeUpdateType.FRAME;

		this.buffer = null;
		this.bufferColor = null;

	}

	setup( builder ) {

		const { count, instanceMatrix, instanceColor } = this;

		let { instanceMatrixNode, instanceColorNode } = this;

		if ( instanceMatrixNode === null ) {

			// Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.

			if ( count <= 1000 ) {

				instanceMatrixNode = buffer( instanceMatrix.array, 'mat4', Math.max( count, 1 ) ).element( instanceIndex );

			} else {

				const buffer = new InstancedInterleavedBuffer( instanceMatrix.array, 16, 1 );

				this.buffer = buffer;

				const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;

				const instanceBuffers = [
					// F.Signature -> bufferAttribute( array, type, stride, offset )
					bufferFn( buffer, 'vec4', 16, 0 ),
					bufferFn( buffer, 'vec4', 16, 4 ),
					bufferFn( buffer, 'vec4', 16, 8 ),
					bufferFn( buffer, 'vec4', 16, 12 )
				];

				instanceMatrixNode = mat4( ...instanceBuffers );

			}

			this.instanceMatrixNode = instanceMatrixNode;

		}

		if ( instanceColor && instanceColorNode === null ) {

			const buffer = new InstancedBufferAttribute( instanceColor.array, 3 );

			const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;

			this.bufferColor = buffer;

			instanceColorNode = vec3( bufferFn( buffer, 'vec3', 3, 0 ) );

			this.instanceColorNode = instanceColorNode;

		}

		// POSITION

		const instancePosition = instanceMatrixNode.mul( positionLocal ).xyz;
		positionLocal.assign( instancePosition );

		// NORMAL

		if ( builder.hasGeometryAttribute( 'normal' ) ) {

			const instanceNormal = transformNormal( normalLocal, instanceMatrixNode );

			// ASSIGNS

			normalLocal.assign( instanceNormal );

		}

		// COLOR

		if ( this.instanceColorNode !== null ) {

			varyingProperty( 'vec3', 'vInstanceColor' ).assign( this.instanceColorNode );

		}

	}

	update( /*frame*/ ) {

		if ( this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer != null && this.instanceMatrix.version !== this.buffer.version ) {

			this.buffer.version = this.instanceMatrix.version;

		}

		if ( this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor != null && this.instanceColor.version !== this.bufferColor.version ) {

			this.bufferColor.version = this.instanceColor.version;

		}

	}

}

const instance = /*@__PURE__*/ nodeProxy( InstanceNode );

class InstancedMeshNode extends InstanceNode {

	static get type() {

		return 'InstancedMeshNode';

	}

	constructor( instanceMesh ) {

		const { count, instanceMatrix, instanceColor } = instanceMesh;

		super( count, instanceMatrix, instanceColor );

		this.instanceMesh = instanceMesh;

	}

}

const instancedMesh = /*@__PURE__*/ nodeProxy( InstancedMeshNode );

class BatchNode extends Node {

	static get type() {

		return 'BatchNode';

	}

	constructor( batchMesh ) {

		super( 'void' );

		this.batchMesh = batchMesh;


		this.batchingIdNode = null;

	}

	setup( builder ) {

		// POSITION

		if ( this.batchingIdNode === null ) {

			if ( builder.getDrawIndex() === null ) {

				this.batchingIdNode = instanceIndex;

			} else {

				this.batchingIdNode = drawIndex;

			}

		}

		const getIndirectIndex = Fn( ( [ id ] ) => {

			const size = textureSize( textureLoad( this.batchMesh._indirectTexture ), 0 );
			const x = int( id ).modInt( int( size ) );
			const y = int( id ).div( int( size ) );
			return textureLoad( this.batchMesh._indirectTexture, ivec2( x, y ) ).x;

		} ).setLayout( {
			name: 'getIndirectIndex',
			type: 'uint',
			inputs: [
				{ name: 'id', type: 'int' }
			]
		} );

		const indirectId = getIndirectIndex( int( this.batchingIdNode ) );

		const matricesTexture = this.batchMesh._matricesTexture;

		const size = textureSize( textureLoad( matricesTexture ), 0 );
		const j = float( indirectId ).mul( 4 ).toInt().toVar();

		const x = j.modInt( size );
		const y = j.div( int( size ) );
		const batchingMatrix = mat4(
			textureLoad( matricesTexture, ivec2( x, y ) ),
			textureLoad( matricesTexture, ivec2( x.add( 1 ), y ) ),
			textureLoad( matricesTexture, ivec2( x.add( 2 ), y ) ),
			textureLoad( matricesTexture, ivec2( x.add( 3 ), y ) )
		);


		const colorsTexture = this.batchMesh._colorsTexture;

		if ( colorsTexture !== null ) {

			const getBatchingColor = Fn( ( [ id ] ) => {

				const size = textureSize( textureLoad( colorsTexture ), 0 ).x;
				const j = id;
				const x = j.modInt( size );
				const y = j.div( size );
				return textureLoad( colorsTexture, ivec2( x, y ) ).rgb;

			} ).setLayout( {
				name: 'getBatchingColor',
				type: 'vec3',
				inputs: [
					{ name: 'id', type: 'int' }
				]
			} );

			const color = getBatchingColor( indirectId );

			varyingProperty( 'vec3', 'vBatchColor' ).assign( color );

		}

		const bm = mat3( batchingMatrix );

		positionLocal.assign( batchingMatrix.mul( positionLocal ) );

		const transformedNormal = normalLocal.div( vec3( bm[ 0 ].dot( bm[ 0 ] ), bm[ 1 ].dot( bm[ 1 ] ), bm[ 2 ].dot( bm[ 2 ] ) ) );

		const batchingNormal = bm.mul( transformedNormal ).xyz;

		normalLocal.assign( batchingNormal );

		if ( builder.hasGeometryAttribute( 'tangent' ) ) {

			tangentLocal.mulAssign( bm );

		}

	}

}

const batch = /*@__PURE__*/ nodeProxy( BatchNode );

const _frameId = new WeakMap();

class SkinningNode extends Node {

	static get type() {

		return 'SkinningNode';

	}

	constructor( skinnedMesh, useReference = false ) {

		super( 'void' );

		this.skinnedMesh = skinnedMesh;
		this.useReference = useReference;

		this.updateType = NodeUpdateType.OBJECT;

		//

		this.skinIndexNode = attribute( 'skinIndex', 'uvec4' );
		this.skinWeightNode = attribute( 'skinWeight', 'vec4' );

		let bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;

		if ( useReference ) {

			bindMatrixNode = reference( 'bindMatrix', 'mat4' );
			bindMatrixInverseNode = reference( 'bindMatrixInverse', 'mat4' );
			boneMatricesNode = referenceBuffer( 'skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );

		} else {

			bindMatrixNode = uniform( skinnedMesh.bindMatrix, 'mat4' );
			bindMatrixInverseNode = uniform( skinnedMesh.bindMatrixInverse, 'mat4' );
			boneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );

		}

		this.bindMatrixNode = bindMatrixNode;
		this.bindMatrixInverseNode = bindMatrixInverseNode;
		this.boneMatricesNode = boneMatricesNode;
		this.previousBoneMatricesNode = null;

	}

	getSkinnedPosition( boneMatrices = this.boneMatricesNode, position = positionLocal ) {

		const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;

		const boneMatX = boneMatrices.element( skinIndexNode.x );
		const boneMatY = boneMatrices.element( skinIndexNode.y );
		const boneMatZ = boneMatrices.element( skinIndexNode.z );
		const boneMatW = boneMatrices.element( skinIndexNode.w );

		// POSITION

		const skinVertex = bindMatrixNode.mul( position );

		const skinned = add(
			boneMatX.mul( skinWeightNode.x ).mul( skinVertex ),
			boneMatY.mul( skinWeightNode.y ).mul( skinVertex ),
			boneMatZ.mul( skinWeightNode.z ).mul( skinVertex ),
			boneMatW.mul( skinWeightNode.w ).mul( skinVertex )
		);

		return bindMatrixInverseNode.mul( skinned ).xyz;

	}

	getSkinnedNormal( boneMatrices = this.boneMatricesNode, normal = normalLocal ) {

		const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;

		const boneMatX = boneMatrices.element( skinIndexNode.x );
		const boneMatY = boneMatrices.element( skinIndexNode.y );
		const boneMatZ = boneMatrices.element( skinIndexNode.z );
		const boneMatW = boneMatrices.element( skinIndexNode.w );

		// NORMAL

		let skinMatrix = add(
			skinWeightNode.x.mul( boneMatX ),
			skinWeightNode.y.mul( boneMatY ),
			skinWeightNode.z.mul( boneMatZ ),
			skinWeightNode.w.mul( boneMatW )
		);

		skinMatrix = bindMatrixInverseNode.mul( skinMatrix ).mul( bindMatrixNode );

		return skinMatrix.transformDirection( normal ).xyz;

	}

	getPreviousSkinnedPosition( builder ) {

		const skinnedMesh = builder.object;

		if ( this.previousBoneMatricesNode === null ) {

			skinnedMesh.skeleton.previousBoneMatrices = new Float32Array( skinnedMesh.skeleton.boneMatrices );

			this.previousBoneMatricesNode = referenceBuffer( 'skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );

		}

		return this.getSkinnedPosition( this.previousBoneMatricesNode, positionPrevious );

	}

	needsPreviousBoneMatrices( builder ) {

		const mrt = builder.renderer.getMRT();

		return mrt && mrt.has( 'velocity' );

	}

	setup( builder ) {

		if ( this.needsPreviousBoneMatrices( builder ) ) {

			positionPrevious.assign( this.getPreviousSkinnedPosition( builder ) );

		}

		const skinPosition = this.getSkinnedPosition();


		positionLocal.assign( skinPosition );

		if ( builder.hasGeometryAttribute( 'normal' ) ) {

			const skinNormal = this.getSkinnedNormal();

			normalLocal.assign( skinNormal );

			if ( builder.hasGeometryAttribute( 'tangent' ) ) {

				tangentLocal.assign( skinNormal );

			}

		}

	}

	generate( builder, output ) {

		if ( output !== 'void' ) {

			return positionLocal.build( builder, output );

		}

	}

	update( frame ) {

		const object = this.useReference ? frame.object : this.skinnedMesh;
		const skeleton = object.skeleton;

		if ( _frameId.get( skeleton ) === frame.frameId ) return;

		_frameId.set( skeleton, frame.frameId );

		if ( this.previousBoneMatricesNode !== null ) skeleton.previousBoneMatrices.set( skeleton.boneMatrices );

		skeleton.update();

	}

}

const skinning = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh ) );
const skinningReference = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh, true ) );

class LoopNode extends Node {

	static get type() {

		return 'LoopNode';

	}

	constructor( params = [] ) {

		super();

		this.params = params;

	}

	getVarName( index ) {

		return String.fromCharCode( 'i'.charCodeAt() + index );

	}

	getProperties( builder ) {

		const properties = builder.getNodeProperties( this );

		if ( properties.stackNode !== undefined ) return properties;

		//

		const inputs = {};

		for ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {

			const param = this.params[ i ];

			const name = ( param.isNode !== true && param.name ) || this.getVarName( i );
			const type = ( param.isNode !== true && param.type ) || 'int';

			inputs[ name ] = expression( name, type );

		}

		const stack = builder.addStack(); // TODO: cache() it

		properties.returnsNode = this.params[ this.params.length - 1 ]( inputs, stack, builder );
		properties.stackNode = stack;

		builder.removeStack();

		return properties;

	}

	getNodeType( builder ) {

		const { returnsNode } = this.getProperties( builder );

		return returnsNode ? returnsNode.getNodeType( builder ) : 'void';

	}

	setup( builder ) {

		// setup properties

		this.getProperties( builder );

	}

	generate( builder ) {

		const properties = this.getProperties( builder );

		const params = this.params;
		const stackNode = properties.stackNode;

		for ( let i = 0, l = params.length - 1; i < l; i ++ ) {

			const param = params[ i ];

			let start = null, end = null, name = null, type = null, condition = null, update = null;

			if ( param.isNode ) {

				type = 'int';
				name = this.getVarName( i );
				start = '0';
				end = param.build( builder, type );
				condition = '<';

			} else {

				type = param.type || 'int';
				name = param.name || this.getVarName( i );
				start = param.start;
				end = param.end;
				condition = param.condition;
				update = param.update;

				if ( typeof start === 'number' ) start = builder.generateConst( type, start );
				else if ( start && start.isNode ) start = start.build( builder, type );

				if ( typeof end === 'number' ) end = builder.generateConst( type, end );
				else if ( end && end.isNode ) end = end.build( builder, type );

				if ( start !== undefined && end === undefined ) {

					start = start + ' - 1';
					end = '0';
					condition = '>=';

				} else if ( end !== undefined && start === undefined ) {

					start = '0';
					condition = '<';

				}

				if ( condition === undefined ) {

					if ( Number( start ) > Number( end ) ) {

						condition = '>=';

					} else {

						condition = '<';

					}

				}

			}

			const internalParam = { start, end, condition };

			//

			const startSnippet = internalParam.start;
			const endSnippet = internalParam.end;

			let declarationSnippet = '';
			let conditionalSnippet = '';
			let updateSnippet = '';

			if ( ! update ) {

				if ( type === 'int' || type === 'uint' ) {

					if ( condition.includes( '<' ) ) update = '++';
					else update = '--';

				} else {

					if ( condition.includes( '<' ) ) update = '+= 1.';
					else update = '-= 1.';

				}

			}

			declarationSnippet += builder.getVar( type, name ) + ' = ' + startSnippet;

			conditionalSnippet += name + ' ' + condition + ' ' + endSnippet;
			updateSnippet += name + ' ' + update;

			const forSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;

			builder.addFlowCode( ( i === 0 ? '\n' : '' ) + builder.tab + forSnippet + ' {\n\n' ).addFlowTab();

		}

		const stackSnippet = stackNode.build( builder, 'void' );

		const returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';

		builder.removeFlowTab().addFlowCode( '\n' + builder.tab + stackSnippet );

		for ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {

			builder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\n\n' ).removeFlowTab();

		}

		builder.addFlowTab();

		return returnsSnippet;

	}

}

const Loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) ).append();
const Continue = () => expression( 'continue' ).append();
const Break = () => expression( 'break' ).append();

//

const loop = ( ...params ) => { // @deprecated, r168

	console.warn( 'TSL.LoopNode: loop() has been renamed to Loop().' );
	return Loop( ...params );

};

const _morphTextures = /*@__PURE__*/ new WeakMap();
const _morphVec4 = /*@__PURE__*/ new Vector4();

const getMorph = /*@__PURE__*/ Fn( ( { bufferMap, influence, stride, width, depth, offset } ) => {

	const texelIndex = int( vertexIndex ).mul( stride ).add( offset );

	const y = texelIndex.div( width );
	const x = texelIndex.sub( y.mul( width ) );

	const bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth );

	return bufferAttrib.mul( influence );

} );

function getEntry( geometry ) {

	const hasMorphPosition = geometry.morphAttributes.position !== undefined;
	const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
	const hasMorphColors = geometry.morphAttributes.color !== undefined;

	// instead of using attributes, the WebGL 2 code path encodes morph targets
	// into an array of data textures. Each layer represents a single morph target.

	const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
	const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

	let entry = _morphTextures.get( geometry );

	if ( entry === undefined || entry.count !== morphTargetsCount ) {

		if ( entry !== undefined ) entry.texture.dispose();

		const morphTargets = geometry.morphAttributes.position || [];
		const morphNormals = geometry.morphAttributes.normal || [];
		const morphColors = geometry.morphAttributes.color || [];

		let vertexDataCount = 0;

		if ( hasMorphPosition === true ) vertexDataCount = 1;
		if ( hasMorphNormals === true ) vertexDataCount = 2;
		if ( hasMorphColors === true ) vertexDataCount = 3;

		let width = geometry.attributes.position.count * vertexDataCount;
		let height = 1;

		const maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'

		if ( width > maxTextureSize ) {

			height = Math.ceil( width / maxTextureSize );
			width = maxTextureSize;

		}

		const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

		const bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
		bufferTexture.type = FloatType;
		bufferTexture.needsUpdate = true;

		// fill buffer

		const vertexDataStride = vertexDataCount * 4;

		for ( let i = 0; i < morphTargetsCount; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const morphNormal = morphNormals[ i ];
			const morphColor = morphColors[ i ];

			const offset = width * height * 4 * i;

			for ( let j = 0; j < morphTarget.count; j ++ ) {

				const stride = j * vertexDataStride;

				if ( hasMorphPosition === true ) {

					_morphVec4.fromBufferAttribute( morphTarget, j );

					buffer[ offset + stride + 0 ] = _morphVec4.x;
					buffer[ offset + stride + 1 ] = _morphVec4.y;
					buffer[ offset + stride + 2 ] = _morphVec4.z;
					buffer[ offset + stride + 3 ] = 0;

				}

				if ( hasMorphNormals === true ) {

					_morphVec4.fromBufferAttribute( morphNormal, j );

					buffer[ offset + stride + 4 ] = _morphVec4.x;
					buffer[ offset + stride + 5 ] = _morphVec4.y;
					buffer[ offset + stride + 6 ] = _morphVec4.z;
					buffer[ offset + stride + 7 ] = 0;

				}

				if ( hasMorphColors === true ) {

					_morphVec4.fromBufferAttribute( morphColor, j );

					buffer[ offset + stride + 8 ] = _morphVec4.x;
					buffer[ offset + stride + 9 ] = _morphVec4.y;
					buffer[ offset + stride + 10 ] = _morphVec4.z;
					buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? _morphVec4.w : 1;

				}

			}

		}

		entry = {
			count: morphTargetsCount,
			texture: bufferTexture,
			stride: vertexDataCount,
			size: new Vector2( width, height )
		};

		_morphTextures.set( geometry, entry );

		function disposeTexture() {

			bufferTexture.dispose();

			_morphTextures.delete( geometry );

			geometry.removeEventListener( 'dispose', disposeTexture );

		}

		geometry.addEventListener( 'dispose', disposeTexture );

	}

	return entry;

}


class MorphNode extends Node {

	static get type() {

		return 'MorphNode';

	}

	constructor( mesh ) {

		super( 'void' );

		this.mesh = mesh;
		this.morphBaseInfluence = uniform( 1 );

		this.updateType = NodeUpdateType.OBJECT;

	}

	setup( builder ) {

		const { geometry } = builder;

		const hasMorphPosition = geometry.morphAttributes.position !== undefined;
		const hasMorphNormals = geometry.hasAttribute( 'normal' ) && geometry.morphAttributes.normal !== undefined;

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		// nodes

		const { texture: bufferMap, stride, size } = getEntry( geometry );

		if ( hasMorphPosition === true ) positionLocal.mulAssign( this.morphBaseInfluence );
		if ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );

		const width = int( size.width );

		Loop( morphTargetsCount, ( { i } ) => {

			const influence = float( 0 ).toVar();

			if ( this.mesh.count > 1 && ( this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined ) ) {

				influence.assign( textureLoad( this.mesh.morphTexture, ivec2( int( i ).add( 1 ), int( instanceIndex ) ) ).r );

			} else {

				influence.assign( reference( 'morphTargetInfluences', 'float' ).element( i ).toVar() );

			}

			if ( hasMorphPosition === true ) {

				positionLocal.addAssign( getMorph( {
					bufferMap,
					influence,
					stride,
					width,
					depth: i,
					offset: int( 0 )
				} ) );

			}

			if ( hasMorphNormals === true ) {

				normalLocal.addAssign( getMorph( {
					bufferMap,
					influence,
					stride,
					width,
					depth: i,
					offset: int( 1 )
				} ) );

			}

		} );

	}

	update() {

		const morphBaseInfluence = this.morphBaseInfluence;

		if ( this.mesh.geometry.morphTargetsRelative ) {

			morphBaseInfluence.value = 1;

		} else {

			morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );

		}

	}

}

const morphReference = /*@__PURE__*/ nodeProxy( MorphNode );

class LightingNode extends Node {

	static get type() {

		return 'LightingNode';

	}

	constructor() {

		super( 'vec3' );

		this.isLightingNode = true;

	}

	generate( /*builder*/ ) {

		console.warn( 'Abstract function.' );

	}

}

class AONode extends LightingNode {

	static get type() {

		return 'AONode';

	}

	constructor( aoNode = null ) {

		super();

		this.aoNode = aoNode;

	}

	setup( builder ) {

		builder.context.ambientOcclusion.mulAssign( this.aoNode );

	}

}

class LightingContextNode extends ContextNode {

	static get type() {

		return 'LightingContextNode';

	}

	constructor( node, lightingModel = null, backdropNode = null, backdropAlphaNode = null ) {

		super( node );

		this.lightingModel = lightingModel;
		this.backdropNode = backdropNode;
		this.backdropAlphaNode = backdropAlphaNode;

		this._value = null;

	}

	getContext() {

		const { backdropNode, backdropAlphaNode } = this;

		const directDiffuse = vec3().toVar( 'directDiffuse' ),
			directSpecular = vec3().toVar( 'directSpecular' ),
			indirectDiffuse = vec3().toVar( 'indirectDiffuse' ),
			indirectSpecular = vec3().toVar( 'indirectSpecular' );

		const reflectedLight = {
			directDiffuse,
			directSpecular,
			indirectDiffuse,
			indirectSpecular
		};

		const context = {
			radiance: vec3().toVar( 'radiance' ),
			irradiance: vec3().toVar( 'irradiance' ),
			iblIrradiance: vec3().toVar( 'iblIrradiance' ),
			ambientOcclusion: float( 1 ).toVar( 'ambientOcclusion' ),
			reflectedLight,
			backdrop: backdropNode,
			backdropAlpha: backdropAlphaNode
		};

		return context;

	}

	setup( builder ) {

		this.value = this._value || ( this._value = this.getContext() );
		this.value.lightingModel = this.lightingModel || builder.context.lightingModel;

		return super.setup( builder );

	}

}

const lightingContext = /*@__PURE__*/ nodeProxy( LightingContextNode );

class IrradianceNode extends LightingNode {

	static get type() {

		return 'IrradianceNode';

	}

	constructor( node ) {

		super();

		this.node = node;

	}

	setup( builder ) {

		builder.context.irradiance.addAssign( this.node );

	}

}

let screenSizeVec, viewportVec;

class ScreenNode extends Node {

	static get type() {

		return 'ScreenNode';

	}

	constructor( scope ) {

		super();

		this.scope = scope;

		this.isViewportNode = true;

	}

	getNodeType() {

		if ( this.scope === ScreenNode.VIEWPORT ) return 'vec4';
		else return 'vec2';

	}

	getUpdateType() {

		let updateType = NodeUpdateType.NONE;

		if ( this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT ) {

			updateType = NodeUpdateType.RENDER;

		}

		this.updateType = updateType;

		return updateType;

	}

	update( { renderer } ) {

		const renderTarget = renderer.getRenderTarget();

		if ( this.scope === ScreenNode.VIEWPORT ) {

			if ( renderTarget !== null ) {

				viewportVec.copy( renderTarget.viewport );

			} else {

				renderer.getViewport( viewportVec );

				viewportVec.multiplyScalar( renderer.getPixelRatio() );

			}

		} else {

			if ( renderTarget !== null ) {

				screenSizeVec.width = renderTarget.width;
				screenSizeVec.height = renderTarget.height;

			} else {

				renderer.getDrawingBufferSize( screenSizeVec );

			}

		}

	}

	setup( /*builder*/ ) {

		const scope = this.scope;

		let output = null;

		if ( scope === ScreenNode.SIZE ) {

			output = uniform( screenSizeVec || ( screenSizeVec = new Vector2() ) );

		} else if ( scope === ScreenNode.VIEWPORT ) {

			output = uniform( viewportVec || ( viewportVec = new Vector4() ) );

		} else {

			output = vec2( screenCoordinate.div( screenSize ) );

		}

		return output;

	}

	generate( builder ) {

		if ( this.scope === ScreenNode.COORDINATE ) {

			let coord = builder.getFragCoord();

			if ( builder.isFlipY() ) {

				// follow webgpu standards

				const size = builder.getNodeProperties( screenSize ).outputNode.build( builder );

				coord = `${ builder.getType( 'vec2' ) }( ${ coord }.x, ${ size }.y - ${ coord }.y )`;

			}

			return coord;

		}

		return super.generate( builder );

	}

}

ScreenNode.COORDINATE = 'coordinate';
ScreenNode.VIEWPORT = 'viewport';
ScreenNode.SIZE = 'size';
ScreenNode.UV = 'uv';

// Screen

const screenUV = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.UV );
const screenSize = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.SIZE );
const screenCoordinate = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.COORDINATE );

// Viewport

const viewport = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.VIEWPORT );
const viewportSize = viewport.zw;
const viewportCoordinate = /*@__PURE__*/ screenCoordinate.sub( viewport.xy );
const viewportUV = /*@__PURE__*/ viewportCoordinate.div( viewportSize );

// Deprecated

const viewportResolution = /*@__PURE__*/ ( Fn( () => { // @deprecated, r169

	console.warn( 'TSL.ViewportNode: "viewportResolution" is deprecated. Use "screenSize" instead.' );

	return screenSize;

}, 'vec2' ).once() )();

const viewportTopLeft = /*@__PURE__*/ ( Fn( () => { // @deprecated, r168

	console.warn( 'TSL.ViewportNode: "viewportTopLeft" is deprecated. Use "screenUV" instead.' );

	return screenUV;

}, 'vec2' ).once() )();

const viewportBottomLeft = /*@__PURE__*/ ( Fn( () => { // @deprecated, r168

	console.warn( 'TSL.ViewportNode: "viewportBottomLeft" is deprecated. Use "screenUV.flipY()" instead.' );

	return screenUV.flipY();

}, 'vec2' ).once() )();

const _size$4 = /*@__PURE__*/ new Vector2();

class ViewportTextureNode extends TextureNode {

	static get type() {

		return 'ViewportTextureNode';

	}

	constructor( uvNode = screenUV, levelNode = null, framebufferTexture = null ) {

		if ( framebufferTexture === null ) {

			framebufferTexture = new FramebufferTexture();
			framebufferTexture.minFilter = LinearMipmapLinearFilter;

		}

		super( framebufferTexture, uvNode, levelNode );

		this.generateMipmaps = false;

		this.isOutputTextureNode = true;

		this.updateBeforeType = NodeUpdateType.FRAME;

	}

	updateBefore( frame ) {

		const renderer = frame.renderer;
		renderer.getDrawingBufferSize( _size$4 );

		//

		const framebufferTexture = this.value;

		if ( framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height ) {

			framebufferTexture.image.width = _size$4.width;
			framebufferTexture.image.height = _size$4.height;
			framebufferTexture.needsUpdate = true;

		}

		//

		const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
		framebufferTexture.generateMipmaps = this.generateMipmaps;

		renderer.copyFramebufferToTexture( framebufferTexture );

		framebufferTexture.generateMipmaps = currentGenerateMipmaps;

	}

	clone() {

		const viewportTextureNode = new this.constructor( this.uvNode, this.levelNode, this.value );
		viewportTextureNode.generateMipmaps = this.generateMipmaps;

		return viewportTextureNode;

	}

}

const viewportTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode );
const viewportMipTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode, null, null, { generateMipmaps: true } );

let sharedDepthbuffer = null;

class ViewportDepthTextureNode extends ViewportTextureNode {

	static get type() {

		return 'ViewportDepthTextureNode';

	}

	constructor( uvNode = screenUV, levelNode = null ) {

		if ( sharedDepthbuffer === null ) {

			sharedDepthbuffer = new DepthTexture();

		}

		super( uvNode, levelNode, sharedDepthbuffer );

	}

}

const viewportDepthTexture = /*@__PURE__*/ nodeProxy( ViewportDepthTextureNode );

class ViewportDepthNode extends Node {

	static get type() {

		return 'ViewportDepthNode';

	}

	constructor( scope, valueNode = null ) {

		super( 'float' );

		this.scope = scope;
		this.valueNode = valueNode;

		this.isViewportDepthNode = true;

	}

	generate( builder ) {

		const { scope } = this;

		if ( scope === ViewportDepthNode.DEPTH_BASE ) {

			return builder.getFragDepth();

		}

		return super.generate( builder );

	}

	setup( { camera } ) {

		const { scope } = this;
		const value = this.valueNode;

		let node = null;

		if ( scope === ViewportDepthNode.DEPTH_BASE ) {

			if ( value !== null ) {

 				node = depthBase().assign( value );

			}

		} else if ( scope === ViewportDepthNode.DEPTH ) {

			if ( camera.isPerspectiveCamera ) {

				node = viewZToPerspectiveDepth( positionView.z, cameraNear, cameraFar );

			} else {

				node = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );

			}

		} else if ( scope === ViewportDepthNode.LINEAR_DEPTH ) {

			if ( value !== null ) {

				if ( camera.isPerspectiveCamera ) {

					const viewZ = perspectiveDepthToViewZ( value, cameraNear, cameraFar );

					node = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

				} else {

					node = value;

				}

			} else {

				node = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );

			}

		}

		return node;

	}

}

ViewportDepthNode.DEPTH_BASE = 'depthBase';
ViewportDepthNode.DEPTH = 'depth';
ViewportDepthNode.LINEAR_DEPTH = 'linearDepth';

// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera

// -near maps to 0; -far maps to 1
const viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );

// maps orthographic depth in [ 0, 1 ] to viewZ
const orthographicDepthToViewZ = ( depth, near, far ) => near.sub( far ).mul( depth ).sub( near );

// NOTE: https://twitter.com/gonnavis/status/1377183786949959682

// -near maps to 0; -far maps to 1
const viewZToPerspectiveDepth = ( viewZ, near, far ) => near.add( viewZ ).mul( far ).div( far.sub( near ).mul( viewZ ) );

// maps perspective depth in [ 0, 1 ] to viewZ
const perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );

// -near maps to 0; -far maps to 1
const viewZToLogarithmicDepth = ( viewZ, near, far ) => {

	// NOTE: viewZ must be negative--see explanation at the end of this comment block.
	// The final logarithmic depth formula used here is adapted from one described in an
	// article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),
	// which was an improvement upon an earlier formula one described in an
	// Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).
	// Ulrich's formula is the following:
	//     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )
	//     where K = 2^k - 1, and k is the number of bits in the depth buffer.
	// The Outerra variant ignored the camera near plane (it assumed it was 0) and instead
	// opted for a "C-constant" for resolution adjustment of objects near the camera.
	// Outerra states: "Notice that the 'C' variant doesnt use a near plane distance, it has it
	// set at 0" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).
	// Ulrich's variant has the benefit of constant relative precision over the whole near-far range.
	// It was debated here whether Outerra's "C-constant" or Ulrich's "near plane" variant should
	// be used, and ultimately Ulrich's "near plane" version was chosen.
	// Outerra eventually made another improvement to their original "C-constant" variant,
	// but it still does not incorporate the camera near plane (for this version,
	// see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).
	// Here we make 4 changes to Ulrich's formula:
	// 1. Clamp the camera near plane so we don't divide by 0.
	// 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).
	// 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).
	// 4. To maintain consistency with the functions "viewZToOrthographicDepth" and "viewZToPerspectiveDepth",
	//    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,
	//    so we do the same here, hence the 'viewZ.negate()' call.
	// For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u
	near = near.max( 1e-6 ).toVar();
	const numerator = log2( viewZ.negate().div( near ) );
	const denominator = log2( far.div( near ) );
	return numerator.div( denominator );

};

// maps logarithmic depth in [ 0, 1 ] to viewZ
const logarithmicDepthToViewZ = ( depth, near, far ) => {

	// NOTE: we add a 'negate()' call to the return value here to maintain consistency with
	// the functions "orthographicDepthToViewZ" and "perspectiveDepthToViewZ" (they return
	// a negative viewZ).
	const exponent = depth.mul( log( far.div( near ) ) );
	return float( Math.E ).pow( exponent ).mul( near ).negate();

};

const depthBase = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_BASE );

const depth = /*@__PURE__*/ nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );
const linearDepth = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH );
const viewportLinearDepth = /*@__PURE__*/ linearDepth( viewportDepthTexture() );

depth.assign = ( value ) => depthBase( value );

class BuiltinNode extends Node {

	constructor( name ) {

		super( 'float' );

		this.name = name;

		this.isBuiltinNode = true;

	}

	generate( /* builder */ ) {

		return this.name;

	}

}

const builtin = nodeProxy( BuiltinNode );

class ClippingNode extends Node {

	static get type() {

		return 'ClippingNode';

	}

	constructor( scope = ClippingNode.DEFAULT ) {

		super();

		this.scope = scope;

	}

	setup( builder ) {

		super.setup( builder );

		const clippingContext = builder.clippingContext;
		const { intersectionPlanes, unionPlanes } = clippingContext;

		this.hardwareClipping = builder.material.hardwareClipping;

		if ( this.scope === ClippingNode.ALPHA_TO_COVERAGE ) {

			return this.setupAlphaToCoverage( intersectionPlanes, unionPlanes );

		} else if ( this.scope === ClippingNode.HARDWARE ) {

			return this.setupHardwareClipping( unionPlanes, builder );

		} else {

			return this.setupDefault( intersectionPlanes, unionPlanes );

		}

	}

	setupAlphaToCoverage( intersectionPlanes, unionPlanes ) {

		return Fn( () => {

			const distanceToPlane = float().toVar( 'distanceToPlane' );
			const distanceGradient = float().toVar( 'distanceToGradient' );

			const clipOpacity = float( 1 ).toVar( 'clipOpacity' );

			const numUnionPlanes = unionPlanes.length;

			if ( ! this.hardwareClipping && numUnionPlanes > 0 ) {

				const clippingPlanes = uniformArray( unionPlanes );

				Loop( numUnionPlanes, ( { i } ) => {

					const plane = clippingPlanes.element( i );

					distanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );
					distanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );

					clipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ) );

				} );

			}

			const numIntersectionPlanes = intersectionPlanes.length;

			if ( numIntersectionPlanes > 0 ) {

				const clippingPlanes = uniformArray( intersectionPlanes );
				const intersectionClipOpacity = float( 1 ).toVar( 'intersectionClipOpacity' );

				Loop( numIntersectionPlanes, ( { i } ) => {

					const plane = clippingPlanes.element( i );

					distanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );
					distanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );

					intersectionClipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ).oneMinus() );

				} );

				clipOpacity.mulAssign( intersectionClipOpacity.oneMinus() );

			}

			diffuseColor.a.mulAssign( clipOpacity );

			diffuseColor.a.equal( 0.0 ).discard();

		} )();

	}

	setupDefault( intersectionPlanes, unionPlanes ) {

		return Fn( () => {

			const numUnionPlanes = unionPlanes.length;

			if ( ! this.hardwareClipping && numUnionPlanes > 0 ) {

				const clippingPlanes = uniformArray( unionPlanes );

				Loop( numUnionPlanes, ( { i } ) => {

					const plane = clippingPlanes.element( i );
					positionView.dot( plane.xyz ).greaterThan( plane.w ).discard();

				} );

			}

			const numIntersectionPlanes = intersectionPlanes.length;

			if ( numIntersectionPlanes > 0 ) {

				const clippingPlanes = uniformArray( intersectionPlanes );
				const clipped = bool( true ).toVar( 'clipped' );

				Loop( numIntersectionPlanes, ( { i } ) => {

					const plane = clippingPlanes.element( i );
					clipped.assign( positionView.dot( plane.xyz ).greaterThan( plane.w ).and( clipped ) );

				} );

				clipped.discard();

			}

		} )();

	}

	setupHardwareClipping( unionPlanes, builder ) {

		const numUnionPlanes = unionPlanes.length;

		builder.enableHardwareClipping( numUnionPlanes );

		return Fn( () => {

			const clippingPlanes = uniformArray( unionPlanes );
			const hw_clip_distances = builtin( builder.getClipDistance() );

			Loop( numUnionPlanes, ( { i } ) => {

				const plane = clippingPlanes.element( i );

				const distance = positionView.dot( plane.xyz ).sub( plane.w ).negate();
				hw_clip_distances.element( i ).assign( distance );

			} );

		} )();

	}

}

ClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';
ClippingNode.DEFAULT = 'default';
ClippingNode.HARDWARE = 'hardware';

const clipping = () => nodeObject( new ClippingNode() );
const clippingAlpha = () => nodeObject( new ClippingNode( ClippingNode.ALPHA_TO_COVERAGE ) );
const hardwareClipping = () => nodeObject( new ClippingNode( ClippingNode.HARDWARE ) );

/**
 * See: https://casual-effects.com/research/Wyman2017Hashed/index.html
 */

const ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.

const hash2D = /*@__PURE__*/ Fn( ( [ value ] ) => {

	return fract( mul( 1.0e4, sin( mul( 17.0, value.x ).add( mul( 0.1, value.y ) ) ) ).mul( add( 0.1, abs( sin( mul( 13.0, value.y ).add( value.x ) ) ) ) ) );

} );

const hash3D = /*@__PURE__*/ Fn( ( [ value ] ) => {

	return hash2D( vec2( hash2D( value.xy ), value.z ) );

} );

const getAlphaHashThreshold = /*@__PURE__*/ Fn( ( [ position ] ) => {

	// Find the discretized derivatives of our coordinates
	const maxDeriv = max$1(
		length( dFdx( position.xyz ) ),
		length( dFdy( position.xyz ) )
	);

	const pixScale = float( 1 ).div( float( ALPHA_HASH_SCALE ).mul( maxDeriv ) ).toVar( 'pixScale' );

	// Find two nearest log-discretized noise scales
	const pixScales = vec2(
		exp2( floor( log2( pixScale ) ) ),
		exp2( ceil( log2( pixScale ) ) )
	);

	// Compute alpha thresholds at our two noise scales
	const alpha = vec2(
		hash3D( floor( pixScales.x.mul( position.xyz ) ) ),
		hash3D( floor( pixScales.y.mul( position.xyz ) ) ),
	);

	// Factor to interpolate lerp with
	const lerpFactor = fract( log2( pixScale ) );

	// Interpolate alpha threshold from noise at two scales
	const x = add( mul( lerpFactor.oneMinus(), alpha.x ), mul( lerpFactor, alpha.y ) );

	// Pass into CDF to compute uniformly distrib threshold
	const a = min$1( lerpFactor, lerpFactor.oneMinus() );
	const cases = vec3(
		x.mul( x ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ),
		x.sub( mul( 0.5, a ) ).div( sub( 1.0, a ) ),
		sub( 1.0, sub( 1.0, x ).mul( sub( 1.0, x ) ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ) ) );

	// Find our final, uniformly distributed alpha threshold ()
	const threshold = x.lessThan( a.oneMinus() ).select( x.lessThan( a ).select( cases.x, cases.y ), cases.z );

	// Avoids  == 0. Could also do  =1-
	return clamp( threshold, 1.0e-6, 1.0 );

} ).setLayout( {
	name: 'getAlphaHashThreshold',
	type: 'float',
	inputs: [
		{ name: 'position', type: 'vec3' }
	]
} );

class NodeMaterial extends Material {

	static get type() {

		return 'NodeMaterial';

	}

	get type() {

		return this.constructor.type;

	}

	set type( _value ) { /* */ }

	constructor() {

		super();

		this.isNodeMaterial = true;

		this.forceSinglePass = false;

		this.fog = true;
		this.lights = false;
		this.hardwareClipping = false;

		this.lightsNode = null;
		this.envNode = null;
		this.aoNode = null;

		this.colorNode = null;
		this.normalNode = null;
		this.opacityNode = null;
		this.backdropNode = null;
		this.backdropAlphaNode = null;
		this.alphaTestNode = null;

		this.positionNode = null;
		this.geometryNode = null;

		this.depthNode = null;
		this.shadowPositionNode = null;
		this.receivedShadowNode = null;
		this.castShadowNode = null;

		this.outputNode = null;
		this.mrtNode = null;

		this.fragmentNode = null;
		this.vertexNode = null;

	}

	customProgramCacheKey() {

		return this.type + getCacheKey$1( this );

	}

	build( builder ) {

		this.setup( builder );

	}

	setupObserver( builder ) {

		return new NodeMaterialObserver( builder );

	}

	setup( builder ) {

		builder.context.setupNormal = () => this.setupNormal( builder );

		const renderer = builder.renderer;
		const renderTarget = renderer.getRenderTarget();

		// < VERTEX STAGE >

		builder.addStack();

		builder.stack.outputNode = this.vertexNode || this.setupPosition( builder );

		if ( this.geometryNode !== null ) {

			builder.stack.outputNode = builder.stack.outputNode.bypass( this.geometryNode );

		}

		builder.addFlow( 'vertex', builder.removeStack() );

		// < FRAGMENT STAGE >

		builder.addStack();

		let resultNode;

		const clippingNode = this.setupClipping( builder );

		if ( this.depthWrite === true ) {

			// only write depth if depth buffer is configured

			if ( renderTarget !== null ) {

				if ( renderTarget.depthBuffer === true ) this.setupDepth( builder );

			} else {

				if ( renderer.depth === true ) this.setupDepth( builder );

			}

		}

		if ( this.fragmentNode === null ) {

			this.setupDiffuseColor( builder );
			this.setupVariants( builder );

			const outgoingLightNode = this.setupLighting( builder );

			if ( clippingNode !== null ) builder.stack.add( clippingNode );

			// force unsigned floats - useful for RenderTargets

			const basicOutput = vec4( outgoingLightNode, diffuseColor.a ).max( 0 );

			resultNode = this.setupOutput( builder, basicOutput );

			// OUTPUT NODE

			output.assign( resultNode );

			//

			if ( this.outputNode !== null ) resultNode = this.outputNode;

			// MRT

			if ( renderTarget !== null ) {

				const mrt = renderer.getMRT();
				const materialMRT = this.mrtNode;

				if ( mrt !== null ) {

					resultNode = mrt;

					if ( materialMRT !== null ) {

						resultNode = mrt.merge( materialMRT );

					}

				} else if ( materialMRT !== null ) {

					resultNode = materialMRT;

				}

			}

		} else {

			let fragmentNode = this.fragmentNode;

			if ( fragmentNode.isOutputStructNode !== true ) {

				fragmentNode = vec4( fragmentNode );

			}

			resultNode = this.setupOutput( builder, fragmentNode );

		}

		builder.stack.outputNode = resultNode;

		builder.addFlow( 'fragment', builder.removeStack() );

		// < MONITOR >

		builder.monitor = this.setupObserver( builder );

	}

	setupClipping( builder ) {

		if ( builder.clippingContext === null ) return null;

		const { unionPlanes, intersectionPlanes } = builder.clippingContext;

		let result = null;

		if ( unionPlanes.length > 0 || intersectionPlanes.length > 0 ) {

			const samples = builder.renderer.samples;

			if ( this.alphaToCoverage && samples > 1 ) {

				// to be added to flow when the color/alpha value has been determined
				result = clippingAlpha();

			} else {

				builder.stack.add( clipping() );

			}

		}

		return result;

	}

	setupHardwareClipping( builder ) {

		this.hardwareClipping = false;

		if ( builder.clippingContext === null ) return;

		const candidateCount = builder.clippingContext.unionPlanes.length;

		// 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances

		if ( candidateCount > 0 && candidateCount <= 8 && builder.isAvailable( 'clipDistance' ) ) {

			builder.stack.add( hardwareClipping() );

			this.hardwareClipping = true;

		}

		return;

	}

	setupDepth( builder ) {

		const { renderer, camera } = builder;

		// Depth

		let depthNode = this.depthNode;

		if ( depthNode === null ) {

			const mrt = renderer.getMRT();

			if ( mrt && mrt.has( 'depth' ) ) {

				depthNode = mrt.get( 'depth' );

			} else if ( renderer.logarithmicDepthBuffer === true ) {

				if ( camera.isPerspectiveCamera ) {

					depthNode = viewZToLogarithmicDepth( positionView.z, cameraNear, cameraFar );

				} else {

					depthNode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );

				}

			}

		}

		if ( depthNode !== null ) {

			depth.assign( depthNode ).append();

		}

	}

	setupPosition( builder ) {

		const { object } = builder;
		const geometry = object.geometry;

		builder.addStack();

		// Vertex

		if ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {

			morphReference( object ).append();

		}

		if ( object.isSkinnedMesh === true ) {

			skinningReference( object ).append();

		}

		if ( this.displacementMap ) {

			const displacementMap = materialReference( 'displacementMap', 'texture' );
			const displacementScale = materialReference( 'displacementScale', 'float' );
			const displacementBias = materialReference( 'displacementBias', 'float' );

			positionLocal.addAssign( normalLocal.normalize().mul( ( displacementMap.x.mul( displacementScale ).add( displacementBias ) ) ) );

		}

		if ( object.isBatchedMesh ) {

			batch( object ).append();

		}

		if ( ( object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) ) {

			instancedMesh( object ).append();

		}

		if ( this.positionNode !== null ) {

			positionLocal.assign( this.positionNode );

		}

		this.setupHardwareClipping( builder );

		const mvp = modelViewProjection();

		builder.context.vertex = builder.removeStack();
		builder.context.mvp = mvp;

		return mvp;

	}

	setupDiffuseColor( { object, geometry } ) {

		let colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;

		// VERTEX COLORS

		if ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {

			colorNode = vec4( colorNode.xyz.mul( attribute( 'color', 'vec3' ) ), colorNode.a );

		}

		// Instanced colors

		if ( object.instanceColor ) {

			const instanceColor = varyingProperty( 'vec3', 'vInstanceColor' );

			colorNode = instanceColor.mul( colorNode );

		}

		if ( object.isBatchedMesh && object._colorsTexture ) {

			const batchColor = varyingProperty( 'vec3', 'vBatchColor' );

			colorNode = batchColor.mul( colorNode );

		}


		// COLOR

		diffuseColor.assign( colorNode );

		// OPACITY

		const opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;
		diffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );

		// ALPHA TEST

		if ( this.alphaTestNode !== null || this.alphaTest > 0 ) {

			const alphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;

			diffuseColor.a.lessThanEqual( alphaTestNode ).discard();

		}

		// ALPHA HASH

		if ( this.alphaHash === true ) {

			diffuseColor.a.lessThan( getAlphaHashThreshold( positionLocal ) ).discard();

		}

		if ( this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false ) {

			diffuseColor.a.assign( 1.0 );

		}

	}

	setupVariants( /*builder*/ ) {

		// Interface function.

	}

	setupOutgoingLight() {

		return ( this.lights === true ) ? vec3( 0 ) : diffuseColor.rgb;

	}

	setupNormal() {

		return this.normalNode ? vec3( this.normalNode ) : materialNormal;

	}

	setupEnvironment( /*builder*/ ) {

		let node = null;

		if ( this.envNode ) {

			node = this.envNode;

		} else if ( this.envMap ) {

			node = this.envMap.isCubeTexture ? materialReference( 'envMap', 'cubeTexture' ) : materialReference( 'envMap', 'texture' );

		}

		return node;

	}

	setupLightMap( builder ) {

		let node = null;

		if ( builder.material.lightMap ) {

			node = new IrradianceNode( materialLightMap );

		}

		return node;

	}

	setupLights( builder ) {

		const materialLightsNode = [];

		//

		const envNode = this.setupEnvironment( builder );

		if ( envNode && envNode.isLightingNode ) {

			materialLightsNode.push( envNode );

		}

		const lightMapNode = this.setupLightMap( builder );

		if ( lightMapNode && lightMapNode.isLightingNode ) {

			materialLightsNode.push( lightMapNode );

		}

		if ( this.aoNode !== null || builder.material.aoMap ) {

			const aoNode = this.aoNode !== null ? this.aoNode : materialAOMap;

			materialLightsNode.push( new AONode( aoNode ) );

		}

		let lightsN = this.lightsNode || builder.lightsNode;

		if ( materialLightsNode.length > 0 ) {

			lightsN = builder.renderer.lighting.createNode( [ ...lightsN.getLights(), ...materialLightsNode ] );

		}

		return lightsN;

	}

	setupLightingModel( /*builder*/ ) {

		// Interface function.

	}

	setupLighting( builder ) {

		const { material } = builder;
		const { backdropNode, backdropAlphaNode, emissiveNode } = this;

		// OUTGOING LIGHT

		const lights = this.lights === true || this.lightsNode !== null;

		const lightsNode = lights ? this.setupLights( builder ) : null;

		let outgoingLightNode = this.setupOutgoingLight( builder );

		if ( lightsNode && lightsNode.getScope().hasLights ) {

			const lightingModel = this.setupLightingModel( builder );

			outgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );

		} else if ( backdropNode !== null ) {

			outgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );

		}

		// EMISSIVE

		if ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {

			emissive.assign( vec3( emissiveNode ? emissiveNode : materialEmissive ) );

			outgoingLightNode = outgoingLightNode.add( emissive );

		}

		return outgoingLightNode;

	}

	setupOutput( builder, outputNode ) {

		// FOG

		if ( this.fog === true ) {

			const fogNode = builder.fogNode;

			if ( fogNode ) outputNode = vec4( fogNode.mix( outputNode.rgb, fogNode.colorNode ), outputNode.a );

		}

		return outputNode;

	}

	setDefaultValues( material ) {

		// This approach is to reuse the native refreshUniforms*
		// and turn available the use of features like transmission and environment in core

		for ( const property in material ) {

			const value = material[ property ];

			if ( this[ property ] === undefined ) {

				this[ property ] = value;

				if ( value && value.clone ) this[ property ] = value.clone();

			}

		}

		const descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );

		for ( const key in descriptors ) {

			if ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&
			     descriptors[ key ].get !== undefined ) {

				Object.defineProperty( this.constructor.prototype, key, descriptors[ key ] );

			}

		}

	}

	toJSON( meta ) {

		const isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {},
				nodes: {}
			};

		}

		const data = Material.prototype.toJSON.call( this, meta );
		const nodeChildren = getNodeChildren( this );

		data.inputNodes = {};

		for ( const { property, childNode } of nodeChildren ) {

			data.inputNodes[ property ] = childNode.toJSON( meta ).uuid;

		}

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const nodes = extractFromCache( meta.nodes );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;
			if ( nodes.length > 0 ) data.nodes = nodes;

		}

		return data;

	}

	copy( source ) {

		this.lightsNode = source.lightsNode;
		this.envNode = source.envNode;

		this.colorNode = source.colorNode;
		this.normalNode = source.normalNode;
		this.opacityNode = source.opacityNode;
		this.backdropNode = source.backdropNode;
		this.backdropAlphaNode = source.backdropAlphaNode;
		this.alphaTestNode = source.alphaTestNode;

		this.positionNode = source.positionNode;
		this.geometryNode = source.geometryNode;

		this.depthNode = source.depthNode;
		this.shadowPositionNode = source.shadowPositionNode;
		this.receivedShadowNode = source.receivedShadowNode;
		this.castShadowNode = source.castShadowNode;

		this.outputNode = source.outputNode;
		this.mrtNode = source.mrtNode;

		this.fragmentNode = source.fragmentNode;
		this.vertexNode = source.vertexNode;

		return super.copy( source );

	}

}

const _defaultValues$e = /*@__PURE__*/ new PointsMaterial();

class InstancedPointsNodeMaterial extends NodeMaterial {

	static get type() {

		return 'InstancedPointsNodeMaterial';

	}

	constructor( params = {} ) {

		super();

		this.lights = false;

		this.useAlphaToCoverage = true;

		this.useColor = params.vertexColors;

		this.pointWidth = 1;

		this.pointColorNode = null;

		this.pointWidthNode = null;

		this.setDefaultValues( _defaultValues$e );

		this.setValues( params );

	}

	setup( builder ) {

		this.setupShaders( builder );

		super.setup( builder );

	}

	setupShaders( { renderer } ) {

		const useAlphaToCoverage = this.alphaToCoverage;
		const useColor = this.useColor;

		this.vertexNode = Fn( () => {

			const instancePosition = attribute( 'instancePosition' ).xyz;

			// camera space
			const mvPos = vec4( modelViewMatrix.mul( vec4( instancePosition, 1.0 ) ) );

			const aspect = viewport.z.div( viewport.w );

			// clip space
			const clipPos = cameraProjectionMatrix.mul( mvPos );

			// offset in ndc space
			const offset = positionGeometry.xy.toVar();

			offset.mulAssign( this.pointWidthNode ? this.pointWidthNode : materialPointWidth );

			offset.assign( offset.div( viewport.z ) );
			offset.y.assign( offset.y.mul( aspect ) );

			// back to clip space
			offset.assign( offset.mul( clipPos.w ) );

			//clipPos.xy += offset;
			clipPos.addAssign( vec4( offset, 0, 0 ) );

			return clipPos;

		} )();

		this.fragmentNode = Fn( () => {

			const alpha = float( 1 ).toVar();

			const len2 = lengthSq( uv().mul( 2 ).sub( 1 ) );

			if ( useAlphaToCoverage && renderer.samples > 1 ) {

				const dlen = float( len2.fwidth() ).toVar();

				alpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );

			} else {

				len2.greaterThan( 1.0 ).discard();

			}

			let pointColorNode;

			if ( this.pointColorNode ) {

				pointColorNode = this.pointColorNode;

			} else {

				if ( useColor ) {

					const instanceColor = attribute( 'instanceColor' );

					pointColorNode = instanceColor.mul( materialColor );

				} else {

					pointColorNode = materialColor;

				}

			}

			alpha.mulAssign( materialOpacity );

			return vec4( pointColorNode, alpha );

		} )();

	}

	get alphaToCoverage() {

		return this.useAlphaToCoverage;

	}

	set alphaToCoverage( value ) {

		if ( this.useAlphaToCoverage !== value ) {

			this.useAlphaToCoverage = value;
			this.needsUpdate = true;

		}

	}

}

const _defaultValues$d = /*@__PURE__*/ new LineBasicMaterial();

class LineBasicNodeMaterial extends NodeMaterial {

	static get type() {

		return 'LineBasicNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isLineBasicNodeMaterial = true;

		this.lights = false;

		this.setDefaultValues( _defaultValues$d );

		this.setValues( parameters );

	}

}

const _defaultValues$c = /*@__PURE__*/ new LineDashedMaterial();

class LineDashedNodeMaterial extends NodeMaterial {

	static get type() {

		return 'LineDashedNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isLineDashedNodeMaterial = true;

		this.lights = false;

		this.setDefaultValues( _defaultValues$c );

		this.dashOffset = 0;

		this.offsetNode = null;
		this.dashScaleNode = null;
		this.dashSizeNode = null;
		this.gapSizeNode = null;

		this.setValues( parameters );

	}

	setupVariants() {

		const offsetNode = this.offsetNode ? float( this.offsetNodeNode ) : materialLineDashOffset;
		const dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;
		const dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;
		const gapSizeNode = this.dashSizeNode ? float( this.dashGapNode ) : materialLineGapSize;

		dashSize.assign( dashSizeNode );
		gapSize.assign( gapSizeNode );

		const vLineDistance = varying( attribute( 'lineDistance' ).mul( dashScaleNode ) );
		const vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;

		vLineDistanceOffset.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard();

	}

}

let _sharedFramebuffer = null;

class ViewportSharedTextureNode extends ViewportTextureNode {

	static get type() {

		return 'ViewportSharedTextureNode';

	}

	constructor( uvNode = screenUV, levelNode = null ) {

		if ( _sharedFramebuffer === null ) {

			_sharedFramebuffer = new FramebufferTexture();

		}

		super( uvNode, levelNode, _sharedFramebuffer );

	}

	updateReference() {

		return this;

	}

}

const viewportSharedTexture = /*@__PURE__*/ nodeProxy( ViewportSharedTextureNode );

const _defaultValues$b = /*@__PURE__*/ new LineDashedMaterial();

class Line2NodeMaterial extends NodeMaterial {

	static get type() {

		return 'Line2NodeMaterial';

	}

	constructor( params = {} ) {

		super();

		this.lights = false;

		this.setDefaultValues( _defaultValues$b );

		this.useAlphaToCoverage = true;
		this.useColor = params.vertexColors;
		this.useDash = params.dashed;
		this.useWorldUnits = false;

		this.dashOffset = 0;
		this.lineWidth = 1;

		this.lineColorNode = null;

		this.offsetNode = null;
		this.dashScaleNode = null;
		this.dashSizeNode = null;
		this.gapSizeNode = null;

		this.blending = NoBlending;

		this.setValues( params );

	}

	setup( builder ) {

		this.setupShaders( builder );

		super.setup( builder );

	}

	setupShaders( { renderer } ) {

		const useAlphaToCoverage = this.alphaToCoverage;
		const useColor = this.useColor;
		const useDash = this.dashed;
		const useWorldUnits = this.worldUnits;

		const trimSegment = Fn( ( { start, end } ) => {

			const a = cameraProjectionMatrix.element( 2 ).element( 2 ); // 3nd entry in 3th column
			const b = cameraProjectionMatrix.element( 3 ).element( 2 ); // 3nd entry in 4th column
			const nearEstimate = b.mul( - 0.5 ).div( a );

			const alpha = nearEstimate.sub( start.z ).div( end.z.sub( start.z ) );

			return vec4( mix( start.xyz, end.xyz, alpha ), end.w );

		} ).setLayout( {
			name: 'trimSegment',
			type: 'vec4',
			inputs: [
				{ name: 'start', type: 'vec4' },
				{ name: 'end', type: 'vec4' }
			]
		} );

		this.vertexNode = Fn( () => {

			const instanceStart = attribute( 'instanceStart' );
			const instanceEnd = attribute( 'instanceEnd' );

			// camera space

			const start = vec4( modelViewMatrix.mul( vec4( instanceStart, 1.0 ) ) ).toVar( 'start' );
			const end = vec4( modelViewMatrix.mul( vec4( instanceEnd, 1.0 ) ) ).toVar( 'end' );

			if ( useDash ) {

				const dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;
				const offsetNode = this.offsetNode ? float( this.offsetNodeNode ) : materialLineDashOffset;

				const instanceDistanceStart = attribute( 'instanceDistanceStart' );
				const instanceDistanceEnd = attribute( 'instanceDistanceEnd' );

				let lineDistance = positionGeometry.y.lessThan( 0.5 ).select( dashScaleNode.mul( instanceDistanceStart ), dashScaleNode.mul( instanceDistanceEnd ) );
				lineDistance = lineDistance.add( offsetNode );

				varyingProperty( 'float', 'lineDistance' ).assign( lineDistance );

			}

			if ( useWorldUnits ) {

				varyingProperty( 'vec3', 'worldStart' ).assign( start.xyz );
				varyingProperty( 'vec3', 'worldEnd' ).assign( end.xyz );

			}

			const aspect = viewport.z.div( viewport.w );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			const perspective = cameraProjectionMatrix.element( 2 ).element( 3 ).equal( - 1.0 ); // 4th entry in the 3rd column

			If( perspective, () => {

				If( start.z.lessThan( 0.0 ).and( end.z.greaterThan( 0.0 ) ), () => {

					end.assign( trimSegment( { start: start, end: end } ) );

				} ).ElseIf( end.z.lessThan( 0.0 ).and( start.z.greaterThanEqual( 0.0 ) ), () => {

					start.assign( trimSegment( { start: end, end: start } ) );

			 	} );

			} );

			// clip space
			const clipStart = cameraProjectionMatrix.mul( start );
			const clipEnd = cameraProjectionMatrix.mul( end );

			// ndc space
			const ndcStart = clipStart.xyz.div( clipStart.w );
			const ndcEnd = clipEnd.xyz.div( clipEnd.w );

			// direction
			const dir = ndcEnd.xy.sub( ndcStart.xy ).toVar();

			// account for clip-space aspect ratio
			dir.x.assign( dir.x.mul( aspect ) );
			dir.assign( dir.normalize() );

			const clip = vec4().toVar();

			if ( useWorldUnits ) {

				// get the offset direction as perpendicular to the view vector

				const worldDir = end.xyz.sub( start.xyz ).normalize();
				const tmpFwd = mix( start.xyz, end.xyz, 0.5 ).normalize();
				const worldUp = worldDir.cross( tmpFwd ).normalize();
				const worldFwd = worldDir.cross( worldUp );

				const worldPos = varyingProperty( 'vec4', 'worldPos' );

				worldPos.assign( positionGeometry.y.lessThan( 0.5 ).select( start, end ) );

				// height offset
				const hw = materialLineWidth.mul( 0.5 );
				worldPos.addAssign( vec4( positionGeometry.x.lessThan( 0.0 ).select( worldUp.mul( hw ), worldUp.mul( hw ).negate() ), 0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				if ( ! useDash ) {

					// cap extension
					worldPos.addAssign( vec4( positionGeometry.y.lessThan( 0.5 ).select( worldDir.mul( hw ).negate(), worldDir.mul( hw ) ), 0 ) );

					// add width to the box
					worldPos.addAssign( vec4( worldFwd.mul( hw ), 0 ) );

					// endcaps
					If( positionGeometry.y.greaterThan( 1.0 ).or( positionGeometry.y.lessThan( 0.0 ) ), () => {

						worldPos.subAssign( vec4( worldFwd.mul( 2.0 ).mul( hw ), 0 ) );

					} );

				}

				// project the worldpos
				clip.assign( cameraProjectionMatrix.mul( worldPos ) );

				// shift the depth of the projected points so the line
				// segments overlap neatly
				const clipPose = vec3().toVar();

				clipPose.assign( positionGeometry.y.lessThan( 0.5 ).select( ndcStart, ndcEnd ) );
				clip.z.assign( clipPose.z.mul( clip.w ) );

			} else {

				const offset = vec2( dir.y, dir.x.negate() ).toVar( 'offset' );

				// undo aspect ratio adjustment
				dir.x.assign( dir.x.div( aspect ) );
				offset.x.assign( offset.x.div( aspect ) );

				// sign flip
				offset.assign( positionGeometry.x.lessThan( 0.0 ).select( offset.negate(), offset ) );

				// endcaps
				If( positionGeometry.y.lessThan( 0.0 ), () => {

					offset.assign( offset.sub( dir ) );

				} ).ElseIf( positionGeometry.y.greaterThan( 1.0 ), () => {

					offset.assign( offset.add( dir ) );

				} );

				// adjust for linewidth
				offset.assign( offset.mul( materialLineWidth ) );

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset.assign( offset.div( viewport.w ) );

				// select end
				clip.assign( positionGeometry.y.lessThan( 0.5 ).select( clipStart, clipEnd ) );

				// back to clip space
				offset.assign( offset.mul( clip.w ) );

				clip.assign( clip.add( vec4( offset, 0, 0 ) ) );

			}

			return clip;

		} )();

		const closestLineToLine = Fn( ( { p1, p2, p3, p4 } ) => {

			const p13 = p1.sub( p3 );
			const p43 = p4.sub( p3 );

			const p21 = p2.sub( p1 );

			const d1343 = p13.dot( p43 );
			const d4321 = p43.dot( p21 );
			const d1321 = p13.dot( p21 );
			const d4343 = p43.dot( p43 );
			const d2121 = p21.dot( p21 );

			const denom = d2121.mul( d4343 ).sub( d4321.mul( d4321 ) );
			const numer = d1343.mul( d4321 ).sub( d1321.mul( d4343 ) );

			const mua = numer.div( denom ).clamp();
			const mub = d1343.add( d4321.mul( mua ) ).div( d4343 ).clamp();

			return vec2( mua, mub );

		} );

		this.colorNode = Fn( () => {

			const vUv = uv();

			if ( useDash ) {

				const dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;
				const gapSizeNode = this.dashSizeNode ? float( this.dashGapNode ) : materialLineGapSize;

				dashSize.assign( dashSizeNode );
				gapSize.assign( gapSizeNode );

				const vLineDistance = varyingProperty( 'float', 'lineDistance' );

				vUv.y.lessThan( - 1.0 ).or( vUv.y.greaterThan( 1.0 ) ).discard(); // discard endcaps
				vLineDistance.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard(); // todo - FIX

			}

			const alpha = float( 1 ).toVar( 'alpha' );

			if ( useWorldUnits ) {

				const worldStart = varyingProperty( 'vec3', 'worldStart' );
				const worldEnd = varyingProperty( 'vec3', 'worldEnd' );

				// Find the closest points on the view ray and the line segment
				const rayEnd = varyingProperty( 'vec4', 'worldPos' ).xyz.normalize().mul( 1e5 );
				const lineDir = worldEnd.sub( worldStart );
				const params = closestLineToLine( { p1: worldStart, p2: worldEnd, p3: vec3( 0.0, 0.0, 0.0 ), p4: rayEnd } );

				const p1 = worldStart.add( lineDir.mul( params.x ) );
				const p2 = rayEnd.mul( params.y );
				const delta = p1.sub( p2 );
				const len = delta.length();
				const norm = len.div( materialLineWidth );

				if ( ! useDash ) {

					if ( useAlphaToCoverage && renderer.samples > 1 ) {

						const dnorm = norm.fwidth();
						alpha.assign( smoothstep( dnorm.negate().add( 0.5 ), dnorm.add( 0.5 ), norm ).oneMinus() );

					} else {

						norm.greaterThan( 0.5 ).discard();

					}

				}

			} else {

				// round endcaps

				if ( useAlphaToCoverage && renderer.samples > 1 ) {

					const a = vUv.x;
					const b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );

					const len2 = a.mul( a ).add( b.mul( b ) );

					const dlen = float( len2.fwidth() ).toVar( 'dlen' );

					If( vUv.y.abs().greaterThan( 1.0 ), () => {

						alpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );

					} );

				} else {

					If( vUv.y.abs().greaterThan( 1.0 ), () => {

						const a = vUv.x;
						const b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );
						const len2 = a.mul( a ).add( b.mul( b ) );

						len2.greaterThan( 1.0 ).discard();

					} );

				}

			}

			let lineColorNode;

			if ( this.lineColorNode ) {

				lineColorNode = this.lineColorNode;

			} else {

				if ( useColor ) {

					const instanceColorStart = attribute( 'instanceColorStart' );
					const instanceColorEnd = attribute( 'instanceColorEnd' );

					const instanceColor = positionGeometry.y.lessThan( 0.5 ).select( instanceColorStart, instanceColorEnd );

					lineColorNode = instanceColor.mul( materialColor );

				} else {

					lineColorNode = materialColor;

				}

			}

			return vec4( lineColorNode, alpha );

		} )();

		if ( this.transparent ) {

			const opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;

			this.outputNode = vec4( this.colorNode.rgb.mul( opacityNode ).add( viewportSharedTexture().rgb.mul( opacityNode.oneMinus() ) ), this.colorNode.a );

		}

	}


	get worldUnits() {

		return this.useWorldUnits;

	}

	set worldUnits( value ) {

		if ( this.useWorldUnits !== value ) {

			this.useWorldUnits = value;
			this.needsUpdate = true;

		}

	}


	get dashed() {

		return this.useDash;

	}

	set dashed( value ) {

		if ( this.useDash !== value ) {

			this.useDash = value;
			this.needsUpdate = true;

		}

	}


	get alphaToCoverage() {

		return this.useAlphaToCoverage;

	}

	set alphaToCoverage( value ) {

		if ( this.useAlphaToCoverage !== value ) {

			this.useAlphaToCoverage = value;
			this.needsUpdate = true;

		}

	}

}

const directionToColor = ( node ) => nodeObject( node ).mul( 0.5 ).add( 0.5 );
const colorToDirection = ( node ) => nodeObject( node ).mul( 2.0 ).sub( 1 );

const _defaultValues$a = /*@__PURE__*/ new MeshNormalMaterial();

class MeshNormalNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshNormalNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.lights = false;

		this.isMeshNormalNodeMaterial = true;

		this.setDefaultValues( _defaultValues$a );

		this.setValues( parameters );

	}

	setupDiffuseColor() {

		const opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;

		diffuseColor.assign( vec4( directionToColor( transformedNormalView ), opacityNode ) );

	}

}

class EquirectUVNode extends TempNode {

	static get type() {

		return 'EquirectUVNode';

	}

	constructor( dirNode = positionWorldDirection ) {

		super( 'vec2' );

		this.dirNode = dirNode;

	}

	setup() {

		const dir = this.dirNode;

		const u = dir.z.atan2( dir.x ).mul( 1 / ( Math.PI * 2 ) ).add( 0.5 );
		const v = dir.y.clamp( - 1.0, 1.0 ).asin().mul( 1 / Math.PI ).add( 0.5 );

		return vec2( u, v );

	}

}

const equirectUV = /*@__PURE__*/ nodeProxy( EquirectUVNode );

// @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget

class CubeRenderTarget extends WebGLCubeRenderTarget {

	constructor( size = 1, options = {} ) {

		super( size, options );

		this.isCubeRenderTarget = true;

	}

	fromEquirectangularTexture( renderer, texture$1 ) {

		const currentMinFilter = texture$1.minFilter;
		const currentGenerateMipmaps = texture$1.generateMipmaps;

		texture$1.generateMipmaps = true;

		this.texture.type = texture$1.type;
		this.texture.colorSpace = texture$1.colorSpace;

		this.texture.generateMipmaps = texture$1.generateMipmaps;
		this.texture.minFilter = texture$1.minFilter;
		this.texture.magFilter = texture$1.magFilter;

		const geometry = new BoxGeometry( 5, 5, 5 );

		const uvNode = equirectUV( positionWorldDirection );

		const material = new NodeMaterial();
		material.colorNode = texture( texture$1, uvNode, 0 );
		material.side = BackSide;
		material.blending = NoBlending;

		const mesh = new Mesh( geometry, material );

		const scene = new Scene();
		scene.add( mesh );

		// Avoid blurred poles
		if ( texture$1.minFilter === LinearMipmapLinearFilter ) texture$1.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );

		const currentMRT = renderer.getMRT();
		renderer.setMRT( null );

		camera.update( renderer, scene );

		renderer.setMRT( currentMRT );

		texture$1.minFilter = currentMinFilter;
		texture$1.currentGenerateMipmaps = currentGenerateMipmaps;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

}

const _cache$1 = new WeakMap();

class CubeMapNode extends TempNode {

	static get type() {

		return 'CubeMapNode';

	}

	constructor( envNode ) {

		super( 'vec3' );

		this.envNode = envNode;

		this._cubeTexture = null;
		this._cubeTextureNode = cubeTexture();

		const defaultTexture = new CubeTexture();
		defaultTexture.isRenderTargetTexture = true;

		this._defaultTexture = defaultTexture;

		this.updateBeforeType = NodeUpdateType.RENDER;

	}

	updateBefore( frame ) {

		const { renderer, material } = frame;

		const envNode = this.envNode;

		if ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {

			const texture = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];

			if ( texture && texture.isTexture ) {

				const mapping = texture.mapping;

				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

					// check for converted cubemap map

					if ( _cache$1.has( texture ) ) {

						const cubeMap = _cache$1.get( texture );

						mapTextureMapping( cubeMap, texture.mapping );
						this._cubeTexture = cubeMap;

					} else {

						// create cube map from equirectangular map

						const image = texture.image;

						if ( isEquirectangularMapReady$1( image ) ) {

							const renderTarget = new CubeRenderTarget( image.height );
							renderTarget.fromEquirectangularTexture( renderer, texture );

							mapTextureMapping( renderTarget.texture, texture.mapping );
							this._cubeTexture = renderTarget.texture;

							_cache$1.set( texture, renderTarget.texture );

							texture.addEventListener( 'dispose', onTextureDispose );

						} else {

							// default cube texture as fallback when equirectangular texture is not yet loaded

							this._cubeTexture = this._defaultTexture;

						}

					}

					//

					this._cubeTextureNode.value = this._cubeTexture;

				} else {

					// envNode already refers to a cube map

					this._cubeTextureNode = this.envNode;

				}

			}

		}

	}

	setup( builder ) {

		this.updateBefore( builder );

		return this._cubeTextureNode;

	}

}

function isEquirectangularMapReady$1( image ) {

	if ( image === null || image === undefined ) return false;

	return image.height > 0;

}

function onTextureDispose( event ) {

	const texture = event.target;

	texture.removeEventListener( 'dispose', onTextureDispose );

	const renderTarget = _cache$1.get( texture );

	if ( renderTarget !== undefined ) {

		_cache$1.delete( texture );

		renderTarget.dispose();

	}

}

function mapTextureMapping( texture, mapping ) {

	if ( mapping === EquirectangularReflectionMapping ) {

		texture.mapping = CubeReflectionMapping;

	} else if ( mapping === EquirectangularRefractionMapping ) {

		texture.mapping = CubeRefractionMapping;

	}

}

const cubeMapNode = /*@__PURE__*/ nodeProxy( CubeMapNode );

class BasicEnvironmentNode extends LightingNode {

	static get type() {

		return 'BasicEnvironmentNode';

	}

	constructor( envNode = null ) {

		super();

		this.envNode = envNode;

	}

	setup( builder ) {

		// environment property is used in the finish() method of BasicLightingModel

		builder.context.environment = cubeMapNode( this.envNode );

	}

}

class BasicLightMapNode extends LightingNode {

	static get type() {

		return 'BasicLightMapNode';

	}

	constructor( lightMapNode = null ) {

		super();

		this.lightMapNode = lightMapNode;

	}

	setup( builder ) {

		// irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel

		const RECIPROCAL_PI = float( 1 / Math.PI );

		builder.context.irradianceLightMap = this.lightMapNode.mul( RECIPROCAL_PI );

	}

}

class LightingModel {

	start( /*input, stack, builder*/ ) { }

	finish( /*input, stack, builder*/ ) { }

	direct( /*input, stack, builder*/ ) { }

	directRectArea( /*input, stack, builder*/ ) {}

	indirect( /*input, stack, builder*/ ) { }

	ambientOcclusion( /*input, stack, builder*/ ) { }

}

class BasicLightingModel extends LightingModel {

	constructor() {

		super();

	}

	indirect( context, stack, builder ) {

		const ambientOcclusion = context.ambientOcclusion;
		const reflectedLight = context.reflectedLight;
		const irradianceLightMap = builder.context.irradianceLightMap;

		reflectedLight.indirectDiffuse.assign( vec4( 0.0 ) );

		// accumulation (baked indirect lighting only)

		if ( irradianceLightMap ) {

			reflectedLight.indirectDiffuse.addAssign( irradianceLightMap );

		} else {

			reflectedLight.indirectDiffuse.addAssign( vec4( 1.0, 1.0, 1.0, 0.0 ) );

		}

		// modulation

		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

		reflectedLight.indirectDiffuse.mulAssign( diffuseColor.rgb );

	}

	finish( context, stack, builder ) {

		const material = builder.material;
		const outgoingLight = context.outgoingLight;
		const envNode = builder.context.environment;

		if ( envNode ) {

			switch ( material.combine ) {

				case MultiplyOperation:
					outgoingLight.rgb.assign( mix( outgoingLight.rgb, outgoingLight.rgb.mul( envNode.rgb ), materialSpecularStrength.mul( materialReflectivity ) ) );
					break;

				case MixOperation:
					outgoingLight.rgb.assign( mix( outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul( materialReflectivity ) ) );
					break;

				case AddOperation:
					outgoingLight.rgb.addAssign( envNode.rgb.mul( materialSpecularStrength.mul( materialReflectivity ) ) );
					break;

				default:
					console.warn( 'THREE.BasicLightingModel: Unsupported .combine value:', material.combine );
					break;

			}

		}

	}

}

const _defaultValues$9 = /*@__PURE__*/ new MeshBasicMaterial();

class MeshBasicNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshBasicNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshBasicNodeMaterial = true;

		this.lights = true;

		this.setDefaultValues( _defaultValues$9 );

		this.setValues( parameters );

	}

	setupNormal() {

		return normalView; // see #28839

	}

	setupEnvironment( builder ) {

		const envNode = super.setupEnvironment( builder );

		return envNode ? new BasicEnvironmentNode( envNode ) : null;

	}

	setupLightMap( builder ) {

		let node = null;

		if ( builder.material.lightMap ) {

			node = new BasicLightMapNode( materialLightMap );

		}

		return node;

	}

	setupOutgoingLight() {

		return diffuseColor.rgb;

	}

	setupLightingModel() {

		return new BasicLightingModel();

	}

}

const F_Schlick = /*@__PURE__*/ Fn( ( { f0, f90, dotVH } ) => {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	const fresnel = dotVH.mul( - 5.55473 ).sub( 6.98316 ).mul( dotVH ).exp2();

	return f0.mul( fresnel.oneMinus() ).add( f90.mul( fresnel ) );

} ); // validated

const BRDF_Lambert = /*@__PURE__*/ Fn( ( inputs ) => {

	return inputs.diffuseColor.mul( 1 / Math.PI ); // punctual light

} ); // validated

const G_BlinnPhong_Implicit = () => float( 0.25 );

const D_BlinnPhong = /*@__PURE__*/ Fn( ( { dotNH } ) => {

	return shininess.mul( float( 0.5 ) ).add( 1.0 ).mul( float( 1 / Math.PI ) ).mul( dotNH.pow( shininess ) );

} );

const BRDF_BlinnPhong = /*@__PURE__*/ Fn( ( { lightDirection } ) => {

	const halfDir = lightDirection.add( positionViewDirection ).normalize();

	const dotNH = transformedNormalView.dot( halfDir ).clamp();
	const dotVH = positionViewDirection.dot( halfDir ).clamp();

	const F = F_Schlick( { f0: specularColor, f90: 1.0, dotVH } );
	const G = G_BlinnPhong_Implicit();
	const D = D_BlinnPhong( { dotNH } );

	return F.mul( G ).mul( D );

} );

class PhongLightingModel extends BasicLightingModel {

	constructor( specular = true ) {

		super();

		this.specular = specular;

	}

	direct( { lightDirection, lightColor, reflectedLight } ) {

		const dotNL = transformedNormalView.dot( lightDirection ).clamp();
		const irradiance = dotNL.mul( lightColor );

		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

		if ( this.specular === true ) {

			reflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_BlinnPhong( { lightDirection } ) ).mul( materialSpecularStrength ) );

		}

	}

	indirect( { ambientOcclusion, irradiance, reflectedLight } ) {

		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

	}

}

const _defaultValues$8 = /*@__PURE__*/ new MeshLambertMaterial();

class MeshLambertNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshLambertNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshLambertNodeMaterial = true;

		this.lights = true;

		this.setDefaultValues( _defaultValues$8 );

		this.setValues( parameters );

	}

	setupEnvironment( builder ) {

		const envNode = super.setupEnvironment( builder );

		return envNode ? new BasicEnvironmentNode( envNode ) : null;

	}

	setupLightingModel( /*builder*/ ) {

		return new PhongLightingModel( false ); // ( specular ) -> force lambert

	}

}

const _defaultValues$7 = /*@__PURE__*/ new MeshPhongMaterial();

class MeshPhongNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshPhongNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshPhongNodeMaterial = true;

		this.lights = true;

		this.shininessNode = null;
		this.specularNode = null;

		this.setDefaultValues( _defaultValues$7 );

		this.setValues( parameters );

	}

	setupEnvironment( builder ) {

		const envNode = super.setupEnvironment( builder );

		return envNode ? new BasicEnvironmentNode( envNode ) : null;

	}

	setupLightingModel( /*builder*/ ) {

		return new PhongLightingModel();

	}

	setupVariants() {

		// SHININESS

		const shininessNode = ( this.shininessNode ? float( this.shininessNode ) : materialShininess ).max( 1e-4 ); // to prevent pow( 0.0, 0.0 )

		shininess.assign( shininessNode );

		// SPECULAR COLOR

		const specularNode = this.specularNode || materialSpecular;

		specularColor.assign( specularNode );

	}

	copy( source ) {

		this.shininessNode = source.shininessNode;
		this.specularNode = source.specularNode;

		return super.copy( source );

	}

}

const getGeometryRoughness = /*@__PURE__*/ Fn( ( builder ) => {

	if ( builder.geometry.hasAttribute( 'normal' ) === false ) {

		return float( 0 );

	}

	const dxy = normalView.dFdx().abs().max( normalView.dFdy().abs() );
	const geometryRoughness = dxy.x.max( dxy.y ).max( dxy.z );

	return geometryRoughness;

} );

const getRoughness = /*@__PURE__*/ Fn( ( inputs ) => {

	const { roughness } = inputs;

	const geometryRoughness = getGeometryRoughness();

	let roughnessFactor = roughness.max( 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.
	roughnessFactor = roughnessFactor.add( geometryRoughness );
	roughnessFactor = roughnessFactor.min( 1.0 );

	return roughnessFactor;

} );

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
const V_GGX_SmithCorrelated = /*@__PURE__*/ Fn( ( { alpha, dotNL, dotNV } ) => {

	const a2 = alpha.pow2();

	const gv = dotNL.mul( a2.add( a2.oneMinus().mul( dotNV.pow2() ) ).sqrt() );
	const gl = dotNV.mul( a2.add( a2.oneMinus().mul( dotNL.pow2() ) ).sqrt() );

	return div( 0.5, gv.add( gl ).max( EPSILON ) );

} ).setLayout( {
	name: 'V_GGX_SmithCorrelated',
	type: 'float',
	inputs: [
		{ name: 'alpha', type: 'float' },
		{ name: 'dotNL', type: 'float' },
		{ name: 'dotNV', type: 'float' }
	]
} ); // validated

// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf

const V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } ) => {

	const gv = dotNL.mul( vec3( alphaT.mul( dotTV ), alphaB.mul( dotBV ), dotNV ).length() );
	const gl = dotNV.mul( vec3( alphaT.mul( dotTL ), alphaB.mul( dotBL ), dotNL ).length() );
	const v = div( 0.5, gv.add( gl ) );

	return v.saturate();

} ).setLayout( {
	name: 'V_GGX_SmithCorrelated_Anisotropic',
	type: 'float',
	inputs: [
		{ name: 'alphaT', type: 'float', qualifier: 'in' },
		{ name: 'alphaB', type: 'float', qualifier: 'in' },
		{ name: 'dotTV', type: 'float', qualifier: 'in' },
		{ name: 'dotBV', type: 'float', qualifier: 'in' },
		{ name: 'dotTL', type: 'float', qualifier: 'in' },
		{ name: 'dotBL', type: 'float', qualifier: 'in' },
		{ name: 'dotNV', type: 'float', qualifier: 'in' },
		{ name: 'dotNL', type: 'float', qualifier: 'in' }
	]
} );

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disneys reparameterization
const D_GGX = /*@__PURE__*/ Fn( ( { alpha, dotNH } ) => {

	const a2 = alpha.pow2();

	const denom = dotNH.pow2().mul( a2.oneMinus() ).oneMinus(); // avoid alpha = 0 with dotNH = 1

	return a2.div( denom.pow2() ).mul( 1 / Math.PI );

} ).setLayout( {
	name: 'D_GGX',
	type: 'float',
	inputs: [
		{ name: 'alpha', type: 'float' },
		{ name: 'dotNH', type: 'float' }
	]
} ); // validated

const RECIPROCAL_PI = /*@__PURE__*/ float( 1 / Math.PI );

// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf

const D_GGX_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotNH, dotTH, dotBH } ) => {

	const a2 = alphaT.mul( alphaB );
	const v = vec3( alphaB.mul( dotTH ), alphaT.mul( dotBH ), a2.mul( dotNH ) );
	const v2 = v.dot( v );
	const w2 = a2.div( v2 );

	return RECIPROCAL_PI.mul( a2.mul( w2.pow2() ) );

} ).setLayout( {
	name: 'D_GGX_Anisotropic',
	type: 'float',
	inputs: [
		{ name: 'alphaT', type: 'float', qualifier: 'in' },
		{ name: 'alphaB', type: 'float', qualifier: 'in' },
		{ name: 'dotNH', type: 'float', qualifier: 'in' },
		{ name: 'dotTH', type: 'float', qualifier: 'in' },
		{ name: 'dotBH', type: 'float', qualifier: 'in' }
	]
} );

// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
const BRDF_GGX = /*@__PURE__*/ Fn( ( inputs ) => {

	const { lightDirection, f0, f90, roughness, f, USE_IRIDESCENCE, USE_ANISOTROPY } = inputs;

	const normalView = inputs.normalView || transformedNormalView;

	const alpha = roughness.pow2(); // UE4's roughness

	const halfDir = lightDirection.add( positionViewDirection ).normalize();

	const dotNL = normalView.dot( lightDirection ).clamp();
	const dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV
	const dotNH = normalView.dot( halfDir ).clamp();
	const dotVH = positionViewDirection.dot( halfDir ).clamp();

	let F = F_Schlick( { f0, f90, dotVH } );
	let V, D;

	if ( defined( USE_IRIDESCENCE ) ) {

		F = iridescence.mix( F, f );

	}

	if ( defined( USE_ANISOTROPY ) ) {

		const dotTL = anisotropyT.dot( lightDirection );
		const dotTV = anisotropyT.dot( positionViewDirection );
		const dotTH = anisotropyT.dot( halfDir );
		const dotBL = anisotropyB.dot( lightDirection );
		const dotBV = anisotropyB.dot( positionViewDirection );
		const dotBH = anisotropyB.dot( halfDir );

		V = V_GGX_SmithCorrelated_Anisotropic( { alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } );
		D = D_GGX_Anisotropic( { alphaT, alphaB: alpha, dotNH, dotTH, dotBH } );

	} else {

		V = V_GGX_SmithCorrelated( { alpha, dotNL, dotNV } );
		D = D_GGX( { alpha, dotNH } );

	}

	return F.mul( V ).mul( D );

} ); // validated

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile
const DFGApprox = /*@__PURE__*/ Fn( ( { roughness, dotNV } ) => {

	const c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	const r = roughness.mul( c0 ).add( c1 );

	const a004 = r.x.mul( r.x ).min( dotNV.mul( - 9.28 ).exp2() ).mul( r.x ).add( r.y );

	const fab = vec2( - 1.04, 1.04 ).mul( a004 ).add( r.zw );

	return fab;

} ).setLayout( {
	name: 'DFGApprox',
	type: 'vec2',
	inputs: [
		{ name: 'roughness', type: 'float' },
		{ name: 'dotNV', type: 'vec3' }
	]
} );

const EnvironmentBRDF = /*@__PURE__*/ Fn( ( inputs ) => {

	const { dotNV, specularColor, specularF90, roughness } = inputs;

	const fab = DFGApprox( { dotNV, roughness } );
	return specularColor.mul( fab.x ).add( specularF90.mul( fab.y ) );

} );

const Schlick_to_F0 = /*@__PURE__*/ Fn( ( { f, f90, dotVH } ) => {

	const x = dotVH.oneMinus().saturate();
	const x2 = x.mul( x );
	const x5 = x.mul( x2, x2 ).clamp( 0, .9999 );

	return f.sub( vec3( f90 ).mul( x5 ) ).div( x5.oneMinus() );

} ).setLayout( {
	name: 'Schlick_to_F0',
	type: 'vec3',
	inputs: [
		{ name: 'f', type: 'vec3' },
		{ name: 'f90', type: 'float' },
		{ name: 'dotVH', type: 'float' }
	]
} );

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
const D_Charlie = /*@__PURE__*/ Fn( ( { roughness, dotNH } ) => {

	const alpha = roughness.pow2();

	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	const invAlpha = float( 1.0 ).div( alpha );
	const cos2h = dotNH.pow2();
	const sin2h = cos2h.oneMinus().max( 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16

	return float( 2.0 ).add( invAlpha ).mul( sin2h.pow( invAlpha.mul( 0.5 ) ) ).div( 2.0 * Math.PI );

} ).setLayout( {
	name: 'D_Charlie',
	type: 'float',
	inputs: [
		{ name: 'roughness', type: 'float' },
		{ name: 'dotNH', type: 'float' }
	]
} );

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
const V_Neubelt = /*@__PURE__*/ Fn( ( { dotNV, dotNL } ) => {

	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return float( 1.0 ).div( float( 4.0 ).mul( dotNL.add( dotNV ).sub( dotNL.mul( dotNV ) ) ) );

} ).setLayout( {
	name: 'V_Neubelt',
	type: 'float',
	inputs: [
		{ name: 'dotNV', type: 'float' },
		{ name: 'dotNL', type: 'float' }
	]
} );

const BRDF_Sheen = /*@__PURE__*/ Fn( ( { lightDirection } ) => {

	const halfDir = lightDirection.add( positionViewDirection ).normalize();

	const dotNL = transformedNormalView.dot( lightDirection ).clamp();
	const dotNV = transformedNormalView.dot( positionViewDirection ).clamp();
	const dotNH = transformedNormalView.dot( halfDir ).clamp();

	const D = D_Charlie( { roughness: sheenRoughness, dotNH } );
	const V = V_Neubelt( { dotNV, dotNL } );

	return sheen.mul( D ).mul( V );

} );

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

const LTC_Uv = /*@__PURE__*/ Fn( ( { N, V, roughness } ) => {

	const LUT_SIZE = 64.0;
	const LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const LUT_BIAS = 0.5 / LUT_SIZE;

	const dotNV = N.dot( V ).saturate();

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	const uv = vec2( roughness, dotNV.oneMinus().sqrt() );

	uv.assign( uv.mul( LUT_SCALE ).add( LUT_BIAS ) );

	return uv;

} ).setLayout( {
	name: 'LTC_Uv',
	type: 'vec2',
	inputs: [
		{ name: 'N', type: 'vec3' },
		{ name: 'V', type: 'vec3' },
		{ name: 'roughness', type: 'float' }
	]
} );

const LTC_ClippedSphereFormFactor = /*@__PURE__*/ Fn( ( { f } ) => {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	const l = f.length();

	return max$1( l.mul( l ).add( f.z ).div( l.add( 1.0 ) ), 0 );

} ).setLayout( {
	name: 'LTC_ClippedSphereFormFactor',
	type: 'float',
	inputs: [
		{ name: 'f', type: 'vec3' }
	]
} );

const LTC_EdgeVectorFormFactor = /*@__PURE__*/ Fn( ( { v1, v2 } ) => {

	const x = v1.dot( v2 );
	const y = x.abs().toVar();

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	const a = y.mul( 0.0145206 ).add( 0.4965155 ).mul( y ).add( 0.8543985 ).toVar();
	const b = y.add( 4.1616724 ).mul( y ).add( 3.4175940 ).toVar();
	const v = a.div( b );

	const theta_sintheta = x.greaterThan( 0.0 ).select( v, max$1( x.mul( x ).oneMinus(), 1e-7 ).inverseSqrt().mul( 0.5 ).sub( v ) );

	return v1.cross( v2 ).mul( theta_sintheta );

} ).setLayout( {
	name: 'LTC_EdgeVectorFormFactor',
	type: 'vec3',
	inputs: [
		{ name: 'v1', type: 'vec3' },
		{ name: 'v2', type: 'vec3' }
	]
} );

const LTC_Evaluate = /*@__PURE__*/ Fn( ( { N, V, P, mInv, p0, p1, p2, p3 } ) => {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	const v1 = p1.sub( p0 ).toVar();
	const v2 = p3.sub( p0 ).toVar();

	const lightNormal = v1.cross( v2 );
	const result = vec3().toVar();

	If( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {

		// construct orthonormal basis around N
		const T1 = V.sub( N.mul( V.dot( N ) ) ).normalize();
		const T2 = N.cross( T1 ).negate(); // negated from paper; possibly due to a different handedness of world coordinate system

		// compute transform
		const mat = mInv.mul( mat3( T1, T2, N ).transpose() ).toVar();

		// transform rect
		// & project rect onto sphere
		const coords0 = mat.mul( p0.sub( P ) ).normalize().toVar();
		const coords1 = mat.mul( p1.sub( P ) ).normalize().toVar();
		const coords2 = mat.mul( p2.sub( P ) ).normalize().toVar();
		const coords3 = mat.mul( p3.sub( P ) ).normalize().toVar();

		// calculate vector form factor
		const vectorFormFactor = vec3( 0 ).toVar();
		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );
		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );
		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );
		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );

		// adjust for horizon clipping
		result.assign( vec3( LTC_ClippedSphereFormFactor( { f: vectorFormFactor } ) ) );

	} );

	return result;

} ).setLayout( {
	name: 'LTC_Evaluate',
	type: 'vec3',
	inputs: [
		{ name: 'N', type: 'vec3' },
		{ name: 'V', type: 'vec3' },
		{ name: 'P', type: 'vec3' },
		{ name: 'mInv', type: 'mat3' },
		{ name: 'p0', type: 'vec3' },
		{ name: 'p1', type: 'vec3' },
		{ name: 'p2', type: 'vec3' },
		{ name: 'p3', type: 'vec3' }
	]
} );

// Mipped Bicubic Texture Filtering by N8
// https://www.shadertoy.com/view/Dl2SDW

const bC = 1.0 / 6.0;

const w0 = ( a ) => mul( bC, mul( a, mul( a, a.negate().add( 3.0 ) ).sub( 3.0 ) ).add( 1.0 ) );

const w1 = ( a ) => mul( bC, mul( a, mul( a, mul( 3.0, a ).sub( 6.0 ) ) ).add( 4.0 ) );

const w2 = ( a ) => mul( bC, mul( a, mul( a, mul( - 3.0, a ).add( 3.0 ) ).add( 3.0 ) ).add( 1.0 ) );

const w3 = ( a ) => mul( bC, pow( a, 3 ) );

const g0 = ( a ) => w0( a ).add( w1( a ) );

const g1 = ( a ) => w2( a ).add( w3( a ) );

// h0 and h1 are the two offset functions
const h0 = ( a ) => add( - 1.0, w1( a ).div( w0( a ).add( w1( a ) ) ) );

const h1 = ( a ) => add( 1.0, w3( a ).div( w2( a ).add( w3( a ) ) ) );

const bicubic = ( textureNode, texelSize, lod ) => {

	const uv = textureNode.uvNode;
	const uvScaled = mul( uv, texelSize.zw ).add( 0.5 );

	const iuv = floor( uvScaled );
	const fuv = fract( uvScaled );

	const g0x = g0( fuv.x );
	const g1x = g1( fuv.x );
	const h0x = h0( fuv.x );
	const h1x = h1( fuv.x );
	const h0y = h0( fuv.y );
	const h1y = h1( fuv.y );

	const p0 = vec2( iuv.x.add( h0x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );
	const p1 = vec2( iuv.x.add( h1x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );
	const p2 = vec2( iuv.x.add( h0x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );
	const p3 = vec2( iuv.x.add( h1x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );

	const a = g0( fuv.y ).mul( add( g0x.mul( textureNode.uv( p0 ).level( lod ) ), g1x.mul( textureNode.uv( p1 ).level( lod ) ) ) );
	const b = g1( fuv.y ).mul( add( g0x.mul( textureNode.uv( p2 ).level( lod ) ), g1x.mul( textureNode.uv( p3 ).level( lod ) ) ) );

	return a.add( b );

};

const textureBicubic = /*@__PURE__*/ Fn( ( [ textureNode, lodNode = float( 3 ) ] ) => {

	const fLodSize = vec2( textureNode.size( int( lodNode ) ) );
	const cLodSize = vec2( textureNode.size( int( lodNode.add( 1.0 ) ) ) );
	const fLodSizeInv = div( 1.0, fLodSize );
	const cLodSizeInv = div( 1.0, cLodSize );
	const fSample = bicubic( textureNode, vec4( fLodSizeInv, fLodSize ), floor( lodNode ) );
	const cSample = bicubic( textureNode, vec4( cLodSizeInv, cLodSize ), ceil( lodNode ) );

	return fract( lodNode ).mix( fSample, cSample );

} );

//
// Transmission
//

const getVolumeTransmissionRay = /*@__PURE__*/ Fn( ( [ n, v, thickness, ior, modelMatrix ] ) => {

	// Direction of refracted light.
	const refractionVector = vec3( refract( v.negate(), normalize( n ), div( 1.0, ior ) ) );

	// Compute rotation-independant scaling of the model matrix.
	const modelScale = vec3(
		length( modelMatrix[ 0 ].xyz ),
		length( modelMatrix[ 1 ].xyz ),
		length( modelMatrix[ 2 ].xyz )
	);

	// The thickness is specified in local space.
	return normalize( refractionVector ).mul( thickness.mul( modelScale ) );

} ).setLayout( {
	name: 'getVolumeTransmissionRay',
	type: 'vec3',
	inputs: [
		{ name: 'n', type: 'vec3' },
		{ name: 'v', type: 'vec3' },
		{ name: 'thickness', type: 'float' },
		{ name: 'ior', type: 'float' },
		{ name: 'modelMatrix', type: 'mat4' }
	]
} );

const applyIorToRoughness = /*@__PURE__*/ Fn( ( [ roughness, ior ] ) => {

	// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
	// an IOR of 1.5 results in the default amount of microfacet refraction.
	return roughness.mul( clamp( ior.mul( 2.0 ).sub( 2.0 ), 0.0, 1.0 ) );

} ).setLayout( {
	name: 'applyIorToRoughness',
	type: 'float',
	inputs: [
		{ name: 'roughness', type: 'float' },
		{ name: 'ior', type: 'float' }
	]
} );

const viewportBackSideTexture = /*@__PURE__*/ viewportMipTexture();
const viewportFrontSideTexture = /*@__PURE__*/ viewportMipTexture();

const getTransmissionSample = /*@__PURE__*/ Fn( ( [ fragCoord, roughness, ior ], { material } ) => {

	const vTexture = material.side == BackSide ? viewportBackSideTexture : viewportFrontSideTexture;

	const transmissionSample = vTexture.uv( fragCoord );
	//const transmissionSample = viewportMipTexture( fragCoord );

	const lod = log2( screenSize.x ).mul( applyIorToRoughness( roughness, ior ) );

	return textureBicubic( transmissionSample, lod );

} );

const volumeAttenuation = /*@__PURE__*/ Fn( ( [ transmissionDistance, attenuationColor, attenuationDistance ] ) => {

	If( attenuationDistance.notEqual( 0 ), () => {

		// Compute light attenuation using Beer's law.
		const attenuationCoefficient = log( attenuationColor ).negate().div( attenuationDistance );
		const transmittance = exp( attenuationCoefficient.negate().mul( transmissionDistance ) );

		return transmittance;

	} );

	// Attenuation distance is +, i.e. the transmitted color is not attenuated at all.
	return vec3( 1.0 );

} ).setLayout( {
	name: 'volumeAttenuation',
	type: 'vec3',
	inputs: [
		{ name: 'transmissionDistance', type: 'float' },
		{ name: 'attenuationColor', type: 'vec3' },
		{ name: 'attenuationDistance', type: 'float' }
	]
} );

const getIBLVolumeRefraction = /*@__PURE__*/ Fn( ( [ n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion ] ) => {

	let transmittedLight, transmittance;

	if ( dispersion ) {

		transmittedLight = vec4().toVar();
		transmittance = vec3().toVar();

		const halfSpread = ior.sub( 1.0 ).mul( dispersion.mul( 0.025 ) );
		const iors = vec3( ior.sub( halfSpread ), ior, ior.add( halfSpread ) );

		Loop( { start: 0, end: 3 }, ( { i } ) => {

			const ior = iors.element( i );

			const transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			const refractedRayExit = position.add( transmissionRay );

			// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
			const ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );
			const refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();
			refractionCoords.addAssign( 1.0 );
			refractionCoords.divAssign( 2.0 );
			refractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu

			// Sample framebuffer to get pixel the refracted ray hits.
			const transmissionSample = getTransmissionSample( refractionCoords, roughness, ior );

			transmittedLight.element( i ).assign( transmissionSample.element( i ) );
			transmittedLight.a.addAssign( transmissionSample.a );

			transmittance.element( i ).assign( diffuseColor.element( i ).mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ).element( i ) ) );

		} );

		transmittedLight.a.divAssign( 3.0 );

	} else {

		const transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		const refractedRayExit = position.add( transmissionRay );

		// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
		const ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );
		const refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();
		refractionCoords.addAssign( 1.0 );
		refractionCoords.divAssign( 2.0 );
		refractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu

		// Sample framebuffer to get pixel the refracted ray hits.
		transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		transmittance = diffuseColor.mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ) );

	}

	const attenuatedColor = transmittance.rgb.mul( transmittedLight.rgb );
	const dotNV = n.dot( v ).clamp();

	// Get the specular component.
	const F = vec3( EnvironmentBRDF( { // n, v, specularColor, specularF90, roughness
		dotNV,
		specularColor,
		specularF90,
		roughness
	} ) );

	// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job
	// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.
	const transmittanceFactor = transmittance.r.add( transmittance.g, transmittance.b ).div( 3.0 );

	return vec4( F.oneMinus().mul( attenuatedColor ), transmittedLight.a.oneMinus().mul( transmittanceFactor ).oneMinus() );

} );

//
// Iridescence
//

// XYZ to linear-sRGB color space
const XYZ_TO_REC709 = /*@__PURE__*/ mat3(
	3.2404542, - 0.9692660, 0.0556434,
	- 1.5371385, 1.8760108, - 0.2040259,
	- 0.4985314, 0.0415560, 1.0572252
);

// Assume air interface for top
// Note: We don't handle the case fresnel0 == 1
const Fresnel0ToIor = ( fresnel0 ) => {

	const sqrtF0 = fresnel0.sqrt();
	return vec3( 1.0 ).add( sqrtF0 ).div( vec3( 1.0 ).sub( sqrtF0 ) );

};

// ior is a value between 1.0 and 3.0. 1.0 is air interface
const IorToFresnel0 = ( transmittedIor, incidentIor ) => {

	return transmittedIor.sub( incidentIor ).div( transmittedIor.add( incidentIor ) ).pow2();

};

// Fresnel equations for dielectric/dielectric interfaces.
// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
// Evaluation XYZ sensitivity curves in Fourier space
const evalSensitivity = ( OPD, shift ) => {

	const phase = OPD.mul( 2.0 * Math.PI * 1.0e-9 );
	const val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
	const pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
	const VAR = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );

	const x = float( 9.7470e-14 * Math.sqrt( 2.0 * Math.PI * 4.5282e+09 ) ).mul( phase.mul( 2.2399e+06 ).add( shift.x ).cos() ).mul( phase.pow2().mul( - 4.5282e+09 ).exp() );

	let xyz = val.mul( VAR.mul( 2.0 * Math.PI ).sqrt() ).mul( pos.mul( phase ).add( shift ).cos() ).mul( phase.pow2().negate().mul( VAR ).exp() );
	xyz = vec3( xyz.x.add( x ), xyz.y, xyz.z ).div( 1.0685e-7 );

	const rgb = XYZ_TO_REC709.mul( xyz );

	return rgb;

};

const evalIridescence = /*@__PURE__*/ Fn( ( { outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 } ) => {

	// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0
	const iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
	// Evaluate the cosTheta on the base layer (Snell law)
	const sinTheta2Sq = outsideIOR.div( iridescenceIOR ).pow2().mul( cosTheta1.pow2().oneMinus() );

	// Handle TIR:
	const cosTheta2Sq = sinTheta2Sq.oneMinus();

	If( cosTheta2Sq.lessThan( 0 ), () => {

		return vec3( 1.0 );

	} );

	const cosTheta2 = cosTheta2Sq.sqrt();

	// First interface
	const R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
	const R12 = F_Schlick( { f0: R0, f90: 1.0, dotVH: cosTheta1 } );
	//const R21 = R12;
	const T121 = R12.oneMinus();
	const phi12 = iridescenceIOR.lessThan( outsideIOR ).select( Math.PI, 0.0 );
	const phi21 = float( Math.PI ).sub( phi12 );

	// Second interface
	const baseIOR = Fresnel0ToIor( baseF0.clamp( 0.0, 0.9999 ) ); // guard against 1.0
	const R1 = IorToFresnel0( baseIOR, iridescenceIOR.toVec3() );
	const R23 = F_Schlick( { f0: R1, f90: 1.0, dotVH: cosTheta2 } );
	const phi23 = vec3(
		baseIOR.x.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),
		baseIOR.y.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),
		baseIOR.z.lessThan( iridescenceIOR ).select( Math.PI, 0.0 )
	);

	// Phase shift
	const OPD = iridescenceIOR.mul( thinFilmThickness, cosTheta2, 2.0 );
	const phi = vec3( phi21 ).add( phi23 );

	// Compound terms
	const R123 = R12.mul( R23 ).clamp( 1e-5, 0.9999 );
	const r123 = R123.sqrt();
	const Rs = T121.pow2().mul( R23 ).div( vec3( 1.0 ).sub( R123 ) );

	// Reflectance term for m = 0 (DC term amplitude)
	const C0 = R12.add( Rs );
	const I = C0.toVar();

	// Reflectance term for m > 0 (pairs of diracs)
	const Cm = Rs.sub( T121 ).toVar();

	Loop( { start: 1, end: 2, condition: '<=', name: 'm' }, ( { m } ) => {

		Cm.mulAssign( r123 );
		const Sm = evalSensitivity( float( m ).mul( OPD ), float( m ).mul( phi ) ).mul( 2.0 );
		I.addAssign( Cm.mul( Sm ) );

	} );

	// Since out of gamut colors might be produced, negative color values are clamped to 0.
	return I.max( vec3( 0.0 ) );

} ).setLayout( {
	name: 'evalIridescence',
	type: 'vec3',
	inputs: [
		{ name: 'outsideIOR', type: 'float' },
		{ name: 'eta2', type: 'float' },
		{ name: 'cosTheta1', type: 'float' },
		{ name: 'thinFilmThickness', type: 'float' },
		{ name: 'baseF0', type: 'vec3' }
	]
} );

//
//	Sheen
//

// This is a curve-fit approxmation to the "Charlie sheen" BRDF integrated over the hemisphere from
// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
const IBLSheenBRDF = /*@__PURE__*/ Fn( ( { normal, viewDir, roughness } ) => {

	const dotNV = normal.dot( viewDir ).saturate();

	const r2 = roughness.pow2();

	const a = select(
		roughness.lessThan( 0.25 ),
		float( - 339.2 ).mul( r2 ).add( float( 161.4 ).mul( roughness ) ).sub( 25.9 ),
		float( - 8.48 ).mul( r2 ).add( float( 14.3 ).mul( roughness ) ).sub( 9.95 )
	);

	const b = select(
		roughness.lessThan( 0.25 ),
		float( 44.0 ).mul( r2 ).sub( float( 23.7 ).mul( roughness ) ).add( 3.26 ),
		float( 1.97 ).mul( r2 ).sub( float( 3.27 ).mul( roughness ) ).add( 0.72 )
	);

	const DG = select( roughness.lessThan( 0.25 ), 0.0, float( 0.1 ).mul( roughness ).sub( 0.025 ) ).add( a.mul( dotNV ).add( b ).exp() );

	return DG.mul( 1.0 / Math.PI ).saturate();

} );

const clearcoatF0 = vec3( 0.04 );
const clearcoatF90 = float( 1 );

//

class PhysicalLightingModel extends LightingModel {

	constructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false ) {

		super();

		this.clearcoat = clearcoat;
		this.sheen = sheen;
		this.iridescence = iridescence;
		this.anisotropy = anisotropy;
		this.transmission = transmission;
		this.dispersion = dispersion;

		this.clearcoatRadiance = null;
		this.clearcoatSpecularDirect = null;
		this.clearcoatSpecularIndirect = null;
		this.sheenSpecularDirect = null;
		this.sheenSpecularIndirect = null;
		this.iridescenceFresnel = null;
		this.iridescenceF0 = null;

	}

	start( context ) {

		if ( this.clearcoat === true ) {

			this.clearcoatRadiance = vec3().toVar( 'clearcoatRadiance' );
			this.clearcoatSpecularDirect = vec3().toVar( 'clearcoatSpecularDirect' );
			this.clearcoatSpecularIndirect = vec3().toVar( 'clearcoatSpecularIndirect' );

		}

		if ( this.sheen === true ) {

			this.sheenSpecularDirect = vec3().toVar( 'sheenSpecularDirect' );
			this.sheenSpecularIndirect = vec3().toVar( 'sheenSpecularIndirect' );

		}

		if ( this.iridescence === true ) {

			const dotNVi = transformedNormalView.dot( positionViewDirection ).clamp();

			this.iridescenceFresnel = evalIridescence( {
				outsideIOR: float( 1.0 ),
				eta2: iridescenceIOR,
				cosTheta1: dotNVi,
				thinFilmThickness: iridescenceThickness,
				baseF0: specularColor
			} );

			this.iridescenceF0 = Schlick_to_F0( { f: this.iridescenceFresnel, f90: 1.0, dotVH: dotNVi } );

		}

		if ( this.transmission === true ) {

			const position = positionWorld;
			const v = cameraPosition.sub( positionWorld ).normalize(); // TODO: Create Node for this, same issue in MaterialX
			const n = transformedNormalWorld;

			context.backdrop = getIBLVolumeRefraction(
				n,
				v,
				roughness,
				diffuseColor,
				specularColor,
				specularF90, // specularF90
				position, // positionWorld
				modelWorldMatrix, // modelMatrix
				cameraViewMatrix, // viewMatrix
				cameraProjectionMatrix, // projMatrix
				ior,
				thickness,
				attenuationColor,
				attenuationDistance,
				this.dispersion ? dispersion : null
			);

			context.backdropAlpha = transmission;

			diffuseColor.a.mulAssign( mix( 1, context.backdrop.a, transmission ) );

		}

	}

	// Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
	// Approximates multiscattering in order to preserve energy.
	// http://www.jcgt.org/published/0008/01/03/

	computeMultiscattering( singleScatter, multiScatter, specularF90 ) {

		const dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV

		const fab = DFGApprox( { roughness, dotNV } );

		const Fr = this.iridescenceF0 ? iridescence.mix( specularColor, this.iridescenceF0 ) : specularColor;

		const FssEss = Fr.mul( fab.x ).add( specularF90.mul( fab.y ) );

		const Ess = fab.x.add( fab.y );
		const Ems = Ess.oneMinus();

		const Favg = specularColor.add( specularColor.oneMinus().mul( 0.047619 ) ); // 1/21
		const Fms = FssEss.mul( Favg ).div( Ems.mul( Favg ).oneMinus() );

		singleScatter.addAssign( FssEss );
		multiScatter.addAssign( Fms.mul( Ems ) );

	}

	direct( { lightDirection, lightColor, reflectedLight } ) {

		const dotNL = transformedNormalView.dot( lightDirection ).clamp();
		const irradiance = dotNL.mul( lightColor );

		if ( this.sheen === true ) {

			this.sheenSpecularDirect.addAssign( irradiance.mul( BRDF_Sheen( { lightDirection } ) ) );

		}

		if ( this.clearcoat === true ) {

			const dotNLcc = transformedClearcoatNormalView.dot( lightDirection ).clamp();
			const ccIrradiance = dotNLcc.mul( lightColor );

			this.clearcoatSpecularDirect.addAssign( ccIrradiance.mul( BRDF_GGX( { lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView } ) ) );

		}

		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

		reflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_GGX( { lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy } ) ) );

	}

	directRectArea( { lightColor, lightPosition, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 } ) {

		const p0 = lightPosition.add( halfWidth ).sub( halfHeight ); // counterclockwise; light shines in local neg z direction
		const p1 = lightPosition.sub( halfWidth ).sub( halfHeight );
		const p2 = lightPosition.sub( halfWidth ).add( halfHeight );
		const p3 = lightPosition.add( halfWidth ).add( halfHeight );

		const N = transformedNormalView;
		const V = positionViewDirection;
		const P = positionView.toVar();

		const uv = LTC_Uv( { N, V, roughness } );

		const t1 = ltc_1.uv( uv ).toVar();
		const t2 = ltc_2.uv( uv ).toVar();

		const mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3( 0, 1, 0 ),
			vec3( t1.z, 0, t1.w )
		).toVar();

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		const fresnel = specularColor.mul( t2.x ).add( specularColor.oneMinus().mul( t2.y ) ).toVar();

		reflectedLight.directSpecular.addAssign( lightColor.mul( fresnel ).mul( LTC_Evaluate( { N, V, P, mInv, p0, p1, p2, p3 } ) ) );

		reflectedLight.directDiffuse.addAssign( lightColor.mul( diffuseColor ).mul( LTC_Evaluate( { N, V, P, mInv: mat3( 1, 0, 0, 0, 1, 0, 0, 0, 1 ), p0, p1, p2, p3 } ) ) );

	}

	indirect( context, stack, builder ) {

		this.indirectDiffuse( context, stack, builder );
		this.indirectSpecular( context, stack, builder );
		this.ambientOcclusion( context, stack, builder );

	}

	indirectDiffuse( { irradiance, reflectedLight } ) {

		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

	}

	indirectSpecular( { radiance, iblIrradiance, reflectedLight } ) {

		if ( this.sheen === true ) {

			this.sheenSpecularIndirect.addAssign( iblIrradiance.mul(
				sheen,
				IBLSheenBRDF( {
					normal: transformedNormalView,
					viewDir: positionViewDirection,
					roughness: sheenRoughness
				} )
			) );

		}

		if ( this.clearcoat === true ) {

			const dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();

			const clearcoatEnv = EnvironmentBRDF( {
				dotNV: dotNVcc,
				specularColor: clearcoatF0,
				specularF90: clearcoatF90,
				roughness: clearcoatRoughness
			} );

			this.clearcoatSpecularIndirect.addAssign( this.clearcoatRadiance.mul( clearcoatEnv ) );

		}

		// Both indirect specular and indirect diffuse light accumulate here

		const singleScattering = vec3().toVar( 'singleScattering' );
		const multiScattering = vec3().toVar( 'multiScattering' );
		const cosineWeightedIrradiance = iblIrradiance.mul( 1 / Math.PI );

		this.computeMultiscattering( singleScattering, multiScattering, specularF90 );

		const totalScattering = singleScattering.add( multiScattering );

		const diffuse = diffuseColor.mul( totalScattering.r.max( totalScattering.g ).max( totalScattering.b ).oneMinus() );

		reflectedLight.indirectSpecular.addAssign( radiance.mul( singleScattering ) );
		reflectedLight.indirectSpecular.addAssign( multiScattering.mul( cosineWeightedIrradiance ) );

		reflectedLight.indirectDiffuse.addAssign( diffuse.mul( cosineWeightedIrradiance ) );

	}

	ambientOcclusion( { ambientOcclusion, reflectedLight } ) {

		const dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV

		const aoNV = dotNV.add( ambientOcclusion );
		const aoExp = roughness.mul( - 16.0 ).oneMinus().negate().exp2();

		const aoNode = ambientOcclusion.sub( aoNV.pow( aoExp ).oneMinus() ).clamp();

		if ( this.clearcoat === true ) {

			this.clearcoatSpecularIndirect.mulAssign( ambientOcclusion );

		}

		if ( this.sheen === true ) {

			this.sheenSpecularIndirect.mulAssign( ambientOcclusion );

		}

		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );
		reflectedLight.indirectSpecular.mulAssign( aoNode );

	}

	finish( context ) {

		const { outgoingLight } = context;

		if ( this.clearcoat === true ) {

			const dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();

			const Fcc = F_Schlick( {
				dotVH: dotNVcc,
				f0: clearcoatF0,
				f90: clearcoatF90
			} );

			const clearcoatLight = outgoingLight.mul( clearcoat.mul( Fcc ).oneMinus() ).add( this.clearcoatSpecularDirect.add( this.clearcoatSpecularIndirect ).mul( clearcoat ) );

			outgoingLight.assign( clearcoatLight );

		}

		if ( this.sheen === true ) {

			const sheenEnergyComp = sheen.r.max( sheen.g ).max( sheen.b ).mul( 0.157 ).oneMinus();
			const sheenLight = outgoingLight.mul( sheenEnergyComp ).add( this.sheenSpecularDirect, this.sheenSpecularIndirect );

			outgoingLight.assign( sheenLight );

		}

	}

}

// These defines must match with PMREMGenerator

const cubeUV_r0 = /*@__PURE__*/ float( 1.0 );
const cubeUV_m0 = /*@__PURE__*/ float( - 2.0 );
const cubeUV_r1 = /*@__PURE__*/ float( 0.8 );
const cubeUV_m1 = /*@__PURE__*/ float( - 1.0 );
const cubeUV_r4 = /*@__PURE__*/ float( 0.4 );
const cubeUV_m4 = /*@__PURE__*/ float( 2.0 );
const cubeUV_r5 = /*@__PURE__*/ float( 0.305 );
const cubeUV_m5 = /*@__PURE__*/ float( 3.0 );
const cubeUV_r6 = /*@__PURE__*/ float( 0.21 );
const cubeUV_m6 = /*@__PURE__*/ float( 4.0 );

const cubeUV_minMipLevel = /*@__PURE__*/ float( 4.0 );
const cubeUV_minTileSize = /*@__PURE__*/ float( 16.0 );

// These shader functions convert between the UV coordinates of a single face of
// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
// sampling a textureCube (not generally normalized ).

const getFace = /*@__PURE__*/ Fn( ( [ direction ] ) => {

	const absDirection = vec3( abs( direction ) ).toVar();
	const face = float( - 1.0 ).toVar();

	If( absDirection.x.greaterThan( absDirection.z ), () => {

		If( absDirection.x.greaterThan( absDirection.y ), () => {

			face.assign( select( direction.x.greaterThan( 0.0 ), 0.0, 3.0 ) );

		} ).Else( () => {

			face.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );

		} );

	} ).Else( () => {

		If( absDirection.z.greaterThan( absDirection.y ), () => {

			face.assign( select( direction.z.greaterThan( 0.0 ), 2.0, 5.0 ) );

		} ).Else( () => {

			face.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );

		} );

	} );

	return face;

} ).setLayout( {
	name: 'getFace',
	type: 'float',
	inputs: [
		{ name: 'direction', type: 'vec3' }
	]
} );

// RH coordinate system; PMREM face-indexing convention
const getUV = /*@__PURE__*/ Fn( ( [ direction, face ] ) => {

	const uv = vec2().toVar();

	If( face.equal( 0.0 ), () => {

		uv.assign( vec2( direction.z, direction.y ).div( abs( direction.x ) ) ); // pos x

	} ).ElseIf( face.equal( 1.0 ), () => {

		uv.assign( vec2( direction.x.negate(), direction.z.negate() ).div( abs( direction.y ) ) ); // pos y

	} ).ElseIf( face.equal( 2.0 ), () => {

		uv.assign( vec2( direction.x.negate(), direction.y ).div( abs( direction.z ) ) ); // pos z

	} ).ElseIf( face.equal( 3.0 ), () => {

		uv.assign( vec2( direction.z.negate(), direction.y ).div( abs( direction.x ) ) ); // neg x

	} ).ElseIf( face.equal( 4.0 ), () => {

		uv.assign( vec2( direction.x.negate(), direction.z ).div( abs( direction.y ) ) ); // neg y

	} ).Else( () => {

		uv.assign( vec2( direction.x, direction.y ).div( abs( direction.z ) ) ); // neg z

	} );

	return mul( 0.5, uv.add( 1.0 ) );

} ).setLayout( {
	name: 'getUV',
	type: 'vec2',
	inputs: [
		{ name: 'direction', type: 'vec3' },
		{ name: 'face', type: 'float' }
	]
} );

const roughnessToMip = /*@__PURE__*/ Fn( ( [ roughness ] ) => {

	const mip = float( 0.0 ).toVar();

	If( roughness.greaterThanEqual( cubeUV_r1 ), () => {

		mip.assign( cubeUV_r0.sub( roughness ).mul( cubeUV_m1.sub( cubeUV_m0 ) ).div( cubeUV_r0.sub( cubeUV_r1 ) ).add( cubeUV_m0 ) );

	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r4 ), () => {

		mip.assign( cubeUV_r1.sub( roughness ).mul( cubeUV_m4.sub( cubeUV_m1 ) ).div( cubeUV_r1.sub( cubeUV_r4 ) ).add( cubeUV_m1 ) );

	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r5 ), () => {

		mip.assign( cubeUV_r4.sub( roughness ).mul( cubeUV_m5.sub( cubeUV_m4 ) ).div( cubeUV_r4.sub( cubeUV_r5 ) ).add( cubeUV_m4 ) );

	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r6 ), () => {

		mip.assign( cubeUV_r5.sub( roughness ).mul( cubeUV_m6.sub( cubeUV_m5 ) ).div( cubeUV_r5.sub( cubeUV_r6 ) ).add( cubeUV_m5 ) );

	} ).Else( () => {

		mip.assign( float( - 2.0 ).mul( log2( mul( 1.16, roughness ) ) ) ); // 1.16 = 1.79^0.25

	} );

	return mip;

} ).setLayout( {
	name: 'roughnessToMip',
	type: 'float',
	inputs: [
		{ name: 'roughness', type: 'float' }
	]
} );

// RH coordinate system; PMREM face-indexing convention
const getDirection = /*@__PURE__*/ Fn( ( [ uv_immutable, face ] ) => {

	const uv = uv_immutable.toVar();
	uv.assign( mul( 2.0, uv ).sub( 1.0 ) );
	const direction = vec3( uv, 1.0 ).toVar();

	If( face.equal( 0.0 ), () => {

		direction.assign( direction.zyx ); // ( 1, v, u ) pos x

	} ).ElseIf( face.equal( 1.0 ), () => {

		direction.assign( direction.xzy );
		direction.xz.mulAssign( - 1.0 ); // ( -u, 1, -v ) pos y

	} ).ElseIf( face.equal( 2.0 ), () => {

		direction.x.mulAssign( - 1.0 ); // ( -u, v, 1 ) pos z

	} ).ElseIf( face.equal( 3.0 ), () => {

		direction.assign( direction.zyx );
		direction.xz.mulAssign( - 1.0 ); // ( -1, v, -u ) neg x

	} ).ElseIf( face.equal( 4.0 ), () => {

		direction.assign( direction.xzy );
		direction.xy.mulAssign( - 1.0 ); // ( -u, -1, v ) neg y

	} ).ElseIf( face.equal( 5.0 ), () => {

		direction.z.mulAssign( - 1.0 ); // ( u, v, -1 ) neg zS

	} );

	return direction;

} ).setLayout( {
	name: 'getDirection',
	type: 'vec3',
	inputs: [
		{ name: 'uv', type: 'vec2' },
		{ name: 'face', type: 'float' }
	]
} );

//

const textureCubeUV = /*@__PURE__*/ Fn( ( [ envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {

	const roughness = float( roughness_immutable );
	const sampleDir = vec3( sampleDir_immutable );

	const mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
	const mipF = fract( mip );
	const mipInt = floor( mip );
	const color0 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();

	If( mipF.notEqual( 0.0 ), () => {

		const color1 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt.add( 1.0 ), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();

		color0.assign( mix( color0, color1, mipF ) );

	} );

	return color0;

} );

const bilinearCubeUV = /*@__PURE__*/ Fn( ( [ envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {

	const mipInt = float( mipInt_immutable ).toVar();
	const direction = vec3( direction_immutable );
	const face = float( getFace( direction ) ).toVar();
	const filterInt = float( max$1( cubeUV_minMipLevel.sub( mipInt ), 0.0 ) ).toVar();
	mipInt.assign( max$1( mipInt, cubeUV_minMipLevel ) );
	const faceSize = float( exp2( mipInt ) ).toVar();
	const uv = vec2( getUV( direction, face ).mul( faceSize.sub( 2.0 ) ).add( 1.0 ) ).toVar();

	If( face.greaterThan( 2.0 ), () => {

		uv.y.addAssign( faceSize );
		face.subAssign( 3.0 );

	} );

	uv.x.addAssign( face.mul( faceSize ) );
	uv.x.addAssign( filterInt.mul( mul( 3.0, cubeUV_minTileSize ) ) );
	uv.y.addAssign( mul( 4.0, exp2( CUBEUV_MAX_MIP ).sub( faceSize ) ) );
	uv.x.mulAssign( CUBEUV_TEXEL_WIDTH );
	uv.y.mulAssign( CUBEUV_TEXEL_HEIGHT );

	return envMap.uv( uv ).grad( vec2(), vec2() ); // disable anisotropic filtering

} );

const getSample = /*@__PURE__*/ Fn( ( { envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {

	const cosTheta = cos( theta );

	// Rodrigues' axis-angle rotation
	const sampleDirection = outputDirection.mul( cosTheta )
		.add( axis.cross( outputDirection ).mul( sin( theta ) ) )
		.add( axis.mul( axis.dot( outputDirection ).mul( cosTheta.oneMinus() ) ) );

	return bilinearCubeUV( envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );

} );

const blur = /*@__PURE__*/ Fn( ( { n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {

	const axis = vec3( select( latitudinal, poleAxis, cross( poleAxis, outputDirection ) ) ).toVar();

	If( all( axis.equals( vec3( 0.0 ) ) ), () => {

		axis.assign( vec3( outputDirection.z, 0.0, outputDirection.x.negate() ) );

	} );

	axis.assign( normalize( axis ) );

	const gl_FragColor = vec3().toVar();
	gl_FragColor.addAssign( weights.element( int( 0 ) ).mul( getSample( { theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );

	Loop( { start: int( 1 ), end: n }, ( { i } ) => {

		If( i.greaterThanEqual( samples ), () => {

			Break();

		} );

		const theta = float( dTheta.mul( float( i ) ) ).toVar();
		gl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta: theta.mul( - 1.0 ), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );
		gl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );

	} );

	return vec4( gl_FragColor, 1 );

} );

let _generator = null;

const _cache = new WeakMap();

function _generateCubeUVSize( imageHeight ) {

	const maxMip = Math.log2( imageHeight ) - 2;

	const texelHeight = 1.0 / imageHeight;

	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

	return { texelWidth, texelHeight, maxMip };

}

function _getPMREMFromTexture( texture ) {

	let cacheTexture = _cache.get( texture );

	const pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : - 1;

	if ( pmremVersion !== texture.pmremVersion ) {

		const image = texture.image;

		if ( texture.isCubeTexture ) {

			if ( isCubeMapReady( image ) ) {

				cacheTexture = _generator.fromCubemap( texture, cacheTexture );

			} else {

				return null;

			}


		} else {

			if ( isEquirectangularMapReady( image ) ) {

				cacheTexture = _generator.fromEquirectangular( texture, cacheTexture );

			} else {

				return null;

			}

		}

		cacheTexture.pmremVersion = texture.pmremVersion;

		_cache.set( texture, cacheTexture );

	}

	return cacheTexture.texture;

}

class PMREMNode extends TempNode {

	static get type() {

		return 'PMREMNode';

	}

	constructor( value, uvNode = null, levelNode = null ) {

		super( 'vec3' );

		this._value = value;
		this._pmrem = null;

		this.uvNode = uvNode;
		this.levelNode = levelNode;

		this._generator = null;

		const defaultTexture = new Texture();
		defaultTexture.isRenderTargetTexture = true;

		this._texture = texture( defaultTexture );

		this._width = uniform( 0 );
		this._height = uniform( 0 );
		this._maxMip = uniform( 0 );

		this.updateBeforeType = NodeUpdateType.RENDER;

	}

	set value( value ) {

		this._value = value;
		this._pmrem = null;

	}

	get value() {

		return this._value;

	}

	updateFromTexture( texture ) {

		const cubeUVSize = _generateCubeUVSize( texture.image.height );

		this._texture.value = texture;
		this._width.value = cubeUVSize.texelWidth;
		this._height.value = cubeUVSize.texelHeight;
		this._maxMip.value = cubeUVSize.maxMip;

	}

	updateBefore() {

		let pmrem = this._pmrem;

		const pmremVersion = pmrem ? pmrem.pmremVersion : - 1;
		const texture = this._value;

		if ( pmremVersion !== texture.pmremVersion ) {

			if ( texture.isPMREMTexture === true ) {

				pmrem = texture;

			} else {

				pmrem = _getPMREMFromTexture( texture );

			}

			if ( pmrem !== null ) {

				this._pmrem = pmrem;

				this.updateFromTexture( pmrem );

			}

		}

	}

	setup( builder ) {

		if ( _generator === null ) {

			_generator = builder.createPMREMGenerator();

		}

		//

		this.updateBefore( builder );

		//

		let uvNode = this.uvNode;

		if ( uvNode === null && builder.context.getUV ) {

			uvNode = builder.context.getUV( this );

		}

		//

		const texture = this.value;

		if ( builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture.isPMREMTexture !== true && texture.isRenderTargetTexture === true ) {

			uvNode = vec3( uvNode.x.negate(), uvNode.yz );

		}

		//

		let levelNode = this.levelNode;

		if ( levelNode === null && builder.context.getTextureLevel ) {

			levelNode = builder.context.getTextureLevel( this );

		}

		//

		return textureCubeUV( this._texture, uvNode, levelNode, this._width, this._height, this._maxMip );

	}

}

function isCubeMapReady( image ) {

	if ( image === null || image === undefined ) return false;

	let count = 0;
	const length = 6;

	for ( let i = 0; i < length; i ++ ) {

		if ( image[ i ] !== undefined ) count ++;

	}

	return count === length;


}

function isEquirectangularMapReady( image ) {

	if ( image === null || image === undefined ) return false;

	return image.height > 0;

}

const pmremTexture = /*@__PURE__*/ nodeProxy( PMREMNode );

const _envNodeCache = new WeakMap();

class EnvironmentNode extends LightingNode {

	static get type() {

		return 'EnvironmentNode';

	}

	constructor( envNode = null ) {

		super();

		this.envNode = envNode;

	}

	setup( builder ) {

		const { material } = builder;

		let envNode = this.envNode;

		if ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {

			const value = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];

			let cacheEnvNode = _envNodeCache.get( value );

			if ( cacheEnvNode === undefined ) {

				cacheEnvNode = pmremTexture( value );

				_envNodeCache.set( value, cacheEnvNode );

			}

			envNode	= cacheEnvNode;

		}

		//

		const envMap = material.envMap;
		const intensity = envMap ? reference( 'envMapIntensity', 'float', builder.material ) : reference( 'environmentIntensity', 'float', builder.scene ); // @TODO: Add materialEnvIntensity in MaterialNode

		const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;
		const radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;

		const radiance = envNode.context( createRadianceContext( roughness, radianceNormalView ) ).mul( intensity );
		const irradiance = envNode.context( createIrradianceContext( transformedNormalWorld ) ).mul( Math.PI ).mul( intensity );

		const isolateRadiance = cache( radiance );
		const isolateIrradiance = cache( irradiance );

		//

		builder.context.radiance.addAssign( isolateRadiance );

		builder.context.iblIrradiance.addAssign( isolateIrradiance );

		//

		const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;

		if ( clearcoatRadiance ) {

			const clearcoatRadianceContext = envNode.context( createRadianceContext( clearcoatRoughness, transformedClearcoatNormalView ) ).mul( intensity );
			const isolateClearcoatRadiance = cache( clearcoatRadianceContext );

			clearcoatRadiance.addAssign( isolateClearcoatRadiance );

		}

	}

}

const createRadianceContext = ( roughnessNode, normalViewNode ) => {

	let reflectVec = null;

	return {
		getUV: () => {

			if ( reflectVec === null ) {

				reflectVec = positionViewDirection.negate().reflect( normalViewNode );

				// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
				reflectVec = roughnessNode.mul( roughnessNode ).mix( reflectVec, normalViewNode ).normalize();

				reflectVec = reflectVec.transformDirection( cameraViewMatrix );

			}

			return reflectVec;

		},
		getTextureLevel: () => {

			return roughnessNode;

		}
	};

};

const createIrradianceContext = ( normalWorldNode ) => {

	return {
		getUV: () => {

			return normalWorldNode;

		},
		getTextureLevel: () => {

			return float( 1.0 );

		}
	};

};

const _defaultValues$6 = /*@__PURE__*/ new MeshStandardMaterial();

class MeshStandardNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshStandardNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshStandardNodeMaterial = true;

		this.lights = true;

		this.emissiveNode = null;

		this.metalnessNode = null;
		this.roughnessNode = null;

		this.setDefaultValues( _defaultValues$6 );

		this.setValues( parameters );

	}

	setupEnvironment( builder ) {

		let envNode = super.setupEnvironment( builder );

		if ( envNode === null && builder.environmentNode ) {

			envNode = builder.environmentNode;

		}

		return envNode ? new EnvironmentNode( envNode ) : null;

	}

	setupLightingModel( /*builder*/ ) {

		return new PhysicalLightingModel();

	}

	setupSpecular() {

		const specularColorNode = mix( vec3( 0.04 ), diffuseColor.rgb, metalness );

		specularColor.assign( specularColorNode );
		specularF90.assign( 1.0 );

	}

	setupVariants() {

		// METALNESS

		const metalnessNode = this.metalnessNode ? float( this.metalnessNode ) : materialMetalness;

		metalness.assign( metalnessNode );

		// ROUGHNESS

		let roughnessNode = this.roughnessNode ? float( this.roughnessNode ) : materialRoughness;
		roughnessNode = getRoughness( { roughness: roughnessNode } );

		roughness.assign( roughnessNode );

		// SPECULAR COLOR

		this.setupSpecular();

		// DIFFUSE COLOR

		diffuseColor.assign( vec4( diffuseColor.rgb.mul( metalnessNode.oneMinus() ), diffuseColor.a ) );

	}

	copy( source ) {

		this.emissiveNode = source.emissiveNode;

		this.metalnessNode = source.metalnessNode;
		this.roughnessNode = source.roughnessNode;

		return super.copy( source );

	}

}

const _defaultValues$5 = /*@__PURE__*/ new MeshPhysicalMaterial();

class MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {

	static get type() {

		return 'MeshPhysicalNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshPhysicalNodeMaterial = true;

		this.clearcoatNode = null;
		this.clearcoatRoughnessNode = null;
		this.clearcoatNormalNode = null;

		this.sheenNode = null;
		this.sheenRoughnessNode = null;

		this.iridescenceNode = null;
		this.iridescenceIORNode = null;
		this.iridescenceThicknessNode = null;

		this.specularIntensityNode = null;
		this.specularColorNode = null;

		this.iorNode = null;
		this.transmissionNode = null;
		this.thicknessNode = null;
		this.attenuationDistanceNode = null;
		this.attenuationColorNode = null;
		this.dispersionNode = null;

		this.anisotropyNode = null;

		this.setDefaultValues( _defaultValues$5 );

		this.setValues( parameters );

	}

	get useClearcoat() {

		return this.clearcoat > 0 || this.clearcoatNode !== null;

	}

	get useIridescence() {

		return this.iridescence > 0 || this.iridescenceNode !== null;

	}

	get useSheen() {

		return this.sheen > 0 || this.sheenNode !== null;

	}

	get useAnisotropy() {

		return this.anisotropy > 0 || this.anisotropyNode !== null;

	}

	get useTransmission() {

		return this.transmission > 0 || this.transmissionNode !== null;

	}

	get useDispersion() {

		return this.dispersion > 0 || this.dispersionNode !== null;

	}

	setupSpecular() {

		const iorNode = this.iorNode ? float( this.iorNode ) : materialIOR;

		ior.assign( iorNode );
		specularColor.assign( mix( min$1( pow2( ior.sub( 1.0 ).div( ior.add( 1.0 ) ) ).mul( materialSpecularColor ), vec3( 1.0 ) ).mul( materialSpecularIntensity ), diffuseColor.rgb, metalness ) );
		specularF90.assign( mix( materialSpecularIntensity, 1.0, metalness ) );

	}

	setupLightingModel( /*builder*/ ) {

		return new PhysicalLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion );

	}

	setupVariants( builder ) {

		super.setupVariants( builder );

		// CLEARCOAT

		if ( this.useClearcoat ) {

			const clearcoatNode = this.clearcoatNode ? float( this.clearcoatNode ) : materialClearcoat;
			const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float( this.clearcoatRoughnessNode ) : materialClearcoatRoughness;

			clearcoat.assign( clearcoatNode );
			clearcoatRoughness.assign( getRoughness( { roughness: clearcoatRoughnessNode } ) );

		}

		// SHEEN

		if ( this.useSheen ) {

			const sheenNode = this.sheenNode ? vec3( this.sheenNode ) : materialSheen;
			const sheenRoughnessNode = this.sheenRoughnessNode ? float( this.sheenRoughnessNode ) : materialSheenRoughness;

			sheen.assign( sheenNode );
			sheenRoughness.assign( sheenRoughnessNode );

		}

		// IRIDESCENCE

		if ( this.useIridescence ) {

			const iridescenceNode = this.iridescenceNode ? float( this.iridescenceNode ) : materialIridescence;
			const iridescenceIORNode = this.iridescenceIORNode ? float( this.iridescenceIORNode ) : materialIridescenceIOR;
			const iridescenceThicknessNode = this.iridescenceThicknessNode ? float( this.iridescenceThicknessNode ) : materialIridescenceThickness;

			iridescence.assign( iridescenceNode );
			iridescenceIOR.assign( iridescenceIORNode );
			iridescenceThickness.assign( iridescenceThicknessNode );

		}

		// ANISOTROPY

		if ( this.useAnisotropy ) {

			const anisotropyV = ( this.anisotropyNode ? vec2( this.anisotropyNode ) : materialAnisotropy ).toVar();

			anisotropy.assign( anisotropyV.length() );

			If( anisotropy.equal( 0.0 ), () => {

				anisotropyV.assign( vec2( 1.0, 0.0 ) );

			} ).Else( () => {

				anisotropyV.divAssign( vec2( anisotropy ) );
				anisotropy.assign( anisotropy.saturate() );

			} );

			// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.
			alphaT.assign( anisotropy.pow2().mix( roughness.pow2(), 1.0 ) );

			anisotropyT.assign( TBNViewMatrix[ 0 ].mul( anisotropyV.x ).add( TBNViewMatrix[ 1 ].mul( anisotropyV.y ) ) );
			anisotropyB.assign( TBNViewMatrix[ 1 ].mul( anisotropyV.x ).sub( TBNViewMatrix[ 0 ].mul( anisotropyV.y ) ) );

		}

		// TRANSMISSION

		if ( this.useTransmission ) {

			const transmissionNode = this.transmissionNode ? float( this.transmissionNode ) : materialTransmission;
			const thicknessNode = this.thicknessNode ? float( this.thicknessNode ) : materialThickness;
			const attenuationDistanceNode = this.attenuationDistanceNode ? float( this.attenuationDistanceNode ) : materialAttenuationDistance;
			const attenuationColorNode = this.attenuationColorNode ? vec3( this.attenuationColorNode ) : materialAttenuationColor;

			transmission.assign( transmissionNode );
			thickness.assign( thicknessNode );
			attenuationDistance.assign( attenuationDistanceNode );
			attenuationColor.assign( attenuationColorNode );

			if ( this.useDispersion ) {

				const dispersionNode = this.dispersionNode ? float( this.dispersionNode ) : materialDispersion;

				dispersion.assign( dispersionNode );

			}

		}

	}

	setupClearcoatNormal() {

		return this.clearcoatNormalNode ? vec3( this.clearcoatNormalNode ) : materialClearcoatNormal;

	}

	setup( builder ) {

		builder.context.setupClearcoatNormal = () => this.setupClearcoatNormal( builder );

		super.setup( builder );

	}

	copy( source ) {

		this.clearcoatNode = source.clearcoatNode;
		this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
		this.clearcoatNormalNode = source.clearcoatNormalNode;

		this.sheenNode = source.sheenNode;
		this.sheenRoughnessNode = source.sheenRoughnessNode;

		this.iridescenceNode = source.iridescenceNode;
		this.iridescenceIORNode = source.iridescenceIORNode;
		this.iridescenceThicknessNode = source.iridescenceThicknessNode;

		this.specularIntensityNode = source.specularIntensityNode;
		this.specularColorNode = source.specularColorNode;

		this.transmissionNode = source.transmissionNode;
		this.thicknessNode = source.thicknessNode;
		this.attenuationDistanceNode = source.attenuationDistanceNode;
		this.attenuationColorNode = source.attenuationColorNode;
		this.dispersionNode = source.dispersionNode;

		this.anisotropyNode = source.anisotropyNode;

		return super.copy( source );

	}

}

class SSSLightingModel extends PhysicalLightingModel {

	constructor( useClearcoat, useSheen, useIridescence, useSSS ) {

		super( useClearcoat, useSheen, useIridescence );

		this.useSSS = useSSS;

	}

	direct( { lightDirection, lightColor, reflectedLight }, stack, builder ) {

		if ( this.useSSS === true ) {

			const material = builder.material;

			const { thicknessColorNode, thicknessDistortionNode, thicknessAmbientNode, thicknessAttenuationNode, thicknessPowerNode, thicknessScaleNode } = material;

			const scatteringHalf = lightDirection.add( transformedNormalView.mul( thicknessDistortionNode ) ).normalize();
			const scatteringDot = float( positionViewDirection.dot( scatteringHalf.negate() ).saturate().pow( thicknessPowerNode ).mul( thicknessScaleNode ) );
			const scatteringIllu = vec3( scatteringDot.add( thicknessAmbientNode ).mul( thicknessColorNode ) );

			reflectedLight.directDiffuse.addAssign( scatteringIllu.mul( thicknessAttenuationNode.mul( lightColor ) ) );

		}

		super.direct( { lightDirection, lightColor, reflectedLight }, stack, builder );

	}

}

class MeshSSSNodeMaterial extends MeshPhysicalNodeMaterial {

	static get type() {

		return 'MeshSSSNodeMaterial';

	}

	constructor( parameters ) {

		super( parameters );

		this.thicknessColorNode = null;
		this.thicknessDistortionNode = float( 0.1 );
		this.thicknessAmbientNode = float( 0.0 );
		this.thicknessAttenuationNode = float( .1 );
		this.thicknessPowerNode = float( 2.0 );
		this.thicknessScaleNode = float( 10.0 );

	}

	get useSSS() {

		return this.thicknessColorNode !== null;

	}

	setupLightingModel( /*builder*/ ) {

		return new SSSLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useSSS );

	}

	copy( source ) {

		this.thicknessColorNode = source.thicknessColorNode;
		this.thicknessDistortionNode = source.thicknessDistortionNode;
		this.thicknessAmbientNode = source.thicknessAmbientNode;
		this.thicknessAttenuationNode = source.thicknessAttenuationNode;
		this.thicknessPowerNode = source.thicknessPowerNode;
		this.thicknessScaleNode = source.thicknessScaleNode;

		return super.copy( source );

	}

}

const getGradientIrradiance = /*@__PURE__*/ Fn( ( { normal, lightDirection, builder } ) => {

	// dotNL will be from -1.0 to 1.0
	const dotNL = normal.dot( lightDirection );
	const coord = vec2( dotNL.mul( 0.5 ).add( 0.5 ), 0.0 );

	if ( builder.material.gradientMap ) {

		const gradientMap = materialReference( 'gradientMap', 'texture' ).context( { getUV: () => coord } );

		return vec3( gradientMap.r );

	} else {

		const fw = coord.fwidth().mul( 0.5 );

		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( float( 0.7 ).sub( fw.x ), float( 0.7 ).add( fw.x ), coord.x ) );

	}

} );

class ToonLightingModel extends LightingModel {

	direct( { lightDirection, lightColor, reflectedLight }, stack, builder ) {

		const irradiance = getGradientIrradiance( { normal: normalGeometry, lightDirection, builder } ).mul( lightColor );

		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

	}

	indirect( { ambientOcclusion, irradiance, reflectedLight } ) {

		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

	}

}

const _defaultValues$4 = /*@__PURE__*/ new MeshToonMaterial();

class MeshToonNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshToonNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshToonNodeMaterial = true;

		this.lights = true;

		this.setDefaultValues( _defaultValues$4 );

		this.setValues( parameters );

	}

	setupLightingModel( /*builder*/ ) {

		return new ToonLightingModel();

	}

}

class MatcapUVNode extends TempNode {

	static get type() {

		return 'MatcapUVNode';

	}

	constructor() {

		super( 'vec2' );

	}

	setup() {

		const x = vec3( positionViewDirection.z, 0, positionViewDirection.x.negate() ).normalize();
		const y = positionViewDirection.cross( x );

		return vec2( x.dot( transformedNormalView ), y.dot( transformedNormalView ) ).mul( 0.495 ).add( 0.5 ); // 0.495 to remove artifacts caused by undersized matcap disks

	}

}

const matcapUV = /*@__PURE__*/ nodeImmutable( MatcapUVNode );

const _defaultValues$3 = /*@__PURE__*/ new MeshMatcapMaterial();

class MeshMatcapNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshMatcapNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.lights = false;

		this.isMeshMatcapNodeMaterial = true;

		this.setDefaultValues( _defaultValues$3 );

		this.setValues( parameters );

	}

	setupVariants( builder ) {

		const uv = matcapUV;

		let matcapColor;

		if ( builder.material.matcap ) {

			matcapColor = materialReference( 'matcap', 'texture' ).context( { getUV: () => uv } );

		} else {

			matcapColor = vec3( mix( 0.2, 0.8, uv.y ) ); // default if matcap is missing

		}

		diffuseColor.rgb.mulAssign( matcapColor.rgb );

	}

}

const _defaultValues$2 = /*@__PURE__*/ new PointsMaterial();

class PointsNodeMaterial extends NodeMaterial {

	static get type() {

		return 'PointsNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isPointsNodeMaterial = true;

		this.lights = false;
		this.transparent = true;

		this.sizeNode = null;

		this.setDefaultValues( _defaultValues$2 );

		this.setValues( parameters );

	}

	copy( source ) {

		this.sizeNode = source.sizeNode;

		return super.copy( source );

	}

}

class RotateNode extends TempNode {

	static get type() {

		return 'RotateNode';

	}

	constructor( positionNode, rotationNode ) {

		super();

		this.positionNode = positionNode;
		this.rotationNode = rotationNode;

	}

	getNodeType( builder ) {

		return this.positionNode.getNodeType( builder );

	}

	setup( builder ) {

		const { rotationNode, positionNode } = this;

		const nodeType = this.getNodeType( builder );

		if ( nodeType === 'vec2' ) {

			const cosAngle = rotationNode.cos();
			const sinAngle = rotationNode.sin();

			const rotationMatrix = mat2(
				cosAngle, sinAngle,
				sinAngle.negate(), cosAngle
			);

			return rotationMatrix.mul( positionNode );

		} else {

			const rotation = rotationNode;
			const rotationXMatrix = mat4( vec4( 1.0, 0.0, 0.0, 0.0 ), vec4( 0.0, cos( rotation.x ), sin( rotation.x ).negate(), 0.0 ), vec4( 0.0, sin( rotation.x ), cos( rotation.x ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );
			const rotationYMatrix = mat4( vec4( cos( rotation.y ), 0.0, sin( rotation.y ), 0.0 ), vec4( 0.0, 1.0, 0.0, 0.0 ), vec4( sin( rotation.y ).negate(), 0.0, cos( rotation.y ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );
			const rotationZMatrix = mat4( vec4( cos( rotation.z ), sin( rotation.z ).negate(), 0.0, 0.0 ), vec4( sin( rotation.z ), cos( rotation.z ), 0.0, 0.0 ), vec4( 0.0, 0.0, 1.0, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );

			return rotationXMatrix.mul( rotationYMatrix ).mul( rotationZMatrix ).mul( vec4( positionNode, 1.0 ) ).xyz;

		}

	}

}

const rotate = /*@__PURE__*/ nodeProxy( RotateNode );

const _defaultValues$1 = /*@__PURE__*/ new SpriteMaterial();

class SpriteNodeMaterial extends NodeMaterial {

	static get type() {

		return 'SpriteNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isSpriteNodeMaterial = true;

		this.lights = false;
		this._useSizeAttenuation = true;

		this.positionNode = null;
		this.rotationNode = null;
		this.scaleNode = null;

		this.setDefaultValues( _defaultValues$1 );

		this.setValues( parameters );

	}

	setupPosition( { object, camera, context } ) {

		const sizeAttenuation = this.sizeAttenuation;

		// < VERTEX STAGE >

		const { positionNode, rotationNode, scaleNode } = this;

		const vertex = positionLocal;

		let mvPosition = modelViewMatrix.mul( vec3( positionNode || 0 ) );

		let scale = vec2( modelWorldMatrix[ 0 ].xyz.length(), modelWorldMatrix[ 1 ].xyz.length() );

		if ( scaleNode !== null ) {

			scale = scale.mul( scaleNode );

		}


		if ( ! sizeAttenuation ) {

			if ( camera.isPerspectiveCamera ) {

				scale = scale.mul( mvPosition.z.negate() );

			} else {

				const orthoScale = float( 2.0 ).div( cameraProjectionMatrix.element( 1 ).element( 1 ) );
				scale = scale.mul( orthoScale.mul( 2 ) );

			}

		}

		let alignedPosition = vertex.xy;

		if ( object.center && object.center.isVector2 === true ) {

			const center = reference$1( 'center', 'vec2' );

			alignedPosition = alignedPosition.sub( center.sub( 0.5 ) );

		}

		alignedPosition = alignedPosition.mul( scale );

		const rotation = float( rotationNode || materialRotation );

		const rotatedPosition = rotate( alignedPosition, rotation );

		mvPosition = vec4( mvPosition.xy.add( rotatedPosition ), mvPosition.zw );

		const modelViewProjection = cameraProjectionMatrix.mul( mvPosition );

		context.vertex = vertex;

		return modelViewProjection;

	}

	copy( source ) {

		this.positionNode = source.positionNode;
		this.rotationNode = source.rotationNode;
		this.scaleNode = source.scaleNode;

		return super.copy( source );

	}

	get sizeAttenuation() {

		return this._useSizeAttenuation;

	}

	set sizeAttenuation( value ) {

		if ( this._useSizeAttenuation !== value ) {

			this._useSizeAttenuation = value;
			this.needsUpdate = true;

		}

	}

}

class ShadowMaskModel extends LightingModel {

	constructor() {

		super();

		this.shadowNode = float( 1 ).toVar( 'shadowMask' );

	}

	direct( { shadowMask } ) {

		this.shadowNode.mulAssign( shadowMask );

	}

	finish( context ) {

		diffuseColor.a.mulAssign( this.shadowNode.oneMinus() );

		context.outgoingLight.rgb.assign( diffuseColor.rgb ); // TODO: Optimize LightsNode to avoid this assignment

	}

}

const _defaultValues = /*@__PURE__*/ new ShadowMaterial();

class ShadowNodeMaterial extends NodeMaterial {

	static get type() {

		return 'ShadowNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isShadowNodeMaterial = true;

		this.lights = true;

		this.setDefaultValues( _defaultValues );

		this.setValues( parameters );

	}

	setupLightingModel( /*builder*/ ) {

		return new ShadowMaskModel();

	}

}

const normal = Fn( ( { texture, uv } ) => {

	const epsilon = 0.0001;

	const ret = vec3().toVar();

	If( uv.x.lessThan( epsilon ), () => {

		ret.assign( vec3( 1, 0, 0 ) );

	} ).ElseIf( uv.y.lessThan( epsilon ), () => {

		ret.assign( vec3( 0, 1, 0 ) );

	} ).ElseIf( uv.z.lessThan( epsilon ), () => {

		ret.assign( vec3( 0, 0, 1 ) );

	} ).ElseIf( uv.x.greaterThan( 1 - epsilon ), () => {

		ret.assign( vec3( - 1, 0, 0 ) );

	} ).ElseIf( uv.y.greaterThan( 1 - epsilon ), () => {

		ret.assign( vec3( 0, - 1, 0 ) );

	} ).ElseIf( uv.z.greaterThan( 1 - epsilon ), () => {

		ret.assign( vec3( 0, 0, - 1 ) );

	} ).Else( () => {

		const step = 0.01;

		const x = texture.uv( uv.add( vec3( - step, 0.0, 0.0 ) ) ).r.sub( texture.uv( uv.add( vec3( step, 0.0, 0.0 ) ) ).r );
		const y = texture.uv( uv.add( vec3( 0.0, - step, 0.0 ) ) ).r.sub( texture.uv( uv.add( vec3( 0.0, step, 0.0 ) ) ).r );
		const z = texture.uv( uv.add( vec3( 0.0, 0.0, - step ) ) ).r.sub( texture.uv( uv.add( vec3( 0.0, 0.0, step ) ) ).r );

		ret.assign( vec3( x, y, z ) );

	} );

	return ret.normalize();

} );


class Texture3DNode extends TextureNode {

	static get type() {

		return 'Texture3DNode';

	}

	constructor( value, uvNode = null, levelNode = null ) {

		super( value, uvNode, levelNode );

		this.isTexture3DNode = true;

	}

	getInputType( /*builder*/ ) {

		return 'texture3D';

	}

	getDefaultUV() {

		return vec3( 0.5, 0.5, 0.5 );

	}

	setUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for 3d TextureNode

	setupUV( builder, uvNode ) {

		return uvNode;

	}

	generateUV( builder, uvNode ) {

		return uvNode.build( builder, 'vec3' );

	}

	normal( uvNode ) {

		return normal( { texture: this, uv: uvNode } );

	}

}

const texture3D = /*@__PURE__*/ nodeProxy( Texture3DNode );

class VolumeNodeMaterial extends NodeMaterial {

	static get type() {

		return 'VolumeNodeMaterial';

	}

	constructor( params = {} ) {

		super();

		this.lights = false;
		this.isVolumeNodeMaterial = true;
		this.testNode = null;

		this.setValues( params );

	}

	setup( builder ) {

		const map = texture3D( this.map, null, 0 );

		const hitBox = Fn( ( { orig, dir } ) => {

			const box_min = vec3( - 0.5 );
			const box_max = vec3( 0.5 );

			const inv_dir = dir.reciprocal();

			const tmin_tmp = box_min.sub( orig ).mul( inv_dir );
			const tmax_tmp = box_max.sub( orig ).mul( inv_dir );

			const tmin = min$1( tmin_tmp, tmax_tmp );
			const tmax = max$1( tmin_tmp, tmax_tmp );

			const t0 = max$1( tmin.x, max$1( tmin.y, tmin.z ) );
			const t1 = min$1( tmax.x, min$1( tmax.y, tmax.z ) );

			return vec2( t0, t1 );

		} );

		this.fragmentNode = Fn( () => {

			const vOrigin = varying( vec3( modelWorldMatrixInverse.mul( vec4( cameraPosition, 1.0 ) ) ) );
			const vDirection = varying( positionGeometry.sub( vOrigin ) );

			const rayDir = vDirection.normalize();
			const bounds = vec2( hitBox( { orig: vOrigin, dir: rayDir } ) ).toVar();

			bounds.x.greaterThan( bounds.y ).discard();

			bounds.assign( vec2( max$1( bounds.x, 0.0 ), bounds.y ) );

			const p = vec3( vOrigin.add( bounds.x.mul( rayDir ) ) ).toVar();
			const inc = vec3( rayDir.abs().reciprocal() ).toVar();
			const delta = float( min$1( inc.x, min$1( inc.y, inc.z ) ) ).toVar( 'delta' ); // used 'delta' name in loop

			delta.divAssign( materialReference( 'steps', 'float' ) );

			const ac = vec4( materialReference( 'base', 'color' ), 0.0 ).toVar();

			Loop( { type: 'float', start: bounds.x, end: bounds.y, update: '+= delta' }, () => {

				const d = property( 'float', 'd' ).assign( map.uv( p.add( 0.5 ) ).r );

				if ( this.testNode !== null ) {

					this.testNode( { map: map, mapValue: d, probe: p, finalColor: ac } ).append();

				} else {

					// default to show surface of mesh
					ac.a.assign( 1 );
					Break();

				}

				p.addAssign( rayDir.mul( delta ) );

			} );

			ac.a.equal( 0 ).discard();

			return vec4( ac );

		} )();

		super.setup( builder );

	}

}

class Animation {

	constructor( nodes, info ) {

		this.nodes = nodes;
		this.info = info;

		this._context = self;
		this._animationLoop = null;
		this._requestId = null;

	}

	start() {

		const update = ( time, frame ) => {

			this._requestId = this._context.requestAnimationFrame( update );

			if ( this.info.autoReset === true ) this.info.reset();

			this.nodes.nodeFrame.update();

			this.info.frame = this.nodes.nodeFrame.frameId;

			if ( this._animationLoop !== null ) this._animationLoop( time, frame );

		};

		update();

	}

	stop() {

		this._context.cancelAnimationFrame( this._requestId );

		this._requestId = null;

	}

	setAnimationLoop( callback ) {

		this._animationLoop = callback;

	}

	setContext( context ) {

		this._context = context;

	}

	dispose() {

		this.stop();

	}

}

class ChainMap {

	constructor() {

		this.weakMap = new WeakMap();

	}

	get( keys ) {

		let map = this.weakMap;

		for ( let i = 0; i < keys.length; i ++ ) {

			map = map.get( keys[ i ] );

			if ( map === undefined ) return undefined;

		}

		return map.get( keys[ keys.length - 1 ] );

	}

	set( keys, value ) {

		let map = this.weakMap;

		for ( let i = 0; i < keys.length; i ++ ) {

			const key = keys[ i ];

			if ( map.has( key ) === false ) map.set( key, new WeakMap() );

			map = map.get( key );

		}

		return map.set( keys[ keys.length - 1 ], value );

	}

	delete( keys ) {

		let map = this.weakMap;

		for ( let i = 0; i < keys.length; i ++ ) {

			map = map.get( keys[ i ] );

			if ( map === undefined ) return false;

		}

		return map.delete( keys[ keys.length - 1 ] );

	}

}

let _id$7 = 0;

function getKeys( obj ) {

	const keys = Object.keys( obj );

	let proto = Object.getPrototypeOf( obj );

	while ( proto ) {

		const descriptors = Object.getOwnPropertyDescriptors( proto );

		for ( const key in descriptors ) {

			if ( descriptors[ key ] !== undefined ) {

				const descriptor = descriptors[ key ];

				if ( descriptor && typeof descriptor.get === 'function' ) {

					keys.push( key );

				}

			}

		}

		proto = Object.getPrototypeOf( proto );

	}

	return keys;

}

class RenderObject {

	constructor( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext ) {

		this._nodes = nodes;
		this._geometries = geometries;

		this.id = _id$7 ++;

		this.renderer = renderer;
		this.object = object;
		this.material = material;
		this.scene = scene;
		this.camera = camera;
		this.lightsNode = lightsNode;
		this.context = renderContext;

		this.geometry = object.geometry;
		this.version = material.version;

		this.drawRange = null;

		this.attributes = null;
		this.pipeline = null;
		this.vertexBuffers = null;
		this.drawParams = null;

		this.bundle = null;

		this.clippingContext = clippingContext;
		this.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';

		this.initialNodesCacheKey = this.getDynamicCacheKey();
		this.initialCacheKey = this.getCacheKey();

		this._nodeBuilderState = null;
		this._bindings = null;
		this._monitor = null;

		this.onDispose = null;

		this.isRenderObject = true;

		this.onMaterialDispose = () => {

			this.dispose();

		};

		this.material.addEventListener( 'dispose', this.onMaterialDispose );

	}

	updateClipping( parent ) {

		this.clippingContext = parent;

	}

	get clippingNeedsUpdate() {

		if ( this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ) return false;

		this.clippingContextCacheKey = this.clippingContext.cacheKey;

		return true;

	}

	get hardwareClippingPlanes() {

		return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;

	}

	getNodeBuilderState() {

		return this._nodeBuilderState || ( this._nodeBuilderState = this._nodes.getForRender( this ) );

	}

	getMonitor() {

		return this._monitor || ( this._monitor = this.getNodeBuilderState().monitor );

	}

	getBindings() {

		return this._bindings || ( this._bindings = this.getNodeBuilderState().createBindings() );

	}

	getIndex() {

		return this._geometries.getIndex( this );

	}

	getIndirect() {

		return this._geometries.getIndirect( this );

	}

	getChainArray() {

		return [ this.object, this.material, this.context, this.lightsNode ];

	}

	setGeometry( geometry ) {

		this.geometry = geometry;
		this.attributes = null;

	}

	getAttributes() {

		if ( this.attributes !== null ) return this.attributes;

		const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
		const geometry = this.geometry;

		const attributes = [];
		const vertexBuffers = new Set();

		for ( const nodeAttribute of nodeAttributes ) {

			const attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute( nodeAttribute.name );

			if ( attribute === undefined ) continue;

			attributes.push( attribute );

			const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
			vertexBuffers.add( bufferAttribute );

		}

		this.attributes = attributes;
		this.vertexBuffers = Array.from( vertexBuffers.values() );

		return attributes;

	}

	getVertexBuffers() {

		if ( this.vertexBuffers === null ) this.getAttributes();

		return this.vertexBuffers;

	}

	getDrawParameters() {

		const { object, material, geometry, group, drawRange } = this;

		const drawParams = this.drawParams || ( this.drawParams = {
			vertexCount: 0,
			firstVertex: 0,
			instanceCount: 0,
			firstInstance: 0
		} );

		const index = this.getIndex();
		const hasIndex = ( index !== null );
		const instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );

		if ( instanceCount === 0 ) return null;

		drawParams.instanceCount = instanceCount;

		if ( object.isBatchedMesh === true ) return drawParams;

		let rangeFactor = 1;

		if ( material.wireframe === true && ! object.isPoints && ! object.isLineSegments && ! object.isLine && ! object.isLineLoop ) {

			rangeFactor = 2;

		}

		let firstVertex = drawRange.start * rangeFactor;
		let lastVertex = ( drawRange.start + drawRange.count ) * rangeFactor;

		if ( group !== null ) {

			firstVertex = Math.max( firstVertex, group.start * rangeFactor );
			lastVertex = Math.min( lastVertex, ( group.start + group.count ) * rangeFactor );

		}

		const position = geometry.attributes.position;
		let itemCount = Infinity;

		if ( hasIndex ) {

			itemCount = index.count;

		} else if ( position !== undefined && position !== null ) {

			itemCount = position.count;

		}

		firstVertex = Math.max( firstVertex, 0 );
		lastVertex = Math.min( lastVertex, itemCount );

		const count = lastVertex - firstVertex;

		if ( count < 0 || count === Infinity ) return null;

		drawParams.vertexCount = count;
		drawParams.firstVertex = firstVertex;

		return drawParams;

	}

	getGeometryCacheKey() {

		const { geometry } = this;

		let cacheKey = '';

		for ( const name of Object.keys( geometry.attributes ).sort() ) {

			const attribute = geometry.attributes[ name ];

			cacheKey += name + ',';

			if ( attribute.data ) cacheKey += attribute.data.stride + ',';
			if ( attribute.offset ) cacheKey += attribute.offset + ',';
			if ( attribute.itemSize ) cacheKey += attribute.itemSize + ',';
			if ( attribute.normalized ) cacheKey += 'n,';

		}

		if ( geometry.index ) {

			cacheKey += 'index,';

		}

		return cacheKey;

	}

	getMaterialCacheKey() {

		const { object, material } = this;

		let cacheKey = material.customProgramCacheKey();

		for ( const property of getKeys( material ) ) {

			if ( /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test( property ) ) continue;

			const value = material[ property ];

			let valueKey;

			if ( value !== null ) {

				// some material values require a formatting

				const type = typeof value;

				if ( type === 'number' ) {

					valueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc

				} else if ( type === 'object' ) {

					valueKey = '{';

					if ( value.isTexture ) {

						valueKey += value.mapping;

					}

					valueKey += '}';

				} else {

					valueKey = String( value );

				}

			} else {

				valueKey = String( value );

			}

			cacheKey += /*property + ':' +*/ valueKey + ',';

		}

		cacheKey += this.clippingContextCacheKey + ',';

		if ( object.geometry ) {

			cacheKey += this.getGeometryCacheKey();

		}

		if ( object.skeleton ) {

			cacheKey += object.skeleton.bones.length + ',';

		}

		if ( object.morphTargetInfluences ) {

			cacheKey += object.morphTargetInfluences.length + ',';

		}

		if ( object.isBatchedMesh ) {

			cacheKey += object._matricesTexture.uuid + ',';

			if ( object._colorsTexture !== null ) {

				cacheKey += object._colorsTexture.uuid + ',';

			}

		}

		if ( object.count > 1 ) {

			// TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850

			cacheKey += object.uuid + ',';

		}

		cacheKey += object.receiveShadow + ',';

		return hashString( cacheKey );

	}

	get needsGeometryUpdate() {

		return this.geometry.id !== this.object.geometry.id;

	}

	get needsUpdate() {

		return /*this.object.static !== true &&*/ ( this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate );

	}

	getDynamicCacheKey() {

		// Environment Nodes Cache Key

		let cacheKey = this._nodes.getCacheKey( this.scene, this.lightsNode );

		if ( this.object.receiveShadow ) {

			cacheKey += 1;

		}

		return cacheKey;

	}

	getCacheKey() {

		return this.getMaterialCacheKey() + this.getDynamicCacheKey();

	}

	dispose() {

		this.material.removeEventListener( 'dispose', this.onMaterialDispose );

		this.onDispose();

	}

}

const chainArray = [];

class RenderObjects {

	constructor( renderer, nodes, geometries, pipelines, bindings, info ) {

		this.renderer = renderer;
		this.nodes = nodes;
		this.geometries = geometries;
		this.pipelines = pipelines;
		this.bindings = bindings;
		this.info = info;

		this.chainMaps = {};

	}

	get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {

		const chainMap = this.getChainMap( passId );

		// reuse chainArray
		chainArray[ 0 ] = object;
		chainArray[ 1 ] = material;
		chainArray[ 2 ] = renderContext;
		chainArray[ 3 ] = lightsNode;

		let renderObject = chainMap.get( chainArray );

		if ( renderObject === undefined ) {

			renderObject = this.createRenderObject( this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );

			chainMap.set( chainArray, renderObject );

		} else {

			renderObject.updateClipping( clippingContext );

			if ( renderObject.needsGeometryUpdate ) {

				renderObject.setGeometry( object.geometry );

			}

			if ( renderObject.version !== material.version || renderObject.needsUpdate ) {

				if ( renderObject.initialCacheKey !== renderObject.getCacheKey() ) {

					renderObject.dispose();

					renderObject = this.get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );

				} else {

					renderObject.version = material.version;

				}

			}

		}

		return renderObject;

	}

	getChainMap( passId = 'default' ) {

		return this.chainMaps[ passId ] || ( this.chainMaps[ passId ] = new ChainMap() );

	}

	dispose() {

		this.chainMaps = {};

	}

	createRenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {

		const chainMap = this.getChainMap( passId );

		const renderObject = new RenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext );

		renderObject.onDispose = () => {

			this.pipelines.delete( renderObject );
			this.bindings.delete( renderObject );
			this.nodes.delete( renderObject );

			chainMap.delete( renderObject.getChainArray() );

		};

		return renderObject;

	}


}

class DataMap {

	constructor() {

		this.data = new WeakMap();

	}

	get( object ) {

		let map = this.data.get( object );

		if ( map === undefined ) {

			map = {};
			this.data.set( object, map );

		}

		return map;

	}

	delete( object ) {

		let map;

		if ( this.data.has( object ) ) {

			map = this.data.get( object );

			this.data.delete( object );

		}

		return map;

	}

	has( object ) {

		return this.data.has( object );

	}

	dispose() {

		this.data = new WeakMap();

	}

}

const AttributeType = {
	VERTEX: 1,
	INDEX: 2,
	STORAGE: 3,
	INDIRECT: 4
};

// size of a chunk in bytes (STD140 layout)

const GPU_CHUNK_BYTES = 16;

// @TODO: Move to src/constants.js

const BlendColorFactor = 211;
const OneMinusBlendColorFactor = 212;

class Attributes extends DataMap {

	constructor( backend ) {

		super();

		this.backend = backend;

	}

	delete( attribute ) {

		const attributeData = super.delete( attribute );

		if ( attributeData !== undefined ) {

			this.backend.destroyAttribute( attribute );

		}

		return attributeData;

	}

	update( attribute, type ) {

		const data = this.get( attribute );

		if ( data.version === undefined ) {

			if ( type === AttributeType.VERTEX ) {

				this.backend.createAttribute( attribute );

			} else if ( type === AttributeType.INDEX ) {

				this.backend.createIndexAttribute( attribute );

			} else if ( type === AttributeType.STORAGE ) {

				this.backend.createStorageAttribute( attribute );

			} else if ( type === AttributeType.INDIRECT ) {

				this.backend.createIndirectStorageAttribute( attribute );

			}

			data.version = this._getBufferAttribute( attribute ).version;

		} else {

			const bufferAttribute = this._getBufferAttribute( attribute );

			if ( data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage ) {

				this.backend.updateAttribute( attribute );

				data.version = bufferAttribute.version;

			}

		}

	}

	_getBufferAttribute( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return attribute;

	}

}

function arrayNeedsUint32( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

	}

	return false;

}

function getWireframeVersion( geometry ) {

	return ( geometry.index !== null ) ? geometry.index.version : geometry.attributes.position.version;

}

function getWireframeIndex( geometry ) {

	const indices = [];

	const geometryIndex = geometry.index;
	const geometryPosition = geometry.attributes.position;

	if ( geometryIndex !== null ) {

		const array = geometryIndex.array;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const a = array[ i + 0 ];
			const b = array[ i + 1 ];
			const c = array[ i + 2 ];

			indices.push( a, b, b, c, c, a );

		}

	} else {

		const array = geometryPosition.array;

		for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

			const a = i + 0;
			const b = i + 1;
			const c = i + 2;

			indices.push( a, b, b, c, c, a );

		}

	}

	const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
	attribute.version = getWireframeVersion( geometry );

	return attribute;

}

class Geometries extends DataMap {

	constructor( attributes, info ) {

		super();

		this.attributes = attributes;
		this.info = info;

		this.wireframes = new WeakMap();

		this.attributeCall = new WeakMap();

	}

	has( renderObject ) {

		const geometry = renderObject.geometry;

		return super.has( geometry ) && this.get( geometry ).initialized === true;

	}

	updateForRender( renderObject ) {

		if ( this.has( renderObject ) === false ) this.initGeometry( renderObject );

		this.updateAttributes( renderObject );

	}

	initGeometry( renderObject ) {

		const geometry = renderObject.geometry;
		const geometryData = this.get( geometry );

		geometryData.initialized = true;

		this.info.memory.geometries ++;

		const onDispose = () => {

			this.info.memory.geometries --;

			const index = geometry.index;
			const geometryAttributes = renderObject.getAttributes();

			if ( index !== null ) {

				this.attributes.delete( index );

			}

			for ( const geometryAttribute of geometryAttributes ) {

				this.attributes.delete( geometryAttribute );

			}

			const wireframeAttribute = this.wireframes.get( geometry );

			if ( wireframeAttribute !== undefined ) {

				this.attributes.delete( wireframeAttribute );

			}

			geometry.removeEventListener( 'dispose', onDispose );

		};

		geometry.addEventListener( 'dispose', onDispose );

	}

	updateAttributes( renderObject ) {

		// attributes

		const attributes = renderObject.getAttributes();

		for ( const attribute of attributes ) {

			if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {

				this.updateAttribute( attribute, AttributeType.STORAGE );

			} else {

				this.updateAttribute( attribute, AttributeType.VERTEX );

			}

		}

		// indexes

		const index = this.getIndex( renderObject );

		if ( index !== null ) {

			this.updateAttribute( index, AttributeType.INDEX );

		}

		// indirect

		const indirect = renderObject.geometry.indirect;

		if ( indirect !== null ) {

			this.updateAttribute( indirect, AttributeType.INDIRECT );

		}

	}

	updateAttribute( attribute, type ) {

		const callId = this.info.render.calls;

		if ( ! attribute.isInterleavedBufferAttribute ) {

			if ( this.attributeCall.get( attribute ) !== callId ) {

				this.attributes.update( attribute, type );

				this.attributeCall.set( attribute, callId );

			}

		} else {

			if ( this.attributeCall.get( attribute ) === undefined ) {

				this.attributes.update( attribute, type );

				this.attributeCall.set( attribute, callId );

			} else if ( this.attributeCall.get( attribute.data ) !== callId ) {

				this.attributes.update( attribute, type );

				this.attributeCall.set( attribute.data, callId );

				this.attributeCall.set( attribute, callId );

			}

		}

	}

	getIndirect( renderObject ) {

		return renderObject.geometry.indirect;

	}

	getIndex( renderObject ) {

		const { geometry, material } = renderObject;

		let index = geometry.index;

		if ( material.wireframe === true ) {

			const wireframes = this.wireframes;

			let wireframeAttribute = wireframes.get( geometry );

			if ( wireframeAttribute === undefined ) {

				wireframeAttribute = getWireframeIndex( geometry );

				wireframes.set( geometry, wireframeAttribute );

			} else if ( wireframeAttribute.version !== getWireframeVersion( geometry ) ) {

				this.attributes.delete( wireframeAttribute );

				wireframeAttribute = getWireframeIndex( geometry );

				wireframes.set( geometry, wireframeAttribute );

			}

			index = wireframeAttribute;

		}

		return index;

	}

}

class Info {

	constructor() {

		this.autoReset = true;

		this.frame = 0;
		this.calls = 0;

		this.render = {
			calls: 0,
			frameCalls: 0,
			drawCalls: 0,
			triangles: 0,
			points: 0,
			lines: 0,
			timestamp: 0,
			previousFrameCalls: 0,
			timestampCalls: 0
		};

		this.compute = {
			calls: 0,
			frameCalls: 0,
			timestamp: 0,
			previousFrameCalls: 0,
			timestampCalls: 0
		};

		this.memory = {
			geometries: 0,
			textures: 0
		};

	}

	update( object, count, instanceCount ) {

		this.render.drawCalls ++;

		if ( object.isMesh || object.isSprite ) {

			this.render.triangles += instanceCount * ( count / 3 );

		} else if ( object.isPoints ) {

			this.render.points += instanceCount * count;

		} else if ( object.isLineSegments ) {

			this.render.lines += instanceCount * ( count / 2 );

		} else if ( object.isLine ) {

			this.render.lines += instanceCount * ( count - 1 );

		} else {

			console.error( 'THREE.WebGPUInfo: Unknown object type.' );

		}

	}

	updateTimestamp( type, time ) {

		if ( this[ type ].timestampCalls === 0 ) {

			this[ type ].timestamp = 0;

		}


		this[ type ].timestamp += time;

		this[ type ].timestampCalls ++;


		if ( this[ type ].timestampCalls >= this[ type ].previousFrameCalls ) {

			this[ type ].timestampCalls = 0;

		}


	}

	reset() {

		const previousRenderFrameCalls = this.render.frameCalls;
		this.render.previousFrameCalls = previousRenderFrameCalls;

		const previousComputeFrameCalls = this.compute.frameCalls;
		this.compute.previousFrameCalls = previousComputeFrameCalls;


		this.render.drawCalls = 0;
		this.render.frameCalls = 0;
		this.compute.frameCalls = 0;

		this.render.triangles = 0;
		this.render.points = 0;
		this.render.lines = 0;


	}

	dispose() {

		this.reset();

		this.calls = 0;

		this.render.calls = 0;
		this.compute.calls = 0;

		this.render.timestamp = 0;
		this.compute.timestamp = 0;
		this.memory.geometries = 0;
		this.memory.textures = 0;

	}

}

class Pipeline {

	constructor( cacheKey ) {

		this.cacheKey = cacheKey;

		this.usedTimes = 0;

	}

}

class RenderPipeline extends Pipeline {

	constructor( cacheKey, vertexProgram, fragmentProgram ) {

		super( cacheKey );

		this.vertexProgram = vertexProgram;
		this.fragmentProgram = fragmentProgram;

	}

}

class ComputePipeline extends Pipeline {

	constructor( cacheKey, computeProgram ) {

		super( cacheKey );

		this.computeProgram = computeProgram;

		this.isComputePipeline = true;

	}

}

let _id$6 = 0;

class ProgrammableStage {

	constructor( code, type, transforms = null, attributes = null ) {

		this.id = _id$6 ++;

		this.code = code;
		this.stage = type;
		this.transforms = transforms;
		this.attributes = attributes;

		this.usedTimes = 0;

	}

}

class Pipelines extends DataMap {

	constructor( backend, nodes ) {

		super();

		this.backend = backend;
		this.nodes = nodes;

		this.bindings = null; // set by the bindings

		this.caches = new Map();
		this.programs = {
			vertex: new Map(),
			fragment: new Map(),
			compute: new Map()
		};

	}

	getForCompute( computeNode, bindings ) {

		const { backend } = this;

		const data = this.get( computeNode );

		if ( this._needsComputeUpdate( computeNode ) ) {

			const previousPipeline = data.pipeline;

			if ( previousPipeline ) {

				previousPipeline.usedTimes --;
				previousPipeline.computeProgram.usedTimes --;

			}

			// get shader

			const nodeBuilderState = this.nodes.getForCompute( computeNode );

			// programmable stage

			let stageCompute = this.programs.compute.get( nodeBuilderState.computeShader );

			if ( stageCompute === undefined ) {

				if ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );

				stageCompute = new ProgrammableStage( nodeBuilderState.computeShader, 'compute', nodeBuilderState.transforms, nodeBuilderState.nodeAttributes );
				this.programs.compute.set( nodeBuilderState.computeShader, stageCompute );

				backend.createProgram( stageCompute );

			}

			// determine compute pipeline

			const cacheKey = this._getComputeCacheKey( computeNode, stageCompute );

			let pipeline = this.caches.get( cacheKey );

			if ( pipeline === undefined ) {

				if ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );

				pipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );

			}

			// keep track of all used times

			pipeline.usedTimes ++;
			stageCompute.usedTimes ++;

			//

			data.version = computeNode.version;
			data.pipeline = pipeline;

		}

		return data.pipeline;

	}

	getForRender( renderObject, promises = null ) {

		const { backend } = this;

		const data = this.get( renderObject );

		if ( this._needsRenderUpdate( renderObject ) ) {

			const previousPipeline = data.pipeline;

			if ( previousPipeline ) {

				previousPipeline.usedTimes --;
				previousPipeline.vertexProgram.usedTimes --;
				previousPipeline.fragmentProgram.usedTimes --;

			}

			// get shader

			const nodeBuilderState = renderObject.getNodeBuilderState();

			// programmable stages

			let stageVertex = this.programs.vertex.get( nodeBuilderState.vertexShader );

			if ( stageVertex === undefined ) {

				if ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );

				stageVertex = new ProgrammableStage( nodeBuilderState.vertexShader, 'vertex' );
				this.programs.vertex.set( nodeBuilderState.vertexShader, stageVertex );

				backend.createProgram( stageVertex );

			}

			let stageFragment = this.programs.fragment.get( nodeBuilderState.fragmentShader );

			if ( stageFragment === undefined ) {

				if ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );

				stageFragment = new ProgrammableStage( nodeBuilderState.fragmentShader, 'fragment' );
				this.programs.fragment.set( nodeBuilderState.fragmentShader, stageFragment );

				backend.createProgram( stageFragment );

			}

			// determine render pipeline

			const cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );

			let pipeline = this.caches.get( cacheKey );

			if ( pipeline === undefined ) {

				if ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );

				pipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises );

			} else {

				renderObject.pipeline = pipeline;

			}

			// keep track of all used times

			pipeline.usedTimes ++;
			stageVertex.usedTimes ++;
			stageFragment.usedTimes ++;

			//

			data.pipeline = pipeline;

		}

		return data.pipeline;

	}

	delete( object ) {

		const pipeline = this.get( object ).pipeline;

		if ( pipeline ) {

			// pipeline

			pipeline.usedTimes --;

			if ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );

			// programs

			if ( pipeline.isComputePipeline ) {

				pipeline.computeProgram.usedTimes --;

				if ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );

			} else {

				pipeline.fragmentProgram.usedTimes --;
				pipeline.vertexProgram.usedTimes --;

				if ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );
				if ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );

			}

		}

		return super.delete( object );

	}

	dispose() {

		super.dispose();

		this.caches = new Map();
		this.programs = {
			vertex: new Map(),
			fragment: new Map(),
			compute: new Map()
		};

	}

	updateForRender( renderObject ) {

		this.getForRender( renderObject );

	}

	_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {

		// check for existing pipeline

		cacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );

		let pipeline = this.caches.get( cacheKey );

		if ( pipeline === undefined ) {

			pipeline = new ComputePipeline( cacheKey, stageCompute );

			this.caches.set( cacheKey, pipeline );

			this.backend.createComputePipeline( pipeline, bindings );

		}

		return pipeline;

	}

	_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises ) {

		// check for existing pipeline

		cacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );

		let pipeline = this.caches.get( cacheKey );

		if ( pipeline === undefined ) {

			pipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );

			this.caches.set( cacheKey, pipeline );

			renderObject.pipeline = pipeline;

			this.backend.createRenderPipeline( renderObject, promises );

		}

		return pipeline;

	}

	_getComputeCacheKey( computeNode, stageCompute ) {

		return computeNode.id + ',' + stageCompute.id;

	}

	_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {

		return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey( renderObject );

	}

	_releasePipeline( pipeline ) {

		this.caches.delete( pipeline.cacheKey );

	}

	_releaseProgram( program ) {

		const code = program.code;
		const stage = program.stage;

		this.programs[ stage ].delete( code );

	}

	_needsComputeUpdate( computeNode ) {

		const data = this.get( computeNode );

		return data.pipeline === undefined || data.version !== computeNode.version;

	}

	_needsRenderUpdate( renderObject ) {

		const data = this.get( renderObject );

		return data.pipeline === undefined || this.backend.needsRenderUpdate( renderObject );

	}

}

class Bindings extends DataMap {

	constructor( backend, nodes, textures, attributes, pipelines, info ) {

		super();

		this.backend = backend;
		this.textures = textures;
		this.pipelines = pipelines;
		this.attributes = attributes;
		this.nodes = nodes;
		this.info = info;

		this.pipelines.bindings = this; // assign bindings to pipelines

	}

	getForRender( renderObject ) {

		const bindings = renderObject.getBindings();

		for ( const bindGroup of bindings ) {

			const groupData = this.get( bindGroup );

			if ( groupData.bindGroup === undefined ) {

				// each object defines an array of bindings (ubos, textures, samplers etc.)

				this._init( bindGroup );

				this.backend.createBindings( bindGroup, bindings, 0 );

				groupData.bindGroup = bindGroup;

			}

		}

		return bindings;

	}

	getForCompute( computeNode ) {

		const bindings = this.nodes.getForCompute( computeNode ).bindings;

		for ( const bindGroup of bindings ) {

			const groupData = this.get( bindGroup );

			if ( groupData.bindGroup === undefined ) {

				this._init( bindGroup );

				this.backend.createBindings( bindGroup, bindings, 0 );

				groupData.bindGroup = bindGroup;

			}

		}

		return bindings;

	}

	updateForCompute( computeNode ) {

		this._updateBindings( this.getForCompute( computeNode ) );

	}

	updateForRender( renderObject ) {

		this._updateBindings( this.getForRender( renderObject ) );

	}

	_updateBindings( bindings ) {

		for ( const bindGroup of bindings ) {

			this._update( bindGroup, bindings );

		}

	}

	_init( bindGroup ) {

		for ( const binding of bindGroup.bindings ) {

			if ( binding.isSampledTexture ) {

				this.textures.updateTexture( binding.texture );

			} else if ( binding.isStorageBuffer ) {

				const attribute = binding.attribute;
				const attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;

				this.attributes.update( attribute, attributeType );

			}

		}

	}

	_update( bindGroup, bindings ) {

		const { backend } = this;

		let needsBindingsUpdate = false;
		let cacheBindings = true;
		let cacheIndex = 0;
		let version = 0;

		// iterate over all bindings and check if buffer updates or a new binding group is required

		for ( const binding of bindGroup.bindings ) {

			if ( binding.isNodeUniformsGroup ) {

				const updated = this.nodes.updateGroup( binding );

				if ( ! updated ) continue;

			}

			if ( binding.isUniformBuffer ) {

				const updated = binding.update();

				if ( updated ) {

					backend.updateBinding( binding );

				}

			} else if ( binding.isSampler ) {

				binding.update();

			} else if ( binding.isSampledTexture ) {

				const texturesTextureData = this.textures.get( binding.texture );

				if ( binding.needsBindingsUpdate( texturesTextureData.generation ) ) needsBindingsUpdate = true;

				const updated = binding.update();

				const texture = binding.texture;

				if ( updated ) {

					this.textures.updateTexture( texture );

				}

				const textureData = backend.get( texture );

				if ( textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture ) {

					cacheBindings = false;

				} else {

					cacheIndex = cacheIndex * 10 + texture.id;
					version += texture.version;

				}

				if ( backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined ) {

					// TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend
					console.error( 'Bindings._update: binding should be available:', binding, updated, texture, binding.textureNode.value, needsBindingsUpdate );

					this.textures.updateTexture( texture );
					needsBindingsUpdate = true;

				}

				if ( texture.isStorageTexture === true ) {

					const textureData = this.get( texture );

					if ( binding.store === true ) {

						textureData.needsMipmap = true;

					} else if ( this.textures.needsMipmaps( texture ) && textureData.needsMipmap === true ) {

						this.backend.generateMipmaps( texture );

						textureData.needsMipmap = false;

					}

				}

			}

		}

		if ( needsBindingsUpdate === true ) {

			this.backend.updateBindings( bindGroup, bindings, cacheBindings ? cacheIndex : 0, version );

		}

	}

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}

function needsDoublePass( material ) {

	const hasTransmission = material.transmission > 0 || material.transmissionNode;

	return hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;

}

class RenderList {

	constructor( lighting, scene, camera ) {

		this.renderItems = [];
		this.renderItemsIndex = 0;

		this.opaque = [];
		this.transparentDoublePass = [];
		this.transparent = [];
		this.bundles = [];

		this.lightsNode = lighting.getNode( scene, camera );
		this.lightsArray = [];

		this.scene = scene;
		this.camera = camera;

		this.occlusionQueryCount = 0;

	}

	begin() {

		this.renderItemsIndex = 0;

		this.opaque.length = 0;
		this.transparentDoublePass.length = 0;
		this.transparent.length = 0;
		this.bundles.length = 0;

		this.lightsArray.length = 0;

		this.occlusionQueryCount = 0;

		return this;

	}

	getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext ) {

		let renderItem = this.renderItems[ this.renderItemsIndex ];

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group,
				clippingContext: clippingContext
			};

			this.renderItems[ this.renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;
			renderItem.clippingContext = clippingContext;

		}

		this.renderItemsIndex ++;

		return renderItem;

	}

	push( object, geometry, material, groupOrder, z, group, clippingContext ) {

		const renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );

		if ( object.occlusionTest === true ) this.occlusionQueryCount ++;

		if ( material.transparent === true || material.transmission > 0 ) {

			if ( needsDoublePass( material ) ) this.transparentDoublePass.push( renderItem );

			this.transparent.push( renderItem );

		} else {

			this.opaque.push( renderItem );

		}

	}

	unshift( object, geometry, material, groupOrder, z, group, clippingContext ) {

		const renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );

		if ( material.transparent === true || material.transmission > 0 ) {

			if ( needsDoublePass( material ) ) this.transparentDoublePass.unshift( renderItem );

			this.transparent.unshift( renderItem );

		} else {

			this.opaque.unshift( renderItem );

		}

	}

	pushBundle( group ) {

		this.bundles.push( group );

	}

	pushLight( light ) {

		this.lightsArray.push( light );

	}

	sort( customOpaqueSort, customTransparentSort ) {

		if ( this.opaque.length > 1 ) this.opaque.sort( customOpaqueSort || painterSortStable );
		if ( this.transparentDoublePass.length > 1 ) this.transparentDoublePass.sort( customTransparentSort || reversePainterSortStable );
		if ( this.transparent.length > 1 ) this.transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	finish() {

		// update lights

		this.lightsNode.setLights( this.lightsArray );

		// Clear references from inactive renderItems in the list

		for ( let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i ++ ) {

			const renderItem = this.renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.groupOrder = null;
			renderItem.renderOrder = null;
			renderItem.z = null;
			renderItem.group = null;
			renderItem.clippingContext = null;

		}

	}

}

class RenderLists {

	constructor( lighting ) {

		this.lighting = lighting;

		this.lists = new ChainMap();

	}

	get( scene, camera ) {

		const lists = this.lists;
		const keys = [ scene, camera ];

		let list = lists.get( keys );

		if ( list === undefined ) {

			list = new RenderList( this.lighting, scene, camera );
			lists.set( keys, list );

		}

		return list;

	}

	dispose() {

		this.lists = new ChainMap();

	}

}

let id$1 = 0;

class RenderContext {

	constructor() {

		this.id = id$1 ++;

		this.color = true;
		this.clearColor = true;
		this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };

		this.depth = true;
		this.clearDepth = true;
		this.clearDepthValue = 1;

		this.stencil = false;
		this.clearStencil = true;
		this.clearStencilValue = 1;

		this.viewport = false;
		this.viewportValue = new Vector4();

		this.scissor = false;
		this.scissorValue = new Vector4();

		this.textures = null;
		this.depthTexture = null;
		this.activeCubeFace = 0;
		this.sampleCount = 1;

		this.width = 0;
		this.height = 0;

		this.isRenderContext = true;

	}

	getCacheKey() {

		return getCacheKey( this );

	}

}

function getCacheKey( renderContext ) {

	const { textures, activeCubeFace } = renderContext;

	const values = [ activeCubeFace ];

	for ( const texture of textures ) {

		values.push( texture.id );

	}

	return hashArray( values );

}

class RenderContexts {

	constructor() {

		this.chainMaps = {};

	}

	get( scene, camera, renderTarget = null ) {

		const chainKey = [ scene, camera ];

		let attachmentState;

		if ( renderTarget === null ) {

			attachmentState = 'default';

		} else {

			const format = renderTarget.texture.format;
			const count = renderTarget.textures.length;

			attachmentState = `${ count }:${ format }:${ renderTarget.samples }:${ renderTarget.depthBuffer }:${ renderTarget.stencilBuffer }`;

		}

		const chainMap = this.getChainMap( attachmentState );

		let renderState = chainMap.get( chainKey );

		if ( renderState === undefined ) {

			renderState = new RenderContext();

			chainMap.set( chainKey, renderState );

		}

		if ( renderTarget !== null ) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;

		return renderState;

	}

	getChainMap( attachmentState ) {

		return this.chainMaps[ attachmentState ] || ( this.chainMaps[ attachmentState ] = new ChainMap() );

	}

	dispose() {

		this.chainMaps = {};

	}

}

const _size$3 = /*@__PURE__*/ new Vector3();

class Textures extends DataMap {

	constructor( renderer, backend, info ) {

		super();

		this.renderer = renderer;
		this.backend = backend;
		this.info = info;

	}

	updateRenderTarget( renderTarget, activeMipmapLevel = 0 ) {

		const renderTargetData = this.get( renderTarget );

		const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
		const depthTextureMips = renderTargetData.depthTextureMips || ( renderTargetData.depthTextureMips = {} );

		const textures = renderTarget.textures;

		const size = this.getSize( textures[ 0 ] );

		const mipWidth = size.width >> activeMipmapLevel;
		const mipHeight = size.height >> activeMipmapLevel;

		let depthTexture = renderTarget.depthTexture || depthTextureMips[ activeMipmapLevel ];
		const useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;

		let textureNeedsUpdate = false;

		if ( depthTexture === undefined && useDepthTexture ) {

			depthTexture = new DepthTexture();
			depthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;
			depthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType
			depthTexture.image.width = mipWidth;
			depthTexture.image.height = mipHeight;

			depthTextureMips[ activeMipmapLevel ] = depthTexture;

		}

		if ( renderTargetData.width !== size.width || size.height !== renderTargetData.height ) {

			textureNeedsUpdate = true;

			if ( depthTexture ) {

				depthTexture.needsUpdate = true;
				depthTexture.image.width = mipWidth;
				depthTexture.image.height = mipHeight;

			}

		}

		renderTargetData.width = size.width;
		renderTargetData.height = size.height;
		renderTargetData.textures = textures;
		renderTargetData.depthTexture = depthTexture || null;
		renderTargetData.depth = renderTarget.depthBuffer;
		renderTargetData.stencil = renderTarget.stencilBuffer;
		renderTargetData.renderTarget = renderTarget;

		if ( renderTargetData.sampleCount !== sampleCount ) {

			textureNeedsUpdate = true;

			if ( depthTexture ) {

				depthTexture.needsUpdate = true;

			}

			renderTargetData.sampleCount = sampleCount;

		}

		//

		const options = { sampleCount };

		for ( let i = 0; i < textures.length; i ++ ) {

			const texture = textures[ i ];

			if ( textureNeedsUpdate ) texture.needsUpdate = true;

			this.updateTexture( texture, options );

		}

		if ( depthTexture ) {

			this.updateTexture( depthTexture, options );

		}

		// dispose handler

		if ( renderTargetData.initialized !== true ) {

			renderTargetData.initialized = true;

			// dispose

			const onDispose = () => {

				renderTarget.removeEventListener( 'dispose', onDispose );

				for ( let i = 0; i < textures.length; i ++ ) {

					this._destroyTexture( textures[ i ] );

				}

				if ( depthTexture ) {

					this._destroyTexture( depthTexture );

				}

				this.delete( renderTarget );

			};

			renderTarget.addEventListener( 'dispose', onDispose );

		}

	}

	updateTexture( texture, options = {} ) {

		const textureData = this.get( texture );
		if ( textureData.initialized === true && textureData.version === texture.version ) return;

		const isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;
		const backend = this.backend;

		if ( isRenderTarget && textureData.initialized === true ) {

			// it's an update

			backend.destroySampler( texture );
			backend.destroyTexture( texture );

		}

		//

		if ( texture.isFramebufferTexture ) {

			const renderTarget = this.renderer.getRenderTarget();

			if ( renderTarget ) {

				texture.type = renderTarget.texture.type;

			} else {

				texture.type = UnsignedByteType;

			}

		}

		//

		const { width, height, depth } = this.getSize( texture );

		options.width = width;
		options.height = height;
		options.depth = depth;
		options.needsMipmaps = this.needsMipmaps( texture );
		options.levels = options.needsMipmaps ? this.getMipLevels( texture, width, height ) : 1;

		//

		if ( isRenderTarget || texture.isStorageTexture === true ) {

			backend.createSampler( texture );
			backend.createTexture( texture, options );

			textureData.generation = texture.version;

		} else {

			const needsCreate = textureData.initialized !== true;

			if ( needsCreate ) backend.createSampler( texture );

			if ( texture.version > 0 ) {

				const image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.Renderer: Texture marked for update but image is undefined.' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.Renderer: Texture marked for update but image is incomplete.' );

				} else {

					if ( texture.images ) {

						const images = [];

						for ( const image of texture.images ) {

							images.push( image );

						}

						options.images = images;

					} else {

						options.image = image;

					}

					if ( textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true ) {

						backend.createTexture( texture, options );

						textureData.isDefaultTexture = false;
						textureData.generation = texture.version;

					}

					if ( texture.source.dataReady === true ) backend.updateTexture( texture, options );

					if ( options.needsMipmaps && texture.mipmaps.length === 0 ) backend.generateMipmaps( texture );

				}

			} else {

				// async update

				backend.createDefaultTexture( texture );

				textureData.isDefaultTexture = true;
				textureData.generation = texture.version;

			}

		}

		// dispose handler

		if ( textureData.initialized !== true ) {

			textureData.initialized = true;
			textureData.generation = texture.version;

			//

			this.info.memory.textures ++;

			// dispose

			const onDispose = () => {

				texture.removeEventListener( 'dispose', onDispose );

				this._destroyTexture( texture );

				this.info.memory.textures --;

			};

			texture.addEventListener( 'dispose', onDispose );

		}

		//

		textureData.version = texture.version;

	}

	getSize( texture, target = _size$3 ) {

		let image = texture.images ? texture.images[ 0 ] : texture.image;

		if ( image ) {

			if ( image.image !== undefined ) image = image.image;

			target.width = image.width || 1;
			target.height = image.height || 1;
			target.depth = texture.isCubeTexture ? 6 : ( image.depth || 1 );

		} else {

			target.width = target.height = target.depth = 1;

		}

		return target;

	}

	getMipLevels( texture, width, height ) {

		let mipLevelCount;

		if ( texture.isCompressedTexture ) {

			if ( texture.mipmaps ) {

				mipLevelCount = texture.mipmaps.length;

			} else {

				mipLevelCount = 1;

			}

		} else {

			mipLevelCount = Math.floor( Math.log2( Math.max( width, height ) ) ) + 1;

		}

		return mipLevelCount;

	}

	needsMipmaps( texture ) {

		return this.isEnvironmentTexture( texture ) || texture.isCompressedTexture === true || texture.generateMipmaps;

	}

	isEnvironmentTexture( texture ) {

		const mapping = texture.mapping;

		return ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

	}

	_destroyTexture( texture ) {

		this.backend.destroySampler( texture );
		this.backend.destroyTexture( texture );

		this.delete( texture );

	}

}

class Color4 extends Color {

	constructor( r, g, b, a = 1 ) {

		super( r, g, b );

		this.a = a;

	}

	set( r, g, b, a = 1 ) {

		this.a = a;

		return super.set( r, g, b );

	}

	copy( color ) {

		if ( color.a !== undefined ) this.a = color.a;

		return super.copy( color );

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b, this.a );

	}

}

class ParameterNode extends PropertyNode {

	static get type() {

		return 'ParameterNode';

	}

	constructor( nodeType, name = null ) {

		super( nodeType, name );

		this.isParameterNode = true;

	}

	getHash() {

		return this.uuid;

	}

	generate() {

		return this.name;

	}

}

const parameter = ( type, name ) => nodeObject( new ParameterNode( type, name ) );

class StackNode extends Node {

	static get type() {

		return 'StackNode';

	}

	constructor( parent = null ) {

		super();

		this.nodes = [];
		this.outputNode = null;

		this.parent = parent;

		this._currentCond = null;

		this.isStackNode = true;

	}

	getNodeType( builder ) {

		return this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';

	}

	add( node ) {

		this.nodes.push( node );

		return this;

	}

	If( boolNode, method ) {

		const methodNode = new ShaderNode( method );
		this._currentCond = select( boolNode, methodNode );

		return this.add( this._currentCond );

	}

	ElseIf( boolNode, method ) {

		const methodNode = new ShaderNode( method );
		const ifNode = select( boolNode, methodNode );

		this._currentCond.elseNode = ifNode;
		this._currentCond = ifNode;

		return this;

	}

	Else( method ) {

		this._currentCond.elseNode = new ShaderNode( method );

		return this;

	}

	build( builder, ...params ) {

		const previousStack = getCurrentStack();

		setCurrentStack( this );

		for ( const node of this.nodes ) {

			node.build( builder, 'void' );

		}

		setCurrentStack( previousStack );

		return this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );

	}

	//

	else( ...params ) { // @deprecated, r168

		console.warn( 'TSL.StackNode: .else() has been renamed to .Else().' );
		return this.Else( ...params );

	}

	elseif( ...params ) { // @deprecated, r168

		console.warn( 'TSL.StackNode: .elseif() has been renamed to .ElseIf().' );
		return this.ElseIf( ...params );

	}

}

const stack = /*@__PURE__*/ nodeProxy( StackNode );

class StructTypeNode extends Node {

	static get type() {

		return 'StructTypeNode';

	}

	constructor( types ) {

		super();

		this.types = types;
		this.isStructTypeNode = true;

	}

	getMemberTypes() {

		return this.types;

	}

}

class OutputStructNode extends Node {

	static get type() {

		return 'OutputStructNode';

	}

	constructor( ...members ) {

		super();

		this.members = members;

		this.isOutputStructNode = true;

	}

	setup( builder ) {

		super.setup( builder );

		const members = this.members;
		const types = [];

		for ( let i = 0; i < members.length; i ++ ) {

			types.push( members[ i ].getNodeType( builder ) );

		}

		this.nodeType = builder.getStructTypeFromNode( new StructTypeNode( types ) ).name;

	}

	generate( builder, output ) {

		const propertyName = builder.getOutputStructName();
		const members = this.members;

		const structPrefix = propertyName !== '' ? propertyName + '.' : '';

		for ( let i = 0; i < members.length; i ++ ) {

			const snippet = members[ i ].build( builder, output );

			builder.addLineFlowCode( `${ structPrefix }m${ i } = ${ snippet }`, this );

		}

		return propertyName;

	}

}

const outputStruct = /*@__PURE__*/ nodeProxy( OutputStructNode );

function getTextureIndex( textures, name ) {

	for ( let i = 0; i < textures.length; i ++ ) {

		if ( textures[ i ].name === name ) {

			return i;

		}

	}

	return - 1;

}

class MRTNode extends OutputStructNode {

	static get type() {

		return 'MRTNode';

	}

	constructor( outputNodes ) {

		super();

		this.outputNodes = outputNodes;

		this.isMRTNode = true;

	}

	has( name ) {

		return this.outputNodes[ name ] !== undefined;

	}

	get( name ) {

		return this.outputNodes[ name ];

	}

	merge( mrtNode ) {

		const outputs = { ...this.outputNodes, ...mrtNode.outputNodes };

		return mrt( outputs );

	}

	setup( builder ) {

		const outputNodes = this.outputNodes;
		const mrt = builder.renderer.getRenderTarget();

		const members = [];

		const textures = mrt.textures;

		for ( const name in outputNodes ) {

			const index = getTextureIndex( textures, name );

			members[ index ] = vec4( outputNodes[ name ] );

		}

		this.members = members;

		return super.setup( builder );

	}

}

const mrt = /*@__PURE__*/ nodeProxy( MRTNode );

const hash = /*@__PURE__*/ Fn( ( [ seed ] ) => {

	// Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org

	const state = seed.toUint().mul( 747796405 ).add( 2891336453 );
	const word = state.shiftRight( state.shiftRight( 28 ).add( 4 ) ).bitXor( state ).mul( 277803737 );
	const result = word.shiftRight( 22 ).bitXor( word );

	return result.toFloat().mul( 1 / 2 ** 32 ); // Convert to range [0, 1)

} );

// remapping functions https://iquilezles.org/articles/functions/
const parabola = ( x, k ) => pow( mul( 4.0, x.mul( sub( 1.0, x ) ) ), k );
const gain = ( x, k ) => x.lessThan( 0.5 ) ? parabola( x.mul( 2.0 ), k ).div( 2.0 ) : sub( 1.0, parabola( mul( sub( 1.0, x ), 2.0 ), k ).div( 2.0 ) );
const pcurve = ( x, a, b ) => pow( div( pow( x, a ), add( pow( x, a ), pow( sub( 1.0, x ), b ) ) ), 1.0 / a );
const sinc = ( x, k ) => sin( PI.mul( k.mul( x ).sub( 1.0 ) ) ).div( PI.mul( k.mul( x ).sub( 1.0 ) ) );

// https://github.com/cabbibo/glsl-tri-noise-3d


const tri = /*@__PURE__*/ Fn( ( [ x ] ) => {

	return x.fract().sub( .5 ).abs();

} ).setLayout( {
	name: 'tri',
	type: 'float',
	inputs: [
		{ name: 'x', type: 'float' }
	]
} );

const tri3 = /*@__PURE__*/ Fn( ( [ p ] ) => {

	return vec3( tri( p.z.add( tri( p.y.mul( 1. ) ) ) ), tri( p.z.add( tri( p.x.mul( 1. ) ) ) ), tri( p.y.add( tri( p.x.mul( 1. ) ) ) ) );

} ).setLayout( {
	name: 'tri3',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const triNoise3D = /*@__PURE__*/ Fn( ( [ p_immutable, spd, time ] ) => {

	const p = vec3( p_immutable ).toVar();
	const z = float( 1.4 ).toVar();
	const rz = float( 0.0 ).toVar();
	const bp = vec3( p ).toVar();

	Loop( { start: float( 0.0 ), end: float( 3.0 ), type: 'float', condition: '<=' }, () => {

		const dg = vec3( tri3( bp.mul( 2.0 ) ) ).toVar();
		p.addAssign( dg.add( time.mul( float( 0.1 ).mul( spd ) ) ) );
		bp.mulAssign( 1.8 );
		z.mulAssign( 1.5 );
		p.mulAssign( 1.2 );

		const t = float( tri( p.z.add( tri( p.x.add( tri( p.y ) ) ) ) ) ).toVar();
		rz.addAssign( t.div( z ) );
		bp.addAssign( 0.14 );

	} );

	return rz;

} ).setLayout( {
	name: 'triNoise3D',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'spd', type: 'float' },
		{ name: 'time', type: 'float' }
	]
} );

class FunctionOverloadingNode extends Node {

	static get type() {

		return 'FunctionOverloadingNode';

	}

	constructor( functionNodes = [], ...parametersNodes ) {

		super();

		this.functionNodes = functionNodes;
		this.parametersNodes = parametersNodes;

		this._candidateFnCall = null;

		this.global = true;

	}

	getNodeType() {

		return this.functionNodes[ 0 ].shaderNode.layout.type;

	}

	setup( builder ) {

		const params = this.parametersNodes;

		let candidateFnCall = this._candidateFnCall;

		if ( candidateFnCall === null ) {

			let candidateFn = null;
			let candidateScore = - 1;

			for ( const functionNode of this.functionNodes ) {

				const shaderNode = functionNode.shaderNode;
				const layout = shaderNode.layout;

				if ( layout === null ) {

					throw new Error( 'FunctionOverloadingNode: FunctionNode must be a layout.' );

				}

				const inputs = layout.inputs;

				if ( params.length === inputs.length ) {

					let score = 0;

					for ( let i = 0; i < params.length; i ++ ) {

						const param = params[ i ];
						const input = inputs[ i ];

						if ( param.getNodeType( builder ) === input.type ) {

							score ++;

						} else {

							score = 0;

						}

					}

					if ( score > candidateScore ) {

						candidateFn = functionNode;
						candidateScore = score;

					}

				}

			}

			this._candidateFnCall = candidateFnCall = candidateFn( ...params );

		}

		return candidateFnCall;

	}

}

const overloadingBaseFn = /*@__PURE__*/ nodeProxy( FunctionOverloadingNode );

const overloadingFn = ( functionNodes ) => ( ...params ) => overloadingBaseFn( functionNodes, ...params );

const time = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.time );
const deltaTime = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.deltaTime );
const frameId = /*@__PURE__*/ uniform( 0, 'uint' ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.frameId );

// Deprecated

const timerLocal = ( timeScale = 1 ) => { // @deprecated, r170

	console.warn( 'TSL: timerLocal() is deprecated. Use "time" instead.' );
	return time.mul( timeScale );

};

const timerGlobal = ( timeScale = 1 ) => { // @deprecated, r170

	console.warn( 'TSL: timerGlobal() is deprecated. Use "time" instead.' );
	return time.mul( timeScale );

};

const timerDelta = ( timeScale = 1 ) => { // @deprecated, r170

	console.warn( 'TSL: timerDelta() is deprecated. Use "deltaTime" instead.' );
	return deltaTime.mul( timeScale );

};

const oscSine = ( t = time ) => t.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );
const oscSquare = ( t = time ) => t.fract().round();
const oscTriangle = ( t = time ) => t.add( 0.5 ).fract().mul( 2 ).sub( 1 ).abs();
const oscSawtooth = ( t = time ) => t.fract();

const rotateUV = /*@__PURE__*/ Fn( ( [ uv, rotation, center = vec2( 0.5 ) ] ) => {

	return rotate( uv.sub( center ), rotation ).add( center );

} );

const spherizeUV = /*@__PURE__*/ Fn( ( [ uv, strength, center = vec2( 0.5 ) ] ) => {

	const delta = uv.sub( center );
	const delta2 = delta.dot( delta );
	const delta4 = delta2.mul( delta2 );
	const deltaOffset = delta4.mul( strength );

	return uv.add( delta.mul( deltaOffset ) );

} );

const billboarding = /*@__PURE__*/ Fn( ( { position = null, horizontal = true, vertical = false } ) => {

	let worldMatrix;

	if ( position !== null ) {

		worldMatrix = modelWorldMatrix.toVar();
		worldMatrix[ 3 ][ 0 ] = position.x;
		worldMatrix[ 3 ][ 1 ] = position.y;
		worldMatrix[ 3 ][ 2 ] = position.z;

	} else {

		worldMatrix = modelWorldMatrix;

	}

	const modelViewMatrix = cameraViewMatrix.mul( worldMatrix );

	if ( defined( horizontal ) ) {

		modelViewMatrix[ 0 ][ 0 ] = modelWorldMatrix[ 0 ].length();
		modelViewMatrix[ 0 ][ 1 ] = 0;
		modelViewMatrix[ 0 ][ 2 ] = 0;

	}

	if ( defined( vertical ) ) {

		modelViewMatrix[ 1 ][ 0 ] = 0;
		modelViewMatrix[ 1 ][ 1 ] = modelWorldMatrix[ 1 ].length();
		modelViewMatrix[ 1 ][ 2 ] = 0;

	}

	modelViewMatrix[ 2 ][ 0 ] = 0;
	modelViewMatrix[ 2 ][ 1 ] = 0;
	modelViewMatrix[ 2 ][ 2 ] = 1;

	return cameraProjectionMatrix.mul( modelViewMatrix ).mul( positionLocal );

} );

const viewportSafeUV = /*@__PURE__*/ Fn( ( [ uv = null ] ) => {

	const depth = linearDepth();
	const depthDiff = linearDepth( viewportDepthTexture( uv ) ).sub( depth );
	const finalUV = depthDiff.lessThan( 0 ).select( screenUV, uv );

	return finalUV;

} );

class SpriteSheetUVNode extends Node {

	static get type() {

		return 'SpriteSheetUVNode';

	}

	constructor( countNode, uvNode = uv(), frameNode = float( 0 ) ) {

		super( 'vec2' );

		this.countNode = countNode;
		this.uvNode = uvNode;
		this.frameNode = frameNode;

	}

	setup() {

		const { frameNode, uvNode, countNode } = this;

		const { width, height } = countNode;

		const frameNum = frameNode.mod( width.mul( height ) ).floor();

		const column = frameNum.mod( width );
		const row = height.sub( frameNum.add( 1 ).div( width ).ceil() );

		const scale = countNode.reciprocal();
		const uvFrameOffset = vec2( column, row );

		return uvNode.add( uvFrameOffset ).mul( scale );

	}

}

const spritesheetUV = /*@__PURE__*/ nodeProxy( SpriteSheetUVNode );

class TriplanarTexturesNode extends Node {

	static get type() {

		return 'TriplanarTexturesNode';

	}

	constructor( textureXNode, textureYNode = null, textureZNode = null, scaleNode = float( 1 ), positionNode = positionLocal, normalNode = normalLocal ) {

		super( 'vec4' );

		this.textureXNode = textureXNode;
		this.textureYNode = textureYNode;
		this.textureZNode = textureZNode;

		this.scaleNode = scaleNode;

		this.positionNode = positionNode;
		this.normalNode = normalNode;

	}

	setup() {

		const { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;

		// Ref: https://github.com/keijiro/StandardTriplanar

		// Blending factor of triplanar mapping
		let bf = normalNode.abs().normalize();
		bf = bf.div( bf.dot( vec3( 1.0 ) ) );

		// Triplanar mapping
		const tx = positionNode.yz.mul( scaleNode );
		const ty = positionNode.zx.mul( scaleNode );
		const tz = positionNode.xy.mul( scaleNode );

		// Base color
		const textureX = textureXNode.value;
		const textureY = textureYNode !== null ? textureYNode.value : textureX;
		const textureZ = textureZNode !== null ? textureZNode.value : textureX;

		const cx = texture( textureX, tx ).mul( bf.x );
		const cy = texture( textureY, ty ).mul( bf.y );
		const cz = texture( textureZ, tz ).mul( bf.z );

		return add( cx, cy, cz );

	}

}

const triplanarTextures = /*@__PURE__*/ nodeProxy( TriplanarTexturesNode );
const triplanarTexture = ( ...params ) => triplanarTextures( ...params );

const _reflectorPlane = new Plane();
const _normal = new Vector3();
const _reflectorWorldPosition = new Vector3();
const _cameraWorldPosition = new Vector3();
const _rotationMatrix = new Matrix4();
const _lookAtPosition = new Vector3( 0, 0, - 1 );
const clipPlane = new Vector4();

const _view = new Vector3();
const _target = new Vector3();
const _q = new Vector4();

const _size$2 = new Vector2();

const _defaultRT = new RenderTarget();
const _defaultUV = screenUV.flipX();

_defaultRT.depthTexture = new DepthTexture( 1, 1 );

let _inReflector = false;

class ReflectorNode extends TextureNode {

	static get type() {

		return 'ReflectorNode';

	}

	constructor( parameters = {} ) {

		super( parameters.defaultTexture || _defaultRT.texture, _defaultUV );

		this._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode( this, parameters );
		this._depthNode = null;

		this.setUpdateMatrix( false );

	}

	get reflector() {

		return this._reflectorBaseNode;

	}

	get target() {

		return this._reflectorBaseNode.target;

	}

	getDepthNode() {

		if ( this._depthNode === null ) {

			if ( this._reflectorBaseNode.depth !== true ) {

				throw new Error( 'THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ' );

			}

			this._depthNode = nodeObject( new ReflectorNode( {
				defaultTexture: _defaultRT.depthTexture,
				reflector: this._reflectorBaseNode
			} ) );

		}

		return this._depthNode;

	}

	setup( builder ) {

		// ignore if used in post-processing
		if ( ! builder.object.isQuadMesh ) this._reflectorBaseNode.build( builder );

		return super.setup( builder );

	}

	clone() {

		const texture = new this.constructor( this.reflectorNode );
		texture._reflectorBaseNode = this._reflectorBaseNode;

		return texture;

	}

}


class ReflectorBaseNode extends Node {

	static get type() {

		return 'ReflectorBaseNode';

	}

	constructor( textureNode, parameters = {} ) {

		super();

		const {
			target = new Object3D(),
			resolution = 1,
			generateMipmaps = false,
			bounces = true,
			depth = false
		} = parameters;

		//

		this.textureNode = textureNode;

		this.target = target;
		this.resolution = resolution;
		this.generateMipmaps = generateMipmaps;
		this.bounces = bounces;
		this.depth = depth;

		this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;

		this.virtualCameras = new WeakMap();
		this.renderTargets = new WeakMap();

	}

	_updateResolution( renderTarget, renderer ) {

		const resolution = this.resolution;

		renderer.getDrawingBufferSize( _size$2 );

		renderTarget.setSize( Math.round( _size$2.width * resolution ), Math.round( _size$2.height * resolution ) );

	}

	setup( builder ) {

		this._updateResolution( _defaultRT, builder.renderer );

		return super.setup( builder );

	}

	getVirtualCamera( camera ) {

		let virtualCamera = this.virtualCameras.get( camera );

		if ( virtualCamera === undefined ) {

			virtualCamera = camera.clone();

			this.virtualCameras.set( camera, virtualCamera );

		}

		return virtualCamera;

	}

	getRenderTarget( camera ) {

		let renderTarget = this.renderTargets.get( camera );

		if ( renderTarget === undefined ) {

			renderTarget = new RenderTarget( 0, 0, { type: HalfFloatType } );

			if ( this.generateMipmaps === true ) {

				renderTarget.texture.minFilter = LinearMipMapLinearFilter;
				renderTarget.texture.generateMipmaps = true;

			}

			if ( this.depth === true ) {

				renderTarget.depthTexture = new DepthTexture();

			}

			this.renderTargets.set( camera, renderTarget );

		}

		return renderTarget;

	}

	updateBefore( frame ) {

		if ( this.bounces === false && _inReflector ) return;

		_inReflector = true;

		const { scene, camera, renderer, material } = frame;
		const { target } = this;

		const virtualCamera = this.getVirtualCamera( camera );
		const renderTarget = this.getRenderTarget( virtualCamera );

		renderer.getDrawingBufferSize( _size$2 );

		this._updateResolution( renderTarget, renderer );

		//

		_reflectorWorldPosition.setFromMatrixPosition( target.matrixWorld );
		_cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );

		_rotationMatrix.extractRotation( target.matrixWorld );

		_normal.set( 0, 0, 1 );
		_normal.applyMatrix4( _rotationMatrix );

		_view.subVectors( _reflectorWorldPosition, _cameraWorldPosition );

		// Avoid rendering when reflector is facing away

		if ( _view.dot( _normal ) > 0 ) return;

		_view.reflect( _normal ).negate();
		_view.add( _reflectorWorldPosition );

		_rotationMatrix.extractRotation( camera.matrixWorld );

		_lookAtPosition.set( 0, 0, - 1 );
		_lookAtPosition.applyMatrix4( _rotationMatrix );
		_lookAtPosition.add( _cameraWorldPosition );

		_target.subVectors( _reflectorWorldPosition, _lookAtPosition );
		_target.reflect( _normal ).negate();
		_target.add( _reflectorWorldPosition );

		//

		virtualCamera.coordinateSystem = camera.coordinateSystem;
		virtualCamera.position.copy( _view );
		virtualCamera.up.set( 0, 1, 0 );
		virtualCamera.up.applyMatrix4( _rotationMatrix );
		virtualCamera.up.reflect( _normal );
		virtualCamera.lookAt( _target );

		virtualCamera.near = camera.near;
		virtualCamera.far = camera.far;

		virtualCamera.updateMatrixWorld();
		virtualCamera.projectionMatrix.copy( camera.projectionMatrix );

		// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
		// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
		_reflectorPlane.setFromNormalAndCoplanarPoint( _normal, _reflectorWorldPosition );
		_reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );

		clipPlane.set( _reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant );

		const projectionMatrix = virtualCamera.projectionMatrix;

		_q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];
		_q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];
		_q.z = - 1.0;
		_q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];

		// Calculate the scaled plane vector
		clipPlane.multiplyScalar( 1.0 / clipPlane.dot( _q ) );

		const clipBias = 0;

		// Replacing the third row of the projection matrix
		projectionMatrix.elements[ 2 ] = clipPlane.x;
		projectionMatrix.elements[ 6 ] = clipPlane.y;
		projectionMatrix.elements[ 10 ] = ( renderer.coordinateSystem === WebGPUCoordinateSystem ) ? ( clipPlane.z - clipBias ) : ( clipPlane.z + 1.0 - clipBias );
		projectionMatrix.elements[ 14 ] = clipPlane.w;

		//

		this.textureNode.value = renderTarget.texture;

		if ( this.depth === true ) {

			this.textureNode.getDepthNode().value = renderTarget.depthTexture;

		}

		material.visible = false;

		const currentRenderTarget = renderer.getRenderTarget();
		const currentMRT = renderer.getMRT();

		renderer.setMRT( null );
		renderer.setRenderTarget( renderTarget );

		renderer.render( scene, virtualCamera );

		renderer.setMRT( currentMRT );
		renderer.setRenderTarget( currentRenderTarget );

		material.visible = true;

		_inReflector = false;

	}

}

const reflector = ( parameters ) => nodeObject( new ReflectorNode( parameters ) );

// Helper for passes that need to fill the viewport with a single quad.

const _camera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

class QuadGeometry extends BufferGeometry {

	constructor( flipY = false ) {

		super();

		const uv = flipY === false ? [ 0, - 1, 0, 1, 2, 1 ] : [ 0, 2, 0, 0, 2, 0 ];

		this.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );

	}

}

const _geometry = /*@__PURE__*/ new QuadGeometry();

class QuadMesh extends Mesh {

	constructor( material = null ) {

		super( _geometry, material );

		this.camera = _camera;

		this.isQuadMesh = true;

	}

	renderAsync( renderer ) {

		return renderer.renderAsync( this, _camera );

	}

	render( renderer ) {

		renderer.render( this, _camera );

	}

}

const _size$1 = /*@__PURE__*/ new Vector2();

class RTTNode extends TextureNode {

	static get type() {

		return 'RTTNode';

	}

	constructor( node, width = null, height = null, options = { type: HalfFloatType } ) {

		const renderTarget = new RenderTarget( width, height, options );

		super( renderTarget.texture, uv() );

		this.node = node;
		this.width = width;
		this.height = height;

		this.renderTarget = renderTarget;

		this.textureNeedsUpdate = true;
		this.autoUpdate = true;

		this.updateMap = new WeakMap();

		this._rttNode = null;
		this._quadMesh = new QuadMesh( new NodeMaterial() );

		this.updateBeforeType = NodeUpdateType.RENDER;

	}

	get autoSize() {

		return this.width === null;

	}

	setup( builder ) {

		this._rttNode = this.node.context( builder.getSharedContext() );
		this._quadMesh.material.name = 'RTT';
		this._quadMesh.material.needsUpdate = true;

		return super.setup( builder );

	}

	setSize( width, height ) {

		this.width = width;
		this.height = height;

		const effectiveWidth = width * this.pixelRatio;
		const effectiveHeight = height * this.pixelRatio;

		this.renderTarget.setSize( effectiveWidth, effectiveHeight );

		this.textureNeedsUpdate = true;

	}

	setPixelRatio( pixelRatio ) {

		this.pixelRatio = pixelRatio;

		this.setSize( this.width, this.height );

	}

	updateBefore( { renderer } ) {

		if ( this.textureNeedsUpdate === false && this.autoUpdate === false ) return;

		this.textureNeedsUpdate = false;

		//

		if ( this.autoSize === true ) {

			this.pixelRatio = renderer.getPixelRatio();

			const size = renderer.getSize( _size$1 );

			this.setSize( size.width, size.height );

		}

		//

		this._quadMesh.material.fragmentNode = this._rttNode;

		//

		const currentRenderTarget = renderer.getRenderTarget();

		renderer.setRenderTarget( this.renderTarget );

		this._quadMesh.render( renderer );

		renderer.setRenderTarget( currentRenderTarget );

	}

	clone() {

		const newNode = new TextureNode( this.value, this.uvNode, this.levelNode );
		newNode.sampler = this.sampler;
		newNode.referenceNode = this;

		return newNode;

	}

}

const rtt = ( node, ...params ) => nodeObject( new RTTNode( nodeObject( node ), ...params ) );

const convertToTexture = ( node, ...params ) => {

	if ( node.isTextureNode ) return node;
	if ( node.isPassNode ) return node.getTextureNode();

	return rtt( node, ...params );

};

/**
* Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments
* depth value and the camera's inverse projection matrix.
*
* @param {vec2} screenPosition - The fragment's screen position expressed as uv coordinates.
* @param {float} depth - The fragment's depth value.
* @param {mat4} projectionMatrixInverse - The camera's inverse projection matrix.
* @return {vec3} The fragments position in view space.
*/
const getViewPosition = /*@__PURE__*/ Fn( ( [ screenPosition, depth, projectionMatrixInverse ], builder ) => {

	let clipSpacePosition;

	if ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem ) {

		screenPosition = vec2( screenPosition.x, screenPosition.y.oneMinus() ).mul( 2.0 ).sub( 1.0 );
		clipSpacePosition = vec4( vec3( screenPosition, depth ), 1.0 );

	} else {

		clipSpacePosition = vec4( vec3( screenPosition.x, screenPosition.y.oneMinus(), depth ).mul( 2.0 ).sub( 1.0 ), 1.0 );

	}

	const viewSpacePosition = vec4( projectionMatrixInverse.mul( clipSpacePosition ) );

	return viewSpacePosition.xyz.div( viewSpacePosition.w );

} );

/**
* Computes a screen position expressed as uv coordinates based on a fragment's position in view space
* and the camera's projection matrix
*
* @param {vec3} viewPosition - The fragments position in view space.
* @param {mat4} projectionMatrix - The camera's projection matrix.
* @return {vec2} The fragment's screen position expressed as uv coordinates.
*/
const getScreenPosition = /*@__PURE__*/ Fn( ( [ viewPosition, projectionMatrix ] ) => {

	const sampleClipPos = projectionMatrix.mul( vec4( viewPosition, 1.0 ) );
	const sampleUv = sampleClipPos.xy.div( sampleClipPos.w ).mul( 0.5 ).add( 0.5 ).toVar();
	return vec2( sampleUv.x, sampleUv.y.oneMinus() );

} );

/**
* Computes a normal vector based on depth data. Can be used as a fallback when no normal render
* target is available or if flat surface normals are required.
*
* @param {vec2} uv - The texture coordinate.
* @param {DepthTexture} depthTexture - The depth texture.
* @param {mat4} projectionMatrixInverse - The camera's inverse projection matrix.
* @return {vec3} The computed normal vector.
*/
const getNormalFromDepth = /*@__PURE__*/ Fn( ( [ uv, depthTexture, projectionMatrixInverse ] ) => {

	const size = textureSize( textureLoad( depthTexture ) );
	const p = ivec2( uv.mul( size ) ).toVar();

	const c0 = textureLoad( depthTexture, p ).toVar();

	const l2 = textureLoad( depthTexture, p.sub( ivec2( 2, 0 ) ) ).toVar();
	const l1 = textureLoad( depthTexture, p.sub( ivec2( 1, 0 ) ) ).toVar();
	const r1 = textureLoad( depthTexture, p.add( ivec2( 1, 0 ) ) ).toVar();
	const r2 = textureLoad( depthTexture, p.add( ivec2( 2, 0 ) ) ).toVar();
	const b2 = textureLoad( depthTexture, p.add( ivec2( 0, 2 ) ) ).toVar();
	const b1 = textureLoad( depthTexture, p.add( ivec2( 0, 1 ) ) ).toVar();
	const t1 = textureLoad( depthTexture, p.sub( ivec2( 0, 1 ) ) ).toVar();
	const t2 = textureLoad( depthTexture, p.sub( ivec2( 0, 2 ) ) ).toVar();

	const dl = abs( sub( float( 2 ).mul( l1 ).sub( l2 ), c0 ) ).toVar();
	const dr = abs( sub( float( 2 ).mul( r1 ).sub( r2 ), c0 ) ).toVar();
	const db = abs( sub( float( 2 ).mul( b1 ).sub( b2 ), c0 ) ).toVar();
	const dt = abs( sub( float( 2 ).mul( t1 ).sub( t2 ), c0 ) ).toVar();

	const ce = getViewPosition( uv, c0, projectionMatrixInverse ).toVar();

	const dpdx = dl.lessThan( dr ).select( ce.sub( getViewPosition( uv.sub( vec2( float( 1 ).div( size.x ), 0 ) ), l1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.add( vec2( float( 1 ).div( size.x ), 0 ) ), r1, projectionMatrixInverse ) ) );
	const dpdy = db.lessThan( dt ).select( ce.sub( getViewPosition( uv.add( vec2( 0, float( 1 ).div( size.y ) ) ), b1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.sub( vec2( 0, float( 1 ).div( size.y ) ) ), t1, projectionMatrixInverse ) ) );

	return normalize( cross( dpdx, dpdy ) );

} );

class StorageInstancedBufferAttribute extends InstancedBufferAttribute {

	constructor( array, itemSize, typeClass = Float32Array ) {

		if ( ArrayBuffer.isView( array ) === false ) array = new typeClass( array * itemSize );

		super( array, itemSize );

		this.isStorageInstancedBufferAttribute = true;

	}

}

class StorageBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, typeClass = Float32Array ) {

		if ( ArrayBuffer.isView( array ) === false ) array = new typeClass( array * itemSize );

		super( array, itemSize );

		this.isStorageBufferAttribute = true;

	}

}

class StorageArrayElementNode extends ArrayElementNode {

	static get type() {

		return 'StorageArrayElementNode';

	}

	constructor( storageBufferNode, indexNode ) {

		super( storageBufferNode, indexNode );

		this.isStorageArrayElementNode = true;

	}

	set storageBufferNode( value ) {

		this.node = value;

	}

	get storageBufferNode() {

		return this.node;

	}

	setup( builder ) {

		if ( builder.isAvailable( 'storageBuffer' ) === false ) {

			if ( this.node.isPBO === true ) {

				builder.setupPBO( this.node );

			}

		}

		return super.setup( builder );

	}

	generate( builder, output ) {

		let snippet;

		const isAssignContext = builder.context.assign;

		//

		if ( builder.isAvailable( 'storageBuffer' ) === false ) {

			if ( this.node.isPBO === true && isAssignContext !== true && ( this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute' ) ) {

				snippet = builder.generatePBO( this );

			} else {

				snippet = this.node.build( builder );

			}

		} else {

			snippet = super.generate( builder );

		}

		if ( isAssignContext !== true ) {

			const type = this.getNodeType( builder );

			snippet = builder.format( snippet, type, output );

		}

		return snippet;

	}

}

const storageElement = /*@__PURE__*/ nodeProxy( StorageArrayElementNode );

class StorageBufferNode extends BufferNode {

	static get type() {

		return 'StorageBufferNode';

	}

	constructor( value, bufferType = null, bufferCount = 0 ) {

		if ( bufferType === null && ( value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute ) ) {

			bufferType = getTypeFromLength( value.itemSize );
			bufferCount = value.count;

		}

		super( value, bufferType, bufferCount );

		this.isStorageBufferNode = true;

		this.access = NodeAccess.READ_WRITE;
		this.isAtomic = false;
		this.isPBO = false;

		this.bufferCount = bufferCount;

		this._attribute = null;
		this._varying = null;

		this.global = true;

		if ( value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true ) {

			// TOOD: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer

			if ( value.isInstancedBufferAttribute ) value.isStorageInstancedBufferAttribute = true;
			else value.isStorageBufferAttribute = true;

		}

	}

	getHash( builder ) {

		if ( this.bufferCount === 0 ) {

			let bufferData = builder.globalCache.getData( this.value );

			if ( bufferData === undefined ) {

				bufferData = {
					node: this
				};

				builder.globalCache.setData( this.value, bufferData );

			}

			return bufferData.node.uuid;

		}

		return this.uuid;

	}

	getInputType( /*builder*/ ) {

		return this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';

	}

	element( indexNode ) {

		return storageElement( this, indexNode );

	}

	setPBO( value ) {

		this.isPBO = value;

		return this;

	}

	getPBO() {

		return this.isPBO;

	}

	setAccess( value ) {

		this.access = value;

		return this;

	}

	toReadOnly() {

		return this.setAccess( NodeAccess.READ_ONLY );

	}

	setAtomic( value ) {

		this.isAtomic = value;

		return this;

	}

	toAtomic() {

		return this.setAtomic( true );

	}

	getAttributeData() {

		if ( this._attribute === null ) {

			this._attribute = bufferAttribute( this.value );
			this._varying = varying( this._attribute );

		}

		return {
			attribute: this._attribute,
			varying: this._varying
		};

	}

	getNodeType( builder ) {

		if ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {

			return super.getNodeType( builder );

		}

		const { attribute } = this.getAttributeData();

		return attribute.getNodeType( builder );

	}

	generate( builder ) {

		if ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {

			return super.generate( builder );

		}

		const { attribute, varying } = this.getAttributeData();

		const output = varying.build( builder );

		builder.registerTransform( output, attribute );

		return output;

	}

}

const storage = ( value, type, count ) => nodeObject( new StorageBufferNode( value, type, count ) );

const storageObject = ( value, type, count ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.' );

	return storage( value, type, count ).setPBO( true );

};

const attributeArray = ( count, type = 'float' ) => {

	const itemSize = getLengthFromType( type );

	const buffer = new StorageBufferAttribute( count, itemSize );
	const node = storage( buffer, type, count );

	return node;

};


const instancedArray = ( count, type = 'float' ) => {

	const itemSize = getLengthFromType( type );

	const buffer = new StorageInstancedBufferAttribute( count, itemSize );
	const node = storage( buffer, type, count );

	return node;

};

class VertexColorNode extends AttributeNode {

	static get type() {

		return 'VertexColorNode';

	}

	constructor( index = 0 ) {

		super( null, 'vec4' );

		this.isVertexColorNode = true;

		this.index = index;

	}

	getAttributeName( /*builder*/ ) {

		const index = this.index;

		return 'color' + ( index > 0 ? index : '' );

	}

	generate( builder ) {

		const attributeName = this.getAttributeName( builder );
		const geometryAttribute = builder.hasGeometryAttribute( attributeName );

		let result;

		if ( geometryAttribute === true ) {

			result = super.generate( builder );

		} else {

			// Vertex color fallback should be white
			result = builder.generateConst( this.nodeType, new Vector4( 1, 1, 1, 1 ) );

		}

		return result;

	}

	serialize( data ) {

		super.serialize( data );

		data.index = this.index;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.index = data.index;

	}

}

const vertexColor = ( ...params ) => nodeObject( new VertexColorNode( ...params ) );

class PointUVNode extends Node {

	static get type() {

		return 'PointUVNode';

	}

	constructor() {

		super( 'vec2' );

		this.isPointUVNode = true;

	}

	generate( /*builder*/ ) {

		return 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';

	}

}

const pointUV = /*@__PURE__*/ nodeImmutable( PointUVNode );

const _e1 = /*@__PURE__*/ new Euler();
const _m1 = /*@__PURE__*/ new Matrix4();

class SceneNode extends Node {

	static get type() {

		return 'SceneNode';

	}

	constructor( scope = SceneNode.BACKGROUND_BLURRINESS, scene = null ) {

		super();

		this.scope = scope;
		this.scene = scene;

	}

	setup( builder ) {

		const scope = this.scope;
		const scene = this.scene !== null ? this.scene : builder.scene;

		let output;

		if ( scope === SceneNode.BACKGROUND_BLURRINESS ) {

			output = reference( 'backgroundBlurriness', 'float', scene );

		} else if ( scope === SceneNode.BACKGROUND_INTENSITY ) {

			output = reference( 'backgroundIntensity', 'float', scene );

		} else if ( scope === SceneNode.BACKGROUND_ROTATION ) {

			output = uniform( 'mat4' ).label( 'backgroundRotation' ).setGroup( renderGroup ).onRenderUpdate( () => {

				const background = scene.background;

				if ( background !== null && background.isTexture && background.mapping !== UVMapping ) {

					_e1.copy( scene.backgroundRotation );

					// accommodate left-handed frame
					_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;

					_m1.makeRotationFromEuler( _e1 );

				} else {

					_m1.identity();

				}

				return _m1;

			} );

		} else {

			console.error( 'THREE.SceneNode: Unknown scope:', scope );

		}

		return output;

	}

}

SceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';
SceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';
SceneNode.BACKGROUND_ROTATION = 'backgroundRotation';

const backgroundBlurriness = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_BLURRINESS );
const backgroundIntensity = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_INTENSITY );
const backgroundRotation = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_ROTATION );

class StorageTextureNode extends TextureNode {

	static get type() {

		return 'StorageTextureNode';

	}

	constructor( value, uvNode, storeNode = null ) {

		super( value, uvNode );

		this.storeNode = storeNode;

		this.isStorageTextureNode = true;

		this.access = NodeAccess.WRITE_ONLY;

	}

	getInputType( /*builder*/ ) {

		return 'storageTexture';

	}

	setup( builder ) {

		super.setup( builder );

		const properties = builder.getNodeProperties( this );
		properties.storeNode = this.storeNode;

	}

	setAccess( value ) {

		this.access = value;
		return this;

	}

	generate( builder, output ) {

		let snippet;

		if ( this.storeNode !== null ) {

			snippet = this.generateStore( builder );

		} else {

			snippet = super.generate( builder, output );

		}

		return snippet;

	}

	toReadWrite() {

		return this.setAccess( NodeAccess.READ_WRITE );

	}

	toReadOnly() {

		return this.setAccess( NodeAccess.READ_ONLY );

	}

	toWriteOnly() {

		return this.setAccess( NodeAccess.WRITE_ONLY );

	}

	generateStore( builder ) {

		const properties = builder.getNodeProperties( this );

		const { uvNode, storeNode } = properties;

		const textureProperty = super.generate( builder, 'property' );
		const uvSnippet = uvNode.build( builder, 'uvec2' );
		const storeSnippet = storeNode.build( builder, 'vec4' );

		const snippet = builder.generateTextureStore( builder, textureProperty, uvSnippet, storeSnippet );

		builder.addLineFlowCode( snippet, this );

	}

}

const storageTexture = /*@__PURE__*/ nodeProxy( StorageTextureNode );

const textureStore = ( value, uvNode, storeNode ) => {

	const node = storageTexture( value, uvNode, storeNode );

	if ( storeNode !== null ) node.append();

	return node;

};

class UserDataNode extends ReferenceNode {

	static get type() {

		return 'UserDataNode';

	}

	constructor( property, inputType, userData = null ) {

		super( property, inputType, userData );

		this.userData = userData;

	}

	updateReference( state ) {

		this.reference = this.userData !== null ? this.userData : state.object.userData;

		return this.reference;

	}

}

const userData = ( name, inputType, userData ) => nodeObject( new UserDataNode( name, inputType, userData ) );

const _objectData = new WeakMap();

class VelocityNode extends TempNode {

	static get type() {

		return 'VelocityNode';

	}

	constructor() {

		super( 'vec2' );

		this.projectionMatrix = null;

		this.updateType = NodeUpdateType.OBJECT;
		this.updateAfterType = NodeUpdateType.OBJECT;

		this.previousModelWorldMatrix = uniform( new Matrix4() );
		this.previousProjectionMatrix = uniform( new Matrix4() ).setGroup( renderGroup );
		this.previousCameraViewMatrix = uniform( new Matrix4() );

	}

	setProjectionMatrix( projectionMatrix ) {

		this.projectionMatrix = projectionMatrix;

	}

	update( { frameId, camera, object } ) {

		const previousModelMatrix = getPreviousMatrix( object );

		this.previousModelWorldMatrix.value.copy( previousModelMatrix );

		//

		const cameraData = getData( camera );

		if ( cameraData.frameId !== frameId ) {

			cameraData.frameId = frameId;

			if ( cameraData.previousProjectionMatrix === undefined ) {

				cameraData.previousProjectionMatrix = new Matrix4();
				cameraData.previousCameraViewMatrix = new Matrix4();

				cameraData.currentProjectionMatrix = new Matrix4();
				cameraData.currentCameraViewMatrix = new Matrix4();

				cameraData.previousProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );
				cameraData.previousCameraViewMatrix.copy( camera.matrixWorldInverse );

			} else {

				cameraData.previousProjectionMatrix.copy( cameraData.currentProjectionMatrix );
				cameraData.previousCameraViewMatrix.copy( cameraData.currentCameraViewMatrix );

			}

			cameraData.currentProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );
			cameraData.currentCameraViewMatrix.copy( camera.matrixWorldInverse );

			this.previousProjectionMatrix.value.copy( cameraData.previousProjectionMatrix );
			this.previousCameraViewMatrix.value.copy( cameraData.previousCameraViewMatrix );

		}

	}

	updateAfter( { object } ) {

		getPreviousMatrix( object ).copy( object.matrixWorld );

	}

	setup( /*builder*/ ) {

		const projectionMatrix = ( this.projectionMatrix === null ) ? cameraProjectionMatrix : uniform( this.projectionMatrix );

		const previousModelViewMatrix = this.previousCameraViewMatrix.mul( this.previousModelWorldMatrix );

		const clipPositionCurrent = projectionMatrix.mul( modelViewMatrix ).mul( positionLocal );
		const clipPositionPrevious = this.previousProjectionMatrix.mul( previousModelViewMatrix ).mul( positionPrevious );

		const ndcPositionCurrent = clipPositionCurrent.xy.div( clipPositionCurrent.w );
		const ndcPositionPrevious = clipPositionPrevious.xy.div( clipPositionPrevious.w );

		const velocity = sub( ndcPositionCurrent, ndcPositionPrevious );

		return velocity;

	}

}

function getData( object ) {

	let objectData = _objectData.get( object );

	if ( objectData === undefined ) {

		objectData = {};
		_objectData.set( object, objectData );

	}

	return objectData;

}

function getPreviousMatrix( object, index = 0 ) {

	const objectData = getData( object );

	let matrix = objectData[ index ];

	if ( matrix === undefined ) {

		objectData[ index ] = matrix = new Matrix4();

	}

	return matrix;

}

const velocity = /*@__PURE__*/ nodeImmutable( VelocityNode );

const blendBurn = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {

	return min$1( 1.0, base.oneMinus().div( blend ) ).oneMinus();

} ).setLayout( {
	name: 'blendBurn',
	type: 'vec3',
	inputs: [
		{ name: 'base', type: 'vec3' },
		{ name: 'blend', type: 'vec3' }
	]
} );

const blendDodge = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {

	return min$1( base.div( blend.oneMinus() ), 1.0 );

} ).setLayout( {
	name: 'blendDodge',
	type: 'vec3',
	inputs: [
		{ name: 'base', type: 'vec3' },
		{ name: 'blend', type: 'vec3' }
	]
} );

const blendScreen = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {

	return base.oneMinus().mul( blend.oneMinus() ).oneMinus();

} ).setLayout( {
	name: 'blendScreen',
	type: 'vec3',
	inputs: [
		{ name: 'base', type: 'vec3' },
		{ name: 'blend', type: 'vec3' }
	]
} );

const blendOverlay = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {

	return mix( base.mul( 2.0 ).mul( blend ), base.oneMinus().mul( 2.0 ).mul( blend.oneMinus() ).oneMinus(), step( 0.5, base ) );

} ).setLayout( {
	name: 'blendOverlay',
	type: 'vec3',
	inputs: [
		{ name: 'base', type: 'vec3' },
		{ name: 'blend', type: 'vec3' }
	]
} );

const blendColor = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {

	const outAlpha = blend.a.add( base.a.mul( blend.a.oneMinus() ) );

	return vec4( blend.rgb.mul( blend.a ).add( base.rgb.mul( base.a ).mul( blend.a.oneMinus() ) ).div( outAlpha ), outAlpha );

} ).setLayout( {
	name: 'blendColor',
	type: 'vec4',
	inputs: [
		{ name: 'base', type: 'vec4' },
		{ name: 'blend', type: 'vec4' }
	]
} );

// deprecated

const burn = ( ...params ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.' );
	return blendBurn( params );

};

const dodge = ( ...params ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.' );
	return blendDodge( params );

};

const screen = ( ...params ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.' );
	return blendScreen( params );

};

const overlay = ( ...params ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.' );
	return blendOverlay( params );

};

const grayscale = /*@__PURE__*/ Fn( ( [ color ] ) => {

	return luminance( color.rgb );

} );

const saturation = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {

	return adjustment.mix( luminance( color.rgb ), color.rgb );

} );

const vibrance = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {

	const average = add( color.r, color.g, color.b ).div( 3.0 );

	const mx = color.r.max( color.g.max( color.b ) );
	const amt = mx.sub( average ).mul( adjustment ).mul( - 3.0 );

	return mix( color.rgb, mx, amt );

} );

const hue = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {

	const k = vec3( 0.57735, 0.57735, 0.57735 );

	const cosAngle = adjustment.cos();

	return vec3( color.rgb.mul( cosAngle ).add( k.cross( color.rgb ).mul( adjustment.sin() ).add( k.mul( dot( k, color.rgb ).mul( cosAngle.oneMinus() ) ) ) ) );

} );

const luminance = (
	color,
	luminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3() ) )
) => dot( color, luminanceCoefficients );

const threshold = ( color, threshold ) => mix( vec3( 0.0 ), color, luminance( color ).sub( threshold ).max( 0 ) );

/**
 * Color Decision List (CDL) v1.2
 *
 * Compact representation of color grading information, defined by slope, offset, power, and
 * saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,
 * or AgX Log), and will return output in the same space. Output may require clamping >=0.
 *
 * @param {vec4} color Input (-Infinity < input < +Infinity)
 * @param {number | vec3} slope Slope (0  slope < +Infinity)
 * @param {number | vec3} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)
 * @param {number | vec3} power Power (0 < power < +Infinity)
 * @param {number} saturation Saturation (0  saturation < +Infinity; typically 0  saturation < 4)
 * @param {vec3} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709
 * @return Output, -Infinity < output < +Infinity
 *
 * References:
 * - ASC CDL v1.2
 * - https://blender.stackexchange.com/a/55239/43930
 * - https://docs.acescentral.com/specifications/acescc/
 */
const cdl = /*@__PURE__*/ Fn( ( [
	color,
	slope = vec3( 1 ),
	offset = vec3( 0 ),
	power = vec3( 1 ),
	saturation = float( 1 ),
	// ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.
	luminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3(), LinearSRGBColorSpace ) )
] ) => {

	// NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the
	// saturation term. Per the ACEScc specification and Filament, limits may be omitted to support
	// values outside [0, 1], requiring a workaround for negative values in the power expression.

	const luma = color.rgb.dot( vec3( luminanceCoefficients ) );

	const v = max$1( color.rgb.mul( slope ).add( offset ), 0.0 ).toVar();
	const pv = v.pow( power ).toVar();

	If( v.r.greaterThan( 0.0 ), () => { v.r.assign( pv.r ); } ); // eslint-disable-line
	If( v.g.greaterThan( 0.0 ), () => { v.g.assign( pv.g ); } ); // eslint-disable-line
	If( v.b.greaterThan( 0.0 ), () => { v.b.assign( pv.b ); } ); // eslint-disable-line

	v.assign( luma.add( v.sub( luma ).mul( saturation ) ) );

	return vec4( v.rgb, color.a );

} );

class PosterizeNode extends TempNode {

	static get type() {

		return 'PosterizeNode';

	}

	constructor( sourceNode, stepsNode ) {

		super();

		this.sourceNode = sourceNode;
		this.stepsNode = stepsNode;

	}

	setup() {

		const { sourceNode, stepsNode } = this;

		return sourceNode.mul( stepsNode ).floor().div( stepsNode );

	}

}

const posterize = /*@__PURE__*/ nodeProxy( PosterizeNode );

const _size = /*@__PURE__*/ new Vector2();

class PassTextureNode extends TextureNode {

	static get type() {

		return 'PassTextureNode';

	}

	constructor( passNode, texture ) {

		super( texture );

		this.passNode = passNode;

		this.setUpdateMatrix( false );

	}

	setup( builder ) {

		if ( builder.object.isQuadMesh ) this.passNode.build( builder );

		return super.setup( builder );

	}

	clone() {

		return new this.constructor( this.passNode, this.value );

	}

}

class PassMultipleTextureNode extends PassTextureNode {

	static get type() {

		return 'PassMultipleTextureNode';

	}

	constructor( passNode, textureName, previousTexture = false ) {

		super( passNode, null );

		this.textureName = textureName;
		this.previousTexture = previousTexture;

	}

	updateTexture() {

		this.value = this.previousTexture ? this.passNode.getPreviousTexture( this.textureName ) : this.passNode.getTexture( this.textureName );

	}

	setup( builder ) {

		this.updateTexture();

		return super.setup( builder );

	}

	clone() {

		return new this.constructor( this.passNode, this.textureName, this.previousTexture );

	}

}

class PassNode extends TempNode {

	static get type() {

		return 'PassNode';

	}

	constructor( scope, scene, camera, options = {} ) {

		super( 'vec4' );

		this.scope = scope;
		this.scene = scene;
		this.camera = camera;
		this.options = options;

		this._pixelRatio = 1;
		this._width = 1;
		this._height = 1;

		const depthTexture = new DepthTexture();
		depthTexture.isRenderTargetTexture = true;
		//depthTexture.type = FloatType;
		depthTexture.name = 'depth';

		const renderTarget = new RenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options, } );
		renderTarget.texture.name = 'output';
		renderTarget.depthTexture = depthTexture;

		this.renderTarget = renderTarget;

		this.updateBeforeType = NodeUpdateType.FRAME;

		this._textures = {
			output: renderTarget.texture,
			depth: depthTexture
		};

		this._textureNodes = {};
		this._linearDepthNodes = {};
		this._viewZNodes = {};

		this._previousTextures = {};
		this._previousTextureNodes = {};

		this._cameraNear = uniform( 0 );
		this._cameraFar = uniform( 0 );

		this._mrt = null;

		this.isPassNode = true;

	}

	setMRT( mrt ) {

		this._mrt = mrt;

		return this;

	}

	getMRT() {

		return this._mrt;

	}

	isGlobal() {

		return true;

	}

	getTexture( name ) {

		let texture = this._textures[ name ];

		if ( texture === undefined ) {

			const refTexture = this.renderTarget.texture;

			texture = refTexture.clone();
			texture.isRenderTargetTexture = true;
			texture.name = name;

			this._textures[ name ] = texture;

			this.renderTarget.textures.push( texture );

		}

		return texture;

	}

	getPreviousTexture( name ) {

		let texture = this._previousTextures[ name ];

		if ( texture === undefined ) {

			texture = this.getTexture( name ).clone();
			texture.isRenderTargetTexture = true;

			this._previousTextures[ name ] = texture;

		}

		return texture;

	}

	toggleTexture( name ) {

		const prevTexture = this._previousTextures[ name ];

		if ( prevTexture !== undefined ) {

			const texture = this._textures[ name ];

			const index = this.renderTarget.textures.indexOf( texture );
			this.renderTarget.textures[ index ] = prevTexture;

			this._textures[ name ] = prevTexture;
			this._previousTextures[ name ] = texture;

			this._textureNodes[ name ].updateTexture();
			this._previousTextureNodes[ name ].updateTexture();

		}

	}

	getTextureNode( name = 'output' ) {

		let textureNode = this._textureNodes[ name ];

		if ( textureNode === undefined ) {

			textureNode = nodeObject( new PassMultipleTextureNode( this, name ) );
			textureNode.updateTexture();
			this._textureNodes[ name ] = textureNode;

		}

		return textureNode;

	}

	getPreviousTextureNode( name = 'output' ) {

		let textureNode = this._previousTextureNodes[ name ];

		if ( textureNode === undefined ) {

			if ( this._textureNodes[ name ] === undefined ) this.getTextureNode( name );

			textureNode = nodeObject( new PassMultipleTextureNode( this, name, true ) );
			textureNode.updateTexture();
			this._previousTextureNodes[ name ] = textureNode;

		}

		return textureNode;

	}

	getViewZNode( name = 'depth' ) {

		let viewZNode = this._viewZNodes[ name ];

		if ( viewZNode === undefined ) {

			const cameraNear = this._cameraNear;
			const cameraFar = this._cameraFar;

			this._viewZNodes[ name ] = viewZNode = perspectiveDepthToViewZ( this.getTextureNode( name ), cameraNear, cameraFar );

		}

		return viewZNode;

	}

	getLinearDepthNode( name = 'depth' ) {

		let linearDepthNode = this._linearDepthNodes[ name ];

		if ( linearDepthNode === undefined ) {

			const cameraNear = this._cameraNear;
			const cameraFar = this._cameraFar;
			const viewZNode = this.getViewZNode( name );

			// TODO: just if ( builder.camera.isPerspectiveCamera )

			this._linearDepthNodes[ name ] = linearDepthNode = viewZToOrthographicDepth( viewZNode, cameraNear, cameraFar );

		}

		return linearDepthNode;

	}

	setup( { renderer } ) {

		this.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;

		// Disable MSAA for WebGL backend for now
		if ( renderer.backend.isWebGLBackend === true ) {

			this.renderTarget.samples = 0;

		}

		this.renderTarget.depthTexture.isMultisampleRenderTargetTexture = this.renderTarget.samples > 1;

		return this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();

	}

	updateBefore( frame ) {

		const { renderer } = frame;
		const { scene, camera } = this;

		this._pixelRatio = renderer.getPixelRatio();

		const size = renderer.getSize( _size );

		this.setSize( size.width, size.height );

		const currentRenderTarget = renderer.getRenderTarget();
		const currentMRT = renderer.getMRT();

		this._cameraNear.value = camera.near;
		this._cameraFar.value = camera.far;

		for ( const name in this._previousTextures ) {

			this.toggleTexture( name );

		}

		renderer.setRenderTarget( this.renderTarget );
		renderer.setMRT( this._mrt );

		renderer.render( scene, camera );

		renderer.setRenderTarget( currentRenderTarget );
		renderer.setMRT( currentMRT );

	}

	setSize( width, height ) {

		this._width = width;
		this._height = height;

		const effectiveWidth = this._width * this._pixelRatio;
		const effectiveHeight = this._height * this._pixelRatio;

		this.renderTarget.setSize( effectiveWidth, effectiveHeight );

	}

	setPixelRatio( pixelRatio ) {

		this._pixelRatio = pixelRatio;

		this.setSize( this._width, this._height );

	}

	dispose() {

		this.renderTarget.dispose();

	}


}

PassNode.COLOR = 'color';
PassNode.DEPTH = 'depth';

const pass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.COLOR, scene, camera, options ) );
const passTexture = ( pass, texture ) => nodeObject( new PassTextureNode( pass, texture ) );
const depthPass = ( scene, camera ) => nodeObject( new PassNode( PassNode.DEPTH, scene, camera ) );

class ToonOutlinePassNode extends PassNode {

	static get type() {

		return 'ToonOutlinePassNode';

	}

	constructor( scene, camera, colorNode, thicknessNode, alphaNode ) {

		super( PassNode.COLOR, scene, camera );

		this.colorNode = colorNode;
		this.thicknessNode = thicknessNode;
		this.alphaNode = alphaNode;

		this._materialCache = new WeakMap();

	}

	updateBefore( frame ) {

		const { renderer } = frame;

		const currentRenderObjectFunction = renderer.getRenderObjectFunction();

		renderer.setRenderObjectFunction( ( object, scene, camera, geometry, material, group, lightsNode, clippingContext ) => {

			// only render outline for supported materials

			if ( material.isMeshToonMaterial || material.isMeshToonNodeMaterial ) {

				if ( material.wireframe === false ) {

					const outlineMaterial = this._getOutlineMaterial( material );
					renderer.renderObject( object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext );

				}

			}

			// default

			renderer.renderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext );

		} );

		super.updateBefore( frame );

		renderer.setRenderObjectFunction( currentRenderObjectFunction );

	}

	_createMaterial() {

		const material = new NodeMaterial();
		material.isMeshToonOutlineMaterial = true;
		material.name = 'Toon_Outline';
		material.side = BackSide;

		// vertex node

		const outlineNormal = normalLocal.negate();
		const mvp = cameraProjectionMatrix.mul( modelViewMatrix );

		const ratio = float( 1.0 ); // TODO: support outline thickness ratio for each vertex
		const pos = mvp.mul( vec4( positionLocal, 1.0 ) );
		const pos2 = mvp.mul( vec4( positionLocal.add( outlineNormal ), 1.0 ) );
		const norm = normalize( pos.sub( pos2 ) ); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative

		material.vertexNode = pos.add( norm.mul( this.thicknessNode ).mul( pos.w ).mul( ratio ) );

		// color node

		material.colorNode = vec4( this.colorNode, this.alphaNode );

		return material;

	}

	_getOutlineMaterial( originalMaterial ) {

		let outlineMaterial = this._materialCache.get( originalMaterial );

		if ( outlineMaterial === undefined ) {

			outlineMaterial = this._createMaterial();

			this._materialCache.set( originalMaterial, outlineMaterial );

		}

		return outlineMaterial;

	}

}

const toonOutlinePass = ( scene, camera, color = new Color( 0, 0, 0 ), thickness = 0.003, alpha = 1 ) => nodeObject( new ToonOutlinePassNode( scene, camera, nodeObject( color ), nodeObject( thickness ), nodeObject( alpha ) ) );

// exposure only

const linearToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

	return color.mul( exposure ).clamp();

} ).setLayout( {
	name: 'linearToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf

const reinhardToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

	color = color.mul( exposure );

	return color.div( color.add( 1.0 ) ).clamp();

} ).setLayout( {
	name: 'reinhardToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/

const cineonToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

	// filmic operator by Jim Hejl and Richard Burgess-Dawson
	color = color.mul( exposure );
	color = color.sub( 0.004 ).max( 0.0 );

	const a = color.mul( color.mul( 6.2 ).add( 0.5 ) );
	const b = color.mul( color.mul( 6.2 ).add( 1.7 ) ).add( 0.06 );

	return a.div( b ).pow( 2.2 );

} ).setLayout( {
	name: 'cineonToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs

const RRTAndODTFit = /*@__PURE__*/ Fn( ( [ color ] ) => {

	const a = color.mul( color.add( 0.0245786 ) ).sub( 0.000090537 );
	const b = color.mul( color.add( 0.4329510 ).mul( 0.983729 ) ).add( 0.238081 );

	return a.div( b );

} );

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs

const acesFilmicToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const ACESInputMat = mat3(
		0.59719, 0.35458, 0.04823,
		0.07600, 0.90834, 0.01566,
		0.02840, 0.13383, 0.83777
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const ACESOutputMat = mat3(
		1.60475, - 0.53108, - 0.07367,
		- 0.10208, 1.10813, - 0.00605,
		- 0.00327, - 0.07276, 1.07602
	);

	color = color.mul( exposure ).div( 0.6 );

	color = ACESInputMat.mul( color );

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat.mul( color );

	// Clamp to [0, 1]
	return color.clamp();

} ).setLayout( {
	name: 'acesFilmicToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

const LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/ mat3( vec3( 1.6605, - 0.1246, - 0.0182 ), vec3( - 0.5876, 1.1329, - 0.1006 ), vec3( - 0.0728, - 0.0083, 1.1187 ) );
const LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/ mat3( vec3( 0.6274, 0.0691, 0.0164 ), vec3( 0.3293, 0.9195, 0.0880 ), vec3( 0.0433, 0.0113, 0.8956 ) );

const agxDefaultContrastApprox = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {

	const x = vec3( x_immutable ).toVar();
	const x2 = vec3( x.mul( x ) ).toVar();
	const x4 = vec3( x2.mul( x2 ) ).toVar();

	return float( 15.5 ).mul( x4.mul( x2 ) ).sub( mul( 40.14, x4.mul( x ) ) ).add( mul( 31.96, x4 ).sub( mul( 6.868, x2.mul( x ) ) ).add( mul( 0.4298, x2 ).add( mul( 0.1191, x ).sub( 0.00232 ) ) ) );

} );

const agxToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

	const colortone = vec3( color ).toVar();
	const AgXInsetMatrix = mat3( vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ), vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ), vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 ) );
	const AgXOutsetMatrix = mat3( vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ), vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ), vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 ) );
	const AgxMinEv = float( - 12.47393 );
	const AgxMaxEv = float( 4.026069 );
	colortone.mulAssign( exposure );
	colortone.assign( LINEAR_SRGB_TO_LINEAR_REC2020.mul( colortone ) );
	colortone.assign( AgXInsetMatrix.mul( colortone ) );
	colortone.assign( max$1( colortone, 1e-10 ) );
	colortone.assign( log2( colortone ) );
	colortone.assign( colortone.sub( AgxMinEv ).div( AgxMaxEv.sub( AgxMinEv ) ) );
	colortone.assign( clamp( colortone, 0.0, 1.0 ) );
	colortone.assign( agxDefaultContrastApprox( colortone ) );
	colortone.assign( AgXOutsetMatrix.mul( colortone ) );
	colortone.assign( pow( max$1( vec3( 0.0 ), colortone ), vec3( 2.2 ) ) );
	colortone.assign( LINEAR_REC2020_TO_LINEAR_SRGB.mul( colortone ) );
	colortone.assign( clamp( colortone, 0.0, 1.0 ) );

	return colortone;

} ).setLayout( {
	name: 'agxToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

// https://modelviewer.dev/examples/tone-mapping

const neutralToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

	const StartCompression = float( 0.8 - 0.04 );
	const Desaturation = float( 0.15 );

	color = color.mul( exposure );

	const x = min$1( color.r, min$1( color.g, color.b ) );
	const offset = select( x.lessThan( 0.08 ), x.sub( mul( 6.25, x.mul( x ) ) ), 0.04 );

	color.subAssign( offset );

	const peak = max$1( color.r, max$1( color.g, color.b ) );

	If( peak.lessThan( StartCompression ), () => {

		return color;

	} );

	const d = sub( 1, StartCompression );
	const newPeak = sub( 1, d.mul( d ).div( peak.add( d.sub( StartCompression ) ) ) );
	color.mulAssign( newPeak.div( peak ) );
	const g = sub( 1, div( 1, Desaturation.mul( peak.sub( newPeak ) ).add( 1 ) ) );

	return mix( color, vec3( newPeak ), g );

} ).setLayout( {
	name: 'neutralToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

class CodeNode extends Node {

	static get type() {

		return 'CodeNode';

	}

	constructor( code = '', includes = [], language = '' ) {

		super( 'code' );

		this.isCodeNode = true;

		this.code = code;
		this.language = language;

		this.includes = includes;

	}

	isGlobal() {

		return true;

	}

	setIncludes( includes ) {

		this.includes = includes;

		return this;

	}

	getIncludes( /*builder*/ ) {

		return this.includes;

	}

	generate( builder ) {

		const includes = this.getIncludes( builder );

		for ( const include of includes ) {

			include.build( builder );

		}

		const nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );
		nodeCode.code = this.code;

		return nodeCode.code;

	}

	serialize( data ) {

		super.serialize( data );

		data.code = this.code;
		data.language = this.language;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.code = data.code;
		this.language = data.language;

	}

}

const code = /*@__PURE__*/ nodeProxy( CodeNode );

const js = ( src, includes ) => code( src, includes, 'js' );
const wgsl = ( src, includes ) => code( src, includes, 'wgsl' );
const glsl = ( src, includes ) => code( src, includes, 'glsl' );

class FunctionNode extends CodeNode {

	static get type() {

		return 'FunctionNode';

	}

	constructor( code = '', includes = [], language = '' ) {

		super( code, includes, language );

	}

	getNodeType( builder ) {

		return this.getNodeFunction( builder ).type;

	}

	getInputs( builder ) {

		return this.getNodeFunction( builder ).inputs;

	}

	getNodeFunction( builder ) {

		const nodeData = builder.getDataFromNode( this );

		let nodeFunction = nodeData.nodeFunction;

		if ( nodeFunction === undefined ) {

			nodeFunction = builder.parser.parseFunction( this.code );

			nodeData.nodeFunction = nodeFunction;

		}

		return nodeFunction;

	}

	generate( builder, output ) {

		super.generate( builder );

		const nodeFunction = this.getNodeFunction( builder );

		const name = nodeFunction.name;
		const type = nodeFunction.type;

		const nodeCode = builder.getCodeFromNode( this, type );

		if ( name !== '' ) {

			// use a custom property name

			nodeCode.name = name;

		}

		const propertyName = builder.getPropertyName( nodeCode );

		const code = this.getNodeFunction( builder ).getCode( propertyName );

		nodeCode.code = code + '\n';

		if ( output === 'property' ) {

			return propertyName;

		} else {

			return builder.format( `${ propertyName }()`, type, output );

		}

	}

}

const nativeFn = ( code, includes = [], language = '' ) => {

	for ( let i = 0; i < includes.length; i ++ ) {

		const include = includes[ i ];

		// TSL Function: glslFn, wgslFn

		if ( typeof include === 'function' ) {

			includes[ i ] = include.functionNode;

		}

	}

	const functionNode = nodeObject( new FunctionNode( code, includes, language ) );

	const fn = ( ...params ) => functionNode.call( ...params );
	fn.functionNode = functionNode;

	return fn;

};

const glslFn = ( code, includes ) => nativeFn( code, includes, 'glsl' );
const wgslFn = ( code, includes ) => nativeFn( code, includes, 'wgsl' );

class ScriptableValueNode extends Node {

	static get type() {

		return 'ScriptableValueNode';

	}

	constructor( value = null ) {

		super();

		this._value = value;
		this._cache = null;

		this.inputType = null;
		this.outpuType = null;

		this.events = new EventDispatcher();

		this.isScriptableValueNode = true;

	}

	get isScriptableOutputNode() {

		return this.outputType !== null;

	}

	set value( val ) {

		if ( this._value === val ) return;

		if ( this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer ) {

			URL.revokeObjectURL( this._cache );

			this._cache = null;

		}

		this._value = val;

		this.events.dispatchEvent( { type: 'change' } );

		this.refresh();

	}

	get value() {

		return this._value;

	}

	refresh() {

		this.events.dispatchEvent( { type: 'refresh' } );

	}

	getValue() {

		const value = this.value;

		if ( value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer ) {

			this._cache = URL.createObjectURL( new Blob( [ value.value ] ) );

		} else if ( value && value.value !== null && value.value !== undefined && (
			( ( this.inputType === 'URL' || this.inputType === 'String' ) && typeof value.value === 'string' ) ||
			( this.inputType === 'Number' && typeof value.value === 'number' ) ||
			( this.inputType === 'Vector2' && value.value.isVector2 ) ||
			( this.inputType === 'Vector3' && value.value.isVector3 ) ||
			( this.inputType === 'Vector4' && value.value.isVector4 ) ||
			( this.inputType === 'Color' && value.value.isColor ) ||
			( this.inputType === 'Matrix3' && value.value.isMatrix3 ) ||
			( this.inputType === 'Matrix4' && value.value.isMatrix4 )
		) ) {

			return value.value;

		}

		return this._cache || value;

	}

	getNodeType( builder ) {

		return this.value && this.value.isNode ? this.value.getNodeType( builder ) : 'float';

	}

	setup() {

		return this.value && this.value.isNode ? this.value : float();

	}

	serialize( data ) {

		super.serialize( data );

		if ( this.value !== null ) {

			if ( this.inputType === 'ArrayBuffer' ) {

				data.value = arrayBufferToBase64( this.value );

			} else {

				data.value = this.value ? this.value.toJSON( data.meta ).uuid : null;

			}

		} else {

			data.value = null;

		}

		data.inputType = this.inputType;
		data.outputType = this.outputType;

	}

	deserialize( data ) {

		super.deserialize( data );

		let value = null;

		if ( data.value !== null ) {

			if ( data.inputType === 'ArrayBuffer' ) {

				value = base64ToArrayBuffer( data.value );

			} else if ( data.inputType === 'Texture' ) {

				value = data.meta.textures[ data.value ];

			} else {

				value = data.meta.nodes[ data.value ] || null;

			}

		}

		this.value = value;

		this.inputType = data.inputType;
		this.outputType = data.outputType;

	}

}

const scriptableValue = /*@__PURE__*/ nodeProxy( ScriptableValueNode );

class Resources extends Map {

	get( key, callback = null, ...params ) {

		if ( this.has( key ) ) return super.get( key );

		if ( callback !== null ) {

			const value = callback( ...params );
			this.set( key, value );
			return value;

		}

	}

}

class Parameters {

	constructor( scriptableNode ) {

		this.scriptableNode = scriptableNode;

	}

	get parameters() {

		return this.scriptableNode.parameters;

	}

	get layout() {

		return this.scriptableNode.getLayout();

	}

	getInputLayout( id ) {

		return this.scriptableNode.getInputLayout( id );

	}

	get( name ) {

		const param = this.parameters[ name ];
		const value = param ? param.getValue() : null;

		return value;

	}

}

const ScriptableNodeResources = new Resources();

class ScriptableNode extends Node {

	static get type() {

		return 'ScriptableNode';

	}

	constructor( codeNode = null, parameters = {} ) {

		super();

		this.codeNode = codeNode;
		this.parameters = parameters;

		this._local = new Resources();
		this._output = scriptableValue();
		this._outputs = {};
		this._source = this.source;
		this._method = null;
		this._object = null;
		this._value = null;
		this._needsOutputUpdate = true;

		this.onRefresh = this.onRefresh.bind( this );

		this.isScriptableNode = true;

	}

	get source() {

		return this.codeNode ? this.codeNode.code : '';

	}

	setLocal( name, value ) {

		return this._local.set( name, value );

	}

	getLocal( name ) {

		return this._local.get( name );

	}

	onRefresh() {

		this._refresh();

	}

	getInputLayout( id ) {

		for ( const element of this.getLayout() ) {

			if ( element.inputType && ( element.id === id || element.name === id ) ) {

				return element;

			}

		}

	}

	getOutputLayout( id ) {

		for ( const element of this.getLayout() ) {

			if ( element.outputType && ( element.id === id || element.name === id ) ) {

				return element;

			}

		}

	}

	setOutput( name, value ) {

		const outputs = this._outputs;

		if ( outputs[ name ] === undefined ) {

			outputs[ name ] = scriptableValue( value );

		} else {

			outputs[ name ].value = value;

		}

		return this;

	}

	getOutput( name ) {

		return this._outputs[ name ];

	}

	getParameter( name ) {

		return this.parameters[ name ];

	}

	setParameter( name, value ) {

		const parameters = this.parameters;

		if ( value && value.isScriptableNode ) {

			this.deleteParameter( name );

			parameters[ name ] = value;
			parameters[ name ].getDefaultOutput().events.addEventListener( 'refresh', this.onRefresh );

		} else if ( value && value.isScriptableValueNode ) {

			this.deleteParameter( name );

			parameters[ name ] = value;
			parameters[ name ].events.addEventListener( 'refresh', this.onRefresh );

		} else if ( parameters[ name ] === undefined ) {

			parameters[ name ] = scriptableValue( value );
			parameters[ name ].events.addEventListener( 'refresh', this.onRefresh );

		} else {

			parameters[ name ].value = value;

		}

		return this;

	}

	getValue() {

		return this.getDefaultOutput().getValue();

	}

	deleteParameter( name ) {

		let valueNode = this.parameters[ name ];

		if ( valueNode ) {

			if ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();

			valueNode.events.removeEventListener( 'refresh', this.onRefresh );

		}

		return this;

	}

	clearParameters() {

		for ( const name of Object.keys( this.parameters ) ) {

			this.deleteParameter( name );

		}

		this.needsUpdate = true;

		return this;

	}

	call( name, ...params ) {

		const object = this.getObject();
		const method = object[ name ];

		if ( typeof method === 'function' ) {

			return method( ...params );

		}

	}

	async callAsync( name, ...params ) {

		const object = this.getObject();
		const method = object[ name ];

		if ( typeof method === 'function' ) {

			return method.constructor.name === 'AsyncFunction' ? await method( ...params ) : method( ...params );

		}

	}

	getNodeType( builder ) {

		return this.getDefaultOutputNode().getNodeType( builder );

	}

	refresh( output = null ) {

		if ( output !== null ) {

			this.getOutput( output ).refresh();

		} else {

			this._refresh();

		}

	}

	getObject() {

		if ( this.needsUpdate ) this.dispose();
		if ( this._object !== null ) return this._object;

		//

		const refresh = () => this.refresh();
		const setOutput = ( id, value ) => this.setOutput( id, value );

		const parameters = new Parameters( this );

		const THREE = ScriptableNodeResources.get( 'THREE' );
		const TSL = ScriptableNodeResources.get( 'TSL' );

		const method = this.getMethod( this.codeNode );
		const params = [ parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL ];

		this._object = method( ...params );

		const layout = this._object.layout;

		if ( layout ) {

			if ( layout.cache === false ) {

				this._local.clear();

			}

			// default output
			this._output.outputType = layout.outputType || null;

			if ( Array.isArray( layout.elements ) ) {

				for ( const element of layout.elements ) {

					const id = element.id || element.name;

					if ( element.inputType ) {

						if ( this.getParameter( id ) === undefined ) this.setParameter( id, null );

						this.getParameter( id ).inputType = element.inputType;

					}

					if ( element.outputType ) {

						if ( this.getOutput( id ) === undefined ) this.setOutput( id, null );

						this.getOutput( id ).outputType = element.outputType;

					}

				}

			}

		}

		return this._object;

	}

	deserialize( data ) {

		super.deserialize( data );

		for ( const name in this.parameters ) {

			let valueNode = this.parameters[ name ];

			if ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();

			valueNode.events.addEventListener( 'refresh', this.onRefresh );

		}

	}

	getLayout() {

		return this.getObject().layout;

	}

	getDefaultOutputNode() {

		const output = this.getDefaultOutput().value;

		if ( output && output.isNode ) {

			return output;

		}

		return float();

	}

	getDefaultOutput()	{

		return this._exec()._output;

	}

	getMethod() {

		if ( this.needsUpdate ) this.dispose();
		if ( this._method !== null ) return this._method;

		//

		const parametersProps = [ 'parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL' ];
		const interfaceProps = [ 'layout', 'init', 'main', 'dispose' ];

		const properties = interfaceProps.join( ', ' );
		const declarations = 'var ' + properties + '; var output = {};\n';
		const returns = '\nreturn { ...output, ' + properties + ' };';

		const code = declarations + this.codeNode.code + returns;

		//

		this._method = new Function( ...parametersProps, code );

		return this._method;

	}

	dispose() {

		if ( this._method === null ) return;

		if ( this._object && typeof this._object.dispose === 'function' ) {

			this._object.dispose();

		}

		this._method = null;
		this._object = null;
		this._source = null;
		this._value = null;
		this._needsOutputUpdate = true;
		this._output.value = null;
		this._outputs = {};

	}

	setup() {

		return this.getDefaultOutputNode();

	}

	getCacheKey( force ) {

		const values = [ hashString( this.source ), this.getDefaultOutputNode().getCacheKey( force ) ];

		for ( const param in this.parameters ) {

			values.push( this.parameters[ param ].getCacheKey( force ) );

		}

		return hashArray( values );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.dispose();

	}

	get needsUpdate() {

		return this.source !== this._source;

	}

	_exec()	{

		if ( this.codeNode === null ) return this;

		if ( this._needsOutputUpdate === true ) {

			this._value = this.call( 'main' );

			this._needsOutputUpdate = false;

		}

		this._output.value = this._value;

		return this;

	}

	_refresh() {

		this.needsUpdate = true;

		this._exec();

		this._output.refresh();

	}

}

const scriptable = /*@__PURE__*/ nodeProxy( ScriptableNode );

class FogNode extends Node {

	static get type() {

		return 'FogNode';

	}

	constructor( colorNode, factorNode ) {

		super( 'float' );

		this.isFogNode = true;

		this.colorNode = colorNode;
		this.factorNode = factorNode;

	}

	getViewZNode( builder ) {

		let viewZ;

		const getViewZ = builder.context.getViewZ;

		if ( getViewZ !== undefined ) {

			viewZ = getViewZ( this );

		}

		return ( viewZ || positionView.z ).negate();

	}

	setup() {

		return this.factorNode;

	}

}

const fog = /*@__PURE__*/ nodeProxy( FogNode );

class FogRangeNode extends FogNode {

	static get type() {

		return 'FogRangeNode';

	}

	constructor( colorNode, nearNode, farNode ) {

		super( colorNode );

		this.isFogRangeNode = true;

		this.nearNode = nearNode;
		this.farNode = farNode;

	}

	setup( builder ) {

		const viewZ = this.getViewZNode( builder );

		return smoothstep( this.nearNode, this.farNode, viewZ );

	}

}

const rangeFog = /*@__PURE__*/ nodeProxy( FogRangeNode );

class FogExp2Node extends FogNode {

	static get type() {

		return 'FogExp2Node';

	}

	constructor( colorNode, densityNode ) {

		super( colorNode );

		this.isFogExp2Node = true;

		this.densityNode = densityNode;

	}

	setup( builder ) {

		const viewZ = this.getViewZNode( builder );
		const density = this.densityNode;

		return density.mul( density, viewZ, viewZ ).negate().exp().oneMinus();

	}

}

const densityFog = /*@__PURE__*/ nodeProxy( FogExp2Node );

let min = null;
let max = null;

class RangeNode extends Node {

	static get type() {

		return 'RangeNode';

	}

	constructor( minNode = float(), maxNode = float() ) {

		super();

		this.minNode = minNode;
		this.maxNode = maxNode;

	}

	getVectorLength( builder ) {

		const minLength = builder.getTypeLength( getValueType( this.minNode.value ) );
		const maxLength = builder.getTypeLength( getValueType( this.maxNode.value ) );

		return minLength > maxLength ? minLength : maxLength;

	}

	getNodeType( builder ) {

		return builder.object.count > 1 ? builder.getTypeFromLength( this.getVectorLength( builder ) ) : 'float';

	}

	setup( builder ) {

		const object = builder.object;

		let output = null;

		if ( object.count > 1 ) {

			const minValue = this.minNode.value;
			const maxValue = this.maxNode.value;

			const minLength = builder.getTypeLength( getValueType( minValue ) );
			const maxLength = builder.getTypeLength( getValueType( maxValue ) );

			min = min || new Vector4();
			max = max || new Vector4();

			min.setScalar( 0 );
			max.setScalar( 0 );

			if ( minLength === 1 ) min.setScalar( minValue );
			else if ( minValue.isColor ) min.set( minValue.r, minValue.g, minValue.b );
			else min.set( minValue.x, minValue.y, minValue.z || 0, minValue.w || 0 );

			if ( maxLength === 1 ) max.setScalar( maxValue );
			else if ( maxValue.isColor ) max.set( maxValue.r, maxValue.g, maxValue.b );
			else max.set( maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0 );

			const stride = 4;

			const length = stride * object.count;
			const array = new Float32Array( length );

			for ( let i = 0; i < length; i ++ ) {

				const index = i % stride;

				const minElementValue = min.getComponent( index );
				const maxElementValue = max.getComponent( index );

				array[ i ] = MathUtils.lerp( minElementValue, maxElementValue, Math.random() );

			}

			const nodeType = this.getNodeType( builder );

			if ( object.count <= 4096 ) {

				output = buffer( array, 'vec4', object.count ).element( instanceIndex ).convert( nodeType );

			} else {

				// TODO: Improve anonymous buffer attribute creation removing this part
				const bufferAttribute = new InstancedBufferAttribute( array, 4 );
				builder.geometry.setAttribute( '__range' + this.id, bufferAttribute );

				output = instancedBufferAttribute( bufferAttribute ).convert( nodeType );

			}

		} else {

			output = float( 0 );

		}

		return output;

	}

}

const range = /*@__PURE__*/ nodeProxy( RangeNode );

class ComputeBuiltinNode extends Node {

	static get type() {

		return 'ComputeBuiltinNode';

	}

	constructor( builtinName, nodeType ) {

		super( nodeType );

		this._builtinName = builtinName;

	}

	getHash( builder ) {

		return this.getBuiltinName( builder );

	}

	getNodeType( /*builder*/ ) {

		return this.nodeType;

	}

	setBuiltinName( builtinName ) {

		this._builtinName = builtinName;

		return this;

	}

	getBuiltinName( /*builder*/ ) {

		return this._builtinName;

	}

	hasBuiltin( builder ) {

		builder.hasBuiltin( this._builtinName );

	}

	generate( builder, output ) {

		const builtinName = this.getBuiltinName( builder );
		const nodeType = this.getNodeType( builder );

		if ( builder.shaderStage === 'compute' ) {

			return builder.format( builtinName, nodeType, output );

		} else {

			console.warn( `ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage` );
			return builder.generateConst( nodeType );

		}

	}

	serialize( data ) {

		super.serialize( data );

		data.global = this.global;
		data._builtinName = this._builtinName;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.global = data.global;
		this._builtinName = data._builtinName;

	}

}

const computeBuiltin = ( name, nodeType ) => nodeObject( new ComputeBuiltinNode( name, nodeType ) );

const numWorkgroups = /*@__PURE__*/ computeBuiltin( 'numWorkgroups', 'uvec3' );
const workgroupId = /*@__PURE__*/ computeBuiltin( 'workgroupId', 'uvec3' );
const localId = /*@__PURE__*/ computeBuiltin( 'localId', 'uvec3' );
const subgroupSize = /*@__PURE__*/ computeBuiltin( 'subgroupSize', 'uint' );

class BarrierNode extends Node {

	constructor( scope ) {

		super();

		this.scope = scope;

	}

	generate( builder ) {

		const { scope } = this;
		const { renderer } = builder;

		if ( renderer.backend.isWebGLBackend === true ) {

			builder.addFlowCode( `\t// ${scope}Barrier \n` );

		} else {

			builder.addLineFlowCode( `${scope}Barrier()`, this );

		}

	}

}

const barrier = nodeProxy( BarrierNode );

const workgroupBarrier = () => barrier( 'workgroup' ).append();
const storageBarrier = () => barrier( 'storage' ).append();
const textureBarrier = () => barrier( 'texture' ).append();

class WorkgroupInfoElementNode extends ArrayElementNode {

	constructor( workgroupInfoNode, indexNode ) {

		super( workgroupInfoNode, indexNode );

		this.isWorkgroupInfoElementNode = true;

	}

	generate( builder, output ) {

		let snippet;

		const isAssignContext = builder.context.assign;
		snippet = super.generate( builder );

		if ( isAssignContext !== true ) {

			const type = this.getNodeType( builder );

			snippet = builder.format( snippet, type, output );

		}

		// TODO: Possibly activate clip distance index on index access rather than from clipping context

		return snippet;

	}

}


class WorkgroupInfoNode extends Node {

	constructor( scope, bufferType, bufferCount = 0 ) {

		super( bufferType );

		this.bufferType = bufferType;
		this.bufferCount = bufferCount;

		this.isWorkgroupInfoNode = true;

		this.scope = scope;

	}

	label( name ) {

		this.name = name;

		return this;

	}

	getHash() {

		return this.uuid;

	}

	setScope( scope ) {

		this.scope = scope;

		return this;

	}

	getInputType( /*builder*/ ) {

		return `${this.scope}Array`;

	}

	element( indexNode ) {

		return nodeObject( new WorkgroupInfoElementNode( this, indexNode ) );

	}

	generate( builder ) {

		return builder.getScopedArray( this.name || `${this.scope}Array_${this.id}`, this.scope.toLowerCase(), this.bufferType, this.bufferCount );

	}

}

const workgroupArray = ( type, count ) => nodeObject( new WorkgroupInfoNode( 'Workgroup', type, count ) );

class AtomicFunctionNode extends TempNode {

	static get type() {

		return 'AtomicFunctionNode';

	}

	constructor( method, pointerNode, valueNode, storeNode = null ) {

		super( 'uint' );

		this.method = method;

		this.pointerNode = pointerNode;
		this.valueNode = valueNode;
		this.storeNode = storeNode;

	}

	getInputType( builder ) {

		return this.pointerNode.getNodeType( builder );

	}

	getNodeType( builder ) {

		return this.getInputType( builder );

	}

	generate( builder ) {

		const method = this.method;

		const type = this.getNodeType( builder );
		const inputType = this.getInputType( builder );

		const a = this.pointerNode;
		const b = this.valueNode;

		const params = [];

		params.push( `&${ a.build( builder, inputType ) }` );
		params.push( b.build( builder, inputType ) );

		const methodSnippet = `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`;

		if ( this.storeNode !== null ) {

			const varSnippet = this.storeNode.build( builder, inputType );

			builder.addLineFlowCode( `${varSnippet} = ${methodSnippet}`, this );

		} else {

			builder.addLineFlowCode( methodSnippet, this );

		}

	}

}

AtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';
AtomicFunctionNode.ATOMIC_STORE = 'atomicStore';
AtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';
AtomicFunctionNode.ATOMIC_SUB = 'atomicSub';
AtomicFunctionNode.ATOMIC_MAX = 'atomicMax';
AtomicFunctionNode.ATOMIC_MIN = 'atomicMin';
AtomicFunctionNode.ATOMIC_AND = 'atomicAnd';
AtomicFunctionNode.ATOMIC_OR = 'atomicOr';
AtomicFunctionNode.ATOMIC_XOR = 'atomicXor';

const atomicNode = nodeProxy( AtomicFunctionNode );

const atomicFunc = ( method, pointerNode, valueNode, storeNode ) => {

	const node = atomicNode( method, pointerNode, valueNode, storeNode );
	node.append();

	return node;

};

const atomicStore = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode, storeNode );
const atomicAdd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode, storeNode );
const atomicSub = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode, storeNode );
const atomicMax = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode, storeNode );
const atomicMin = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode, storeNode );
const atomicAnd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode, storeNode );
const atomicOr = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode, storeNode );
const atomicXor = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode, storeNode );

let uniformsLib;

function getLightData( light ) {

	uniformsLib = uniformsLib || new WeakMap();

	let uniforms = uniformsLib.get( light );

	if ( uniforms === undefined ) uniformsLib.set( light, uniforms = {} );

	return uniforms;

}

function lightShadowMatrix( light ) {

	const data = getLightData( light );

	return data.shadowMatrix || ( data.shadowMatrix = uniform( 'mat4' ).setGroup( renderGroup ).onRenderUpdate( () => {

		light.shadow.updateMatrices( light );

		return light.shadow.matrix;

	} ) );

}

function lightProjectionUV( light ) {

	const data = getLightData( light );

	if ( data.projectionUV === undefined ) {

		const spotLightCoord = lightShadowMatrix( light ).mul( positionWorld );

		data.projectionUV = spotLightCoord.xyz.div( spotLightCoord.w );


	}

	return data.projectionUV;

}

function lightPosition( light ) {

	const data = getLightData( light );

	return data.position || ( data.position = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.matrixWorld ) ) );

}

function lightTargetPosition( light ) {

	const data = getLightData( light );

	return data.targetPosition || ( data.targetPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.target.matrixWorld ) ) );

}

function lightViewPosition( light ) {

	const data = getLightData( light );

	return data.viewPosition || ( data.viewPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => {

		self.value = self.value || new Vector3();
		self.value.setFromMatrixPosition( light.matrixWorld );

		self.value.applyMatrix4( camera.matrixWorldInverse );

	} ) );

}

const lightTargetDirection = ( light ) => cameraViewMatrix.transformDirection( lightPosition( light ).sub( lightTargetPosition( light ) ) );

const sortLights = ( lights ) => {

	return lights.sort( ( a, b ) => a.id - b.id );

};

const getLightNodeById = ( id, lightNodes ) => {

	for ( const lightNode of lightNodes ) {

		if ( lightNode.isAnalyticLightNode && lightNode.light.id === id ) {

			return lightNode;

		}

	}

	return null;

};

const _lightsNodeRef = /*@__PURE__*/ new WeakMap();

class LightsNode extends Node {

	static get type() {

		return 'LightsNode';

	}

	constructor() {

		super( 'vec3' );

		this.totalDiffuseNode = vec3().toVar( 'totalDiffuse' );
		this.totalSpecularNode = vec3().toVar( 'totalSpecular' );

		this.outgoingLightNode = vec3().toVar( 'outgoingLight' );

		this._lights = [];

		this._lightNodes = null;
		this._lightNodesHash = null;

		this.global = true;

	}

	getHash( builder ) {

		if ( this._lightNodesHash === null ) {

			if ( this._lightNodes === null ) this.setupLightsNode( builder );

			const hash = [];

			for ( const lightNode of this._lightNodes ) {

				hash.push( lightNode.getSelf().getHash() );

			}

			this._lightNodesHash = 'lights-' + hash.join( ',' );

		}

		return this._lightNodesHash;

	}

	analyze( builder ) {

		const properties = builder.getDataFromNode( this );

		for ( const node of properties.nodes ) {

			node.build( builder );

		}

	}

	setupLightsNode( builder ) {

		const lightNodes = [];

		const previousLightNodes = this._lightNodes;

		const lights = sortLights( this._lights );
		const nodeLibrary = builder.renderer.library;

		for ( const light of lights ) {

			if ( light.isNode ) {

				lightNodes.push( nodeObject( light ) );

			} else {

				let lightNode = null;

				if ( previousLightNodes !== null ) {

					lightNode = getLightNodeById( light.id, previousLightNodes ); // resuse existing light node

				}

				if ( lightNode === null ) {

					const lightNodeClass = nodeLibrary.getLightNodeClass( light.constructor );

					if ( lightNodeClass === null ) {

						console.warn( `LightsNode.setupNodeLights: Light node not found for ${ light.constructor.name }` );
						continue;

					}

					let lightNode = null;

					if ( ! _lightsNodeRef.has( light ) ) {

						lightNode = nodeObject( new lightNodeClass( light ) );
						_lightsNodeRef.set( light, lightNode );

					} else {

						lightNode = _lightsNodeRef.get( light );

					}

					lightNodes.push( lightNode );

				}

			}

		}

		this._lightNodes = lightNodes;

	}

	setupLights( builder, lightNodes ) {

		for ( const lightNode of lightNodes ) {

			lightNode.build( builder );

		}

	}

	setup( builder ) {

		if ( this._lightNodes === null ) this.setupLightsNode( builder );

		const context = builder.context;
		const lightingModel = context.lightingModel;

		let outgoingLightNode = this.outgoingLightNode;

		if ( lightingModel ) {

			const { _lightNodes, totalDiffuseNode, totalSpecularNode } = this;

			context.outgoingLight = outgoingLightNode;

			const stack = builder.addStack();

			//

			const properties = builder.getDataFromNode( this );
			properties.nodes = stack.nodes;

			//

			lightingModel.start( context, stack, builder );

			// lights

			this.setupLights( builder, _lightNodes );

			//

			lightingModel.indirect( context, stack, builder );

			//

			const { backdrop, backdropAlpha } = context;
			const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;

			let totalDiffuse = directDiffuse.add( indirectDiffuse );

			if ( backdrop !== null ) {

				if ( backdropAlpha !== null ) {

					totalDiffuse = vec3( backdropAlpha.mix( totalDiffuse, backdrop ) );

				} else {

					totalDiffuse = vec3( backdrop );

				}

				context.material.transparent = true;

			}

			totalDiffuseNode.assign( totalDiffuse );
			totalSpecularNode.assign( directSpecular.add( indirectSpecular ) );

			outgoingLightNode.assign( totalDiffuseNode.add( totalSpecularNode ) );

			//

			lightingModel.finish( context, stack, builder );

			//

			outgoingLightNode = outgoingLightNode.bypass( builder.removeStack() );

		}

		return outgoingLightNode;

	}

	setLights( lights ) {

		this._lights = lights;

		this._lightNodes = null;
		this._lightNodesHash = null;

		return this;

	}

	getLights() {

		return this._lights;

	}

	get hasLights() {

		return this._lights.length > 0;

	}

}

const lights = ( lights = [] ) => nodeObject( new LightsNode() ).setLights( lights );

const shadowMaterialLib = /*@__PURE__*/ new WeakMap();
const shadowWorldPosition = /*@__PURE__*/ vec3().toVar( 'shadowWorldPosition' );

const linearDistance = /*@__PURE__*/ Fn( ( [ position, cameraNear, cameraFar ] ) => {

	let dist = positionWorld.sub( position ).length();
	dist = dist.sub( cameraNear ).div( cameraFar.sub( cameraNear ) );
	dist = dist.saturate(); // clamp to [ 0, 1 ]

	return dist;

} );

const linearShadowDistance = ( light ) => {

	const camera = light.shadow.camera;

	const nearDistance = reference( 'near', 'float', camera ).setGroup( renderGroup );
	const farDistance = reference( 'far', 'float', camera ).setGroup( renderGroup );

	const referencePosition = objectPosition( light );

	return linearDistance( referencePosition, nearDistance, farDistance );

};

const getShadowMaterial = ( light ) => {

	let material = shadowMaterialLib.get( light );

	if ( material === undefined ) {

		const depthNode = light.isPointLight ? linearShadowDistance( light ) : null;

		material = new NodeMaterial();
		material.colorNode = vec4( 0, 0, 0, 1 );
		material.depthNode = depthNode;
		material.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode
		material.blending = NoBlending;
		material.name = 'ShadowMaterial';

		shadowMaterialLib.set( light, material );

	}

	return material;

};

const BasicShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord } ) => {

	return texture( depthTexture, shadowCoord.xy ).compare( shadowCoord.z );

} );

const PCFShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow } ) => {

	const depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );

	const mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );
	const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );

	const texelSize = vec2( 1 ).div( mapSize );
	const dx0 = texelSize.x.negate().mul( radius );
	const dy0 = texelSize.y.negate().mul( radius );
	const dx1 = texelSize.x.mul( radius );
	const dy1 = texelSize.y.mul( radius );
	const dx2 = dx0.div( 2 );
	const dy2 = dy0.div( 2 );
	const dx3 = dx1.div( 2 );
	const dy3 = dy1.div( 2 );

	return add(
		depthCompare( shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy, shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )
	).mul( 1 / 17 );

} );

const PCFSoftShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow } ) => {

	const depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );

	const mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );

	const texelSize = vec2( 1 ).div( mapSize );
	const dx = texelSize.x;
	const dy = texelSize.y;

	const uv = shadowCoord.xy;
	const f = fract( uv.mul( mapSize ).add( 0.5 ) );
	uv.subAssign( f.mul( texelSize ) );

	return add(
		depthCompare( uv, shadowCoord.z ),
		depthCompare( uv.add( vec2( dx, 0 ) ), shadowCoord.z ),
		depthCompare( uv.add( vec2( 0, dy ) ), shadowCoord.z ),
		depthCompare( uv.add( texelSize ), shadowCoord.z ),
		mix(
			depthCompare( uv.add( vec2( dx.negate(), 0 ) ), shadowCoord.z ),
			depthCompare( uv.add( vec2( dx.mul( 2 ), 0 ) ), shadowCoord.z ),
			f.x
		),
		mix(
			depthCompare( uv.add( vec2( dx.negate(), dy ) ), shadowCoord.z ),
			depthCompare( uv.add( vec2( dx.mul( 2 ), dy ) ), shadowCoord.z ),
			f.x
		),
		mix(
			depthCompare( uv.add( vec2( 0, dy.negate() ) ), shadowCoord.z ),
			depthCompare( uv.add( vec2( 0, dy.mul( 2 ) ) ), shadowCoord.z ),
			f.y
		),
		mix(
			depthCompare( uv.add( vec2( dx, dy.negate() ) ), shadowCoord.z ),
			depthCompare( uv.add( vec2( dx, dy.mul( 2 ) ) ), shadowCoord.z ),
			f.y
		),
		mix(
			mix(
				depthCompare( uv.add( vec2( dx.negate(), dy.negate() ) ), shadowCoord.z ),
				depthCompare( uv.add( vec2( dx.mul( 2 ), dy.negate() ) ), shadowCoord.z ),
				f.x
			),
			mix(
				depthCompare( uv.add( vec2( dx.negate(), dy.mul( 2 ) ) ), shadowCoord.z ),
				depthCompare( uv.add( vec2( dx.mul( 2 ), dy.mul( 2 ) ) ), shadowCoord.z ),
				f.x
			),
			f.y
		)
	).mul( 1 / 9 );

} );

// VSM

const VSMShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord } ) => {

	const occlusion = float( 1 ).toVar();

	const distribution = texture( depthTexture ).uv( shadowCoord.xy ).rg;

	const hardShadow = step( shadowCoord.z, distribution.x );

	If( hardShadow.notEqual( float( 1.0 ) ), () => {

		const distance = shadowCoord.z.sub( distribution.x );
		const variance = max$1( 0, distribution.y.mul( distribution.y ) );
		let softnessProbability = variance.div( variance.add( distance.mul( distance ) ) ); // Chebeyshevs inequality
		softnessProbability = clamp( sub( softnessProbability, 0.3 ).div( 0.95 - 0.3 ) );
		occlusion.assign( clamp( max$1( hardShadow, softnessProbability ) ) );

	} );

	return occlusion;

} );

const VSMPassVertical = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass } ) => {

	const mean = float( 0 ).toVar();
	const squaredMean = float( 0 ).toVar();

	const uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );
	const uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );

	Loop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {

		const uvOffset = uvStart.add( float( i ).mul( uvStride ) );

		const depth = shadowPass.uv( add( screenCoordinate.xy, vec2( 0, uvOffset ).mul( radius ) ).div( size ) ).x;
		mean.addAssign( depth );
		squaredMean.addAssign( depth.mul( depth ) );

	} );

	mean.divAssign( samples );
	squaredMean.divAssign( samples );

	const std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );
	return vec2( mean, std_dev );

} );

const VSMPassHorizontal = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass } ) => {

	const mean = float( 0 ).toVar();
	const squaredMean = float( 0 ).toVar();

	const uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );
	const uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );

	Loop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {

		const uvOffset = uvStart.add( float( i ).mul( uvStride ) );

		const distribution = shadowPass.uv( add( screenCoordinate.xy, vec2( uvOffset, 0 ).mul( radius ) ).div( size ) );
		mean.addAssign( distribution.x );
		squaredMean.addAssign( add( distribution.y.mul( distribution.y ), distribution.x.mul( distribution.x ) ) );

	} );

	mean.divAssign( samples );
	squaredMean.divAssign( samples );

	const std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );
	return vec2( mean, std_dev );

} );

const _shadowFilterLib = [ BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter ];

//

const _quadMesh$1 = /*@__PURE__*/ new QuadMesh();

class ShadowNode extends Node {

	static get type() {

		return 'ShadowNode';

	}

	constructor( light, shadow = null ) {

		super();

		this.light = light;
		this.shadow = shadow || light.shadow;

		this.shadowMap = null;

		this.vsmShadowMapVertical = null;
		this.vsmShadowMapHorizontal = null;

		this.vsmMaterialVertical = null;
		this.vsmMaterialHorizontal = null;

		this.updateBeforeType = NodeUpdateType.RENDER;
		this._node = null;

		this.isShadowNode = true;

	}

	setupShadowFilter( builder, { filterFn, depthTexture, shadowCoord, shadow } ) {

		const frustumTest = shadowCoord.x.greaterThanEqual( 0 )
			.and( shadowCoord.x.lessThanEqual( 1 ) )
			.and( shadowCoord.y.greaterThanEqual( 0 ) )
			.and( shadowCoord.y.lessThanEqual( 1 ) )
			.and( shadowCoord.z.lessThanEqual( 1 ) );

		const shadowNode = filterFn( { depthTexture, shadowCoord, shadow } );

		return frustumTest.select( shadowNode, float( 1 ) );

	}

	setupShadowCoord( builder, shadowPosition ) {

		const { shadow } = this;
		const { renderer } = builder;

		const bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );

		let shadowCoord = shadowPosition;
		let coordZ;

		if ( shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true ) {

			shadowCoord = shadowCoord.xyz.div( shadowCoord.w );

			coordZ = shadowCoord.z;

			if ( renderer.coordinateSystem === WebGPUCoordinateSystem ) {

				coordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]

			}

		} else {

			const w = shadowCoord.w;
			shadowCoord = shadowCoord.xy.div( w ); // <-- Only divide X/Y coords since we don't need Z

			// The normally available "cameraNear" and "cameraFar" nodes cannot be used here because they do not get
			// updated to use the shadow camera. So, we have to declare our own "local" ones here.
			// TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?
			const cameraNearLocal = reference( 'near', 'float', shadow.camera ).setGroup( renderGroup );
			const cameraFarLocal = reference( 'far', 'float', shadow.camera ).setGroup( renderGroup );

			coordZ = viewZToLogarithmicDepth( w.negate(), cameraNearLocal, cameraFarLocal );

		}

		shadowCoord = vec3(
			shadowCoord.x,
			shadowCoord.y.oneMinus(), // follow webgpu standards
			coordZ.add( bias )
		);

		return shadowCoord;

	}

	getShadowFilterFn( type ) {

		return _shadowFilterLib[ type ];

	}

	setupShadow( builder ) {

		const { renderer } = builder;

		const { light, shadow } = this;

		const shadowMapType = renderer.shadowMap.type;

		const depthTexture = new DepthTexture( shadow.mapSize.width, shadow.mapSize.height );
		depthTexture.compareFunction = LessCompare;

		const shadowMap = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height );
		shadowMap.depthTexture = depthTexture;

		shadow.camera.updateProjectionMatrix();

		// VSM

		if ( shadowMapType === VSMShadowMap ) {

			depthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()

			this.vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );
			this.vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );

			const shadowPassVertical = texture( depthTexture );
			const shadowPassHorizontal = texture( this.vsmShadowMapVertical.texture );

			const samples = reference( 'blurSamples', 'float', shadow ).setGroup( renderGroup );
			const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );
			const size = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );

			let material = this.vsmMaterialVertical || ( this.vsmMaterialVertical = new NodeMaterial() );
			material.fragmentNode = VSMPassVertical( { samples, radius, size, shadowPass: shadowPassVertical } ).context( builder.getSharedContext() );
			material.name = 'VSMVertical';

			material = this.vsmMaterialHorizontal || ( this.vsmMaterialHorizontal = new NodeMaterial() );
			material.fragmentNode = VSMPassHorizontal( { samples, radius, size, shadowPass: shadowPassHorizontal } ).context( builder.getSharedContext() );
			material.name = 'VSMHorizontal';

		}

		//

		const shadowIntensity = reference( 'intensity', 'float', shadow ).setGroup( renderGroup );
		const normalBias = reference( 'normalBias', 'float', shadow ).setGroup( renderGroup );

		const shadowPosition = lightShadowMatrix( light ).mul( shadowWorldPosition.add( transformedNormalWorld.mul( normalBias ) ) );
		const shadowCoord = this.setupShadowCoord( builder, shadowPosition );

		//

		const filterFn = shadow.filterNode || this.getShadowFilterFn( renderer.shadowMap.type ) || null;

		if ( filterFn === null ) {

			throw new Error( 'THREE.WebGPURenderer: Shadow map type not supported yet.' );

		}

		const shadowDepthTexture = ( shadowMapType === VSMShadowMap ) ? this.vsmShadowMapHorizontal.texture : depthTexture;

		const shadowNode = this.setupShadowFilter( builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow } );

		const shadowColor = texture( shadowMap.texture, shadowCoord );
		const shadowOutput = mix( 1, shadowNode.rgb.mix( shadowColor, 1 ), shadowIntensity.mul( shadowColor.a ) ).toVar();

		this.shadowMap = shadowMap;
		this.shadow.map = shadowMap;

		return shadowOutput;

	}

	setup( builder ) {

		if ( builder.renderer.shadowMap.enabled === false ) return;

		return Fn( ( { material } ) => {

			shadowWorldPosition.assign( material.shadowPositionNode || positionWorld );

			let node = this._node;

			if ( node === null ) {

				this._node = node = this.setupShadow( builder );

			}

			if ( builder.material.shadowNode ) { // @deprecated, r171

				console.warn( 'THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.' );

			}

			if ( builder.material.receivedShadowNode ) {

				node = builder.material.receivedShadowNode( node );

			}

			return node;

		} )();

	}

	renderShadow( frame ) {

		const { shadow, shadowMap } = this;
		const { renderer, scene } = frame;

		shadowMap.setSize( shadow.mapSize.width, shadow.mapSize.height );

		renderer.render( scene, shadow.camera );

	}

	updateShadow( frame ) {

		const { shadowMap, light, shadow } = this;
		const { renderer, scene, camera } = frame;

		const shadowType = renderer.shadowMap.type;

		const depthVersion = shadowMap.depthTexture.version;
		this._depthVersionCached = depthVersion;

		const currentOverrideMaterial = scene.overrideMaterial;

		scene.overrideMaterial = getShadowMaterial( light );

		shadow.camera.layers.mask = camera.layers.mask;

		const currentRenderTarget = renderer.getRenderTarget();
		const currentRenderObjectFunction = renderer.getRenderObjectFunction();
		const currentMRT = renderer.getMRT();

		renderer.setMRT( null );

		renderer.setRenderObjectFunction( ( object, ...params ) => {

			if ( object.castShadow === true || ( object.receiveShadow && shadowType === VSMShadowMap ) ) {

				renderer.renderObject( object, ...params );

			}

		} );

		renderer.setRenderTarget( shadowMap );

		this.renderShadow( frame );

		renderer.setRenderObjectFunction( currentRenderObjectFunction );

		// vsm blur pass

		if ( light.isPointLight !== true && shadowType === VSMShadowMap ) {

			this.vsmPass( renderer );

		}

		renderer.setRenderTarget( currentRenderTarget );

		renderer.setMRT( currentMRT );

		scene.overrideMaterial = currentOverrideMaterial;

	}

	vsmPass( renderer ) {

		const { shadow } = this;

		this.vsmShadowMapVertical.setSize( shadow.mapSize.width, shadow.mapSize.height );
		this.vsmShadowMapHorizontal.setSize( shadow.mapSize.width, shadow.mapSize.height );

		renderer.setRenderTarget( this.vsmShadowMapVertical );
		_quadMesh$1.material = this.vsmMaterialVertical;
		_quadMesh$1.render( renderer );

		renderer.setRenderTarget( this.vsmShadowMapHorizontal );
		_quadMesh$1.material = this.vsmMaterialHorizontal;
		_quadMesh$1.render( renderer );

	}

	dispose() {

		this.shadowMap.dispose();
		this.shadowMap = null;

		if ( this.vsmShadowMapVertical !== null ) {

			this.vsmShadowMapVertical.dispose();
			this.vsmShadowMapVertical = null;

			this.vsmMaterialVertical.dispose();
			this.vsmMaterialVertical = null;

		}

		if ( this.vsmShadowMapHorizontal !== null ) {

			this.vsmShadowMapHorizontal.dispose();
			this.vsmShadowMapHorizontal = null;

			this.vsmMaterialHorizontal.dispose();
			this.vsmMaterialHorizontal = null;

		}

		this.updateBeforeType = NodeUpdateType.NONE;

	}

	updateBefore( frame ) {

		const { shadow } = this;

		const needsUpdate = shadow.needsUpdate || shadow.autoUpdate;

		if ( needsUpdate ) {

			this.updateShadow( frame );

			if ( this.shadowMap.depthTexture.version === this._depthVersionCached ) {

				shadow.needsUpdate = false;

			}

		}

	}

}

const shadow = ( light, shadow ) => nodeObject( new ShadowNode( light, shadow ) );

class AnalyticLightNode extends LightingNode {

	static get type() {

		return 'AnalyticLightNode';

	}

	constructor( light = null ) {

		super();

		this.light = light;

		this.color = new Color();
		this.colorNode = ( light && light.colorNode ) || uniform( this.color ).setGroup( renderGroup );

		this.baseColorNode = null;

		this.shadowNode = null;
		this.shadowColorNode = null;

		this.isAnalyticLightNode = true;

		this.updateType = NodeUpdateType.FRAME;

	}

	getCacheKey() {

		return hash$1( super.getCacheKey(), this.light.id, this.light.castShadow ? 1 : 0 );

	}

	getHash() {

		return this.light.uuid;

	}

	setupShadowNode() {

		return shadow( this.light );

	}

	setupShadow( builder ) {

		const { renderer } = builder;

		if ( renderer.shadowMap.enabled === false ) return;

		let shadowColorNode = this.shadowColorNode;

		if ( shadowColorNode === null ) {

			const customShadowNode = this.light.shadow.shadowNode;

			let shadowNode;

			if ( customShadowNode !== undefined ) {

				shadowNode = nodeObject( customShadowNode );

			} else {

				shadowNode = this.setupShadowNode( builder );

			}

			this.shadowNode = shadowNode;

			this.shadowColorNode = shadowColorNode = this.colorNode.mul( shadowNode );

			this.baseColorNode = this.colorNode;

		}

		//

		this.colorNode = shadowColorNode;

	}

	setup( builder ) {

		this.colorNode = this.baseColorNode || this.colorNode;

		if ( this.light.castShadow ) {

			if ( builder.object.receiveShadow ) {

				this.setupShadow( builder );

			}

		} else if ( this.shadowNode !== null ) {

			this.shadowNode.dispose();
			this.shadowNode = null;
			this.shadowColorNode = null;

		}

	}

	update( /*frame*/ ) {

		const { light } = this;

		this.color.copy( light.color ).multiplyScalar( light.intensity );

	}

}

const getDistanceAttenuation = /*@__PURE__*/ Fn( ( inputs ) => {

	const { lightDistance, cutoffDistance, decayExponent } = inputs;

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	const distanceFalloff = lightDistance.pow( decayExponent ).max( 0.01 ).reciprocal();

	return cutoffDistance.greaterThan( 0 ).select(
		distanceFalloff.mul( lightDistance.div( cutoffDistance ).pow4().oneMinus().clamp().pow2() ),
		distanceFalloff
	);

} ); // validated

const _clearColor$2 = /*@__PURE__*/ new Color();

// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
// vector suitable for 2D texture mapping. This code uses the following layout for the
// 2D texture:
//
// xzXZ
//  y Y
//
// Y - Positive y direction
// y - Negative y direction
// X - Positive x direction
// x - Negative x direction
// Z - Positive z direction
// z - Negative z direction
//
// Source and test bed:
// https://gist.github.com/tschw/da10c43c467ce8afd0c4

const cubeToUV = /*@__PURE__*/ Fn( ( [ pos, texelSizeY ] ) => {

	const v = pos.toVar();

	// Number of texels to avoid at the edge of each square

	const absV = abs( v );

	// Intersect unit cube

	const scaleToCube = div( 1.0, max$1( absV.x, max$1( absV.y, absV.z ) ) );
	absV.mulAssign( scaleToCube );

	// Apply scale to avoid seams

	// two texels less per square (one texel will do for NEAREST)
	v.mulAssign( scaleToCube.mul( texelSizeY.mul( 2 ).oneMinus() ) );

	// Unwrap

	// space: -1 ... 1 range for each square
	//
	// #X##		dim    := ( 4 , 2 )
	//  # #		center := ( 1 , 1 )

	const planar = vec2( v.xy ).toVar();

	const almostATexel = texelSizeY.mul( 1.5 );
	const almostOne = almostATexel.oneMinus();

	If( absV.z.greaterThanEqual( almostOne ), () => {

		If( v.z.greaterThan( 0.0 ), () => {

			planar.x.assign( sub( 4.0, v.x ) );

		} );

	} ).ElseIf( absV.x.greaterThanEqual( almostOne ), () => {

		const signX = sign( v.x );
		planar.x.assign( v.z.mul( signX ).add( signX.mul( 2.0 ) ) );

	} ).ElseIf( absV.y.greaterThanEqual( almostOne ), () => {

		const signY = sign( v.y );
		planar.x.assign( v.x.add( signY.mul( 2.0 ) ).add( 2.0 ) );
		planar.y.assign( v.z.mul( signY ).sub( 2.0 ) );

	} );

	// Transform to UV space

	// scale := 0.5 / dim
	// translate := ( center + 0.5 ) / dim
	return vec2( 0.125, 0.25 ).mul( planar ).add( vec2( 0.375, 0.75 ) ).flipY();

} ).setLayout( {
	name: 'cubeToUV',
	type: 'vec2',
	inputs: [
		{ name: 'pos', type: 'vec3' },
		{ name: 'texelSizeY', type: 'float' }
	]
} );

const BasicPointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize } ) => {

	return texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp );

} );

const PointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize, shadow } ) => {

	const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );
	const offset = vec2( - 1.0, 1.0 ).mul( radius ).mul( texelSize.y );

	return texture( depthTexture, cubeToUV( bd3D.add( offset.xyy ), texelSize.y ) ).compare( dp )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyy ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xyx ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyx ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxy ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxy ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxx ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxx ), texelSize.y ) ).compare( dp ) )
		.mul( 1.0 / 9.0 );

} );

const pointShadowFilter = /*@__PURE__*/ Fn( ( { filterFn, depthTexture, shadowCoord, shadow } ) => {

	// for point lights, the uniform @vShadowCoord is re-purposed to hold
	// the vector from the light to the world-space position of the fragment.
	const lightToPosition = shadowCoord.xyz.toVar();
	const lightToPositionLength = lightToPosition.length();

	const cameraNearLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.near );
	const cameraFarLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.far );
	const bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );
	const mapSize = uniform( shadow.mapSize ).setGroup( renderGroup );

	const result = float( 1.0 ).toVar();

	If( lightToPositionLength.sub( cameraFarLocal ).lessThanEqual( 0.0 ).and( lightToPositionLength.sub( cameraNearLocal ).greaterThanEqual( 0.0 ) ), () => {

		// dp = normalized distance from light to fragment position
		const dp = lightToPositionLength.sub( cameraNearLocal ).div( cameraFarLocal.sub( cameraNearLocal ) ).toVar(); // need to clamp?
		dp.addAssign( bias );

		// bd3D = base direction 3D
		const bd3D = lightToPosition.normalize();
		const texelSize = vec2( 1.0 ).div( mapSize.mul( vec2( 4.0, 2.0 ) ) );

		// percentage-closer filtering
		result.assign( filterFn( { depthTexture, bd3D, dp, texelSize, shadow } ) );

	} );

	return result;

} );

const _viewport = /*@__PURE__*/ new Vector4();
const _viewportSize = /*@__PURE__*/ new Vector2();
const _shadowMapSize = /*@__PURE__*/ new Vector2();

//

class PointShadowNode extends ShadowNode {

	static get type() {

		return 'PointShadowNode';

	}

	constructor( light, shadow = null ) {

		super( light, shadow );

	}

	getShadowFilterFn( type ) {

		return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;

	}

	setupShadowCoord( builder, shadowPosition ) {

		return shadowPosition;

	}

	setupShadowFilter( builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } ) {

		return pointShadowFilter( { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } );

	}

	renderShadow( frame ) {

		const { shadow, shadowMap, light } = this;
		const { renderer, scene } = frame;

		const shadowFrameExtents = shadow.getFrameExtents();

		_shadowMapSize.copy( shadow.mapSize );
		_shadowMapSize.multiply( shadowFrameExtents );

		shadowMap.setSize( _shadowMapSize.width, _shadowMapSize.height );

		_viewportSize.copy( shadow.mapSize );

		//

		const previousAutoClear = renderer.autoClear;

		const previousClearColor = renderer.getClearColor( _clearColor$2 );
		const previousClearAlpha = renderer.getClearAlpha();

		renderer.autoClear = false;
		renderer.setClearColor( shadow.clearColor, shadow.clearAlpha );
		renderer.clear();

		const viewportCount = shadow.getViewportCount();

		for ( let vp = 0; vp < viewportCount; vp ++ ) {

			const viewport = shadow.getViewport( vp );

			const x = _viewportSize.x * viewport.x;
			const y = _shadowMapSize.y - _viewportSize.y - ( _viewportSize.y * viewport.y );

			_viewport.set(
				x,
				y,
				_viewportSize.x * viewport.z,
				_viewportSize.y * viewport.w
			);

			shadowMap.viewport.copy( _viewport );

			shadow.updateMatrices( light, vp );

			renderer.render( scene, shadow.camera );

		}

		//

		renderer.autoClear = previousAutoClear;
		renderer.setClearColor( previousClearColor, previousClearAlpha );

	}

}

const pointShadow = ( light, shadow ) => nodeObject( new PointShadowNode( light, shadow ) );

const directPointLight = Fn( ( { color, lightViewPosition, cutoffDistance, decayExponent }, builder ) => {

	const lightingModel = builder.context.lightingModel;

	const lVector = lightViewPosition.sub( positionView ); // @TODO: Add it into LightNode

	const lightDirection = lVector.normalize();
	const lightDistance = lVector.length();

	const lightAttenuation = getDistanceAttenuation( {
		lightDistance,
		cutoffDistance,
		decayExponent
	} );

	const lightColor = color.mul( lightAttenuation );

	const reflectedLight = builder.context.reflectedLight;

	lightingModel.direct( {
		lightDirection,
		lightColor,
		reflectedLight
	}, builder.stack, builder );

} );

class PointLightNode extends AnalyticLightNode {

	static get type() {

		return 'PointLightNode';

	}

	constructor( light = null ) {

		super( light );

		this.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );
		this.decayExponentNode = uniform( 0 ).setGroup( renderGroup );

	}

	update( frame ) {

		const { light } = this;

		super.update( frame );

		this.cutoffDistanceNode.value = light.distance;
		this.decayExponentNode.value = light.decay;

	}

	setupShadowNode() {

		return pointShadow( this.light );

	}

	setup( builder ) {

		super.setup( builder );

		directPointLight( {
			color: this.colorNode,
			lightViewPosition: lightViewPosition( this.light ),
			cutoffDistance: this.cutoffDistanceNode,
			decayExponent: this.decayExponentNode
		} ).append();

	}

}

const checker = /*@__PURE__*/ Fn( ( [ coord = uv() ] ) => {

	const uv = coord.mul( 2.0 );

	const cx = uv.x.floor();
	const cy = uv.y.floor();
	const result = cx.add( cy ).mod( 2.0 );

	return result.sign();

} );

// Three.js Transpiler
// https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl



const mx_select = /*@__PURE__*/ Fn( ( [ b_immutable, t_immutable, f_immutable ] ) => {

	const f = float( f_immutable ).toVar();
	const t = float( t_immutable ).toVar();
	const b = bool( b_immutable ).toVar();

	return select( b, t, f );

} ).setLayout( {
	name: 'mx_select',
	type: 'float',
	inputs: [
		{ name: 'b', type: 'bool' },
		{ name: 't', type: 'float' },
		{ name: 'f', type: 'float' }
	]
} );

const mx_negate_if = /*@__PURE__*/ Fn( ( [ val_immutable, b_immutable ] ) => {

	const b = bool( b_immutable ).toVar();
	const val = float( val_immutable ).toVar();

	return select( b, val.negate(), val );

} ).setLayout( {
	name: 'mx_negate_if',
	type: 'float',
	inputs: [
		{ name: 'val', type: 'float' },
		{ name: 'b', type: 'bool' }
	]
} );

const mx_floor = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {

	const x = float( x_immutable ).toVar();

	return int( floor( x ) );

} ).setLayout( {
	name: 'mx_floor',
	type: 'int',
	inputs: [
		{ name: 'x', type: 'float' }
	]
} );

const mx_floorfrac = /*@__PURE__*/ Fn( ( [ x_immutable, i ] ) => {

	const x = float( x_immutable ).toVar();
	i.assign( mx_floor( x ) );

	return x.sub( float( i ) );

} );

const mx_bilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {

	const t = float( t_immutable ).toVar();
	const s = float( s_immutable ).toVar();
	const v3 = float( v3_immutable ).toVar();
	const v2 = float( v2_immutable ).toVar();
	const v1 = float( v1_immutable ).toVar();
	const v0 = float( v0_immutable ).toVar();
	const s1 = float( sub( 1.0, s ) ).toVar();

	return sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );

} ).setLayout( {
	name: 'mx_bilerp_0',
	type: 'float',
	inputs: [
		{ name: 'v0', type: 'float' },
		{ name: 'v1', type: 'float' },
		{ name: 'v2', type: 'float' },
		{ name: 'v3', type: 'float' },
		{ name: 's', type: 'float' },
		{ name: 't', type: 'float' }
	]
} );

const mx_bilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {

	const t = float( t_immutable ).toVar();
	const s = float( s_immutable ).toVar();
	const v3 = vec3( v3_immutable ).toVar();
	const v2 = vec3( v2_immutable ).toVar();
	const v1 = vec3( v1_immutable ).toVar();
	const v0 = vec3( v0_immutable ).toVar();
	const s1 = float( sub( 1.0, s ) ).toVar();

	return sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );

} ).setLayout( {
	name: 'mx_bilerp_1',
	type: 'vec3',
	inputs: [
		{ name: 'v0', type: 'vec3' },
		{ name: 'v1', type: 'vec3' },
		{ name: 'v2', type: 'vec3' },
		{ name: 'v3', type: 'vec3' },
		{ name: 's', type: 'float' },
		{ name: 't', type: 'float' }
	]
} );

const mx_bilerp = /*@__PURE__*/ overloadingFn( [ mx_bilerp_0, mx_bilerp_1 ] );

const mx_trilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {

	const r = float( r_immutable ).toVar();
	const t = float( t_immutable ).toVar();
	const s = float( s_immutable ).toVar();
	const v7 = float( v7_immutable ).toVar();
	const v6 = float( v6_immutable ).toVar();
	const v5 = float( v5_immutable ).toVar();
	const v4 = float( v4_immutable ).toVar();
	const v3 = float( v3_immutable ).toVar();
	const v2 = float( v2_immutable ).toVar();
	const v1 = float( v1_immutable ).toVar();
	const v0 = float( v0_immutable ).toVar();
	const s1 = float( sub( 1.0, s ) ).toVar();
	const t1 = float( sub( 1.0, t ) ).toVar();
	const r1 = float( sub( 1.0, r ) ).toVar();

	return r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );

} ).setLayout( {
	name: 'mx_trilerp_0',
	type: 'float',
	inputs: [
		{ name: 'v0', type: 'float' },
		{ name: 'v1', type: 'float' },
		{ name: 'v2', type: 'float' },
		{ name: 'v3', type: 'float' },
		{ name: 'v4', type: 'float' },
		{ name: 'v5', type: 'float' },
		{ name: 'v6', type: 'float' },
		{ name: 'v7', type: 'float' },
		{ name: 's', type: 'float' },
		{ name: 't', type: 'float' },
		{ name: 'r', type: 'float' }
	]
} );

const mx_trilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {

	const r = float( r_immutable ).toVar();
	const t = float( t_immutable ).toVar();
	const s = float( s_immutable ).toVar();
	const v7 = vec3( v7_immutable ).toVar();
	const v6 = vec3( v6_immutable ).toVar();
	const v5 = vec3( v5_immutable ).toVar();
	const v4 = vec3( v4_immutable ).toVar();
	const v3 = vec3( v3_immutable ).toVar();
	const v2 = vec3( v2_immutable ).toVar();
	const v1 = vec3( v1_immutable ).toVar();
	const v0 = vec3( v0_immutable ).toVar();
	const s1 = float( sub( 1.0, s ) ).toVar();
	const t1 = float( sub( 1.0, t ) ).toVar();
	const r1 = float( sub( 1.0, r ) ).toVar();

	return r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );

} ).setLayout( {
	name: 'mx_trilerp_1',
	type: 'vec3',
	inputs: [
		{ name: 'v0', type: 'vec3' },
		{ name: 'v1', type: 'vec3' },
		{ name: 'v2', type: 'vec3' },
		{ name: 'v3', type: 'vec3' },
		{ name: 'v4', type: 'vec3' },
		{ name: 'v5', type: 'vec3' },
		{ name: 'v6', type: 'vec3' },
		{ name: 'v7', type: 'vec3' },
		{ name: 's', type: 'float' },
		{ name: 't', type: 'float' },
		{ name: 'r', type: 'float' }
	]
} );

const mx_trilerp = /*@__PURE__*/ overloadingFn( [ mx_trilerp_0, mx_trilerp_1 ] );

const mx_gradient_float_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {

	const y = float( y_immutable ).toVar();
	const x = float( x_immutable ).toVar();
	const hash = uint( hash_immutable ).toVar();
	const h = uint( hash.bitAnd( uint( 7 ) ) ).toVar();
	const u = float( mx_select( h.lessThan( uint( 4 ) ), x, y ) ).toVar();
	const v = float( mul( 2.0, mx_select( h.lessThan( uint( 4 ) ), y, x ) ) ).toVar();

	return mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );

} ).setLayout( {
	name: 'mx_gradient_float_0',
	type: 'float',
	inputs: [
		{ name: 'hash', type: 'uint' },
		{ name: 'x', type: 'float' },
		{ name: 'y', type: 'float' }
	]
} );

const mx_gradient_float_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {

	const z = float( z_immutable ).toVar();
	const y = float( y_immutable ).toVar();
	const x = float( x_immutable ).toVar();
	const hash = uint( hash_immutable ).toVar();
	const h = uint( hash.bitAnd( uint( 15 ) ) ).toVar();
	const u = float( mx_select( h.lessThan( uint( 8 ) ), x, y ) ).toVar();
	const v = float( mx_select( h.lessThan( uint( 4 ) ), y, mx_select( h.equal( uint( 12 ) ).or( h.equal( uint( 14 ) ) ), x, z ) ) ).toVar();

	return mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );

} ).setLayout( {
	name: 'mx_gradient_float_1',
	type: 'float',
	inputs: [
		{ name: 'hash', type: 'uint' },
		{ name: 'x', type: 'float' },
		{ name: 'y', type: 'float' },
		{ name: 'z', type: 'float' }
	]
} );

const mx_gradient_float = /*@__PURE__*/ overloadingFn( [ mx_gradient_float_0, mx_gradient_float_1 ] );

const mx_gradient_vec3_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {

	const y = float( y_immutable ).toVar();
	const x = float( x_immutable ).toVar();
	const hash = uvec3( hash_immutable ).toVar();

	return vec3( mx_gradient_float( hash.x, x, y ), mx_gradient_float( hash.y, x, y ), mx_gradient_float( hash.z, x, y ) );

} ).setLayout( {
	name: 'mx_gradient_vec3_0',
	type: 'vec3',
	inputs: [
		{ name: 'hash', type: 'uvec3' },
		{ name: 'x', type: 'float' },
		{ name: 'y', type: 'float' }
	]
} );

const mx_gradient_vec3_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {

	const z = float( z_immutable ).toVar();
	const y = float( y_immutable ).toVar();
	const x = float( x_immutable ).toVar();
	const hash = uvec3( hash_immutable ).toVar();

	return vec3( mx_gradient_float( hash.x, x, y, z ), mx_gradient_float( hash.y, x, y, z ), mx_gradient_float( hash.z, x, y, z ) );

} ).setLayout( {
	name: 'mx_gradient_vec3_1',
	type: 'vec3',
	inputs: [
		{ name: 'hash', type: 'uvec3' },
		{ name: 'x', type: 'float' },
		{ name: 'y', type: 'float' },
		{ name: 'z', type: 'float' }
	]
} );

const mx_gradient_vec3 = /*@__PURE__*/ overloadingFn( [ mx_gradient_vec3_0, mx_gradient_vec3_1 ] );

const mx_gradient_scale2d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {

	const v = float( v_immutable ).toVar();

	return mul( 0.6616, v );

} ).setLayout( {
	name: 'mx_gradient_scale2d_0',
	type: 'float',
	inputs: [
		{ name: 'v', type: 'float' }
	]
} );

const mx_gradient_scale3d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {

	const v = float( v_immutable ).toVar();

	return mul( 0.9820, v );

} ).setLayout( {
	name: 'mx_gradient_scale3d_0',
	type: 'float',
	inputs: [
		{ name: 'v', type: 'float' }
	]
} );

const mx_gradient_scale2d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {

	const v = vec3( v_immutable ).toVar();

	return mul( 0.6616, v );

} ).setLayout( {
	name: 'mx_gradient_scale2d_1',
	type: 'vec3',
	inputs: [
		{ name: 'v', type: 'vec3' }
	]
} );

const mx_gradient_scale2d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale2d_0, mx_gradient_scale2d_1 ] );

const mx_gradient_scale3d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {

	const v = vec3( v_immutable ).toVar();

	return mul( 0.9820, v );

} ).setLayout( {
	name: 'mx_gradient_scale3d_1',
	type: 'vec3',
	inputs: [
		{ name: 'v', type: 'vec3' }
	]
} );

const mx_gradient_scale3d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale3d_0, mx_gradient_scale3d_1 ] );

const mx_rotl32 = /*@__PURE__*/ Fn( ( [ x_immutable, k_immutable ] ) => {

	const k = int( k_immutable ).toVar();
	const x = uint( x_immutable ).toVar();

	return x.shiftLeft( k ).bitOr( x.shiftRight( int( 32 ).sub( k ) ) );

} ).setLayout( {
	name: 'mx_rotl32',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'uint' },
		{ name: 'k', type: 'int' }
	]
} );

const mx_bjmix = /*@__PURE__*/ Fn( ( [ a, b, c ] ) => {

	a.subAssign( c );
	a.bitXorAssign( mx_rotl32( c, int( 4 ) ) );
	c.addAssign( b );
	b.subAssign( a );
	b.bitXorAssign( mx_rotl32( a, int( 6 ) ) );
	a.addAssign( c );
	c.subAssign( b );
	c.bitXorAssign( mx_rotl32( b, int( 8 ) ) );
	b.addAssign( a );
	a.subAssign( c );
	a.bitXorAssign( mx_rotl32( c, int( 16 ) ) );
	c.addAssign( b );
	b.subAssign( a );
	b.bitXorAssign( mx_rotl32( a, int( 19 ) ) );
	a.addAssign( c );
	c.subAssign( b );
	c.bitXorAssign( mx_rotl32( b, int( 4 ) ) );
	b.addAssign( a );

} );

const mx_bjfinal = /*@__PURE__*/ Fn( ( [ a_immutable, b_immutable, c_immutable ] ) => {

	const c = uint( c_immutable ).toVar();
	const b = uint( b_immutable ).toVar();
	const a = uint( a_immutable ).toVar();
	c.bitXorAssign( b );
	c.subAssign( mx_rotl32( b, int( 14 ) ) );
	a.bitXorAssign( c );
	a.subAssign( mx_rotl32( c, int( 11 ) ) );
	b.bitXorAssign( a );
	b.subAssign( mx_rotl32( a, int( 25 ) ) );
	c.bitXorAssign( b );
	c.subAssign( mx_rotl32( b, int( 16 ) ) );
	a.bitXorAssign( c );
	a.subAssign( mx_rotl32( c, int( 4 ) ) );
	b.bitXorAssign( a );
	b.subAssign( mx_rotl32( a, int( 14 ) ) );
	c.bitXorAssign( b );
	c.subAssign( mx_rotl32( b, int( 24 ) ) );

	return c;

} ).setLayout( {
	name: 'mx_bjfinal',
	type: 'uint',
	inputs: [
		{ name: 'a', type: 'uint' },
		{ name: 'b', type: 'uint' },
		{ name: 'c', type: 'uint' }
	]
} );

const mx_bits_to_01 = /*@__PURE__*/ Fn( ( [ bits_immutable ] ) => {

	const bits = uint( bits_immutable ).toVar();

	return float( bits ).div( float( uint( int( 0xffffffff ) ) ) );

} ).setLayout( {
	name: 'mx_bits_to_01',
	type: 'float',
	inputs: [
		{ name: 'bits', type: 'uint' }
	]
} );

const mx_fade = /*@__PURE__*/ Fn( ( [ t_immutable ] ) => {

	const t = float( t_immutable ).toVar();

	return t.mul( t ).mul( t ).mul( t.mul( t.mul( 6.0 ).sub( 15.0 ) ).add( 10.0 ) );

} ).setLayout( {
	name: 'mx_fade',
	type: 'float',
	inputs: [
		{ name: 't', type: 'float' }
	]
} );

const mx_hash_int_0 = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {

	const x = int( x_immutable ).toVar();
	const len = uint( uint( 1 ) ).toVar();
	const seed = uint( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ).toVar();

	return mx_bjfinal( seed.add( uint( x ) ), seed, seed );

} ).setLayout( {
	name: 'mx_hash_int_0',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' }
	]
} );

const mx_hash_int_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {

	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const len = uint( uint( 2 ) ).toVar();
	const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
	a.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );
	a.addAssign( uint( x ) );
	b.addAssign( uint( y ) );

	return mx_bjfinal( a, b, c );

} ).setLayout( {
	name: 'mx_hash_int_1',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' }
	]
} );

const mx_hash_int_2 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {

	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const len = uint( uint( 3 ) ).toVar();
	const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
	a.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );
	a.addAssign( uint( x ) );
	b.addAssign( uint( y ) );
	c.addAssign( uint( z ) );

	return mx_bjfinal( a, b, c );

} ).setLayout( {
	name: 'mx_hash_int_2',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' }
	]
} );

const mx_hash_int_3 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable ] ) => {

	const xx = int( xx_immutable ).toVar();
	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const len = uint( uint( 4 ) ).toVar();
	const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
	a.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );
	a.addAssign( uint( x ) );
	b.addAssign( uint( y ) );
	c.addAssign( uint( z ) );
	mx_bjmix( a, b, c );
	a.addAssign( uint( xx ) );

	return mx_bjfinal( a, b, c );

} ).setLayout( {
	name: 'mx_hash_int_3',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' },
		{ name: 'xx', type: 'int' }
	]
} );

const mx_hash_int_4 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable ] ) => {

	const yy = int( yy_immutable ).toVar();
	const xx = int( xx_immutable ).toVar();
	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const len = uint( uint( 5 ) ).toVar();
	const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
	a.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );
	a.addAssign( uint( x ) );
	b.addAssign( uint( y ) );
	c.addAssign( uint( z ) );
	mx_bjmix( a, b, c );
	a.addAssign( uint( xx ) );
	b.addAssign( uint( yy ) );

	return mx_bjfinal( a, b, c );

} ).setLayout( {
	name: 'mx_hash_int_4',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' },
		{ name: 'xx', type: 'int' },
		{ name: 'yy', type: 'int' }
	]
} );

const mx_hash_int = /*@__PURE__*/ overloadingFn( [ mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4 ] );

const mx_hash_vec3_0 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {

	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const h = uint( mx_hash_int( x, y ) ).toVar();
	const result = uvec3().toVar();
	result.x.assign( h.bitAnd( int( 0xFF ) ) );
	result.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );
	result.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );

	return result;

} ).setLayout( {
	name: 'mx_hash_vec3_0',
	type: 'uvec3',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' }
	]
} );

const mx_hash_vec3_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {

	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const h = uint( mx_hash_int( x, y, z ) ).toVar();
	const result = uvec3().toVar();
	result.x.assign( h.bitAnd( int( 0xFF ) ) );
	result.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );
	result.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );

	return result;

} ).setLayout( {
	name: 'mx_hash_vec3_1',
	type: 'uvec3',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' }
	]
} );

const mx_hash_vec3 = /*@__PURE__*/ overloadingFn( [ mx_hash_vec3_0, mx_hash_vec3_1 ] );

const mx_perlin_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec2( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const fx = float( mx_floorfrac( p.x, X ) ).toVar();
	const fy = float( mx_floorfrac( p.y, Y ) ).toVar();
	const u = float( mx_fade( fx ) ).toVar();
	const v = float( mx_fade( fy ) ).toVar();
	const result = float( mx_bilerp( mx_gradient_float( mx_hash_int( X, Y ), fx, fy ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();

	return mx_gradient_scale2d( result );

} ).setLayout( {
	name: 'mx_perlin_noise_float_0',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec2' }
	]
} );

const mx_perlin_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec3( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const fx = float( mx_floorfrac( p.x, X ) ).toVar();
	const fy = float( mx_floorfrac( p.y, Y ) ).toVar();
	const fz = float( mx_floorfrac( p.z, Z ) ).toVar();
	const u = float( mx_fade( fx ) ).toVar();
	const v = float( mx_fade( fy ) ).toVar();
	const w = float( mx_fade( fz ) ).toVar();
	const result = float( mx_trilerp( mx_gradient_float( mx_hash_int( X, Y, Z ), fx, fy, fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();

	return mx_gradient_scale3d( result );

} ).setLayout( {
	name: 'mx_perlin_noise_float_1',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const mx_perlin_noise_float = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_float_0, mx_perlin_noise_float_1 ] );

const mx_perlin_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec2( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const fx = float( mx_floorfrac( p.x, X ) ).toVar();
	const fy = float( mx_floorfrac( p.y, Y ) ).toVar();
	const u = float( mx_fade( fx ) ).toVar();
	const v = float( mx_fade( fy ) ).toVar();
	const result = vec3( mx_bilerp( mx_gradient_vec3( mx_hash_vec3( X, Y ), fx, fy ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();

	return mx_gradient_scale2d( result );

} ).setLayout( {
	name: 'mx_perlin_noise_vec3_0',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec2' }
	]
} );

const mx_perlin_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec3( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const fx = float( mx_floorfrac( p.x, X ) ).toVar();
	const fy = float( mx_floorfrac( p.y, Y ) ).toVar();
	const fz = float( mx_floorfrac( p.z, Z ) ).toVar();
	const u = float( mx_fade( fx ) ).toVar();
	const v = float( mx_fade( fy ) ).toVar();
	const w = float( mx_fade( fz ) ).toVar();
	const result = vec3( mx_trilerp( mx_gradient_vec3( mx_hash_vec3( X, Y, Z ), fx, fy, fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();

	return mx_gradient_scale3d( result );

} ).setLayout( {
	name: 'mx_perlin_noise_vec3_1',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const mx_perlin_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1 ] );

const mx_cell_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = float( p_immutable ).toVar();
	const ix = int( mx_floor( p ) ).toVar();

	return mx_bits_to_01( mx_hash_int( ix ) );

} ).setLayout( {
	name: 'mx_cell_noise_float_0',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'float' }
	]
} );

const mx_cell_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec2( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();

	return mx_bits_to_01( mx_hash_int( ix, iy ) );

} ).setLayout( {
	name: 'mx_cell_noise_float_1',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec2' }
	]
} );

const mx_cell_noise_float_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec3( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();
	const iz = int( mx_floor( p.z ) ).toVar();

	return mx_bits_to_01( mx_hash_int( ix, iy, iz ) );

} ).setLayout( {
	name: 'mx_cell_noise_float_2',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const mx_cell_noise_float_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec4( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();
	const iz = int( mx_floor( p.z ) ).toVar();
	const iw = int( mx_floor( p.w ) ).toVar();

	return mx_bits_to_01( mx_hash_int( ix, iy, iz, iw ) );

} ).setLayout( {
	name: 'mx_cell_noise_float_3',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec4' }
	]
} );

const mx_cell_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3 ] );

const mx_cell_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = float( p_immutable ).toVar();
	const ix = int( mx_floor( p ) ).toVar();

	return vec3( mx_bits_to_01( mx_hash_int( ix, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 2 ) ) ) );

} ).setLayout( {
	name: 'mx_cell_noise_vec3_0',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'float' }
	]
} );

const mx_cell_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec2( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();

	return vec3( mx_bits_to_01( mx_hash_int( ix, iy, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 2 ) ) ) );

} ).setLayout( {
	name: 'mx_cell_noise_vec3_1',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec2' }
	]
} );

const mx_cell_noise_vec3_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec3( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();
	const iz = int( mx_floor( p.z ) ).toVar();

	return vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 2 ) ) ) );

} ).setLayout( {
	name: 'mx_cell_noise_vec3_2',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const mx_cell_noise_vec3_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec4( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();
	const iz = int( mx_floor( p.z ) ).toVar();
	const iw = int( mx_floor( p.w ) ).toVar();

	return vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 2 ) ) ) );

} ).setLayout( {
	name: 'mx_cell_noise_vec3_3',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec4' }
	]
} );

const mx_cell_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3 ] );

const mx_fractal_noise_float$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {

	const diminish = float( diminish_immutable ).toVar();
	const lacunarity = float( lacunarity_immutable ).toVar();
	const octaves = int( octaves_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const result = float( 0.0 ).toVar();
	const amplitude = float( 1.0 ).toVar();

	Loop( octaves, () => {

		result.addAssign( amplitude.mul( mx_perlin_noise_float( p ) ) );
		amplitude.mulAssign( diminish );
		p.mulAssign( lacunarity );

	} );

	return result;

} ).setLayout( {
	name: 'mx_fractal_noise_float',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'octaves', type: 'int' },
		{ name: 'lacunarity', type: 'float' },
		{ name: 'diminish', type: 'float' }
	]
} );

const mx_fractal_noise_vec3$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {

	const diminish = float( diminish_immutable ).toVar();
	const lacunarity = float( lacunarity_immutable ).toVar();
	const octaves = int( octaves_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const result = vec3( 0.0 ).toVar();
	const amplitude = float( 1.0 ).toVar();

	Loop( octaves, () => {

		result.addAssign( amplitude.mul( mx_perlin_noise_vec3( p ) ) );
		amplitude.mulAssign( diminish );
		p.mulAssign( lacunarity );

	} );

	return result;

} ).setLayout( {
	name: 'mx_fractal_noise_vec3',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'octaves', type: 'int' },
		{ name: 'lacunarity', type: 'float' },
		{ name: 'diminish', type: 'float' }
	]
} );

const mx_fractal_noise_vec2$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {

	const diminish = float( diminish_immutable ).toVar();
	const lacunarity = float( lacunarity_immutable ).toVar();
	const octaves = int( octaves_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();

	return vec2( mx_fractal_noise_float$1( p, octaves, lacunarity, diminish ), mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) );

} ).setLayout( {
	name: 'mx_fractal_noise_vec2',
	type: 'vec2',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'octaves', type: 'int' },
		{ name: 'lacunarity', type: 'float' },
		{ name: 'diminish', type: 'float' }
	]
} );

const mx_fractal_noise_vec4$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {

	const diminish = float( diminish_immutable ).toVar();
	const lacunarity = float( lacunarity_immutable ).toVar();
	const octaves = int( octaves_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const c = vec3( mx_fractal_noise_vec3$1( p, octaves, lacunarity, diminish ) ).toVar();
	const f = float( mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) ).toVar();

	return vec4( c, f );

} ).setLayout( {
	name: 'mx_fractal_noise_vec4',
	type: 'vec4',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'octaves', type: 'int' },
		{ name: 'lacunarity', type: 'float' },
		{ name: 'diminish', type: 'float' }
	]
} );

const mx_worley_distance_0 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const yoff = int( yoff_immutable ).toVar();
	const xoff = int( xoff_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const p = vec2( p_immutable ).toVar();
	const tmp = vec3( mx_cell_noise_vec3( vec2( x.add( xoff ), y.add( yoff ) ) ) ).toVar();
	const off = vec2( tmp.x, tmp.y ).toVar();
	off.subAssign( 0.5 );
	off.mulAssign( jitter );
	off.addAssign( 0.5 );
	const cellpos = vec2( vec2( float( x ), float( y ) ).add( off ) ).toVar();
	const diff = vec2( cellpos.sub( p ) ).toVar();

	If( metric.equal( int( 2 ) ), () => {

		return abs( diff.x ).add( abs( diff.y ) );

	} );

	If( metric.equal( int( 3 ) ), () => {

		return max$1( abs( diff.x ), abs( diff.y ) );

	} );

	return dot( diff, diff );

} ).setLayout( {
	name: 'mx_worley_distance_0',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec2' },
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'xoff', type: 'int' },
		{ name: 'yoff', type: 'int' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_distance_1 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const zoff = int( zoff_immutable ).toVar();
	const yoff = int( yoff_immutable ).toVar();
	const xoff = int( xoff_immutable ).toVar();
	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const off = vec3( mx_cell_noise_vec3( vec3( x.add( xoff ), y.add( yoff ), z.add( zoff ) ) ) ).toVar();
	off.subAssign( 0.5 );
	off.mulAssign( jitter );
	off.addAssign( 0.5 );
	const cellpos = vec3( vec3( float( x ), float( y ), float( z ) ).add( off ) ).toVar();
	const diff = vec3( cellpos.sub( p ) ).toVar();

	If( metric.equal( int( 2 ) ), () => {

		return abs( diff.x ).add( abs( diff.y ) ).add( abs( diff.z ) );

	} );

	If( metric.equal( int( 3 ) ), () => {

		return max$1( max$1( abs( diff.x ), abs( diff.y ) ), abs( diff.z ) );

	} );

	return dot( diff, diff );

} ).setLayout( {
	name: 'mx_worley_distance_1',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' },
		{ name: 'xoff', type: 'int' },
		{ name: 'yoff', type: 'int' },
		{ name: 'zoff', type: 'int' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_distance = /*@__PURE__*/ overloadingFn( [ mx_worley_distance_0, mx_worley_distance_1 ] );

const mx_worley_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const p = vec2( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();
	const sqdist = float( 1e6 ).toVar();

	Loop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			const dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();
			sqdist.assign( min$1( sqdist, dist ) );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_float_0',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec2' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_vec2_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const p = vec2( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();
	const sqdist = vec2( 1e6, 1e6 ).toVar();

	Loop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			const dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();

			If( dist.lessThan( sqdist.x ), () => {

				sqdist.y.assign( sqdist.x );
				sqdist.x.assign( dist );

			} ).ElseIf( dist.lessThan( sqdist.y ), () => {

				sqdist.y.assign( dist );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_vec2_0',
	type: 'vec2',
	inputs: [
		{ name: 'p', type: 'vec2' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const p = vec2( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();
	const sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();

	Loop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			const dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();

			If( dist.lessThan( sqdist.x ), () => {

				sqdist.z.assign( sqdist.y );
				sqdist.y.assign( sqdist.x );
				sqdist.x.assign( dist );

			} ).ElseIf( dist.lessThan( sqdist.y ), () => {

				sqdist.z.assign( sqdist.y );
				sqdist.y.assign( dist );

			} ).ElseIf( dist.lessThan( sqdist.z ), () => {

				sqdist.z.assign( dist );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_vec3_0',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec2' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();
	const sqdist = float( 1e6 ).toVar();

	Loop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			Loop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {

				const dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();
				sqdist.assign( min$1( sqdist, dist ) );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_float_1',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_float_0, mx_worley_noise_float_1 ] );

const mx_worley_noise_vec2_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();
	const sqdist = vec2( 1e6, 1e6 ).toVar();

	Loop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			Loop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {

				const dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();

				If( dist.lessThan( sqdist.x ), () => {

					sqdist.y.assign( sqdist.x );
					sqdist.x.assign( dist );

				} ).ElseIf( dist.lessThan( sqdist.y ), () => {

					sqdist.y.assign( dist );

				} );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_vec2_1',
	type: 'vec2',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_vec2$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec2_0, mx_worley_noise_vec2_1 ] );

const mx_worley_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();
	const sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();

	Loop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			Loop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {

				const dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();

				If( dist.lessThan( sqdist.x ), () => {

					sqdist.z.assign( sqdist.y );
					sqdist.y.assign( sqdist.x );
					sqdist.x.assign( dist );

				} ).ElseIf( dist.lessThan( sqdist.y ), () => {

					sqdist.z.assign( sqdist.y );
					sqdist.y.assign( dist );

				} ).ElseIf( dist.lessThan( sqdist.z ), () => {

					sqdist.z.assign( dist );

				} );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_vec3_1',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_vec3$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec3_0, mx_worley_noise_vec3_1 ] );

// Three.js Transpiler
// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl


const mx_hsvtorgb = /*@__PURE__*/ Fn( ( [ hsv ] ) => {

	const s = hsv.y;
	const v = hsv.z;

	const result = vec3().toVar();

	If( s.lessThan( 0.0001 ), () => {

		result.assign( vec3( v, v, v ) );

	} ).Else( () => {

		let h = hsv.x;
		h = h.sub( floor( h ) ).mul( 6.0 ).toVar(); // TODO: check what .toVar() is needed in node system cache
		const hi = int( trunc( h ) );
		const f = h.sub( float( hi ) );
		const p = v.mul( s.oneMinus() );
		const q = v.mul( s.mul( f ).oneMinus() );
		const t = v.mul( s.mul( f.oneMinus() ).oneMinus() );

		If( hi.equal( int( 0 ) ), () => {

			result.assign( vec3( v, t, p ) );

		} ).ElseIf( hi.equal( int( 1 ) ), () => {

			result.assign( vec3( q, v, p ) );

		} ).ElseIf( hi.equal( int( 2 ) ), () => {

			result.assign( vec3( p, v, t ) );

		} ).ElseIf( hi.equal( int( 3 ) ), () => {

			result.assign( vec3( p, q, v ) );

		} ).ElseIf( hi.equal( int( 4 ) ), () => {

			result.assign( vec3( t, p, v ) );

		} ).Else( () => {

			result.assign( vec3( v, p, q ) );

		} );

	} );

	return result;

} ).setLayout( {
	name: 'mx_hsvtorgb',
	type: 'vec3',
	inputs: [
		{ name: 'hsv', type: 'vec3' }
	]
} );

const mx_rgbtohsv = /*@__PURE__*/ Fn( ( [ c_immutable ] ) => {

	const c = vec3( c_immutable ).toVar();
	const r = float( c.x ).toVar();
	const g = float( c.y ).toVar();
	const b = float( c.z ).toVar();
	const mincomp = float( min$1( r, min$1( g, b ) ) ).toVar();
	const maxcomp = float( max$1( r, max$1( g, b ) ) ).toVar();
	const delta = float( maxcomp.sub( mincomp ) ).toVar();
	const h = float().toVar(), s = float().toVar(), v = float().toVar();
	v.assign( maxcomp );

	If( maxcomp.greaterThan( 0.0 ), () => {

		s.assign( delta.div( maxcomp ) );

	} ).Else( () => {

		s.assign( 0.0 );

	} );

	If( s.lessThanEqual( 0.0 ), () => {

		h.assign( 0.0 );

	} ).Else( () => {

		If( r.greaterThanEqual( maxcomp ), () => {

			h.assign( g.sub( b ).div( delta ) );

		} ).ElseIf( g.greaterThanEqual( maxcomp ), () => {

			h.assign( add( 2.0, b.sub( r ).div( delta ) ) );

		} ).Else( () => {

			h.assign( add( 4.0, r.sub( g ).div( delta ) ) );

		} );

		h.mulAssign( 1.0 / 6.0 );

		If( h.lessThan( 0.0 ), () => {

			h.addAssign( 1.0 );

		} );

	} );

	return vec3( h, s, v );

} ).setLayout( {
	name: 'mx_rgbtohsv',
	type: 'vec3',
	inputs: [
		{ name: 'c', type: 'vec3' }
	]
} );

// Three.js Transpiler
// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl


const mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/ Fn( ( [ color_immutable ] ) => {

	const color = vec3( color_immutable ).toVar();
	const isAbove = bvec3( greaterThan( color, vec3( 0.04045 ) ) ).toVar();
	const linSeg = vec3( color.div( 12.92 ) ).toVar();
	const powSeg = vec3( pow( max$1( color.add( vec3( 0.055 ) ), vec3( 0.0 ) ).div( 1.055 ), vec3( 2.4 ) ) ).toVar();

	return mix( linSeg, powSeg, isAbove );

} ).setLayout( {
	name: 'mx_srgb_texture_to_lin_rec709',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' }
	]
} );

const mx_aastep = ( threshold, value ) => {

	threshold = float( threshold );
	value = float( value );

	const afwidth = vec2( value.dFdx(), value.dFdy() ).length().mul( 0.70710678118654757 );

	return smoothstep( threshold.sub( afwidth ), threshold.add( afwidth ), value );

};

const _ramp = ( a, b, uv, p ) => mix( a, b, uv[ p ].clamp() );
const mx_ramplr = ( valuel, valuer, texcoord = uv() ) => _ramp( valuel, valuer, texcoord, 'x' );
const mx_ramptb = ( valuet, valueb, texcoord = uv() ) => _ramp( valuet, valueb, texcoord, 'y' );

const _split = ( a, b, center, uv, p ) => mix( a, b, mx_aastep( center, uv[ p ] ) );
const mx_splitlr = ( valuel, valuer, center, texcoord = uv() ) => _split( valuel, valuer, center, texcoord, 'x' );
const mx_splittb = ( valuet, valueb, center, texcoord = uv() ) => _split( valuet, valueb, center, texcoord, 'y' );

const mx_transform_uv = ( uv_scale = 1, uv_offset = 0, uv_geo = uv() ) => uv_geo.mul( uv_scale ).add( uv_offset );

const mx_safepower = ( in1, in2 = 1 ) => {

	in1 = float( in1 );

	return in1.abs().pow( in2 ).mul( in1.sign() );

};

const mx_contrast = ( input, amount = 1, pivot = .5 ) => float( input ).sub( pivot ).mul( amount ).add( pivot );

const mx_noise_float = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_float( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );
//export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );
const mx_noise_vec3 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );
const mx_noise_vec4 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => {

	texcoord = texcoord.convert( 'vec2|vec3' ); // overloading type

	const noise_vec4 = vec4( mx_perlin_noise_vec3( texcoord ), mx_perlin_noise_float( texcoord.add( vec2( 19, 73 ) ) ) );

	return noise_vec4.mul( amplitude ).add( pivot );

};

const mx_worley_noise_float = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_float$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );
const mx_worley_noise_vec2 = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_vec2$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );
const mx_worley_noise_vec3 = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_vec3$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );

const mx_cell_noise_float = ( texcoord = uv() ) => mx_cell_noise_float$1( texcoord.convert( 'vec2|vec3' ) );

const mx_fractal_noise_float = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_float$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );
const mx_fractal_noise_vec2 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec2$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );
const mx_fractal_noise_vec3 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec3$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );
const mx_fractal_noise_vec4 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec4$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );

// https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html

const getParallaxCorrectNormal = /*@__PURE__*/ Fn( ( [ normal, cubeSize, cubePos ] ) => {

	const nDir = normalize( normal ).toVar( 'nDir' );
	const rbmax = sub( float( 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar( 'rbmax' );
	const rbmin = sub( float( - 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar( 'rbmin' );
	const rbminmax = vec3().toVar( 'rbminmax' );
	rbminmax.x = nDir.x.greaterThan( float( 0 ) ).select( rbmax.x, rbmin.x );
	rbminmax.y = nDir.y.greaterThan( float( 0 ) ).select( rbmax.y, rbmin.y );
	rbminmax.z = nDir.z.greaterThan( float( 0 ) ).select( rbmax.z, rbmin.z );

	const correction = min$1( min$1( rbminmax.x, rbminmax.y ), rbminmax.z ).toVar( 'correction' );
	const boxIntersection = positionWorld.add( nDir.mul( correction ) ).toVar( 'boxIntersection' );
	return boxIntersection.sub( cubePos );

} );

const getShIrradianceAt = /*@__PURE__*/ Fn( ( [ normal, shCoefficients ] ) => {

	// normal is assumed to have unit length

	const x = normal.x, y = normal.y, z = normal.z;

	// band 0
	let result = shCoefficients.element( 0 ).mul( 0.886227 );

	// band 1
	result = result.add( shCoefficients.element( 1 ).mul( 2.0 * 0.511664 ).mul( y ) );
	result = result.add( shCoefficients.element( 2 ).mul( 2.0 * 0.511664 ).mul( z ) );
	result = result.add( shCoefficients.element( 3 ).mul( 2.0 * 0.511664 ).mul( x ) );

	// band 2
	result = result.add( shCoefficients.element( 4 ).mul( 2.0 * 0.429043 ).mul( x ).mul( y ) );
	result = result.add( shCoefficients.element( 5 ).mul( 2.0 * 0.429043 ).mul( y ).mul( z ) );
	result = result.add( shCoefficients.element( 6 ).mul( z.mul( z ).mul( 0.743125 ).sub( 0.247708 ) ) );
	result = result.add( shCoefficients.element( 7 ).mul( 2.0 * 0.429043 ).mul( x ).mul( z ) );
	result = result.add( shCoefficients.element( 8 ).mul( 0.429043 ).mul( mul( x, x ).sub( mul( y, y ) ) ) );

	return result;

} );

// constants

var TSL = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BRDF_GGX: BRDF_GGX,
	BRDF_Lambert: BRDF_Lambert,
	BasicShadowFilter: BasicShadowFilter,
	Break: Break,
	Continue: Continue,
	DFGApprox: DFGApprox,
	D_GGX: D_GGX,
	Discard: Discard,
	EPSILON: EPSILON,
	F_Schlick: F_Schlick,
	Fn: Fn,
	INFINITY: INFINITY,
	If: If,
	Loop: Loop,
	NodeAccess: NodeAccess,
	NodeShaderStage: NodeShaderStage,
	NodeType: NodeType,
	NodeUpdateType: NodeUpdateType,
	PCFShadowFilter: PCFShadowFilter,
	PCFSoftShadowFilter: PCFSoftShadowFilter,
	PI: PI,
	PI2: PI2,
	Return: Return,
	Schlick_to_F0: Schlick_to_F0,
	ScriptableNodeResources: ScriptableNodeResources,
	ShaderNode: ShaderNode,
	TBNViewMatrix: TBNViewMatrix,
	VSMShadowFilter: VSMShadowFilter,
	V_GGX_SmithCorrelated: V_GGX_SmithCorrelated,
	abs: abs,
	acesFilmicToneMapping: acesFilmicToneMapping,
	acos: acos,
	add: add,
	addMethodChaining: addMethodChaining,
	addNodeElement: addNodeElement,
	agxToneMapping: agxToneMapping,
	all: all,
	alphaT: alphaT,
	and: and,
	anisotropy: anisotropy,
	anisotropyB: anisotropyB,
	anisotropyT: anisotropyT,
	any: any,
	append: append,
	arrayBuffer: arrayBuffer,
	asin: asin,
	assign: assign,
	atan: atan,
	atan2: atan2,
	atomicAdd: atomicAdd,
	atomicAnd: atomicAnd,
	atomicFunc: atomicFunc,
	atomicMax: atomicMax,
	atomicMin: atomicMin,
	atomicOr: atomicOr,
	atomicStore: atomicStore,
	atomicSub: atomicSub,
	atomicXor: atomicXor,
	attenuationColor: attenuationColor,
	attenuationDistance: attenuationDistance,
	attribute: attribute,
	attributeArray: attributeArray,
	backgroundBlurriness: backgroundBlurriness,
	backgroundIntensity: backgroundIntensity,
	backgroundRotation: backgroundRotation,
	batch: batch,
	billboarding: billboarding,
	bitAnd: bitAnd,
	bitNot: bitNot,
	bitOr: bitOr,
	bitXor: bitXor,
	bitangentGeometry: bitangentGeometry,
	bitangentLocal: bitangentLocal,
	bitangentView: bitangentView,
	bitangentWorld: bitangentWorld,
	bitcast: bitcast,
	blendBurn: blendBurn,
	blendColor: blendColor,
	blendDodge: blendDodge,
	blendOverlay: blendOverlay,
	blendScreen: blendScreen,
	blur: blur,
	bool: bool,
	buffer: buffer,
	bufferAttribute: bufferAttribute,
	bumpMap: bumpMap,
	burn: burn,
	bvec2: bvec2,
	bvec3: bvec3,
	bvec4: bvec4,
	bypass: bypass,
	cache: cache,
	call: call,
	cameraFar: cameraFar,
	cameraNear: cameraNear,
	cameraNormalMatrix: cameraNormalMatrix,
	cameraPosition: cameraPosition,
	cameraProjectionMatrix: cameraProjectionMatrix,
	cameraProjectionMatrixInverse: cameraProjectionMatrixInverse,
	cameraViewMatrix: cameraViewMatrix,
	cameraWorldMatrix: cameraWorldMatrix,
	cbrt: cbrt,
	cdl: cdl,
	ceil: ceil,
	checker: checker,
	cineonToneMapping: cineonToneMapping,
	clamp: clamp,
	clearcoat: clearcoat,
	clearcoatRoughness: clearcoatRoughness,
	code: code,
	color: color,
	colorSpaceToWorking: colorSpaceToWorking,
	colorToDirection: colorToDirection,
	compute: compute,
	cond: cond,
	context: context,
	convert: convert,
	convertColorSpace: convertColorSpace,
	convertToTexture: convertToTexture,
	cos: cos,
	cross: cross,
	cubeTexture: cubeTexture,
	dFdx: dFdx,
	dFdy: dFdy,
	dashSize: dashSize,
	defaultBuildStages: defaultBuildStages,
	defaultShaderStages: defaultShaderStages,
	defined: defined,
	degrees: degrees,
	deltaTime: deltaTime,
	densityFog: densityFog,
	depth: depth,
	depthPass: depthPass,
	difference: difference,
	diffuseColor: diffuseColor,
	directPointLight: directPointLight,
	directionToColor: directionToColor,
	dispersion: dispersion,
	distance: distance,
	div: div,
	dodge: dodge,
	dot: dot,
	drawIndex: drawIndex,
	dynamicBufferAttribute: dynamicBufferAttribute,
	element: element,
	emissive: emissive,
	equal: equal,
	equals: equals,
	equirectUV: equirectUV,
	exp: exp,
	exp2: exp2,
	expression: expression,
	faceDirection: faceDirection,
	faceForward: faceForward,
	float: float,
	floor: floor,
	fog: fog,
	fract: fract,
	frameGroup: frameGroup,
	frameId: frameId,
	frontFacing: frontFacing,
	fwidth: fwidth,
	gain: gain,
	gapSize: gapSize,
	getConstNodeType: getConstNodeType,
	getCurrentStack: getCurrentStack,
	getDirection: getDirection,
	getDistanceAttenuation: getDistanceAttenuation,
	getGeometryRoughness: getGeometryRoughness,
	getNormalFromDepth: getNormalFromDepth,
	getParallaxCorrectNormal: getParallaxCorrectNormal,
	getRoughness: getRoughness,
	getScreenPosition: getScreenPosition,
	getShIrradianceAt: getShIrradianceAt,
	getTextureIndex: getTextureIndex,
	getViewPosition: getViewPosition,
	glsl: glsl,
	glslFn: glslFn,
	grayscale: grayscale,
	greaterThan: greaterThan,
	greaterThanEqual: greaterThanEqual,
	hash: hash,
	highPrecisionModelNormalViewMatrix: highPrecisionModelNormalViewMatrix,
	highPrecisionModelViewMatrix: highPrecisionModelViewMatrix,
	hue: hue,
	instance: instance,
	instanceIndex: instanceIndex,
	instancedArray: instancedArray,
	instancedBufferAttribute: instancedBufferAttribute,
	instancedDynamicBufferAttribute: instancedDynamicBufferAttribute,
	instancedMesh: instancedMesh,
	int: int,
	inverseSqrt: inverseSqrt,
	invocationLocalIndex: invocationLocalIndex,
	invocationSubgroupIndex: invocationSubgroupIndex,
	ior: ior,
	iridescence: iridescence,
	iridescenceIOR: iridescenceIOR,
	iridescenceThickness: iridescenceThickness,
	ivec2: ivec2,
	ivec3: ivec3,
	ivec4: ivec4,
	js: js,
	label: label,
	length: length,
	lengthSq: lengthSq,
	lessThan: lessThan,
	lessThanEqual: lessThanEqual,
	lightPosition: lightPosition,
	lightProjectionUV: lightProjectionUV,
	lightShadowMatrix: lightShadowMatrix,
	lightTargetDirection: lightTargetDirection,
	lightTargetPosition: lightTargetPosition,
	lightViewPosition: lightViewPosition,
	lightingContext: lightingContext,
	lights: lights,
	linearDepth: linearDepth,
	linearToneMapping: linearToneMapping,
	localId: localId,
	log: log,
	log2: log2,
	logarithmicDepthToViewZ: logarithmicDepthToViewZ,
	loop: loop,
	luminance: luminance,
	mat2: mat2,
	mat3: mat3,
	mat4: mat4,
	matcapUV: matcapUV,
	materialAOMap: materialAOMap,
	materialAlphaTest: materialAlphaTest,
	materialAnisotropy: materialAnisotropy,
	materialAnisotropyVector: materialAnisotropyVector,
	materialAttenuationColor: materialAttenuationColor,
	materialAttenuationDistance: materialAttenuationDistance,
	materialClearcoat: materialClearcoat,
	materialClearcoatNormal: materialClearcoatNormal,
	materialClearcoatRoughness: materialClearcoatRoughness,
	materialColor: materialColor,
	materialDispersion: materialDispersion,
	materialEmissive: materialEmissive,
	materialIOR: materialIOR,
	materialIridescence: materialIridescence,
	materialIridescenceIOR: materialIridescenceIOR,
	materialIridescenceThickness: materialIridescenceThickness,
	materialLightMap: materialLightMap,
	materialLineDashOffset: materialLineDashOffset,
	materialLineDashSize: materialLineDashSize,
	materialLineGapSize: materialLineGapSize,
	materialLineScale: materialLineScale,
	materialLineWidth: materialLineWidth,
	materialMetalness: materialMetalness,
	materialNormal: materialNormal,
	materialOpacity: materialOpacity,
	materialPointWidth: materialPointWidth,
	materialReference: materialReference,
	materialReflectivity: materialReflectivity,
	materialRefractionRatio: materialRefractionRatio,
	materialRotation: materialRotation,
	materialRoughness: materialRoughness,
	materialSheen: materialSheen,
	materialSheenRoughness: materialSheenRoughness,
	materialShininess: materialShininess,
	materialSpecular: materialSpecular,
	materialSpecularColor: materialSpecularColor,
	materialSpecularIntensity: materialSpecularIntensity,
	materialSpecularStrength: materialSpecularStrength,
	materialThickness: materialThickness,
	materialTransmission: materialTransmission,
	max: max$1,
	maxMipLevel: maxMipLevel,
	metalness: metalness,
	min: min$1,
	mix: mix,
	mixElement: mixElement,
	mod: mod,
	modInt: modInt,
	modelDirection: modelDirection,
	modelNormalMatrix: modelNormalMatrix,
	modelPosition: modelPosition,
	modelScale: modelScale,
	modelViewMatrix: modelViewMatrix,
	modelViewPosition: modelViewPosition,
	modelViewProjection: modelViewProjection,
	modelWorldMatrix: modelWorldMatrix,
	modelWorldMatrixInverse: modelWorldMatrixInverse,
	morphReference: morphReference,
	mrt: mrt,
	mul: mul,
	mx_aastep: mx_aastep,
	mx_cell_noise_float: mx_cell_noise_float,
	mx_contrast: mx_contrast,
	mx_fractal_noise_float: mx_fractal_noise_float,
	mx_fractal_noise_vec2: mx_fractal_noise_vec2,
	mx_fractal_noise_vec3: mx_fractal_noise_vec3,
	mx_fractal_noise_vec4: mx_fractal_noise_vec4,
	mx_hsvtorgb: mx_hsvtorgb,
	mx_noise_float: mx_noise_float,
	mx_noise_vec3: mx_noise_vec3,
	mx_noise_vec4: mx_noise_vec4,
	mx_ramplr: mx_ramplr,
	mx_ramptb: mx_ramptb,
	mx_rgbtohsv: mx_rgbtohsv,
	mx_safepower: mx_safepower,
	mx_splitlr: mx_splitlr,
	mx_splittb: mx_splittb,
	mx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,
	mx_transform_uv: mx_transform_uv,
	mx_worley_noise_float: mx_worley_noise_float,
	mx_worley_noise_vec2: mx_worley_noise_vec2,
	mx_worley_noise_vec3: mx_worley_noise_vec3,
	negate: negate,
	neutralToneMapping: neutralToneMapping,
	nodeArray: nodeArray,
	nodeImmutable: nodeImmutable,
	nodeObject: nodeObject,
	nodeObjects: nodeObjects,
	nodeProxy: nodeProxy,
	normalFlat: normalFlat,
	normalGeometry: normalGeometry,
	normalLocal: normalLocal,
	normalMap: normalMap,
	normalView: normalView,
	normalWorld: normalWorld,
	normalize: normalize,
	not: not,
	notEqual: notEqual,
	numWorkgroups: numWorkgroups,
	objectDirection: objectDirection,
	objectGroup: objectGroup,
	objectPosition: objectPosition,
	objectScale: objectScale,
	objectViewPosition: objectViewPosition,
	objectWorldMatrix: objectWorldMatrix,
	oneMinus: oneMinus,
	or: or,
	orthographicDepthToViewZ: orthographicDepthToViewZ,
	oscSawtooth: oscSawtooth,
	oscSine: oscSine,
	oscSquare: oscSquare,
	oscTriangle: oscTriangle,
	output: output,
	outputStruct: outputStruct,
	overlay: overlay,
	overloadingFn: overloadingFn,
	parabola: parabola,
	parallaxDirection: parallaxDirection,
	parallaxUV: parallaxUV,
	parameter: parameter,
	pass: pass,
	passTexture: passTexture,
	pcurve: pcurve,
	perspectiveDepthToViewZ: perspectiveDepthToViewZ,
	pmremTexture: pmremTexture,
	pointUV: pointUV,
	pointWidth: pointWidth,
	positionGeometry: positionGeometry,
	positionLocal: positionLocal,
	positionPrevious: positionPrevious,
	positionView: positionView,
	positionViewDirection: positionViewDirection,
	positionWorld: positionWorld,
	positionWorldDirection: positionWorldDirection,
	posterize: posterize,
	pow: pow,
	pow2: pow2,
	pow3: pow3,
	pow4: pow4,
	property: property,
	radians: radians,
	rand: rand,
	range: range,
	rangeFog: rangeFog,
	reciprocal: reciprocal,
	reference: reference,
	referenceBuffer: referenceBuffer,
	reflect: reflect,
	reflectVector: reflectVector,
	reflectView: reflectView,
	reflector: reflector,
	refract: refract,
	refractVector: refractVector,
	refractView: refractView,
	reinhardToneMapping: reinhardToneMapping,
	remainder: remainder,
	remap: remap,
	remapClamp: remapClamp,
	renderGroup: renderGroup,
	renderOutput: renderOutput,
	rendererReference: rendererReference,
	rotate: rotate,
	rotateUV: rotateUV,
	roughness: roughness,
	round: round,
	rtt: rtt,
	sRGBTransferEOTF: sRGBTransferEOTF,
	sRGBTransferOETF: sRGBTransferOETF,
	sampler: sampler,
	saturate: saturate,
	saturation: saturation,
	screen: screen,
	screenCoordinate: screenCoordinate,
	screenSize: screenSize,
	screenUV: screenUV,
	scriptable: scriptable,
	scriptableValue: scriptableValue,
	select: select,
	setCurrentStack: setCurrentStack,
	shaderStages: shaderStages,
	shadow: shadow,
	sharedUniformGroup: sharedUniformGroup,
	sheen: sheen,
	sheenRoughness: sheenRoughness,
	shiftLeft: shiftLeft,
	shiftRight: shiftRight,
	shininess: shininess,
	sign: sign,
	sin: sin,
	sinc: sinc,
	skinning: skinning,
	skinningReference: skinningReference,
	smoothstep: smoothstep,
	smoothstepElement: smoothstepElement,
	specularColor: specularColor,
	specularF90: specularF90,
	spherizeUV: spherizeUV,
	split: split,
	spritesheetUV: spritesheetUV,
	sqrt: sqrt,
	stack: stack,
	step: step,
	storage: storage,
	storageBarrier: storageBarrier,
	storageObject: storageObject,
	storageTexture: storageTexture,
	string: string,
	sub: sub,
	subgroupIndex: subgroupIndex,
	subgroupSize: subgroupSize,
	tan: tan,
	tangentGeometry: tangentGeometry,
	tangentLocal: tangentLocal,
	tangentView: tangentView,
	tangentWorld: tangentWorld,
	temp: temp,
	texture: texture,
	texture3D: texture3D,
	textureBarrier: textureBarrier,
	textureBicubic: textureBicubic,
	textureCubeUV: textureCubeUV,
	textureLoad: textureLoad,
	textureSize: textureSize,
	textureStore: textureStore,
	thickness: thickness,
	threshold: threshold,
	time: time,
	timerDelta: timerDelta,
	timerGlobal: timerGlobal,
	timerLocal: timerLocal,
	toOutputColorSpace: toOutputColorSpace,
	toWorkingColorSpace: toWorkingColorSpace,
	toneMapping: toneMapping,
	toneMappingExposure: toneMappingExposure,
	toonOutlinePass: toonOutlinePass,
	transformDirection: transformDirection,
	transformNormal: transformNormal,
	transformNormalToView: transformNormalToView,
	transformedBentNormalView: transformedBentNormalView,
	transformedBitangentView: transformedBitangentView,
	transformedBitangentWorld: transformedBitangentWorld,
	transformedClearcoatNormalView: transformedClearcoatNormalView,
	transformedNormalView: transformedNormalView,
	transformedNormalWorld: transformedNormalWorld,
	transformedTangentView: transformedTangentView,
	transformedTangentWorld: transformedTangentWorld,
	transmission: transmission,
	transpose: transpose,
	tri: tri,
	tri3: tri3,
	triNoise3D: triNoise3D,
	triplanarTexture: triplanarTexture,
	triplanarTextures: triplanarTextures,
	trunc: trunc,
	tslFn: tslFn,
	uint: uint,
	uniform: uniform,
	uniformArray: uniformArray,
	uniformGroup: uniformGroup,
	uniforms: uniforms,
	userData: userData,
	uv: uv,
	uvec2: uvec2,
	uvec3: uvec3,
	uvec4: uvec4,
	varying: varying,
	varyingProperty: varyingProperty,
	vec2: vec2,
	vec3: vec3,
	vec4: vec4,
	vectorComponents: vectorComponents,
	velocity: velocity,
	vertexColor: vertexColor,
	vertexIndex: vertexIndex,
	vibrance: vibrance,
	viewZToLogarithmicDepth: viewZToLogarithmicDepth,
	viewZToOrthographicDepth: viewZToOrthographicDepth,
	viewZToPerspectiveDepth: viewZToPerspectiveDepth,
	viewport: viewport,
	viewportBottomLeft: viewportBottomLeft,
	viewportCoordinate: viewportCoordinate,
	viewportDepthTexture: viewportDepthTexture,
	viewportLinearDepth: viewportLinearDepth,
	viewportMipTexture: viewportMipTexture,
	viewportResolution: viewportResolution,
	viewportSafeUV: viewportSafeUV,
	viewportSharedTexture: viewportSharedTexture,
	viewportSize: viewportSize,
	viewportTexture: viewportTexture,
	viewportTopLeft: viewportTopLeft,
	viewportUV: viewportUV,
	wgsl: wgsl,
	wgslFn: wgslFn,
	workgroupArray: workgroupArray,
	workgroupBarrier: workgroupBarrier,
	workgroupId: workgroupId,
	workingToColorSpace: workingToColorSpace,
	xor: xor
});

const _clearColor$1 = /*@__PURE__*/ new Color4();

class Background extends DataMap {

	constructor( renderer, nodes ) {

		super();

		this.renderer = renderer;
		this.nodes = nodes;

	}

	update( scene, renderList, renderContext ) {

		const renderer = this.renderer;
		const background = this.nodes.getBackgroundNode( scene ) || scene.background;

		let forceClear = false;

		if ( background === null ) {

			// no background settings, use clear color configuration from the renderer

			renderer._clearColor.getRGB( _clearColor$1, LinearSRGBColorSpace );
			_clearColor$1.a = renderer._clearColor.a;

		} else if ( background.isColor === true ) {

			// background is an opaque color

			background.getRGB( _clearColor$1, LinearSRGBColorSpace );
			_clearColor$1.a = 1;

			forceClear = true;

		} else if ( background.isNode === true ) {

			const sceneData = this.get( scene );
			const backgroundNode = background;

			_clearColor$1.copy( renderer._clearColor );

			let backgroundMesh = sceneData.backgroundMesh;

			if ( backgroundMesh === undefined ) {

				const backgroundMeshNode = context( vec4( backgroundNode ).mul( backgroundIntensity ), {
					// @TODO: Add Texture2D support using node context
					getUV: () => backgroundRotation.mul( normalWorld ),
					getTextureLevel: () => backgroundBlurriness
				} );

				let viewProj = modelViewProjection();
				viewProj = viewProj.setZ( viewProj.w );

				const nodeMaterial = new NodeMaterial();
				nodeMaterial.name = 'Background.material';
				nodeMaterial.side = BackSide;
				nodeMaterial.depthTest = false;
				nodeMaterial.depthWrite = false;
				nodeMaterial.fog = false;
				nodeMaterial.lights = false;
				nodeMaterial.vertexNode = viewProj;
				nodeMaterial.colorNode = backgroundMeshNode;

				sceneData.backgroundMeshNode = backgroundMeshNode;
				sceneData.backgroundMesh = backgroundMesh = new Mesh( new SphereGeometry( 1, 32, 32 ), nodeMaterial );
				backgroundMesh.frustumCulled = false;
				backgroundMesh.name = 'Background.mesh';

				backgroundMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

			}

			const backgroundCacheKey = backgroundNode.getCacheKey();

			if ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {

				sceneData.backgroundMeshNode.node = vec4( backgroundNode ).mul( backgroundIntensity );
				sceneData.backgroundMeshNode.needsUpdate = true;

				backgroundMesh.material.needsUpdate = true;

				sceneData.backgroundCacheKey = backgroundCacheKey;

			}

			renderList.unshift( backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null );

		} else {

			console.error( 'THREE.Renderer: Unsupported background configuration.', background );

		}

		//

		if ( renderer.autoClear === true || forceClear === true ) {

			const clearColorValue = renderContext.clearColorValue;

			clearColorValue.r = _clearColor$1.r;
			clearColorValue.g = _clearColor$1.g;
			clearColorValue.b = _clearColor$1.b;
			clearColorValue.a = _clearColor$1.a;

			// premultiply alpha

			if ( renderer.backend.isWebGLBackend === true || renderer.alpha === true ) {

				clearColorValue.r *= clearColorValue.a;
				clearColorValue.g *= clearColorValue.a;
				clearColorValue.b *= clearColorValue.a;

			}

			//

			renderContext.depthClearValue = renderer._clearDepth;
			renderContext.stencilClearValue = renderer._clearStencil;

			renderContext.clearColor = renderer.autoClearColor === true;
			renderContext.clearDepth = renderer.autoClearDepth === true;
			renderContext.clearStencil = renderer.autoClearStencil === true;

		} else {

			renderContext.clearColor = false;
			renderContext.clearDepth = false;
			renderContext.clearStencil = false;

		}

	}

}

let _id$5 = 0;

class BindGroup {

	constructor( name = '', bindings = [], index = 0, bindingsReference = [] ) {

		this.name = name;
		this.bindings = bindings;
		this.index = index;
		this.bindingsReference = bindingsReference;

		this.id = _id$5 ++;

	}

}

class NodeBuilderState {

	constructor( vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, monitor, transforms = [] ) {

		this.vertexShader = vertexShader;
		this.fragmentShader = fragmentShader;
		this.computeShader = computeShader;
		this.transforms = transforms;

		this.nodeAttributes = nodeAttributes;
		this.bindings = bindings;

		this.updateNodes = updateNodes;
		this.updateBeforeNodes = updateBeforeNodes;
		this.updateAfterNodes = updateAfterNodes;

		this.monitor = monitor;

		this.usedTimes = 0;

	}

	createBindings() {

		const bindings = [];

		for ( const instanceGroup of this.bindings ) {

			const shared = instanceGroup.bindings[ 0 ].groupNode.shared;

			if ( shared !== true ) {

				const bindingsGroup = new BindGroup( instanceGroup.name, [], instanceGroup.index, instanceGroup );
				bindings.push( bindingsGroup );

				for ( const instanceBinding of instanceGroup.bindings ) {

					bindingsGroup.bindings.push( instanceBinding.clone() );

				}

			} else {

				bindings.push( instanceGroup );

			}

		}

		return bindings;

	}

}

class NodeAttribute {

	constructor( name, type, node = null ) {

		this.isNodeAttribute = true;

		this.name = name;
		this.type = type;
		this.node = node;

	}

}

class NodeUniform {

	constructor( name, type, node ) {

		this.isNodeUniform = true;

		this.name = name;
		this.type = type;
		this.node = node.getSelf();

	}

	get value() {

		return this.node.value;

	}

	set value( val ) {

		this.node.value = val;

	}

	get id() {

		return this.node.id;

	}

	get groupNode() {

		return this.node.groupNode;

	}

}

class NodeVar {

	constructor( name, type ) {

		this.isNodeVar = true;

		this.name = name;
		this.type = type;

	}

}

class NodeVarying extends NodeVar {

	constructor( name, type ) {

		super( name, type );

		this.needsInterpolation = false;

		this.isNodeVarying = true;

	}

}

class NodeCode {

	constructor( name, type, code = '' ) {

		this.name = name;
		this.type = type;
		this.code = code;

		Object.defineProperty( this, 'isNodeCode', { value: true } );

	}

}

let id = 0;

class NodeCache {

	constructor( parent = null ) {

		this.id = id ++;
		this.nodesData = new WeakMap();

		this.parent = parent;

	}

	getData( node ) {

		let data = this.nodesData.get( node );

		if ( data === undefined && this.parent !== null ) {

			data = this.parent.getData( node );

		}

		return data;

	}

	setData( node, data ) {

		this.nodesData.set( node, data );

	}

}

class Uniform {

	constructor( name, value ) {

		this.name = name;
		this.value = value;

		this.boundary = 0; // used to build the uniform buffer according to the STD140 layout
		this.itemSize = 0;

		this.offset = 0; // this property is set by WebGPUUniformsGroup and marks the start position in the uniform buffer

	}

	setValue( value ) {

		this.value = value;

	}

	getValue() {

		return this.value;

	}

}

class NumberUniform extends Uniform {

	constructor( name, value = 0 ) {

		super( name, value );

		this.isNumberUniform = true;

		this.boundary = 4;
		this.itemSize = 1;

	}

}

class Vector2Uniform extends Uniform {

	constructor( name, value = new Vector2() ) {

		super( name, value );

		this.isVector2Uniform = true;

		this.boundary = 8;
		this.itemSize = 2;

	}

}

class Vector3Uniform extends Uniform {

	constructor( name, value = new Vector3() ) {

		super( name, value );

		this.isVector3Uniform = true;

		this.boundary = 16;
		this.itemSize = 3;

	}

}

class Vector4Uniform extends Uniform {

	constructor( name, value = new Vector4() ) {

		super( name, value );

		this.isVector4Uniform = true;

		this.boundary = 16;
		this.itemSize = 4;

	}

}

class ColorUniform extends Uniform {

	constructor( name, value = new Color() ) {

		super( name, value );

		this.isColorUniform = true;

		this.boundary = 16;
		this.itemSize = 3;

	}

}

class Matrix3Uniform extends Uniform {

	constructor( name, value = new Matrix3() ) {

		super( name, value );

		this.isMatrix3Uniform = true;

		this.boundary = 48;
		this.itemSize = 12;

	}

}

class Matrix4Uniform extends Uniform {

	constructor( name, value = new Matrix4() ) {

		super( name, value );

		this.isMatrix4Uniform = true;

		this.boundary = 64;
		this.itemSize = 16;

	}

}

class NumberNodeUniform extends NumberUniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Vector2NodeUniform extends Vector2Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Vector3NodeUniform extends Vector3Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Vector4NodeUniform extends Vector4Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class ColorNodeUniform extends ColorUniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Matrix3NodeUniform extends Matrix3Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Matrix4NodeUniform extends Matrix4Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

const LOD_MIN = 4;

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const _flatCamera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
const _cubeCamera = /*@__PURE__*/ new PerspectiveCamera( 90, 1 );
const _clearColor = /*@__PURE__*/ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, 1 )
];

//

// WebGPU Face indices
const _faceLib = [
	3, 1, 5,
	0, 4, 2
];

const direction = getDirection( uv(), attribute( 'faceIndex' ) ).normalize();
const outputDirection = vec3( direction.x, direction.y.negate(), direction.z );

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._lodMax = 0;
		this._cubeSize = 0;
		this._lodPlanes = [];
		this._sizeLods = [];
		this._sigmas = [];
		this._lodMeshes = [];

		this._blurMaterial = null;
		this._cubemapMaterial = null;
		this._equirectMaterial = null;
		this._backgroundBox = null;

	}

	get _hasInitialized() {

		return this._renderer.hasInitialized();

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {

		this._setSize( 256 );

		if ( this._hasInitialized === false ) {

			console.warn( 'THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.' );

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();

			this.fromSceneAsync( scene, sigma, near, far, cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();

		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		cubeUVRenderTarget.depthBuffer = true;

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );

		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	async fromSceneAsync( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {

		if ( this._hasInitialized === false ) await this._renderer.init();

		return this.fromScene( scene, sigma, near, far, renderTarget );

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular( equirectangular, renderTarget = null ) {

		if ( this._hasInitialized === false ) {

			console.warn( 'THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.' );

			this._setSizeFromTexture( equirectangular );

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();

			this.fromEquirectangularAsync( equirectangular, cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		return this._fromTexture( equirectangular, renderTarget );

	}

	async fromEquirectangularAsync( equirectangular, renderTarget = null ) {

		if ( this._hasInitialized === false ) await this._renderer.init();

		return this._fromTexture( equirectangular, renderTarget );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap( cubemap, renderTarget = null ) {

		if ( this._hasInitialized === false ) {

			console.warn( 'THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.' );

			this._setSizeFromTexture( cubemap );

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();

			this.fromCubemapAsync( cubemap, renderTarget );

			return cubeUVRenderTarget;

		}

		return this._fromTexture( cubemap, renderTarget );

	}

	async fromCubemapAsync( cubemap, renderTarget = null ) {

		if ( this._hasInitialized === false ) await this._renderer.init();

		return this._fromTexture( cubemap, renderTarget );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	async compileCubemapShader() {

		if ( this._cubemapMaterial === null ) {

			this._cubemapMaterial = _getCubemapMaterial();
			await this._compileMaterial( this._cubemapMaterial );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	async compileEquirectangularShader() {

		if ( this._equirectMaterial === null ) {

			this._equirectMaterial = _getEquirectMaterial();
			await this._compileMaterial( this._equirectMaterial );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._dispose();

		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();
		if ( this._backgroundBox !== null ) {

			this._backgroundBox.geometry.dispose();
			this._backgroundBox.material.dispose();

		}

	}

	// private interface

	_setSizeFromTexture( texture ) {

		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

		} else { // Equirectangular

			this._setSize( texture.image.width / 4 );

		}

	}

	_setSize( cubeSize ) {

		this._lodMax = Math.floor( Math.log2( cubeSize ) );
		this._cubeSize = Math.pow( 2, this._lodMax );

	}

	_dispose() {

		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

			this._lodPlanes[ i ].dispose();

		}

	}

	_cleanup( outputTarget ) {

		this._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );
		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture, renderTarget ) {

		this._setSizeFromTexture( texture );

		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();

		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets() {

		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
		const height = 4 * this._cubeSize;

		const params = {
			magFilter: LinearFilter,
			minFilter: LinearFilter,
			generateMipmaps: false,
			type: HalfFloatType,
			format: RGBAFormat,
			colorSpace: LinearSRGBColorSpace,
			//depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

			if ( this._pingPongRenderTarget !== null ) {

				this._dispose();

			}

			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

			const { _lodMax } = this;
			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes( _lodMax ) );

			this._blurMaterial = _getBlurShader( _lodMax, width, height );

		}

		return cubeUVRenderTarget;

	}

	async _compileMaterial( material ) {

		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
		await this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const cubeCamera = _cubeCamera;
		cubeCamera.near = near;
		cubeCamera.far = far;

		// px, py, pz, nx, ny, nz
		const upSign = [ - 1, 1, - 1, - 1, - 1, - 1 ];
		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];

		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;

		renderer.getClearColor( _clearColor );

		renderer.autoClear = false;

		let backgroundBox = this._backgroundBox;

		if ( backgroundBox === null ) {

			const backgroundMaterial = new MeshBasicMaterial( {
				name: 'PMREM.Background',
				side: BackSide,
				depthWrite: false,
				depthTest: false
			} );

			backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

		}

		let useSolidColor = false;
		const background = scene.background;

		if ( background ) {

			if ( background.isColor ) {

				backgroundBox.material.color.copy( background );
				scene.background = null;
				useSolidColor = true;

			}

		} else {

			backgroundBox.material.color.copy( _clearColor );
			useSolidColor = true;

		}

		renderer.setRenderTarget( cubeUVRenderTarget );

		renderer.clear();

		if ( useSolidColor ) {

			renderer.render( backgroundBox, cubeCamera );

		}

		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;

			if ( col === 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col === 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

			renderer.render( scene, cubeCamera );

		}

		renderer.autoClear = originalAutoClear;
		scene.background = background;

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

		if ( isCubeTexture ) {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial( texture );

			}

		} else {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial( texture );

			}

		}

		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
		material.fragmentNode.value = texture;

		const mesh = this._lodMeshes[ 0 ];
		mesh.material = material;

		const size = this._cubeSize;

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;
		const n = this._lodPlanes.length;

		for ( let i = 1; i < n; i ++ ) {

			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error( 'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = this._lodMeshes[ lodOut ];
		blurMesh.material = blurMaterial;

		const blurUniforms = blurMaterial.uniforms;

		const pixels = this._sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i === 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		targetIn.texture.frame = ( targetIn.texture.frame || 0 ) + 1;

		blurUniforms.envMap.value = targetIn.texture;
		blurUniforms.samples.value = samples;
		blurUniforms.weights.array = weights;
		blurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;

		if ( poleAxis ) {

			blurUniforms.poleAxis.value = poleAxis;

		}

		const { _lodMax } = this;
		blurUniforms.dTheta.value = radiansPerPixel;
		blurUniforms.mipInt.value = _lodMax - lodIn;

		const outputSize = this._sizeLods[ lodOut ];
		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
		const y = 4 * ( this._cubeSize - outputSize );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}

function _createPlanes( lodMax ) {

	const lodPlanes = [];
	const sizeLods = [];
	const sigmas = [];
	const lodMeshes = [];

	let lod = lodMax;

	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

	for ( let i = 0; i < totalLods; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > lodMax - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

		} else if ( i === 0 ) {

			sigma = 0;

		}

		sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 2 );
		const min = - texelSize;
		const max = 1 + texelSize;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : - 1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];

			const faceIdx = _faceLib[ face ];
			position.set( coordinates, positionSize * vertices * faceIdx );
			uv.set( uv1, uvSize * vertices * faceIdx );
			const fill = [ faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx ];
			faceIndex.set( fill, faceIndexSize * vertices * faceIdx );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		lodPlanes.push( planes );
		lodMeshes.push( new Mesh( planes, null ) );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { lodPlanes, sizeLods, sigmas, lodMeshes };

}

function _createRenderTarget( width, height, params ) {

	const cubeUVRenderTarget = new RenderTarget( width, height, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.texture.isPMREMTexture = true;
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getMaterial( type ) {

	const material = new NodeMaterial();
	material.depthTest = false;
	material.depthWrite = false;
	material.blending = NoBlending;
	material.name = `PMREM_${ type }`;

	return material;

}

function _getBlurShader( lodMax, width, height ) {

	const weights = uniformArray( new Array( MAX_SAMPLES ).fill( 0 ) );
	const poleAxis = uniform( new Vector3( 0, 1, 0 ) );
	const dTheta = uniform( 0 );
	const n = float( MAX_SAMPLES );
	const latitudinal = uniform( 0 ); // false, bool
	const samples = uniform( 1 ); // int
	const envMap = texture( null );
	const mipInt = uniform( 0 ); // int
	const CUBEUV_TEXEL_WIDTH = float( 1 / width );
	const CUBEUV_TEXEL_HEIGHT = float( 1 / height );
	const CUBEUV_MAX_MIP = float( lodMax );

	const materialUniforms = {
		n,
		latitudinal,
		weights,
		poleAxis,
		outputDirection,
		dTheta,
		samples,
		envMap,
		mipInt,
		CUBEUV_TEXEL_WIDTH,
		CUBEUV_TEXEL_HEIGHT,
		CUBEUV_MAX_MIP
	};

	const material = _getMaterial( 'blur' );
	material.uniforms = materialUniforms; // TODO: Move to outside of the material
	material.fragmentNode = blur( { ...materialUniforms, latitudinal: latitudinal.equal( 1 ) } );

	return material;

}

function _getCubemapMaterial( envTexture ) {

	const material = _getMaterial( 'cubemap' );
	material.fragmentNode = cubeTexture( envTexture, outputDirection );

	return material;

}

function _getEquirectMaterial( envTexture ) {

	const material = _getMaterial( 'equirect' );
	material.fragmentNode = texture( envTexture, equirectUV( outputDirection ), 0 );

	return material;

}

const rendererCache = new WeakMap();

const typeFromArray = new Map( [
	[ Int8Array, 'int' ],
	[ Int16Array, 'int' ],
	[ Int32Array, 'int' ],
	[ Uint8Array, 'uint' ],
	[ Uint16Array, 'uint' ],
	[ Uint32Array, 'uint' ],
	[ Float32Array, 'float' ]
] );

const toFloat = ( value ) => {

	if ( /e/g.test( value ) ) {

		return String( value ).replace( /\+/g, '' );

	} else {

		value = Number( value );

		return value + ( value % 1 ? '' : '.0' );

	}

};

class NodeBuilder {

	constructor( object, renderer, parser ) {

		this.object = object;
		this.material = ( object && object.material ) || null;
		this.geometry = ( object && object.geometry ) || null;
		this.renderer = renderer;
		this.parser = parser;
		this.scene = null;
		this.camera = null;

		this.nodes = [];
		this.sequentialNodes = [];
		this.updateNodes = [];
		this.updateBeforeNodes = [];
		this.updateAfterNodes = [];
		this.hashNodes = {};

		this.monitor = null;

		this.lightsNode = null;
		this.environmentNode = null;
		this.fogNode = null;

		this.clippingContext = null;

		this.vertexShader = null;
		this.fragmentShader = null;
		this.computeShader = null;

		this.flowNodes = { vertex: [], fragment: [], compute: [] };
		this.flowCode = { vertex: '', fragment: '', compute: '' };
		this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
		this.structs = { vertex: [], fragment: [], compute: [], index: 0 };
		this.bindings = { vertex: {}, fragment: {}, compute: {} };
		this.bindingsIndexes = {};
		this.bindGroups = null;
		this.attributes = [];
		this.bufferAttributes = [];
		this.varyings = [];
		this.codes = {};
		this.vars = {};
		this.flow = { code: '' };
		this.chaining = [];
		this.stack = stack();
		this.stacks = [];
		this.tab = '\t';

		this.currentFunctionNode = null;

		this.context = {
			material: this.material
		};

		this.cache = new NodeCache();
		this.globalCache = this.cache;

		this.flowsData = new WeakMap();

		this.shaderStage = null;
		this.buildStage = null;

		this.useComparisonMethod = false;

	}

	getBindGroupsCache() {

		let bindGroupsCache = rendererCache.get( this.renderer );

		if ( bindGroupsCache === undefined ) {

			bindGroupsCache = new ChainMap();

			rendererCache.set( this.renderer, bindGroupsCache );

		}

		return bindGroupsCache;

	}

	createRenderTarget( width, height, options ) {

		return new RenderTarget( width, height, options );

	}

	createCubeRenderTarget( size, options ) {

		return new CubeRenderTarget( size, options );

	}

	createPMREMGenerator() {

		// TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support

		return new PMREMGenerator( this.renderer );

	}

	includes( node ) {

		return this.nodes.includes( node );

	}

	_getBindGroup( groupName, bindings ) {

		const bindGroupsCache = this.getBindGroupsCache();

		//

		const bindingsArray = [];

		let sharedGroup = true;

		for ( const binding of bindings ) {

			bindingsArray.push( binding );

			sharedGroup = sharedGroup && binding.groupNode.shared !== true;

		}

		//

		let bindGroup;

		if ( sharedGroup ) {

			bindGroup = bindGroupsCache.get( bindingsArray );

			if ( bindGroup === undefined ) {

				bindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );

				bindGroupsCache.set( bindingsArray, bindGroup );

			}

		} else {

			bindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );

		}

		return bindGroup;

	}

	getBindGroupArray( groupName, shaderStage ) {

		const bindings = this.bindings[ shaderStage ];

		let bindGroup = bindings[ groupName ];

		if ( bindGroup === undefined ) {

			if ( this.bindingsIndexes[ groupName ] === undefined ) {

				this.bindingsIndexes[ groupName ] = { binding: 0, group: Object.keys( this.bindingsIndexes ).length };

			}

			bindings[ groupName ] = bindGroup = [];

		}

		return bindGroup;

	}

	getBindings() {

		let bindingsGroups = this.bindGroups;

		if ( bindingsGroups === null ) {

			const groups = {};
			const bindings = this.bindings;

			for ( const shaderStage of shaderStages ) {

				for ( const groupName in bindings[ shaderStage ] ) {

					const uniforms = bindings[ shaderStage ][ groupName ];

					const groupUniforms = groups[ groupName ] || ( groups[ groupName ] = [] );
					groupUniforms.push( ...uniforms );

				}

			}

			bindingsGroups = [];

			for ( const groupName in groups ) {

				const group = groups[ groupName ];

				const bindingsGroup = this._getBindGroup( groupName, group );

				bindingsGroups.push( bindingsGroup );

			}

			this.bindGroups = bindingsGroups;

		}

		return bindingsGroups;

	}

	sortBindingGroups() {

		const bindingsGroups = this.getBindings();

		bindingsGroups.sort( ( a, b ) => ( a.bindings[ 0 ].groupNode.order - b.bindings[ 0 ].groupNode.order ) );

		for ( let i = 0; i < bindingsGroups.length; i ++ ) {

			const bindingGroup = bindingsGroups[ i ];
			this.bindingsIndexes[ bindingGroup.name ].group = i;

			bindingGroup.index = i;

		}

	}

	setHashNode( node, hash ) {

		this.hashNodes[ hash ] = node;

	}

	addNode( node ) {

		if ( this.nodes.includes( node ) === false ) {

			this.nodes.push( node );

			this.setHashNode( node, node.getHash( this ) );

		}

	}

	addSequentialNode( node ) {

		if ( this.sequentialNodes.includes( node ) === false ) {

			this.sequentialNodes.push( node );

		}

	}

	buildUpdateNodes() {

		for ( const node of this.nodes ) {

			const updateType = node.getUpdateType();

			if ( updateType !== NodeUpdateType.NONE ) {

				this.updateNodes.push( node.getSelf() );

			}

		}

		for ( const node of this.sequentialNodes ) {

			const updateBeforeType = node.getUpdateBeforeType();
			const updateAfterType = node.getUpdateAfterType();

			if ( updateBeforeType !== NodeUpdateType.NONE ) {

				this.updateBeforeNodes.push( node.getSelf() );

			}

			if ( updateAfterType !== NodeUpdateType.NONE ) {

				this.updateAfterNodes.push( node.getSelf() );

			}

		}

	}

	get currentNode() {

		return this.chaining[ this.chaining.length - 1 ];

	}

	isFilteredTexture( texture ) {

		return ( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||
			texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter );

	}

	addChain( node ) {

		/*
		if ( this.chaining.indexOf( node ) !== - 1 ) {

			console.warn( 'Recursive node: ', node );

		}
		*/

		this.chaining.push( node );

	}

	removeChain( node ) {

		const lastChain = this.chaining.pop();

		if ( lastChain !== node ) {

			throw new Error( 'NodeBuilder: Invalid node chaining!' );

		}

	}

	getMethod( method ) {

		return method;

	}

	getNodeFromHash( hash ) {

		return this.hashNodes[ hash ];

	}

	addFlow( shaderStage, node ) {

		this.flowNodes[ shaderStage ].push( node );

		return node;

	}

	setContext( context ) {

		this.context = context;

	}

	getContext() {

		return this.context;

	}

	getSharedContext() {

		({ ...this.context });

		return this.context;

	}

	setCache( cache ) {

		this.cache = cache;

	}

	getCache() {

		return this.cache;

	}

	getCacheFromNode( node, parent = true ) {

		const data = this.getDataFromNode( node );
		if ( data.cache === undefined ) data.cache = new NodeCache( parent ? this.getCache() : null );

		return data.cache;

	}

	isAvailable( /*name*/ ) {

		return false;

	}

	getVertexIndex() {

		console.warn( 'Abstract function.' );

	}

	getInstanceIndex() {

		console.warn( 'Abstract function.' );

	}

	getDrawIndex() {

		console.warn( 'Abstract function.' );

	}

	getFrontFacing() {

		console.warn( 'Abstract function.' );

	}

	getFragCoord() {

		console.warn( 'Abstract function.' );

	}

	isFlipY() {

		return false;

	}

	increaseUsage( node ) {

		const nodeData = this.getDataFromNode( node );
		nodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;

		return nodeData.usageCount;

	}

	generateTexture( /* texture, textureProperty, uvSnippet */ ) {

		console.warn( 'Abstract function.' );

	}

	generateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {

		console.warn( 'Abstract function.' );

	}

	generateConst( type, value = null ) {

		if ( value === null ) {

			if ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;
			else if ( type === 'bool' ) value = false;
			else if ( type === 'color' ) value = new Color();
			else if ( type === 'vec2' ) value = new Vector2();
			else if ( type === 'vec3' ) value = new Vector3();
			else if ( type === 'vec4' ) value = new Vector4();

		}

		if ( type === 'float' ) return toFloat( value );
		if ( type === 'int' ) return `${ Math.round( value ) }`;
		if ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';
		if ( type === 'bool' ) return value ? 'true' : 'false';
		if ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;

		const typeLength = this.getTypeLength( type );

		const componentType = this.getComponentType( type );

		const generateConst = value => this.generateConst( componentType, value );

		if ( typeLength === 2 ) {

			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;

		} else if ( typeLength === 3 ) {

			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;

		} else if ( typeLength === 4 ) {

			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;

		} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {

			return `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;

		} else if ( typeLength > 4 ) {

			return `${ this.getType( type ) }()`;

		}

		throw new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );

	}

	getType( type ) {

		if ( type === 'color' ) return 'vec3';

		return type;

	}

	hasGeometryAttribute( name ) {

		return this.geometry && this.geometry.getAttribute( name ) !== undefined;

	}

	getAttribute( name, type ) {

		const attributes = this.attributes;

		// find attribute

		for ( const attribute of attributes ) {

			if ( attribute.name === name ) {

				return attribute;

			}

		}

		// create a new if no exist

		const attribute = new NodeAttribute( name, type );

		attributes.push( attribute );

		return attribute;

	}

	getPropertyName( node/*, shaderStage*/ ) {

		return node.name;

	}

	isVector( type ) {

		return /vec\d/.test( type );

	}

	isMatrix( type ) {

		return /mat\d/.test( type );

	}

	isReference( type ) {

		return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';

	}

	needsToWorkingColorSpace( /*texture*/ ) {

		return false;

	}

	getComponentTypeFromTexture( texture ) {

		const type = texture.type;

		if ( texture.isDataTexture ) {

			if ( type === IntType ) return 'int';
			if ( type === UnsignedIntType ) return 'uint';

		}

		return 'float';

	}

	getElementType( type ) {

		if ( type === 'mat2' ) return 'vec2';
		if ( type === 'mat3' ) return 'vec3';
		if ( type === 'mat4' ) return 'vec4';

		return this.getComponentType( type );

	}

	getComponentType( type ) {

		type = this.getVectorType( type );

		if ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;

		const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );

		if ( componentType === null ) return null;

		if ( componentType[ 1 ] === 'b' ) return 'bool';
		if ( componentType[ 1 ] === 'i' ) return 'int';
		if ( componentType[ 1 ] === 'u' ) return 'uint';

		return 'float';

	}

	getVectorType( type ) {

		if ( type === 'color' ) return 'vec3';
		if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) return 'vec4';

		return type;

	}

	getTypeFromLength( length, componentType = 'float' ) {

		if ( length === 1 ) return componentType;

		const baseType = getTypeFromLength( length );
		const prefix = componentType === 'float' ? '' : componentType[ 0 ];

		return prefix + baseType;

	}

	getTypeFromArray( array ) {

		return typeFromArray.get( array.constructor );

	}

	getTypeFromAttribute( attribute ) {

		let dataAttribute = attribute;

		if ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;

		const array = dataAttribute.array;
		const itemSize = attribute.itemSize;
		const normalized = attribute.normalized;

		let arrayType;

		if ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {

			arrayType = this.getTypeFromArray( array );

		}

		return this.getTypeFromLength( itemSize, arrayType );

	}

	getTypeLength( type ) {

		const vecType = this.getVectorType( type );
		const vecNum = /vec([2-4])/.exec( vecType );

		if ( vecNum !== null ) return Number( vecNum[ 1 ] );
		if ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;
		if ( /mat2/.test( type ) === true ) return 4;
		if ( /mat3/.test( type ) === true ) return 9;
		if ( /mat4/.test( type ) === true ) return 16;

		return 0;

	}

	getVectorFromMatrix( type ) {

		return type.replace( 'mat', 'vec' );

	}

	changeComponentType( type, newComponentType ) {

		return this.getTypeFromLength( this.getTypeLength( type ), newComponentType );

	}

	getIntegerType( type ) {

		const componentType = this.getComponentType( type );

		if ( componentType === 'int' || componentType === 'uint' ) return type;

		return this.changeComponentType( type, 'int' );

	}

	addStack() {

		this.stack = stack( this.stack );

		this.stacks.push( getCurrentStack() || this.stack );
		setCurrentStack( this.stack );

		return this.stack;

	}

	removeStack() {

		const lastStack = this.stack;
		this.stack = lastStack.parent;

		setCurrentStack( this.stacks.pop() );

		return lastStack;

	}

	getDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {

		cache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;

		let nodeData = cache.getData( node );

		if ( nodeData === undefined ) {

			nodeData = {};

			cache.setData( node, nodeData );

		}

		if ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};

		return nodeData[ shaderStage ];

	}

	getNodeProperties( node, shaderStage = 'any' ) {

		const nodeData = this.getDataFromNode( node, shaderStage );

		return nodeData.properties || ( nodeData.properties = { outputNode: null } );

	}

	getBufferAttributeFromNode( node, type ) {

		const nodeData = this.getDataFromNode( node );

		let bufferAttribute = nodeData.bufferAttribute;

		if ( bufferAttribute === undefined ) {

			const index = this.uniforms.index ++;

			bufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );

			this.bufferAttributes.push( bufferAttribute );

			nodeData.bufferAttribute = bufferAttribute;

		}

		return bufferAttribute;

	}

	getStructTypeFromNode( node, shaderStage = this.shaderStage ) {

		const nodeData = this.getDataFromNode( node, shaderStage );

		if ( nodeData.structType === undefined ) {

			const index = this.structs.index ++;

			node.name = `StructType${ index }`;
			this.structs[ shaderStage ].push( node );

			nodeData.structType = node;

		}

		return node;

	}

	getUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {

		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

		let nodeUniform = nodeData.uniform;

		if ( nodeUniform === undefined ) {

			const index = this.uniforms.index ++;

			nodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );

			this.uniforms[ shaderStage ].push( nodeUniform );

			nodeData.uniform = nodeUniform;

		}

		return nodeUniform;

	}

	getVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage ) {

		const nodeData = this.getDataFromNode( node, shaderStage );

		let nodeVar = nodeData.variable;

		if ( nodeVar === undefined ) {

			const vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );

			if ( name === null ) name = 'nodeVar' + vars.length;

			nodeVar = new NodeVar( name, type );

			vars.push( nodeVar );

			nodeData.variable = nodeVar;

		}

		return nodeVar;

	}

	getVaryingFromNode( node, name = null, type = node.getNodeType( this ) ) {

		const nodeData = this.getDataFromNode( node, 'any' );

		let nodeVarying = nodeData.varying;

		if ( nodeVarying === undefined ) {

			const varyings = this.varyings;
			const index = varyings.length;

			if ( name === null ) name = 'nodeVarying' + index;

			nodeVarying = new NodeVarying( name, type );

			varyings.push( nodeVarying );

			nodeData.varying = nodeVarying;

		}

		return nodeVarying;

	}

	getCodeFromNode( node, type, shaderStage = this.shaderStage ) {

		const nodeData = this.getDataFromNode( node );

		let nodeCode = nodeData.code;

		if ( nodeCode === undefined ) {

			const codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );
			const index = codes.length;

			nodeCode = new NodeCode( 'nodeCode' + index, type );

			codes.push( nodeCode );

			nodeData.code = nodeCode;

		}

		return nodeCode;

	}

	addFlowCodeHierarchy( node, nodeBlock ) {

		const { flowCodes, flowCodeBlock } = this.getDataFromNode( node );

		let needsFlowCode = true;
		let nodeBlockHierarchy = nodeBlock;

		while ( nodeBlockHierarchy ) {

			if ( flowCodeBlock.get( nodeBlockHierarchy ) === true ) {

				needsFlowCode = false;
				break;

			}

			nodeBlockHierarchy = this.getDataFromNode( nodeBlockHierarchy ).parentNodeBlock;

		}

		if ( needsFlowCode ) {

			for ( const flowCode of flowCodes ) {

				this.addLineFlowCode( flowCode );

			}

		}

	}

	addLineFlowCodeBlock( node, code, nodeBlock ) {

		const nodeData = this.getDataFromNode( node );
		const flowCodes = nodeData.flowCodes || ( nodeData.flowCodes = [] );
		const codeBlock = nodeData.flowCodeBlock || ( nodeData.flowCodeBlock = new WeakMap() );

		flowCodes.push( code );
		codeBlock.set( nodeBlock, true );

	}

	addLineFlowCode( code, node = null ) {

		if ( code === '' ) return this;

		if ( node !== null && this.context.nodeBlock ) {

			this.addLineFlowCodeBlock( node, code, this.context.nodeBlock );

		}

		code = this.tab + code;

		if ( ! /;\s*$/.test( code ) ) {

			code = code + ';\n';

		}

		this.flow.code += code;

		return this;

	}

	addFlowCode( code ) {

		this.flow.code += code;

		return this;

	}

	addFlowTab() {

		this.tab += '\t';

		return this;

	}

	removeFlowTab() {

		this.tab = this.tab.slice( 0, - 1 );

		return this;

	}

	getFlowData( node/*, shaderStage*/ ) {

		return this.flowsData.get( node );

	}

	flowNode( node ) {

		const output = node.getNodeType( this );

		const flowData = this.flowChildNode( node, output );

		this.flowsData.set( node, flowData );

		return flowData;

	}

	buildFunctionNode( shaderNode ) {

		const fn = new FunctionNode();

		const previous = this.currentFunctionNode;

		this.currentFunctionNode = fn;

		fn.code = this.buildFunctionCode( shaderNode );

		this.currentFunctionNode = previous;

		return fn;

	}

	flowShaderNode( shaderNode ) {

		const layout = shaderNode.layout;

		const inputs = {
			[ Symbol.iterator ]() {

				let index = 0;
				const values = Object.values( this );
				return {
					next: () => ( {
						value: values[ index ],
						done: index ++ >= values.length
					} )
				};

			}
		};

		for ( const input of layout.inputs ) {

			inputs[ input.name ] = new ParameterNode( input.type, input.name );

		}

		//

		shaderNode.layout = null;

		const callNode = shaderNode.call( inputs );
		const flowData = this.flowStagesNode( callNode, layout.type );

		shaderNode.layout = layout;

		return flowData;

	}

	flowStagesNode( node, output = null ) {

		const previousFlow = this.flow;
		const previousVars = this.vars;
		const previousCache = this.cache;
		const previousBuildStage = this.buildStage;
		const previousStack = this.stack;

		const flow = {
			code: ''
		};

		this.flow = flow;
		this.vars = {};
		this.cache = new NodeCache();
		this.stack = stack();

		for ( const buildStage of defaultBuildStages ) {

			this.setBuildStage( buildStage );

			flow.result = node.build( this, output );

		}

		flow.vars = this.getVars( this.shaderStage );

		this.flow = previousFlow;
		this.vars = previousVars;
		this.cache = previousCache;
		this.stack = previousStack;

		this.setBuildStage( previousBuildStage );

		return flow;

	}

	getFunctionOperator() {

		return null;

	}

	flowChildNode( node, output = null ) {

		const previousFlow = this.flow;

		const flow = {
			code: ''
		};

		this.flow = flow;

		flow.result = node.build( this, output );

		this.flow = previousFlow;

		return flow;

	}

	flowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {

		const previousShaderStage = this.shaderStage;

		this.setShaderStage( shaderStage );

		const flowData = this.flowChildNode( node, output );

		if ( propertyName !== null ) {

			flowData.code += `${ this.tab + propertyName } = ${ flowData.result };\n`;

		}

		this.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;

		this.setShaderStage( previousShaderStage );

		return flowData;

	}

	getAttributesArray() {

		return this.attributes.concat( this.bufferAttributes );

	}

	getAttributes( /*shaderStage*/ ) {

		console.warn( 'Abstract function.' );

	}

	getVaryings( /*shaderStage*/ ) {

		console.warn( 'Abstract function.' );

	}

	getVar( type, name ) {

		return `${ this.getType( type ) } ${ name }`;

	}

	getVars( shaderStage ) {

		let snippet = '';

		const vars = this.vars[ shaderStage ];

		if ( vars !== undefined ) {

			for ( const variable of vars ) {

				snippet += `${ this.getVar( variable.type, variable.name ) }; `;

			}

		}

		return snippet;

	}

	getUniforms( /*shaderStage*/ ) {

		console.warn( 'Abstract function.' );

	}

	getCodes( shaderStage ) {

		const codes = this.codes[ shaderStage ];

		let code = '';

		if ( codes !== undefined ) {

			for ( const nodeCode of codes ) {

				code += nodeCode.code + '\n';

			}

		}

		return code;

	}

	getHash() {

		return this.vertexShader + this.fragmentShader + this.computeShader;

	}

	setShaderStage( shaderStage ) {

		this.shaderStage = shaderStage;

	}

	getShaderStage() {

		return this.shaderStage;

	}

	setBuildStage( buildStage ) {

		this.buildStage = buildStage;

	}

	getBuildStage() {

		return this.buildStage;

	}

	buildCode() {

		console.warn( 'Abstract function.' );

	}

	build() {

		const { object, material, renderer } = this;

		if ( material !== null ) {

			let nodeMaterial = renderer.library.fromMaterial( material );

			if ( nodeMaterial === null ) {

				console.error( `NodeMaterial: Material "${ material.type }" is not compatible.` );

				nodeMaterial = new NodeMaterial();

			}

			nodeMaterial.build( this );

		} else {

			this.addFlow( 'compute', object );

		}

		// setup() -> stage 1: create possible new nodes and returns an output reference node
		// analyze()   -> stage 2: analyze nodes to possible optimization and validation
		// generate()  -> stage 3: generate shader

		for ( const buildStage of defaultBuildStages ) {

			this.setBuildStage( buildStage );

			if ( this.context.vertex && this.context.vertex.isNode ) {

				this.flowNodeFromShaderStage( 'vertex', this.context.vertex );

			}

			for ( const shaderStage of shaderStages ) {

				this.setShaderStage( shaderStage );

				const flowNodes = this.flowNodes[ shaderStage ];

				for ( const node of flowNodes ) {

					if ( buildStage === 'generate' ) {

						this.flowNode( node );

					} else {

						node.build( this );

					}

				}

			}

		}

		this.setBuildStage( null );
		this.setShaderStage( null );

		// stage 4: build code for a specific output

		this.buildCode();
		this.buildUpdateNodes();

		return this;

	}

	getNodeUniform( uniformNode, type ) {

		if ( type === 'float' || type === 'int' || type === 'uint' ) return new NumberNodeUniform( uniformNode );
		if ( type === 'vec2' || type === 'ivec2' || type === 'uvec2' ) return new Vector2NodeUniform( uniformNode );
		if ( type === 'vec3' || type === 'ivec3' || type === 'uvec3' ) return new Vector3NodeUniform( uniformNode );
		if ( type === 'vec4' || type === 'ivec4' || type === 'uvec4' ) return new Vector4NodeUniform( uniformNode );
		if ( type === 'color' ) return new ColorNodeUniform( uniformNode );
		if ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );
		if ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );

		throw new Error( `Uniform "${type}" not declared.` );

	}

	createNodeMaterial( type = 'NodeMaterial' ) { // @deprecated, r168

		throw new Error( `THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${ type }() instead.` );

	}

	format( snippet, fromType, toType ) {

		fromType = this.getVectorType( fromType );
		toType = this.getVectorType( toType );

		if ( fromType === toType || toType === null || this.isReference( toType ) ) {

			return snippet;

		}

		const fromTypeLength = this.getTypeLength( fromType );
		const toTypeLength = this.getTypeLength( toType );

		if ( fromTypeLength === 16 && toTypeLength === 9 ) {

			return `${ this.getType( toType ) }(${ snippet }[0].xyz, ${ snippet }[1].xyz, ${ snippet }[2].xyz)`;

		}

		if ( fromTypeLength === 9 && toTypeLength === 4 ) {

			return `${ this.getType( toType ) }(${ snippet }[0].xy, ${ snippet }[1].xy)`;

		}


		if ( fromTypeLength > 4 ) { // fromType is matrix-like

			// @TODO: ignore for now

			return snippet;

		}

		if ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown

			// @TODO: ignore for now

			return snippet;

		}

		if ( fromTypeLength === toTypeLength ) {

			return `${ this.getType( toType ) }( ${ snippet } )`;

		}

		if ( fromTypeLength > toTypeLength ) {

			return this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );

		}

		if ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like

			return `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;

		}

		if ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like

			return `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;

		}

		if ( fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType( toType ) ) { // fromType is float-like

			// convert a number value to vector type, e.g:
			// vec3( 1u ) -> vec3( float( 1u ) )

			snippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;

		}

		return `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like

	}

	getSignature() {

		return `// Three.js r${ REVISION } - Node System\n`;

	}

}

class NodeFrame {

	constructor() {

		this.time = 0;
		this.deltaTime = 0;

		this.frameId = 0;
		this.renderId = 0;

		this.startTime = null;

		this.updateMap = new WeakMap();
		this.updateBeforeMap = new WeakMap();
		this.updateAfterMap = new WeakMap();

		this.renderer = null;
		this.material = null;
		this.camera = null;
		this.object = null;
		this.scene = null;

	}

	_getMaps( referenceMap, nodeRef ) {

		let maps = referenceMap.get( nodeRef );

		if ( maps === undefined ) {

			maps = {
				renderMap: new WeakMap(),
				frameMap: new WeakMap()
			};

			referenceMap.set( nodeRef, maps );

		}

		return maps;

	}

	updateBeforeNode( node ) {

		const updateType = node.getUpdateBeforeType();
		const reference = node.updateReference( this );

		if ( updateType === NodeUpdateType.FRAME ) {

			const { frameMap } = this._getMaps( this.updateBeforeMap, reference );

			if ( frameMap.get( reference ) !== this.frameId ) {

				if ( node.updateBefore( this ) !== false ) {

					frameMap.set( reference, this.frameId );

				}

			}

		} else if ( updateType === NodeUpdateType.RENDER ) {

			const { renderMap } = this._getMaps( this.updateBeforeMap, reference );

			if ( renderMap.get( reference ) !== this.renderId ) {

				if ( node.updateBefore( this ) !== false ) {

					renderMap.set( reference, this.renderId );

				}

			}

		} else if ( updateType === NodeUpdateType.OBJECT ) {

			node.updateBefore( this );

		}

	}

	updateAfterNode( node ) {

		const updateType = node.getUpdateAfterType();
		const reference = node.updateReference( this );

		if ( updateType === NodeUpdateType.FRAME ) {

			const { frameMap } = this._getMaps( this.updateAfterMap, reference );

			if ( frameMap.get( reference ) !== this.frameId ) {

				if ( node.updateAfter( this ) !== false ) {

					frameMap.set( reference, this.frameId );

				}

			}

		} else if ( updateType === NodeUpdateType.RENDER ) {

			const { renderMap } = this._getMaps( this.updateAfterMap, reference );

			if ( renderMap.get( reference ) !== this.renderId ) {

				if ( node.updateAfter( this ) !== false ) {

					renderMap.set( reference, this.renderId );

				}

			}

		} else if ( updateType === NodeUpdateType.OBJECT ) {

			node.updateAfter( this );

		}

	}

	updateNode( node ) {

		const updateType = node.getUpdateType();
		const reference = node.updateReference( this );

		if ( updateType === NodeUpdateType.FRAME ) {

			const { frameMap } = this._getMaps( this.updateMap, reference );

			if ( frameMap.get( reference ) !== this.frameId ) {

				if ( node.update( this ) !== false ) {

					frameMap.set( reference, this.frameId );

				}

			}

		} else if ( updateType === NodeUpdateType.RENDER ) {

			const { renderMap } = this._getMaps( this.updateMap, reference );

			if ( renderMap.get( reference ) !== this.renderId ) {

				if ( node.update( this ) !== false ) {

					renderMap.set( reference, this.renderId );

				}

			}

		} else if ( updateType === NodeUpdateType.OBJECT ) {

			node.update( this );

		}

	}

	update() {

		this.frameId ++;

		if ( this.lastTime === undefined ) this.lastTime = performance.now();

		this.deltaTime = ( performance.now() - this.lastTime ) / 1000;

		this.lastTime = performance.now();

		this.time += this.deltaTime;

	}

}

class NodeFunctionInput {

	constructor( type, name, count = null, qualifier = '', isConst = false ) {

		this.type = type;
		this.name = name;
		this.count = count;
		this.qualifier = qualifier;
		this.isConst = isConst;

	}

}

NodeFunctionInput.isNodeFunctionInput = true;

class DirectionalLightNode extends AnalyticLightNode {

	static get type() {

		return 'DirectionalLightNode';

	}

	constructor( light = null ) {

		super( light );

	}

	setup( builder ) {

		super.setup( builder );

		const lightingModel = builder.context.lightingModel;

		const lightColor = this.colorNode;
		const lightDirection = lightTargetDirection( this.light );
		const reflectedLight = builder.context.reflectedLight;

		lightingModel.direct( {
			lightDirection,
			lightColor,
			reflectedLight
		}, builder.stack, builder );

	}

}

const _matrix41 = /*@__PURE__*/ new Matrix4();
const _matrix42 = /*@__PURE__*/ new Matrix4();

let ltcLib = null;

class RectAreaLightNode extends AnalyticLightNode {

	static get type() {

		return 'RectAreaLightNode';

	}

	constructor( light = null ) {

		super( light );

		this.halfHeight = uniform( new Vector3() ).setGroup( renderGroup );
		this.halfWidth = uniform( new Vector3() ).setGroup( renderGroup );

		this.updateType = NodeUpdateType.RENDER;

	}

	update( frame ) {

		super.update( frame );

		const { light } = this;

		const viewMatrix = frame.camera.matrixWorldInverse;

		_matrix42.identity();
		_matrix41.copy( light.matrixWorld );
		_matrix41.premultiply( viewMatrix );
		_matrix42.extractRotation( _matrix41 );

		this.halfWidth.value.set( light.width * 0.5, 0.0, 0.0 );
		this.halfHeight.value.set( 0.0, light.height * 0.5, 0.0 );

		this.halfWidth.value.applyMatrix4( _matrix42 );
		this.halfHeight.value.applyMatrix4( _matrix42 );

	}

	setup( builder ) {

		super.setup( builder );

		let ltc_1, ltc_2;

		if ( builder.isAvailable( 'float32Filterable' ) ) {

			ltc_1 = texture( ltcLib.LTC_FLOAT_1 );
			ltc_2 = texture( ltcLib.LTC_FLOAT_2 );

		} else {

			ltc_1 = texture( ltcLib.LTC_HALF_1 );
			ltc_2 = texture( ltcLib.LTC_HALF_2 );

		}

		const { colorNode, light } = this;
		const lightingModel = builder.context.lightingModel;

		const lightPosition = lightViewPosition( light );
		const reflectedLight = builder.context.reflectedLight;

		lightingModel.directRectArea( {
			lightColor: colorNode,
			lightPosition,
			halfWidth: this.halfWidth,
			halfHeight: this.halfHeight,
			reflectedLight,
			ltc_1,
			ltc_2
		}, builder.stack, builder );

	}

	static setLTC( ltc ) {

		ltcLib = ltc;

	}

}

class SpotLightNode extends AnalyticLightNode {

	static get type() {

		return 'SpotLightNode';

	}

	constructor( light = null ) {

		super( light );

		this.coneCosNode = uniform( 0 ).setGroup( renderGroup );
		this.penumbraCosNode = uniform( 0 ).setGroup( renderGroup );

		this.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );
		this.decayExponentNode = uniform( 0 ).setGroup( renderGroup );

	}

	update( frame ) {

		super.update( frame );

		const { light } = this;

		this.coneCosNode.value = Math.cos( light.angle );
		this.penumbraCosNode.value = Math.cos( light.angle * ( 1 - light.penumbra ) );

		this.cutoffDistanceNode.value = light.distance;
		this.decayExponentNode.value = light.decay;

	}

	getSpotAttenuation( angleCosine ) {

		const { coneCosNode, penumbraCosNode } = this;

		return smoothstep( coneCosNode, penumbraCosNode, angleCosine );

	}

	setup( builder ) {

		super.setup( builder );

		const lightingModel = builder.context.lightingModel;

		const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;

		const lVector = lightViewPosition( light ).sub( positionView ); // @TODO: Add it into LightNode

		const lightDirection = lVector.normalize();
		const angleCos = lightDirection.dot( lightTargetDirection( light ) );
		const spotAttenuation = this.getSpotAttenuation( angleCos );

		const lightDistance = lVector.length();

		const lightAttenuation = getDistanceAttenuation( {
			lightDistance,
			cutoffDistance: cutoffDistanceNode,
			decayExponent: decayExponentNode
		} );

		let lightColor = colorNode.mul( spotAttenuation ).mul( lightAttenuation );

		if ( light.map ) {

			const spotLightCoord = lightProjectionUV( light );
			const projectedTexture = texture( light.map, spotLightCoord.xy ).onRenderUpdate( () => light.map );

			const inSpotLightMap = spotLightCoord.mul( 2. ).sub( 1. ).abs().lessThan( 1. ).all();

			lightColor = inSpotLightMap.select( lightColor.mul( projectedTexture ), lightColor );

		}

		const reflectedLight = builder.context.reflectedLight;

		lightingModel.direct( {
			lightDirection,
			lightColor,
			reflectedLight
		}, builder.stack, builder );

	}

}

class IESSpotLightNode extends SpotLightNode {

	static get type() {

		return 'IESSpotLightNode';

	}

	getSpotAttenuation( angleCosine ) {

		const iesMap = this.light.iesMap;

		let spotAttenuation = null;

		if ( iesMap && iesMap.isTexture === true ) {

			const angle = angleCosine.acos().mul( 1.0 / Math.PI );

			spotAttenuation = texture( iesMap, vec2( angle, 0 ), 0 ).r;

		} else {

			spotAttenuation = super.getSpotAttenuation( angleCosine );

		}

		return spotAttenuation;

	}

}

class AmbientLightNode extends AnalyticLightNode {

	static get type() {

		return 'AmbientLightNode';

	}

	constructor( light = null ) {

		super( light );

	}

	setup( { context } ) {

		context.irradiance.addAssign( this.colorNode );

	}

}

class HemisphereLightNode extends AnalyticLightNode {

	static get type() {

		return 'HemisphereLightNode';

	}

	constructor( light = null ) {

		super( light );

		this.lightPositionNode = lightPosition( light );
		this.lightDirectionNode = this.lightPositionNode.normalize();

		this.groundColorNode = uniform( new Color() ).setGroup( renderGroup );

	}

	update( frame ) {

		const { light } = this;

		super.update( frame );

		this.lightPositionNode.object3d = light;

		this.groundColorNode.value.copy( light.groundColor ).multiplyScalar( light.intensity );

	}

	setup( builder ) {

		const { colorNode, groundColorNode, lightDirectionNode } = this;

		const dotNL = normalView.dot( lightDirectionNode );
		const hemiDiffuseWeight = dotNL.mul( 0.5 ).add( 0.5 );

		const irradiance = mix( groundColorNode, colorNode, hemiDiffuseWeight );

		builder.context.irradiance.addAssign( irradiance );

	}

}

class LightProbeNode extends AnalyticLightNode {

	static get type() {

		return 'LightProbeNode';

	}

	constructor( light = null ) {

		super( light );

		const array = [];

		for ( let i = 0; i < 9; i ++ ) array.push( new Vector3() );

		this.lightProbe = uniformArray( array );

	}

	update( frame ) {

		const { light } = this;

		super.update( frame );

		//

		for ( let i = 0; i < 9; i ++ ) {

			this.lightProbe.array[ i ].copy( light.sh.coefficients[ i ] ).multiplyScalar( light.intensity );

		}

	}

	setup( builder ) {

		const irradiance = getShIrradianceAt( normalWorld, this.lightProbe );

		builder.context.irradiance.addAssign( irradiance );

	}

}

class NodeParser {

	parseFunction( /*source*/ ) {

		console.warn( 'Abstract function.' );

	}

}

class NodeFunction {

	constructor( type, inputs, name = '', precision = '' ) {

		this.type = type;
		this.inputs = inputs;
		this.name = name;
		this.precision = precision;

	}

	getCode( /*name = this.name*/ ) {

		console.warn( 'Abstract function.' );

	}

}

NodeFunction.isNodeFunction = true;

const declarationRegexp$1 = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
const propertiesRegexp$1 = /[a-z_0-9]+/ig;

const pragmaMain = '#pragma main';

const parse$1 = ( source ) => {

	source = source.trim();

	const pragmaMainIndex = source.indexOf( pragmaMain );

	const mainCode = pragmaMainIndex !== - 1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;

	const declaration = mainCode.match( declarationRegexp$1 );

	if ( declaration !== null && declaration.length === 5 ) {

		// tokenizer

		const inputsCode = declaration[ 4 ];
		const propsMatches = [];

		let nameMatch = null;

		while ( ( nameMatch = propertiesRegexp$1.exec( inputsCode ) ) !== null ) {

			propsMatches.push( nameMatch );

		}

		// parser

		const inputs = [];

		let i = 0;

		while ( i < propsMatches.length ) {

			const isConst = propsMatches[ i ][ 0 ] === 'const';

			if ( isConst === true ) {

				i ++;

			}

			let qualifier = propsMatches[ i ][ 0 ];

			if ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {

				i ++;

			} else {

				qualifier = '';

			}

			const type = propsMatches[ i ++ ][ 0 ];

			let count = Number.parseInt( propsMatches[ i ][ 0 ] );

			if ( Number.isNaN( count ) === false ) i ++;
			else count = null;

			const name = propsMatches[ i ++ ][ 0 ];

			inputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );

		}

		//

		const blockCode = mainCode.substring( declaration[ 0 ].length );

		const name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';
		const type = declaration[ 2 ];

		const precision = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';

		const headerCode = pragmaMainIndex !== - 1 ? source.slice( 0, pragmaMainIndex ) : '';

		return {
			type,
			inputs,
			name,
			precision,
			inputsCode,
			blockCode,
			headerCode
		};

	} else {

		throw new Error( 'FunctionNode: Function is not a GLSL code.' );

	}

};

class GLSLNodeFunction extends NodeFunction {

	constructor( source ) {

		const { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1( source );

		super( type, inputs, name, precision );

		this.inputsCode = inputsCode;
		this.blockCode = blockCode;
		this.headerCode = headerCode;

	}

	getCode( name = this.name ) {

		let code;

		const blockCode = this.blockCode;

		if ( blockCode !== '' ) {

			const { type, inputsCode, headerCode, precision } = this;

			let declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;

			if ( precision !== '' ) {

				declarationCode = `${ precision } ${ declarationCode }`;

			}

			code = headerCode + declarationCode + blockCode;

		} else {

			// interface function

			code = '';

		}

		return code;

	}

}

class GLSLNodeParser extends NodeParser {

	parseFunction( source ) {

		return new GLSLNodeFunction( source );

	}

}

const outputNodeMap = new WeakMap();

class Nodes extends DataMap {

	constructor( renderer, backend ) {

		super();

		this.renderer = renderer;
		this.backend = backend;
		this.nodeFrame = new NodeFrame();
		this.nodeBuilderCache = new Map();
		this.callHashCache = new ChainMap();
		this.groupsData = new ChainMap();

	}

	updateGroup( nodeUniformsGroup ) {

		const groupNode = nodeUniformsGroup.groupNode;
		const name = groupNode.name;

		// objectGroup is every updated

		if ( name === objectGroup.name ) return true;

		// renderGroup is updated once per render/compute call

		if ( name === renderGroup.name ) {

			const uniformsGroupData = this.get( nodeUniformsGroup );
			const renderId = this.nodeFrame.renderId;

			if ( uniformsGroupData.renderId !== renderId ) {

				uniformsGroupData.renderId = renderId;

				return true;

			}

			return false;

		}

		// frameGroup is updated once per frame

		if ( name === frameGroup.name ) {

			const uniformsGroupData = this.get( nodeUniformsGroup );
			const frameId = this.nodeFrame.frameId;

			if ( uniformsGroupData.frameId !== frameId ) {

				uniformsGroupData.frameId = frameId;

				return true;

			}

			return false;

		}

		// other groups are updated just when groupNode.needsUpdate is true

		const groupChain = [ groupNode, nodeUniformsGroup ];

		let groupData = this.groupsData.get( groupChain );
		if ( groupData === undefined ) this.groupsData.set( groupChain, groupData = {} );

		if ( groupData.version !== groupNode.version ) {

			groupData.version = groupNode.version;

			return true;

		}

		return false;

	}

	getForRenderCacheKey( renderObject ) {

		return renderObject.initialCacheKey;

	}

	getForRender( renderObject ) {

		const renderObjectData = this.get( renderObject );

		let nodeBuilderState = renderObjectData.nodeBuilderState;

		if ( nodeBuilderState === undefined ) {

			const { nodeBuilderCache } = this;

			const cacheKey = this.getForRenderCacheKey( renderObject );

			nodeBuilderState = nodeBuilderCache.get( cacheKey );

			if ( nodeBuilderState === undefined ) {

				const nodeBuilder = this.backend.createNodeBuilder( renderObject.object, this.renderer );
				nodeBuilder.scene = renderObject.scene;
				nodeBuilder.material = renderObject.material;
				nodeBuilder.camera = renderObject.camera;
				nodeBuilder.context.material = renderObject.material;
				nodeBuilder.lightsNode = renderObject.lightsNode;
				nodeBuilder.environmentNode = this.getEnvironmentNode( renderObject.scene );
				nodeBuilder.fogNode = this.getFogNode( renderObject.scene );
				nodeBuilder.clippingContext = renderObject.clippingContext;
				nodeBuilder.build();

				nodeBuilderState = this._createNodeBuilderState( nodeBuilder );

				nodeBuilderCache.set( cacheKey, nodeBuilderState );

			}

			nodeBuilderState.usedTimes ++;

			renderObjectData.nodeBuilderState = nodeBuilderState;

		}

		return nodeBuilderState;

	}

	delete( object ) {

		if ( object.isRenderObject ) {

			const nodeBuilderState = this.get( object ).nodeBuilderState;
			nodeBuilderState.usedTimes --;

			if ( nodeBuilderState.usedTimes === 0 ) {

				this.nodeBuilderCache.delete( this.getForRenderCacheKey( object ) );

			}

		}

		return super.delete( object );

	}

	getForCompute( computeNode ) {

		const computeData = this.get( computeNode );

		let nodeBuilderState = computeData.nodeBuilderState;

		if ( nodeBuilderState === undefined ) {

			const nodeBuilder = this.backend.createNodeBuilder( computeNode, this.renderer );
			nodeBuilder.build();

			nodeBuilderState = this._createNodeBuilderState( nodeBuilder );

			computeData.nodeBuilderState = nodeBuilderState;

		}

		return nodeBuilderState;

	}

	_createNodeBuilderState( nodeBuilder ) {

		return new NodeBuilderState(
			nodeBuilder.vertexShader,
			nodeBuilder.fragmentShader,
			nodeBuilder.computeShader,
			nodeBuilder.getAttributesArray(),
			nodeBuilder.getBindings(),
			nodeBuilder.updateNodes,
			nodeBuilder.updateBeforeNodes,
			nodeBuilder.updateAfterNodes,
			nodeBuilder.monitor,
			nodeBuilder.transforms
		);

	}

	getEnvironmentNode( scene ) {

		return scene.environmentNode || this.get( scene ).environmentNode || null;

	}

	getBackgroundNode( scene ) {

		return scene.backgroundNode || this.get( scene ).backgroundNode || null;

	}

	getFogNode( scene ) {

		return scene.fogNode || this.get( scene ).fogNode || null;

	}

	getCacheKey( scene, lightsNode ) {

		const chain = [ scene, lightsNode ];
		const callId = this.renderer.info.calls;

		let cacheKeyData = this.callHashCache.get( chain );

		if ( cacheKeyData === undefined || cacheKeyData.callId !== callId ) {

			const environmentNode = this.getEnvironmentNode( scene );
			const fogNode = this.getFogNode( scene );

			const values = [];

			if ( lightsNode ) values.push( lightsNode.getCacheKey( true ) );
			if ( environmentNode ) values.push( environmentNode.getCacheKey() );
			if ( fogNode ) values.push( fogNode.getCacheKey() );

			values.push( this.renderer.shadowMap.enabled ? 1 : 0 );

			cacheKeyData = {
				callId,
				cacheKey: hashArray( values )
			};

			this.callHashCache.set( chain, cacheKeyData );

		}

		return cacheKeyData.cacheKey;

	}

	updateScene( scene ) {

		this.updateEnvironment( scene );
		this.updateFog( scene );
		this.updateBackground( scene );

	}

	get isToneMappingState() {

		return this.renderer.getRenderTarget() ? false : true;

	}

	updateBackground( scene ) {

		const sceneData = this.get( scene );
		const background = scene.background;

		if ( background ) {

			const forceUpdate = ( scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 ) || ( scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0 );

			if ( sceneData.background !== background || forceUpdate ) {

				let backgroundNode = null;

				if ( background.isCubeTexture === true || ( background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping ) ) {

					if ( scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping ) {

						backgroundNode = pmremTexture( background );

					} else {

						let envMap;

						if ( background.isCubeTexture === true ) {

							envMap = cubeTexture( background );

						} else {

							envMap = texture( background );

						}

						backgroundNode = cubeMapNode( envMap );

					}

				} else if ( background.isTexture === true ) {

					backgroundNode = texture( background, screenUV.flipY() ).setUpdateMatrix( true );

				} else if ( background.isColor !== true ) {

					console.error( 'WebGPUNodes: Unsupported background configuration.', background );

				}

				sceneData.backgroundNode = backgroundNode;
				sceneData.background = background;
				sceneData.backgroundBlurriness = scene.backgroundBlurriness;

			}

		} else if ( sceneData.backgroundNode ) {

			delete sceneData.backgroundNode;
			delete sceneData.background;

		}

	}

	updateFog( scene ) {

		const sceneData = this.get( scene );
		const fog = scene.fog;

		if ( fog ) {

			if ( sceneData.fog !== fog ) {

				let fogNode = null;

				if ( fog.isFogExp2 ) {

					const color = reference( 'color', 'color', fog ).setGroup( renderGroup );
					const density = reference( 'density', 'float', fog ).setGroup( renderGroup );

					fogNode = densityFog( color, density );

				} else if ( fog.isFog ) {

					const color = reference( 'color', 'color', fog ).setGroup( renderGroup );
					const near = reference( 'near', 'float', fog ).setGroup( renderGroup );
					const far = reference( 'far', 'float', fog ).setGroup( renderGroup );

					fogNode = rangeFog( color, near, far );

				} else {

					console.error( 'WebGPUNodes: Unsupported fog configuration.', fog );

				}

				sceneData.fogNode = fogNode;
				sceneData.fog = fog;

			}

		} else {

			delete sceneData.fogNode;
			delete sceneData.fog;

		}

	}

	updateEnvironment( scene ) {

		const sceneData = this.get( scene );
		const environment = scene.environment;

		if ( environment ) {

			if ( sceneData.environment !== environment ) {

				let environmentNode = null;

				if ( environment.isCubeTexture === true ) {

					environmentNode = cubeTexture( environment );

				} else if ( environment.isTexture === true ) {

					environmentNode = texture( environment );

				} else {

					console.error( 'Nodes: Unsupported environment configuration.', environment );

				}

				sceneData.environmentNode = environmentNode;
				sceneData.environment = environment;

			}

		} else if ( sceneData.environmentNode ) {

			delete sceneData.environmentNode;
			delete sceneData.environment;

		}

	}

	getNodeFrame( renderer = this.renderer, scene = null, object = null, camera = null, material = null ) {

		const nodeFrame = this.nodeFrame;
		nodeFrame.renderer = renderer;
		nodeFrame.scene = scene;
		nodeFrame.object = object;
		nodeFrame.camera = camera;
		nodeFrame.material = material;

		return nodeFrame;

	}

	getNodeFrameForRender( renderObject ) {

		return this.getNodeFrame( renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material );

	}

	getOutputCacheKey() {

		const renderer = this.renderer;

		return renderer.toneMapping + ',' + renderer.currentColorSpace;

	}

	hasOutputChange( outputTarget ) {

		const cacheKey = outputNodeMap.get( outputTarget );

		return cacheKey !== this.getOutputCacheKey();

	}

	getOutputNode( outputTexture ) {

		const renderer = this.renderer;
		const cacheKey = this.getOutputCacheKey();

		const output = texture( outputTexture, screenUV ).renderOutput( renderer.toneMapping, renderer.currentColorSpace );

		outputNodeMap.set( outputTexture, cacheKey );

		return output;

	}

	updateBefore( renderObject ) {

		const nodeBuilder = renderObject.getNodeBuilderState();

		for ( const node of nodeBuilder.updateBeforeNodes ) {

			// update frame state for each node

			this.getNodeFrameForRender( renderObject ).updateBeforeNode( node );

		}

	}

	updateAfter( renderObject ) {

		const nodeBuilder = renderObject.getNodeBuilderState();

		for ( const node of nodeBuilder.updateAfterNodes ) {

			// update frame state for each node

			this.getNodeFrameForRender( renderObject ).updateAfterNode( node );

		}

	}

	updateForCompute( computeNode ) {

		const nodeFrame = this.getNodeFrame();
		const nodeBuilder = this.getForCompute( computeNode );

		for ( const node of nodeBuilder.updateNodes ) {

			nodeFrame.updateNode( node );

		}

	}

	updateForRender( renderObject ) {

		const nodeFrame = this.getNodeFrameForRender( renderObject );
		const nodeBuilder = renderObject.getNodeBuilderState();

		for ( const node of nodeBuilder.updateNodes ) {

			nodeFrame.updateNode( node );

		}

	}

	needsRefresh( renderObject ) {

		const nodeFrame = this.getNodeFrameForRender( renderObject );
		const monitor = renderObject.getMonitor();

		return monitor.needsRefresh( renderObject, nodeFrame );

	}

	dispose() {

		super.dispose();

		this.nodeFrame = new NodeFrame();
		this.nodeBuilderCache = new Map();

	}

}

const _plane = /*@__PURE__*/ new Plane();

class ClippingContext {

	constructor( parentContext = null ) {

		this.version = 0;

		this.clipIntersection = null;
		this.cacheKey = '';


		if ( parentContext === null ) {

			this.intersectionPlanes = [];
			this.unionPlanes = [];

			this.viewNormalMatrix = new Matrix3();
			this.clippingGroupContexts = new WeakMap();

			this.shadowPass = false;

		} else {

			this.viewNormalMatrix = parentContext.viewNormalMatrix;
			this.clippingGroupContexts = parentContext.clippingGroupContexts;

			this.shadowPass = parentContext.shadowPass;

			this.viewMatrix = parentContext.viewMatrix;

		}

		this.parentVersion = null;

	}

	projectPlanes( source, destination, offset ) {

		const l = source.length;

		for ( let i = 0; i < l; i ++ ) {

			_plane.copy( source[ i ] ).applyMatrix4( this.viewMatrix, this.viewNormalMatrix );

			const v = destination[ offset + i ];
			const normal = _plane.normal;

			v.x = - normal.x;
			v.y = - normal.y;
			v.z = - normal.z;
			v.w = _plane.constant;

		}

	}

	updateGlobal( scene, camera ) {

		this.shadowPass = ( scene.overrideMaterial !== null && scene.overrideMaterial.isShadowNodeMaterial );
		this.viewMatrix = camera.matrixWorldInverse;

		this.viewNormalMatrix.getNormalMatrix( this.viewMatrix );

	}

	update( parentContext, clippingGroup ) {

		let update = false;

		if ( parentContext.version !== this.parentVersion ) {

			this.intersectionPlanes = Array.from( parentContext.intersectionPlanes );
			this.unionPlanes = Array.from( parentContext.unionPlanes );
			this.parentVersion = parentContext.version;

		}

		if ( this.clipIntersection !== clippingGroup.clipIntersection ) {

			this.clipIntersection = clippingGroup.clipIntersection;

			if ( this.clipIntersection ) {

				this.unionPlanes.length = parentContext.unionPlanes.length;

			} else {

				this.intersectionPlanes.length = parentContext.intersectionPlanes.length;

			}

		}

		const srcClippingPlanes = clippingGroup.clippingPlanes;
		const l = srcClippingPlanes.length;

		let dstClippingPlanes;
		let offset;

		if ( this.clipIntersection ) {

			dstClippingPlanes = this.intersectionPlanes;
			offset = parentContext.intersectionPlanes.length;

		} else {

			dstClippingPlanes = this.unionPlanes;
			offset = parentContext.unionPlanes.length;

		}

		if ( dstClippingPlanes.length !== offset + l ) {

			dstClippingPlanes.length = offset + l;

			for ( let i = 0; i < l; i ++ ) {

				dstClippingPlanes[ offset + i ] = new Vector4();

			}

			update = true;

		}

		this.projectPlanes( srcClippingPlanes, dstClippingPlanes, offset );

		if ( update ) {

			this.version ++;
			this.cacheKey = `${ this.intersectionPlanes.length }:${ this.unionPlanes.length }`;

		}

	}

	getGroupContext( clippingGroup ) {

		if ( this.shadowPass && ! clippingGroup.clipShadows ) return this;

		let context = this.clippingGroupContexts.get( clippingGroup );

		if ( context === undefined ) {

			context = new ClippingContext( this );
			this.clippingGroupContexts.set( clippingGroup, context );

		}

		context.update( this, clippingGroup );

		return context;

	}

	get unionClippingCount() {

		return this.unionPlanes.length;

	}

}

class RenderBundle {

	constructor( scene, camera ) {

		this.scene = scene;
		this.camera = camera;

	}

	clone() {

		return Object.assign( new this.constructor(), this );

	}

}

class RenderBundles {

	constructor() {

		this.lists = new ChainMap();

	}

	get( scene, camera ) {

		const lists = this.lists;
		const keys = [ scene, camera ];

		let list = lists.get( keys );

		if ( list === undefined ) {

			list = new RenderBundle( scene, camera );
			lists.set( keys, list );

		}

		return list;

	}

	dispose() {

		this.lists = new ChainMap();

	}

}

class NodeLibrary {

	constructor() {

		this.lightNodes = new WeakMap();
		this.materialNodes = new Map();
		this.toneMappingNodes = new Map();

	}

	fromMaterial( material ) {

		if ( material.isNodeMaterial ) return material;

		let nodeMaterial = null;

		const nodeMaterialClass = this.getMaterialNodeClass( material.type );

		if ( nodeMaterialClass !== null ) {

			nodeMaterial = new nodeMaterialClass();

			for ( const key in material ) {

				nodeMaterial[ key ] = material[ key ];

			}

		}

		return nodeMaterial;

	}

	addToneMapping( toneMappingNode, toneMapping ) {

		this.addType( toneMappingNode, toneMapping, this.toneMappingNodes );

	}

	getToneMappingFunction( toneMapping ) {

		return this.toneMappingNodes.get( toneMapping ) || null;

	}

	getMaterialNodeClass( materialType ) {

		return this.materialNodes.get( materialType ) || null;

	}

	addMaterial( materialNodeClass, materialClassType ) {

		this.addType( materialNodeClass, materialClassType, this.materialNodes );

	}

	getLightNodeClass( light ) {

		return this.lightNodes.get( light ) || null;

	}

	addLight( lightNodeClass, lightClass ) {

		this.addClass( lightNodeClass, lightClass, this.lightNodes );

	}

	addType( nodeClass, type, library ) {

		if ( library.has( type ) ) {

			console.warn( `Redefinition of node ${ type }` );
			return;

		}

		if ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );
		if ( typeof type === 'function' || typeof type === 'object' ) throw new Error( `Base class ${ type } is not a class.` );

		library.set( type, nodeClass );

	}

	addClass( nodeClass, baseClass, library ) {

		if ( library.has( baseClass ) ) {

			console.warn( `Redefinition of node ${ baseClass.name }` );
			return;

		}

		if ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );
		if ( typeof baseClass !== 'function' ) throw new Error( `Base class ${ baseClass.name } is not a class.` );

		library.set( baseClass, nodeClass );

	}

}

const _defaultLights = /*@__PURE__*/ new LightsNode();

class Lighting extends ChainMap {

	constructor() {

		super();

	}

	createNode( lights = [] ) {

		return new LightsNode().setLights( lights );

	}

	getNode( scene, camera ) {

		// ignore post-processing

		if ( scene.isQuadMesh ) return _defaultLights;

		// tiled lighting

		const keys = [ scene, camera ];

		let node = this.get( keys );

		if ( node === undefined ) {

			node = this.createNode();
			this.set( keys, node );

		}

		return node;

	}

}

const _scene = /*@__PURE__*/ new Scene();
const _drawingBufferSize = /*@__PURE__*/ new Vector2();
const _screen = /*@__PURE__*/ new Vector4();
const _frustum = /*@__PURE__*/ new Frustum();
const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _vector4 = /*@__PURE__*/ new Vector4();

class Renderer {

	constructor( backend, parameters = {} ) {

		this.isRenderer = true;

		//

		const {
			logarithmicDepthBuffer = false,
			alpha = true,
			depth = true,
			stencil = false,
			antialias = false,
			samples = 0,
			getFallback = null
		} = parameters;

		// public
		this.domElement = backend.getDomElement();

		this.backend = backend;

		this.samples = samples || ( antialias === true ) ? 4 : 0;

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		this.alpha = alpha;

		this.logarithmicDepthBuffer = logarithmicDepthBuffer;

		this.outputColorSpace = SRGBColorSpace;

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0;

		this.sortObjects = true;

		this.depth = depth;
		this.stencil = stencil;

		this.info = new Info();

		this.nodes = {
			modelViewMatrix: null,
			modelNormalViewMatrix: null
		};

		this.library = new NodeLibrary();
		this.lighting = new Lighting();

		// internals

		this._getFallback = getFallback;

		this._pixelRatio = 1;
		this._width = this.domElement.width;
		this._height = this.domElement.height;

		this._viewport = new Vector4( 0, 0, this._width, this._height );
		this._scissor = new Vector4( 0, 0, this._width, this._height );
		this._scissorTest = false;

		this._attributes = null;
		this._geometries = null;
		this._nodes = null;
		this._animation = null;
		this._bindings = null;
		this._objects = null;
		this._pipelines = null;
		this._bundles = null;
		this._renderLists = null;
		this._renderContexts = null;
		this._textures = null;
		this._background = null;

		this._quad = new QuadMesh( new NodeMaterial() );
		this._quad.material.type = 'Renderer_output';

		this._currentRenderContext = null;

		this._opaqueSort = null;
		this._transparentSort = null;

		this._frameBufferTarget = null;

		const alphaClear = this.alpha === true ? 0 : 1;

		this._clearColor = new Color4( 0, 0, 0, alphaClear );
		this._clearDepth = 1;
		this._clearStencil = 0;

		this._renderTarget = null;
		this._activeCubeFace = 0;
		this._activeMipmapLevel = 0;

		this._mrt = null;

		this._renderObjectFunction = null;
		this._currentRenderObjectFunction = null;
		this._currentRenderBundle = null;

		this._handleObjectFunction = this._renderObjectDirect;

		this._isDeviceLost = false;
		this.onDeviceLost = this._onDeviceLost;

		this._initialized = false;
		this._initPromise = null;

		this._compilationPromises = null;

		this.transparent = true;
		this.opaque = true;

		this.shadowMap = {
			enabled: false,
			type: PCFShadowMap
		};

		this.xr = {
			enabled: false
		};

		this.debug = {
			checkShaderErrors: true,
			onShaderError: null,
			getShaderAsync: async ( scene, camera, object ) => {

				await this.compileAsync( scene, camera );

				const renderList = this._renderLists.get( scene, camera );
				const renderContext = this._renderContexts.get( scene, camera, this._renderTarget );

				const material = scene.overrideMaterial || object.material;

				const renderObject = this._objects.get( object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext );

				const { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();

				return { fragmentShader, vertexShader };

			}
		};

	}

	async init() {

		if ( this._initialized ) {

			throw new Error( 'Renderer: Backend has already been initialized.' );

		}

		if ( this._initPromise !== null ) {

			return this._initPromise;

		}

		this._initPromise = new Promise( async ( resolve, reject ) => {

			let backend = this.backend;

			try {

				await backend.init( this );

			} catch ( error ) {

				if ( this._getFallback !== null ) {

					// try the fallback

					try {

						this.backend = backend = this._getFallback( error );
						await backend.init( this );

					} catch ( error ) {

						reject( error );
						return;

					}

				} else {

					reject( error );
					return;

				}

			}

			this._nodes = new Nodes( this, backend );
			this._animation = new Animation( this._nodes, this.info );
			this._attributes = new Attributes( backend );
			this._background = new Background( this, this._nodes );
			this._geometries = new Geometries( this._attributes, this.info );
			this._textures = new Textures( this, backend, this.info );
			this._pipelines = new Pipelines( backend, this._nodes );
			this._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info );
			this._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info );
			this._renderLists = new RenderLists( this.lighting );
			this._bundles = new RenderBundles();
			this._renderContexts = new RenderContexts();

			//

			this._animation.start();
			this._initialized = true;

			resolve();

		} );

		return this._initPromise;

	}

	get coordinateSystem() {

		return this.backend.coordinateSystem;

	}

	async compileAsync( scene, camera, targetScene = null ) {

		if ( this._isDeviceLost === true ) return;

		if ( this._initialized === false ) await this.init();

		// preserve render tree

		const nodeFrame = this._nodes.nodeFrame;

		const previousRenderId = nodeFrame.renderId;
		const previousRenderContext = this._currentRenderContext;
		const previousRenderObjectFunction = this._currentRenderObjectFunction;
		const previousCompilationPromises = this._compilationPromises;

		//

		const sceneRef = ( scene.isScene === true ) ? scene : _scene;

		if ( targetScene === null ) targetScene = scene;

		const renderTarget = this._renderTarget;
		const renderContext = this._renderContexts.get( targetScene, camera, renderTarget );
		const activeMipmapLevel = this._activeMipmapLevel;

		const compilationPromises = [];

		this._currentRenderContext = renderContext;
		this._currentRenderObjectFunction = this.renderObject;

		this._handleObjectFunction = this._createObjectPipeline;

		this._compilationPromises = compilationPromises;

		nodeFrame.renderId ++;

		//

		nodeFrame.update();

		//

		renderContext.depth = this.depth;
		renderContext.stencil = this.stencil;

		if ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();
		renderContext.clippingContext.updateGlobal( sceneRef, camera );

		//

		sceneRef.onBeforeRender( this, scene, camera, renderTarget );

		//

		const renderList = this._renderLists.get( scene, camera );
		renderList.begin();

		this._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );

		// include lights from target scene
		if ( targetScene !== scene ) {

			targetScene.traverseVisible( function ( object ) {

				if ( object.isLight && object.layers.test( camera.layers ) ) {

					renderList.pushLight( object );

				}

			} );

		}

		renderList.finish();

		//

		if ( renderTarget !== null ) {

			this._textures.updateRenderTarget( renderTarget, activeMipmapLevel );

			const renderTargetData = this._textures.get( renderTarget );

			renderContext.textures = renderTargetData.textures;
			renderContext.depthTexture = renderTargetData.depthTexture;

		} else {

			renderContext.textures = null;
			renderContext.depthTexture = null;

		}

		//

		this._nodes.updateScene( sceneRef );

		//

		this._background.update( sceneRef, renderList, renderContext );

		// process render lists

		const opaqueObjects = renderList.opaque;
		const transparentObjects = renderList.transparent;
		const transparentDoublePassObjects = renderList.transparentDoublePass;
		const lightsNode = renderList.lightsNode;

		if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );
		if ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );

		// restore render tree

		nodeFrame.renderId = previousRenderId;

		this._currentRenderContext = previousRenderContext;
		this._currentRenderObjectFunction = previousRenderObjectFunction;
		this._compilationPromises = previousCompilationPromises;

		this._handleObjectFunction = this._renderObjectDirect;

		// wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete

		await Promise.all( compilationPromises );

	}

	async renderAsync( scene, camera ) {

		if ( this._initialized === false ) await this.init();

		const renderContext = this._renderScene( scene, camera );

		await this.backend.resolveTimestampAsync( renderContext, 'render' );

	}

	async waitForGPU() {

		await this.backend.waitForGPU();

	}

	setMRT( mrt ) {

		this._mrt = mrt;

		return this;

	}

	getMRT() {

		return this._mrt;

	}

	_onDeviceLost( info ) {

		let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\n\nMessage: ${info.message}`;

		if ( info.reason ) {

			errorMessage += `\nReason: ${info.reason}`;

		}

		console.error( errorMessage );

		this._isDeviceLost = true;

	}


	_renderBundle( bundle, sceneRef, lightsNode ) {

		const { bundleGroup, camera, renderList } = bundle;

		const renderContext = this._currentRenderContext;

		//

		const renderBundle = this._bundles.get( bundleGroup, camera );
		const renderBundleData = this.backend.get( renderBundle );

		if ( renderBundleData.renderContexts === undefined ) renderBundleData.renderContexts = new Set();

		//

		const needsUpdate = bundleGroup.version !== renderBundleData.version;
		const renderBundleNeedsUpdate = renderBundleData.renderContexts.has( renderContext ) === false || needsUpdate;

		renderBundleData.renderContexts.add( renderContext );

		if ( renderBundleNeedsUpdate ) {

			this.backend.beginBundle( renderContext );

			if ( renderBundleData.renderObjects === undefined || needsUpdate ) {

				renderBundleData.renderObjects = [];

			}

			this._currentRenderBundle = renderBundle;

			const opaqueObjects = renderList.opaque;

			if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );

			this._currentRenderBundle = null;

			//

			this.backend.finishBundle( renderContext, renderBundle );

			renderBundleData.version = bundleGroup.version;

		} else {

			const { renderObjects } = renderBundleData;

			for ( let i = 0, l = renderObjects.length; i < l; i ++ ) {

				const renderObject = renderObjects[ i ];

				if ( this._nodes.needsRefresh( renderObject ) ) {

					this._nodes.updateBefore( renderObject );

					this._nodes.updateForRender( renderObject );
					this._bindings.updateForRender( renderObject );

					this._nodes.updateAfter( renderObject );

				}

			}

		}

		this.backend.addBundle( renderContext, renderBundle );

	}

	render( scene, camera ) {

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.' );

			return this.renderAsync( scene, camera );

		}

		this._renderScene( scene, camera );

	}

	_getFrameBufferTarget() {

		const { currentToneMapping, currentColorSpace } = this;

		const useToneMapping = currentToneMapping !== NoToneMapping;
		const useColorSpace = currentColorSpace !== LinearSRGBColorSpace;

		if ( useToneMapping === false && useColorSpace === false ) return null;

		const { width, height } = this.getDrawingBufferSize( _drawingBufferSize );
		const { depth, stencil } = this;

		let frameBufferTarget = this._frameBufferTarget;

		if ( frameBufferTarget === null ) {

			frameBufferTarget = new RenderTarget( width, height, {
				depthBuffer: depth,
				stencilBuffer: stencil,
				type: HalfFloatType, // FloatType
				format: RGBAFormat,
				colorSpace: LinearSRGBColorSpace,
				generateMipmaps: false,
				minFilter: LinearFilter,
				magFilter: LinearFilter,
				samples: this.samples
			} );

			frameBufferTarget.isPostProcessingRenderTarget = true;

			this._frameBufferTarget = frameBufferTarget;

		}

		frameBufferTarget.depthBuffer = depth;
		frameBufferTarget.stencilBuffer = stencil;
		frameBufferTarget.setSize( width, height );
		frameBufferTarget.viewport.copy( this._viewport );
		frameBufferTarget.scissor.copy( this._scissor );
		frameBufferTarget.viewport.multiplyScalar( this._pixelRatio );
		frameBufferTarget.scissor.multiplyScalar( this._pixelRatio );
		frameBufferTarget.scissorTest = this._scissorTest;

		return frameBufferTarget;

	}

	_renderScene( scene, camera, useFrameBufferTarget = true ) {

		if ( this._isDeviceLost === true ) return;

		const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;

		// preserve render tree

		const nodeFrame = this._nodes.nodeFrame;

		const previousRenderId = nodeFrame.renderId;
		const previousRenderContext = this._currentRenderContext;
		const previousRenderObjectFunction = this._currentRenderObjectFunction;

		//

		const sceneRef = ( scene.isScene === true ) ? scene : _scene;

		const outputRenderTarget = this._renderTarget;

		const activeCubeFace = this._activeCubeFace;
		const activeMipmapLevel = this._activeMipmapLevel;

		//

		let renderTarget;

		if ( frameBufferTarget !== null ) {

			renderTarget = frameBufferTarget;

			this.setRenderTarget( renderTarget );

		} else {

			renderTarget = outputRenderTarget;

		}

		//

		const renderContext = this._renderContexts.get( scene, camera, renderTarget );

		this._currentRenderContext = renderContext;
		this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;

		//

		this.info.calls ++;
		this.info.render.calls ++;
		this.info.render.frameCalls ++;

		nodeFrame.renderId = this.info.calls;

		//

		const coordinateSystem = this.coordinateSystem;

		if ( camera.coordinateSystem !== coordinateSystem ) {

			camera.coordinateSystem = coordinateSystem;

			camera.updateProjectionMatrix();

		}

		//

		if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

		if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

		//

		let viewport = this._viewport;
		let scissor = this._scissor;
		let pixelRatio = this._pixelRatio;

		if ( renderTarget !== null ) {

			viewport = renderTarget.viewport;
			scissor = renderTarget.scissor;
			pixelRatio = 1;

		}

		this.getDrawingBufferSize( _drawingBufferSize );

		_screen.set( 0, 0, _drawingBufferSize.width, _drawingBufferSize.height );

		const minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;
		const maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;

		renderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();
		renderContext.viewportValue.width >>= activeMipmapLevel;
		renderContext.viewportValue.height >>= activeMipmapLevel;
		renderContext.viewportValue.minDepth = minDepth;
		renderContext.viewportValue.maxDepth = maxDepth;
		renderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;

		renderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();
		renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals( _screen ) === false;
		renderContext.scissorValue.width >>= activeMipmapLevel;
		renderContext.scissorValue.height >>= activeMipmapLevel;

		if ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();
		renderContext.clippingContext.updateGlobal( sceneRef, camera );

		//

		sceneRef.onBeforeRender( this, scene, camera, renderTarget );

		//

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromProjectionMatrix( _projScreenMatrix, coordinateSystem );

		const renderList = this._renderLists.get( scene, camera );
		renderList.begin();

		this._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );

		renderList.finish();

		if ( this.sortObjects === true ) {

			renderList.sort( this._opaqueSort, this._transparentSort );

		}

		//

		if ( renderTarget !== null ) {

			this._textures.updateRenderTarget( renderTarget, activeMipmapLevel );

			const renderTargetData = this._textures.get( renderTarget );

			renderContext.textures = renderTargetData.textures;
			renderContext.depthTexture = renderTargetData.depthTexture;
			renderContext.width = renderTargetData.width;
			renderContext.height = renderTargetData.height;
			renderContext.renderTarget = renderTarget;
			renderContext.depth = renderTarget.depthBuffer;
			renderContext.stencil = renderTarget.stencilBuffer;

		} else {

			renderContext.textures = null;
			renderContext.depthTexture = null;
			renderContext.width = this.domElement.width;
			renderContext.height = this.domElement.height;
			renderContext.depth = this.depth;
			renderContext.stencil = this.stencil;

		}

		renderContext.width >>= activeMipmapLevel;
		renderContext.height >>= activeMipmapLevel;
		renderContext.activeCubeFace = activeCubeFace;
		renderContext.activeMipmapLevel = activeMipmapLevel;
		renderContext.occlusionQueryCount = renderList.occlusionQueryCount;

		//

		this._nodes.updateScene( sceneRef );

		//

		this._background.update( sceneRef, renderList, renderContext );

		//

		this.backend.beginRender( renderContext );

		// process render lists

		const {
			bundles,
			lightsNode,
			transparentDoublePass: transparentDoublePassObjects,
			transparent: transparentObjects,
			opaque: opaqueObjects
		} = renderList;

		if ( bundles.length > 0 ) this._renderBundles( bundles, sceneRef, lightsNode );
		if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );
		if ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );

		// finish render pass

		this.backend.finishRender( renderContext );

		// restore render tree

		nodeFrame.renderId = previousRenderId;

		this._currentRenderContext = previousRenderContext;
		this._currentRenderObjectFunction = previousRenderObjectFunction;

		//

		if ( frameBufferTarget !== null ) {

			this.setRenderTarget( outputRenderTarget, activeCubeFace, activeMipmapLevel );

			const quad = this._quad;

			if ( this._nodes.hasOutputChange( renderTarget.texture ) ) {

				quad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );
				quad.material.needsUpdate = true;

			}

			this._renderScene( quad, quad.camera, false );

		}

		//

		sceneRef.onAfterRender( this, scene, camera, renderTarget );

		//

		return renderContext;

	}

	getMaxAnisotropy() {

		return this.backend.getMaxAnisotropy();

	}

	getActiveCubeFace() {

		return this._activeCubeFace;

	}

	getActiveMipmapLevel() {

		return this._activeMipmapLevel;

	}

	async setAnimationLoop( callback ) {

		if ( this._initialized === false ) await this.init();

		this._animation.setAnimationLoop( callback );

	}

	async getArrayBufferAsync( attribute ) {

		return await this.backend.getArrayBufferAsync( attribute );

	}

	getContext() {

		return this.backend.getContext();

	}

	getPixelRatio() {

		return this._pixelRatio;

	}

	getDrawingBufferSize( target ) {

		return target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();

	}

	getSize( target ) {

		return target.set( this._width, this._height );

	}

	setPixelRatio( value = 1 ) {

		if ( this._pixelRatio === value ) return;

		this._pixelRatio = value;

		this.setSize( this._width, this._height, false );

	}

	setDrawingBufferSize( width, height, pixelRatio ) {

		this._width = width;
		this._height = height;

		this._pixelRatio = pixelRatio;

		this.domElement.width = Math.floor( width * pixelRatio );
		this.domElement.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

		if ( this._initialized ) this.backend.updateSize();

	}

	setSize( width, height, updateStyle = true ) {

		this._width = width;
		this._height = height;

		this.domElement.width = Math.floor( width * this._pixelRatio );
		this.domElement.height = Math.floor( height * this._pixelRatio );

		if ( updateStyle === true ) {

			this.domElement.style.width = width + 'px';
			this.domElement.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

		if ( this._initialized ) this.backend.updateSize();

	}

	setOpaqueSort( method ) {

		this._opaqueSort = method;

	}

	setTransparentSort( method ) {

		this._transparentSort = method;

	}

	getScissor( target ) {

		const scissor = this._scissor;

		target.x = scissor.x;
		target.y = scissor.y;
		target.width = scissor.width;
		target.height = scissor.height;

		return target;

	}

	setScissor( x, y, width, height ) {

		const scissor = this._scissor;

		if ( x.isVector4 ) {

			scissor.copy( x );

		} else {

			scissor.set( x, y, width, height );

		}

	}

	getScissorTest() {

		return this._scissorTest;

	}

	setScissorTest( boolean ) {

		this._scissorTest = boolean;

		this.backend.setScissorTest( boolean );

	}

	getViewport( target ) {

		return target.copy( this._viewport );

	}

	setViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {

		const viewport = this._viewport;

		if ( x.isVector4 ) {

			viewport.copy( x );

		} else {

			viewport.set( x, y, width, height );

		}

		viewport.minDepth = minDepth;
		viewport.maxDepth = maxDepth;

	}

	getClearColor( target ) {

		return target.copy( this._clearColor );

	}

	setClearColor( color, alpha = 1 ) {

		this._clearColor.set( color );
		this._clearColor.a = alpha;

	}

	getClearAlpha() {

		return this._clearColor.a;

	}

	setClearAlpha( alpha ) {

		this._clearColor.a = alpha;

	}

	getClearDepth() {

		return this._clearDepth;

	}

	setClearDepth( depth ) {

		this._clearDepth = depth;

	}

	getClearStencil() {

		return this._clearStencil;

	}

	setClearStencil( stencil ) {

		this._clearStencil = stencil;

	}

	isOccluded( object ) {

		const renderContext = this._currentRenderContext;

		return renderContext && this.backend.isOccluded( renderContext, object );

	}

	clear( color = true, depth = true, stencil = true ) {

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.' );

			return this.clearAsync( color, depth, stencil );

		}

		const renderTarget = this._renderTarget || this._getFrameBufferTarget();

		let renderTargetData = null;

		if ( renderTarget !== null ) {

			this._textures.updateRenderTarget( renderTarget );

			renderTargetData = this._textures.get( renderTarget );

		}

		this.backend.clear( color, depth, stencil, renderTargetData );

		if ( renderTarget !== null && this._renderTarget === null ) {

			// If a color space transform or tone mapping is required,
			// the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.

			const quad = this._quad;

			if ( this._nodes.hasOutputChange( renderTarget.texture ) ) {

				quad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );
				quad.material.needsUpdate = true;

			}

			this._renderScene( quad, quad.camera, false );

		}

	}

	clearColor() {

		return this.clear( true, false, false );

	}

	clearDepth() {

		return this.clear( false, true, false );

	}

	clearStencil() {

		return this.clear( false, false, true );

	}

	async clearAsync( color = true, depth = true, stencil = true ) {

		if ( this._initialized === false ) await this.init();

		this.clear( color, depth, stencil );

	}

	clearColorAsync() {

		return this.clearAsync( true, false, false );

	}

	clearDepthAsync() {

		return this.clearAsync( false, true, false );

	}

	clearStencilAsync() {

		return this.clearAsync( false, false, true );

	}

	get currentToneMapping() {

		return this._renderTarget !== null ? NoToneMapping : this.toneMapping;

	}

	get currentColorSpace() {

		return this._renderTarget !== null ? LinearSRGBColorSpace : this.outputColorSpace;

	}

	dispose() {

		this.info.dispose();
		this.backend.dispose();

		this._animation.dispose();
		this._objects.dispose();
		this._pipelines.dispose();
		this._nodes.dispose();
		this._bindings.dispose();
		this._renderLists.dispose();
		this._renderContexts.dispose();
		this._textures.dispose();

		this.setRenderTarget( null );
		this.setAnimationLoop( null );

	}

	setRenderTarget( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		this._renderTarget = renderTarget;
		this._activeCubeFace = activeCubeFace;
		this._activeMipmapLevel = activeMipmapLevel;

	}

	getRenderTarget() {

		return this._renderTarget;

	}

	setRenderObjectFunction( renderObjectFunction ) {

		this._renderObjectFunction = renderObjectFunction;

	}

	getRenderObjectFunction() {

		return this._renderObjectFunction;

	}

	compute( computeNodes ) {

		if ( this.isDeviceLost === true ) return;

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.' );

			return this.computeAsync( computeNodes );

		}

		//

		const nodeFrame = this._nodes.nodeFrame;

		const previousRenderId = nodeFrame.renderId;

		//

		this.info.calls ++;
		this.info.compute.calls ++;
		this.info.compute.frameCalls ++;

		nodeFrame.renderId = this.info.calls;

		//

		const backend = this.backend;
		const pipelines = this._pipelines;
		const bindings = this._bindings;
		const nodes = this._nodes;

		const computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];

		if ( computeList[ 0 ] === undefined || computeList[ 0 ].isComputeNode !== true ) {

			throw new Error( 'THREE.Renderer: .compute() expects a ComputeNode.' );

		}

		backend.beginCompute( computeNodes );

		for ( const computeNode of computeList ) {

			// onInit

			if ( pipelines.has( computeNode ) === false ) {

				const dispose = () => {

					computeNode.removeEventListener( 'dispose', dispose );

					pipelines.delete( computeNode );
					bindings.delete( computeNode );
					nodes.delete( computeNode );

				};

				computeNode.addEventListener( 'dispose', dispose );

				//

				const onInitFn = computeNode.onInitFunction;

				if ( onInitFn !== null ) {

					onInitFn.call( computeNode, { renderer: this } );

				}

			}

			nodes.updateForCompute( computeNode );
			bindings.updateForCompute( computeNode );

			const computeBindings = bindings.getForCompute( computeNode );
			const computePipeline = pipelines.getForCompute( computeNode, computeBindings );

			backend.compute( computeNodes, computeNode, computeBindings, computePipeline );

		}

		backend.finishCompute( computeNodes );

		//

		nodeFrame.renderId = previousRenderId;

	}

	async computeAsync( computeNodes ) {

		if ( this._initialized === false ) await this.init();

		this.compute( computeNodes );

		await this.backend.resolveTimestampAsync( computeNodes, 'compute' );

	}

	async hasFeatureAsync( name ) {

		if ( this._initialized === false ) await this.init();

		return this.backend.hasFeature( name );

	}

	hasFeature( name ) {

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.' );

			return false;

		}

		return this.backend.hasFeature( name );

	}

	hasInitialized() {

		return this._initialized;

	}

	async initTextureAsync( texture ) {

		if ( this._initialized === false ) await this.init();

		this._textures.updateTexture( texture );

	}

	initTexture( texture ) {

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.' );

			return false;

		}

		this._textures.updateTexture( texture );

	}

	copyFramebufferToTexture( framebufferTexture, rectangle = null ) {

		if ( rectangle !== null ) {

			if ( rectangle.isVector2 ) {

				rectangle = _vector4.set( rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height ).floor();

			} else if ( rectangle.isVector4 ) {

				rectangle = _vector4.copy( rectangle ).floor();

			} else {

				console.error( 'THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.' );

				return;

			}

		} else {

			rectangle = _vector4.set( 0, 0, framebufferTexture.image.width, framebufferTexture.image.height );

		}

		//

		let renderContext = this._currentRenderContext;
		let renderTarget;

		if ( renderContext !== null ) {

			renderTarget = renderContext.renderTarget;

		} else {

			renderTarget = this._renderTarget || this._getFrameBufferTarget();

			if ( renderTarget !== null ) {

				this._textures.updateRenderTarget( renderTarget );

				renderContext = this._textures.get( renderTarget );

			}

		}

		//

		this._textures.updateTexture( framebufferTexture, { renderTarget } );

		this.backend.copyFramebufferToTexture( framebufferTexture, renderContext, rectangle );

	}

	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

		this._textures.updateTexture( srcTexture );
		this._textures.updateTexture( dstTexture );

		this.backend.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );

	}

	readRenderTargetPixelsAsync( renderTarget, x, y, width, height, index = 0, faceIndex = 0 ) {

		return this.backend.copyTextureToBuffer( renderTarget.textures[ index ], x, y, width, height, faceIndex );

	}

	_projectObject( object, camera, groupOrder, renderList, clippingContext ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

				if ( object.isClippingGroup && object.enabled ) clippingContext = clippingContext.getGroupContext( object );

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				renderList.pushLight( object );

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( this.sortObjects === true ) {

						_vector4.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );

					}

					const { geometry, material } = object;

					if ( material.visible ) {

						renderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );

					}

				}

			} else if ( object.isLineLoop ) {

				console.error( 'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.' );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					const { geometry, material } = object;

					if ( this.sortObjects === true ) {

						if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

						_vector4
							.copy( geometry.boundingSphere.center )
							.applyMatrix4( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let i = 0, l = groups.length; i < l; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								renderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext );

							}

						}

					} else if ( material.visible ) {

						renderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );

					}

				}

			}

		}

		if ( object.isBundleGroup === true && this.backend.beginBundle !== undefined ) {

			const baseRenderList = renderList;

			// replace render list
			renderList = this._renderLists.get( object, camera );

			renderList.begin();

			baseRenderList.pushBundle( {
				bundleGroup: object,
				camera,
				renderList,
			} );

			renderList.finish();

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this._projectObject( children[ i ], camera, groupOrder, renderList, clippingContext );

		}

	}

	_renderBundles( bundles, sceneRef, lightsNode ) {

		for ( const bundle of bundles ) {

			this._renderBundle( bundle, sceneRef, lightsNode );

		}

	}

	_renderTransparents( renderList, doublePassList, camera, scene, lightsNode ) {

		if ( doublePassList.length > 0 ) {

			// render back side

			for ( const { material } of doublePassList ) {

				material.side = BackSide;

			}

			this._renderObjects( doublePassList, camera, scene, lightsNode, 'backSide' );

			// render front side

			for ( const { material } of doublePassList ) {

				material.side = FrontSide;

			}

			this._renderObjects( renderList, camera, scene, lightsNode );

			// restore

			for ( const { material } of doublePassList ) {

				material.side = DoubleSide;

			}

		} else {

			this._renderObjects( renderList, camera, scene, lightsNode );

		}

	}

	_renderObjects( renderList, camera, scene, lightsNode, passId = null ) {

		// process renderable objects

		for ( let i = 0, il = renderList.length; i < il; i ++ ) {

			const renderItem = renderList[ i ];

			// @TODO: Add support for multiple materials per object. This will require to extract
			// the material from the renderItem object and pass it with its group data to renderObject().

			const { object, geometry, material, group, clippingContext } = renderItem;

			if ( camera.isArrayCamera ) {

				const cameras = camera.cameras;

				for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

					const camera2 = cameras[ j ];

					if ( object.layers.test( camera2.layers ) ) {

						const vp = camera2.viewport;
						const minDepth = ( vp.minDepth === undefined ) ? 0 : vp.minDepth;
						const maxDepth = ( vp.maxDepth === undefined ) ? 1 : vp.maxDepth;

						const viewportValue = this._currentRenderContext.viewportValue;
						viewportValue.copy( vp ).multiplyScalar( this._pixelRatio ).floor();
						viewportValue.minDepth = minDepth;
						viewportValue.maxDepth = maxDepth;

						this.backend.updateViewport( this._currentRenderContext );

						this._currentRenderObjectFunction( object, scene, camera2, geometry, material, group, lightsNode, clippingContext, passId );

					}

				}

			} else {

				this._currentRenderObjectFunction( object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId );

			}

		}

	}

	renderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null ) {

		let overridePositionNode;
		let overrideColorNode;
		let overrideDepthNode;

		//

		object.onBeforeRender( this, scene, camera, geometry, material, group );

		//

		if ( scene.overrideMaterial !== null ) {

			const overrideMaterial = scene.overrideMaterial;

			if ( material.positionNode && material.positionNode.isNode ) {

				overridePositionNode = overrideMaterial.positionNode;
				overrideMaterial.positionNode = material.positionNode;

			}

			overrideMaterial.alphaTest = material.alphaTest;
			overrideMaterial.alphaMap = material.alphaMap;

			if ( overrideMaterial.isShadowNodeMaterial ) {

				overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;

				if ( material.depthNode && material.depthNode.isNode ) {

					overrideDepthNode = overrideMaterial.depthNode;
					overrideMaterial.depthNode = material.depthNode;

				}

				if ( material.castShadowNode && material.castShadowNode.isNode ) {

					overrideColorNode = overrideMaterial.colorNode;
					overrideMaterial.colorNode = material.castShadowNode;

				}

			}

			material = overrideMaterial;

		}

		//

		if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

			material.side = BackSide;
			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, 'backSide' ); // create backSide pass id

			material.side = FrontSide;
			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId ); // use default pass id

			material.side = DoubleSide;

		} else {

			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId );

		}

		//

		if ( overridePositionNode !== undefined ) {

			scene.overrideMaterial.positionNode = overridePositionNode;

		}

		if ( overrideDepthNode !== undefined ) {

			scene.overrideMaterial.depthNode = overrideDepthNode;

		}

		if ( overrideColorNode !== undefined ) {

			scene.overrideMaterial.colorNode = overrideColorNode;

		}

		//

		object.onAfterRender( this, scene, camera, geometry, material, group );

	}

	_renderObjectDirect( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {

		const renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );
		renderObject.drawRange = object.geometry.drawRange;
		renderObject.group = group;

		//

		const needsRefresh = this._nodes.needsRefresh( renderObject );

		if ( needsRefresh ) {

			this._nodes.updateBefore( renderObject );

			this._geometries.updateForRender( renderObject );

			this._nodes.updateForRender( renderObject );
			this._bindings.updateForRender( renderObject );

		}

		this._pipelines.updateForRender( renderObject );

		//

		if ( this._currentRenderBundle !== null ) {

			const renderBundleData = this.backend.get( this._currentRenderBundle );

			renderBundleData.renderObjects.push( renderObject );

			renderObject.bundle = this._currentRenderBundle.scene;

		}

		this.backend.draw( renderObject, this.info );

		if ( needsRefresh ) this._nodes.updateAfter( renderObject );

	}

	_createObjectPipeline( object, material, scene, camera, lightsNode, clippingContext, passId ) {

		const renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );

		//

		this._nodes.updateBefore( renderObject );

		this._geometries.updateForRender( renderObject );

		this._nodes.updateForRender( renderObject );
		this._bindings.updateForRender( renderObject );

		this._pipelines.getForRender( renderObject, this._compilationPromises );

		this._nodes.updateAfter( renderObject );

	}

	get compile() {

		return this.compileAsync;

	}

}

class Binding {

	constructor( name = '' ) {

		this.name = name;

		this.visibility = 0;

	}

	setVisibility( visibility ) {

		this.visibility |= visibility;

	}

	clone() {

		return Object.assign( new this.constructor(), this );

	}

}

function getFloatLength( floatLength ) {

	// ensure chunk size alignment (STD140 layout)

	return floatLength + ( ( GPU_CHUNK_BYTES - ( floatLength % GPU_CHUNK_BYTES ) ) % GPU_CHUNK_BYTES );

}

class Buffer extends Binding {

	constructor( name, buffer = null ) {

		super( name );

		this.isBuffer = true;

		this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;

		this._buffer = buffer;

	}

	get byteLength() {

		return getFloatLength( this._buffer.byteLength );

	}

	get buffer() {

		return this._buffer;

	}

	update() {

		return true;

	}

}

class UniformBuffer extends Buffer {

	constructor( name, buffer = null ) {

		super( name, buffer );

		this.isUniformBuffer = true;

	}

}

let _id$4 = 0;

class NodeUniformBuffer extends UniformBuffer {

	constructor( nodeUniform, groupNode ) {

		super( 'UniformBuffer_' + _id$4 ++, nodeUniform ? nodeUniform.value : null );

		this.nodeUniform = nodeUniform;
		this.groupNode = groupNode;

	}

	get buffer() {

		return this.nodeUniform.value;

	}

}

class UniformsGroup extends UniformBuffer {

	constructor( name ) {

		super( name );

		this.isUniformsGroup = true;

		this._values = null;

		// the order of uniforms in this array must match the order of uniforms in the shader

		this.uniforms = [];

	}

	addUniform( uniform ) {

		this.uniforms.push( uniform );

		return this;

	}

	removeUniform( uniform ) {

		const index = this.uniforms.indexOf( uniform );

		if ( index !== - 1 ) {

			this.uniforms.splice( index, 1 );

		}

		return this;

	}

	get values() {

		if ( this._values === null ) {

			this._values = Array.from( this.buffer );

		}

		return this._values;

	}

	get buffer() {

		let buffer = this._buffer;

		if ( buffer === null ) {

			const byteLength = this.byteLength;

			buffer = new Float32Array( new ArrayBuffer( byteLength ) );

			this._buffer = buffer;

		}

		return buffer;

	}

	get byteLength() {

		let offset = 0; // global buffer offset in bytes

		for ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {

			const uniform = this.uniforms[ i ];

			const { boundary, itemSize } = uniform;

			// offset within a single chunk in bytes

			const chunkOffset = offset % GPU_CHUNK_BYTES;
			const remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;

			// conformance tests

			if ( chunkOffset !== 0 && ( remainingSizeInChunk - boundary ) < 0 ) {

				// check for chunk overflow

				offset += ( GPU_CHUNK_BYTES - chunkOffset );

			} else if ( chunkOffset % boundary !== 0 ) {

				// check for correct alignment

				offset += ( chunkOffset % boundary );

			}

			uniform.offset = ( offset / this.bytesPerElement );

			offset += ( itemSize * this.bytesPerElement );

		}

		return Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;

	}

	update() {

		let updated = false;

		for ( const uniform of this.uniforms ) {

			if ( this.updateByType( uniform ) === true ) {

				updated = true;

			}

		}

		return updated;

	}

	updateByType( uniform ) {

		if ( uniform.isNumberUniform ) return this.updateNumber( uniform );
		if ( uniform.isVector2Uniform ) return this.updateVector2( uniform );
		if ( uniform.isVector3Uniform ) return this.updateVector3( uniform );
		if ( uniform.isVector4Uniform ) return this.updateVector4( uniform );
		if ( uniform.isColorUniform ) return this.updateColor( uniform );
		if ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );
		if ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );

		console.error( 'THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform );

	}

	updateNumber( uniform ) {

		let updated = false;

		const a = this.values;
		const v = uniform.getValue();
		const offset = uniform.offset;
		const type = uniform.getType();

		if ( a[ offset ] !== v ) {

			const b = this._getBufferForType( type );

			b[ offset ] = a[ offset ] = v;
			updated = true;

		}

		return updated;

	}

	updateVector2( uniform ) {

		let updated = false;

		const a = this.values;
		const v = uniform.getValue();
		const offset = uniform.offset;
		const type = uniform.getType();

		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {

			const b = this._getBufferForType( type );

			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
			b[ offset + 1 ] = a[ offset + 1 ] = v.y;

			updated = true;

		}

		return updated;

	}

	updateVector3( uniform ) {

		let updated = false;

		const a = this.values;
		const v = uniform.getValue();
		const offset = uniform.offset;
		const type = uniform.getType();

		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {

			const b = this._getBufferForType( type );

			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
			b[ offset + 1 ] = a[ offset + 1 ] = v.y;
			b[ offset + 2 ] = a[ offset + 2 ] = v.z;

			updated = true;

		}

		return updated;

	}

	updateVector4( uniform ) {

		let updated = false;

		const a = this.values;
		const v = uniform.getValue();
		const offset = uniform.offset;
		const type = uniform.getType();

		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {

			const b = this._getBufferForType( type );

			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
			b[ offset + 1 ] = a[ offset + 1 ] = v.y;
			b[ offset + 2 ] = a[ offset + 2 ] = v.z;
			b[ offset + 3 ] = a[ offset + 3 ] = v.w;

			updated = true;

		}

		return updated;

	}

	updateColor( uniform ) {

		let updated = false;

		const a = this.values;
		const c = uniform.getValue();
		const offset = uniform.offset;

		if ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {

			const b = this.buffer;

			b[ offset + 0 ] = a[ offset + 0 ] = c.r;
			b[ offset + 1 ] = a[ offset + 1 ] = c.g;
			b[ offset + 2 ] = a[ offset + 2 ] = c.b;

			updated = true;

		}

		return updated;

	}

	updateMatrix3( uniform ) {

		let updated = false;

		const a = this.values;
		const e = uniform.getValue().elements;
		const offset = uniform.offset;

		if ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||
			a[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||
			a[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {

			const b = this.buffer;

			b[ offset + 0 ] = a[ offset + 0 ] = e[ 0 ];
			b[ offset + 1 ] = a[ offset + 1 ] = e[ 1 ];
			b[ offset + 2 ] = a[ offset + 2 ] = e[ 2 ];
			b[ offset + 4 ] = a[ offset + 4 ] = e[ 3 ];
			b[ offset + 5 ] = a[ offset + 5 ] = e[ 4 ];
			b[ offset + 6 ] = a[ offset + 6 ] = e[ 5 ];
			b[ offset + 8 ] = a[ offset + 8 ] = e[ 6 ];
			b[ offset + 9 ] = a[ offset + 9 ] = e[ 7 ];
			b[ offset + 10 ] = a[ offset + 10 ] = e[ 8 ];

			updated = true;

		}

		return updated;

	}

	updateMatrix4( uniform ) {

		let updated = false;

		const a = this.values;
		const e = uniform.getValue().elements;
		const offset = uniform.offset;

		if ( arraysEqual( a, e, offset ) === false ) {

			const b = this.buffer;
			b.set( e, offset );
			setArray( a, e, offset );
			updated = true;

		}

		return updated;

	}

	_getBufferForType( type ) {

		if ( type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4' ) return new Int32Array( this.buffer.buffer );
		if ( type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4' ) return new Uint32Array( this.buffer.buffer );
		return this.buffer;

	}

}

function setArray( a, b, offset ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ offset + i ] = b[ i ];

	}

}

function arraysEqual( a, b, offset ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		if ( a[ offset + i ] !== b[ i ] ) return false;

	}

	return true;

}

let _id$3 = 0;

class NodeUniformsGroup extends UniformsGroup {

	constructor( name, groupNode ) {

		super( name );

		this.id = _id$3 ++;
		this.groupNode = groupNode;

		this.isNodeUniformsGroup = true;

	}

	getNodes() {

		const nodes = [];

		for ( const uniform of this.uniforms ) {

			const node = uniform.nodeUniform.node;

			if ( ! node ) throw new Error( 'NodeUniformsGroup: Uniform has no node.' );

			nodes.push( node );

		}

		return nodes;

	}

}

let _id$2 = 0;

class SampledTexture extends Binding {

	constructor( name, texture ) {

		super( name );

		this.id = _id$2 ++;

		this.texture = texture;
		this.version = texture ? texture.version : 0;
		this.store = false;
		this.generation = null;

		this.isSampledTexture = true;

	}

	needsBindingsUpdate( generation ) {

		const { texture } = this;

		if ( generation !== this.generation ) {

			this.generation = generation;

			return true;

		}

		return texture.isVideoTexture;

	}

	update() {

		const { texture, version } = this;

		if ( version !== texture.version ) {

			this.version = texture.version;

			return true;

		}

		return false;

	}

}

class NodeSampledTexture extends SampledTexture {

	constructor( name, textureNode, groupNode, access = null ) {

		super( name, textureNode ? textureNode.value : null );

		this.textureNode = textureNode;
		this.groupNode = groupNode;

		this.access = access;

	}

	needsBindingsUpdate( generation ) {

		return this.textureNode.value !== this.texture || super.needsBindingsUpdate( generation );

	}

	update() {

		const { textureNode } = this;

		if ( this.texture !== textureNode.value ) {

			this.texture = textureNode.value;

			return true;

		}

		return super.update();

	}

}

class NodeSampledCubeTexture extends NodeSampledTexture {

	constructor( name, textureNode, groupNode, access ) {

		super( name, textureNode, groupNode, access );

		this.isSampledCubeTexture = true;

	}

}

class NodeSampledTexture3D extends NodeSampledTexture {

	constructor( name, textureNode, groupNode, access ) {

		super( name, textureNode, groupNode, access );

		this.isSampledTexture3D = true;

	}

}

const glslMethods = {
	atan2: 'atan',
	textureDimensions: 'textureSize',
	equals: 'equal'
};

const precisionLib = {
	low: 'lowp',
	medium: 'mediump',
	high: 'highp'
};

const supports$1 = {
	swizzleAssign: true,
	storageBuffer: false
};

const defaultPrecisions = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
`;

class GLSLNodeBuilder extends NodeBuilder {

	constructor( object, renderer ) {

		super( object, renderer, new GLSLNodeParser() );

		this.uniformGroups = {};
		this.transforms = [];
		this.extensions = {};
		this.builtins = { vertex: [], fragment: [], compute: [] };

		this.useComparisonMethod = true;

	}

	needsToWorkingColorSpace( texture ) {

		return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;

	}

	getMethod( method ) {

		return glslMethods[ method ] || method;

	}

	getOutputStructName() {

		return '';

	}

	buildFunctionCode( shaderNode ) {

		const layout = shaderNode.layout;
		const flowData = this.flowShaderNode( shaderNode );

		const parameters = [];

		for ( const input of layout.inputs ) {

			parameters.push( this.getType( input.type ) + ' ' + input.name );

		}

		//

		const code = `${ this.getType( layout.type ) } ${ layout.name }( ${ parameters.join( ', ' ) } ) {

	${ flowData.vars }

${ flowData.code }
	return ${ flowData.result };

}`;

		//

		return code;

	}

	setupPBO( storageBufferNode ) {

		const attribute = storageBufferNode.value;

		if ( attribute.pbo === undefined ) {

			const originalArray = attribute.array;
			const numElements = attribute.count * attribute.itemSize;

			const { itemSize } = attribute;

			const isInteger = attribute.array.constructor.name.toLowerCase().includes( 'int' );

			let format = isInteger ? RedIntegerFormat : RedFormat;

			if ( itemSize === 2 ) {

				format = isInteger ? RGIntegerFormat : RGFormat;

			} else if ( itemSize === 3 ) {

				format = isInteger ? RGBIntegerFormat : RGBFormat;

			} else if ( itemSize === 4 ) {

				format = isInteger ? RGBAIntegerFormat : RGBAFormat;

			}

			const typeMap = {
				Float32Array: FloatType,
				Uint8Array: UnsignedByteType,
				Uint16Array: UnsignedShortType,
				Uint32Array: UnsignedIntType,
				Int8Array: ByteType,
				Int16Array: ShortType,
				Int32Array: IntType,
				Uint8ClampedArray: UnsignedByteType,
			};

			const width = Math.pow( 2, Math.ceil( Math.log2( Math.sqrt( numElements / itemSize ) ) ) );
			let height = Math.ceil( ( numElements / itemSize ) / width );
			if ( width * height * itemSize < numElements ) height ++; // Ensure enough space

			const newSize = width * height * itemSize;

			const newArray = new originalArray.constructor( newSize );

			newArray.set( originalArray, 0 );

			attribute.array = newArray;

			const pboTexture = new DataTexture( attribute.array, width, height, format, typeMap[ attribute.array.constructor.name ] || FloatType );
			pboTexture.needsUpdate = true;
			pboTexture.isPBOTexture = true;

			const pbo = new TextureNode( pboTexture, null, null );
			pbo.setPrecision( 'high' );

			attribute.pboNode = pbo;
			attribute.pbo = pbo.value;

			this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );

		}

	}

	getPropertyName( node, shaderStage = this.shaderStage ) {

		if ( node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true ) {

			return shaderStage.charAt( 0 ) + '_' + node.name;

		}

		return super.getPropertyName( node, shaderStage );

	}

	generatePBO( storageArrayElementNode ) {

		const { node, indexNode } = storageArrayElementNode;
		const attribute = node.value;

		if ( this.renderer.backend.has( attribute ) ) {

			const attributeData = this.renderer.backend.get( attribute );
			attributeData.pbo = attribute.pbo;

		}

		const nodeUniform = this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );
		const textureName = this.getPropertyName( nodeUniform );

		this.increaseUsage( indexNode ); // force cache generate to be used as index in x,y
		const indexSnippet = indexNode.build( this, 'uint' );

		const elementNodeData = this.getDataFromNode( storageArrayElementNode );

		let propertyName = elementNodeData.propertyName;

		if ( propertyName === undefined ) {

			// property element

			const nodeVar = this.getVarFromNode( storageArrayElementNode );

			propertyName = this.getPropertyName( nodeVar );

			// property size

			const bufferNodeData = this.getDataFromNode( node );

			let propertySizeName = bufferNodeData.propertySizeName;

			if ( propertySizeName === undefined ) {

				propertySizeName = propertyName + 'Size';

				this.getVarFromNode( node, propertySizeName, 'uint' );

				this.addLineFlowCode( `${ propertySizeName } = uint( textureSize( ${ textureName }, 0 ).x )`, storageArrayElementNode );

				bufferNodeData.propertySizeName = propertySizeName;

			}

			//

			const { itemSize } = attribute;

			const channel = '.' + vectorComponents.join( '' ).slice( 0, itemSize );
			const uvSnippet = `ivec2(${indexSnippet} % ${ propertySizeName }, ${indexSnippet} / ${ propertySizeName })`;

			const snippet = this.generateTextureLoad( null, textureName, uvSnippet, null, '0' );

			//


			let prefix = 'vec4';

			if ( attribute.pbo.type === UnsignedIntType ) {

				prefix = 'uvec4';

			} else if ( attribute.pbo.type === IntType ) {

				prefix = 'ivec4';

			}

			this.addLineFlowCode( `${ propertyName } = ${prefix}(${ snippet })${channel}`, storageArrayElementNode );

			elementNodeData.propertyName = propertyName;

		}

		return propertyName;

	}

	generateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0' ) {

		if ( depthSnippet ) {

			return `texelFetch( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet } )`;

		} else {

			return `texelFetch( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;

		}

	}

	generateTexture( texture, textureProperty, uvSnippet, depthSnippet ) {

		if ( texture.isDepthTexture ) {

			return `texture( ${ textureProperty }, ${ uvSnippet } ).x`;

		} else {

			if ( depthSnippet ) uvSnippet = `vec3( ${ uvSnippet }, ${ depthSnippet } )`;

			return `texture( ${ textureProperty }, ${ uvSnippet } )`;

		}

	}

	generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet ) {

		return `textureLod( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet } )`;

	}

	generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet ) {

		return `texture( ${ textureProperty }, ${ uvSnippet }, ${ biasSnippet } )`;

	}

	generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet ) {

		return `textureGrad( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;

	}

	generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			return `texture( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ) )`;

		} else {

			console.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );

		}

	}

	getVars( shaderStage ) {

		const snippets = [];

		const vars = this.vars[ shaderStage ];

		if ( vars !== undefined ) {

			for ( const variable of vars ) {

				snippets.push( `${ this.getVar( variable.type, variable.name ) };` );

			}

		}

		return snippets.join( '\n\t' );

	}

	getUniforms( shaderStage ) {

		const uniforms = this.uniforms[ shaderStage ];

		const bindingSnippets = [];
		const uniformGroups = {};

		for ( const uniform of uniforms ) {

			let snippet = null;
			let group = false;

			if ( uniform.type === 'texture' ) {

				const texture = uniform.node.value;

				let typePrefix = '';

				if ( texture.isDataTexture === true ) {


					if ( texture.type === UnsignedIntType ) {

						typePrefix = 'u';

					} else if ( texture.type === IntType ) {

						typePrefix = 'i';

					}

				}

				if ( texture.compareFunction ) {

					snippet = `sampler2DShadow ${ uniform.name };`;

				} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

					snippet = `${typePrefix}sampler2DArray ${ uniform.name };`;

				} else {

					snippet = `${typePrefix}sampler2D ${ uniform.name };`;

				}

			} else if ( uniform.type === 'cubeTexture' ) {

				snippet = `samplerCube ${ uniform.name };`;

			} else if ( uniform.type === 'texture3D' ) {

				snippet = `sampler3D ${ uniform.name };`;

			} else if ( uniform.type === 'buffer' ) {

				const bufferNode = uniform.node;
				const bufferType = this.getType( bufferNode.bufferType );
				const bufferCount = bufferNode.bufferCount;

				const bufferCountSnippet = bufferCount > 0 ? bufferCount : '';
				snippet = `${bufferNode.name} {\n\t${ bufferType } ${ uniform.name }[${ bufferCountSnippet }];\n};\n`;

			} else {

				const vectorType = this.getVectorType( uniform.type );

				snippet = `${ vectorType } ${ this.getPropertyName( uniform, shaderStage ) };`;

				group = true;

			}

			const precision = uniform.node.precision;

			if ( precision !== null ) {

				snippet = precisionLib[ precision ] + ' ' + snippet;

			}

			if ( group ) {

				snippet = '\t' + snippet;

				const groupName = uniform.groupNode.name;
				const groupSnippets = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = [] );

				groupSnippets.push( snippet );

			} else {

				snippet = 'uniform ' + snippet;

				bindingSnippets.push( snippet );

			}

		}

		let output = '';

		for ( const name in uniformGroups ) {

			const groupSnippets = uniformGroups[ name ];

			output += this._getGLSLUniformStruct( shaderStage + '_' + name, groupSnippets.join( '\n' ) ) + '\n';

		}

		output += bindingSnippets.join( '\n' );

		return output;

	}

	getTypeFromAttribute( attribute ) {

		let nodeType = super.getTypeFromAttribute( attribute );

		if ( /^[iu]/.test( nodeType ) && attribute.gpuType !== IntType ) {

			let dataAttribute = attribute;

			if ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;

			const array = dataAttribute.array;

			if ( ( array instanceof Uint32Array || array instanceof Int32Array ) === false ) {

				nodeType = nodeType.slice( 1 );

			}

		}

		return nodeType;

	}

	getAttributes( shaderStage ) {

		let snippet = '';

		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

			const attributes = this.getAttributesArray();

			let location = 0;

			for ( const attribute of attributes ) {

				snippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\n`;

			}

		}

		return snippet;

	}

	getStructMembers( struct ) {

		const snippets = [];
		const members = struct.getMemberTypes();

		for ( let i = 0; i < members.length; i ++ ) {

			const member = members[ i ];
			snippets.push( `layout( location = ${i} ) out ${ member} m${i};` );

		}

		return snippets.join( '\n' );

	}

	getStructs( shaderStage ) {

		const snippets = [];
		const structs = this.structs[ shaderStage ];

		if ( structs.length === 0 ) {

			return 'layout( location = 0 ) out vec4 fragColor;\n';

		}

		for ( let index = 0, length = structs.length; index < length; index ++ ) {

			const struct = structs[ index ];

			let snippet = '\n';
			snippet += this.getStructMembers( struct );
			snippet += '\n';

			snippets.push( snippet );

		}

		return snippets.join( '\n\n' );

	}

	getVaryings( shaderStage ) {

		let snippet = '';

		const varyings = this.varyings;

		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

			for ( const varying of varyings ) {

				if ( shaderStage === 'compute' ) varying.needsInterpolation = true;
				const type = this.getType( varying.type );
				const flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';

				snippet += `${flat}${varying.needsInterpolation ? 'out' : '/*out*/'} ${type} ${varying.name};\n`;

			}

		} else if ( shaderStage === 'fragment' ) {

			for ( const varying of varyings ) {

				if ( varying.needsInterpolation ) {

					const type = this.getType( varying.type );
					const flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';

					snippet += `${flat}in ${type} ${varying.name};\n`;

				}

			}

		}

		for ( const builtin of this.builtins[ shaderStage ] ) {

			snippet += `${builtin};\n`;

		}

		return snippet;

	}

	getVertexIndex() {

		return 'uint( gl_VertexID )';

	}

	getInstanceIndex() {

		return 'uint( gl_InstanceID )';

	}

	getInvocationLocalIndex() {

		const workgroupSize = this.object.workgroupSize;

		const size = workgroupSize.reduce( ( acc, curr ) => acc * curr, 1 );

		return `uint( gl_InstanceID ) % ${size}u`;

	}

	getDrawIndex() {

		const extensions = this.renderer.backend.extensions;

		if ( extensions.has( 'WEBGL_multi_draw' ) ) {

			return 'uint( gl_DrawID )';

		}

		return null;

	}

	getFrontFacing() {

		return 'gl_FrontFacing';

	}

	getFragCoord() {

		return 'gl_FragCoord.xy';

	}

	getFragDepth() {

		return 'gl_FragDepth';

	}

	enableExtension( name, behavior, shaderStage = this.shaderStage ) {

		const map = this.extensions[ shaderStage ] || ( this.extensions[ shaderStage ] = new Map() );

		if ( map.has( name ) === false ) {

			map.set( name, {
				name,
				behavior
			} );

		}

	}

	getExtensions( shaderStage ) {

		const snippets = [];

		if ( shaderStage === 'vertex' ) {

			const ext = this.renderer.backend.extensions;
			const isBatchedMesh = this.object.isBatchedMesh;

			if ( isBatchedMesh && ext.has( 'WEBGL_multi_draw' ) ) {

				this.enableExtension( 'GL_ANGLE_multi_draw', 'require', shaderStage );

			}

		}

		const extensions = this.extensions[ shaderStage ];

		if ( extensions !== undefined ) {

			for ( const { name, behavior } of extensions.values() ) {

				snippets.push( `#extension ${name} : ${behavior}` );

			}

		}

		return snippets.join( '\n' );

	}

	getClipDistance() {

		return 'gl_ClipDistance';

	}

	isAvailable( name ) {

		let result = supports$1[ name ];

		if ( result === undefined ) {

			let extensionName;

			result = false;

			switch ( name ) {

				case 'float32Filterable':
					extensionName = 'OES_texture_float_linear';
					break;

				case 'clipDistance':
					extensionName = 'WEBGL_clip_cull_distance';
					break;

			}

			if ( extensionName !== undefined ) {

				const extensions = this.renderer.backend.extensions;

				if ( extensions.has( extensionName ) ) {

					extensions.get( extensionName );
					result = true;

				}

			}

			supports$1[ name ] = result;

		}

		return result;

	}

	isFlipY() {

		return true;

	}

	enableHardwareClipping( planeCount ) {

		this.enableExtension( 'GL_ANGLE_clip_cull_distance', 'require' );

		this.builtins[ 'vertex' ].push( `out float gl_ClipDistance[ ${ planeCount } ]` );

	}

	registerTransform( varyingName, attributeNode ) {

		this.transforms.push( { varyingName, attributeNode } );

	}

	getTransforms( /* shaderStage  */ ) {

		const transforms = this.transforms;

		let snippet = '';

		for ( let i = 0; i < transforms.length; i ++ ) {

			const transform = transforms[ i ];

			const attributeName = this.getPropertyName( transform.attributeNode );

			snippet += `${ transform.varyingName } = ${ attributeName };\n\t`;

		}

		return snippet;

	}

	_getGLSLUniformStruct( name, vars ) {

		return `
layout( std140 ) uniform ${name} {
${vars}
};`;

	}

	_getGLSLVertexCode( shaderData ) {

		return `#version 300 es

${ this.getSignature() }

// extensions 
${shaderData.extensions}

// precision
${ defaultPrecisions }

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// attributes
${shaderData.attributes}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// transforms
	${shaderData.transforms}

	// flow
	${shaderData.flow}

	gl_PointSize = 1.0;

}
`;

	}

	_getGLSLFragmentCode( shaderData ) {

		return `#version 300 es

${ this.getSignature() }

// precision
${ defaultPrecisions }

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

${shaderData.structs}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

	}

	buildCode() {

		const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };

		this.sortBindingGroups();

		for ( const shaderStage in shadersData ) {

			let flow = '// code\n\n';
			flow += this.flowCode[ shaderStage ];

			const flowNodes = this.flowNodes[ shaderStage ];
			const mainNode = flowNodes[ flowNodes.length - 1 ];

			for ( const node of flowNodes ) {

				const flowSlotData = this.getFlowData( node/*, shaderStage*/ );
				const slotName = node.name;

				if ( slotName ) {

					if ( flow.length > 0 ) flow += '\n';

					flow += `\t// flow -> ${ slotName }\n\t`;

				}

				flow += `${ flowSlotData.code }\n\t`;

				if ( node === mainNode && shaderStage !== 'compute' ) {

					flow += '// result\n\t';

					if ( shaderStage === 'vertex' ) {

						flow += 'gl_Position = ';
						flow += `${ flowSlotData.result };`;

					} else if ( shaderStage === 'fragment' ) {

						if ( ! node.outputNode.isOutputStructNode ) {

							flow += 'fragColor = ';
							flow += `${ flowSlotData.result };`;

						}

					}

				}

			}

			const stageData = shadersData[ shaderStage ];

			stageData.extensions = this.getExtensions( shaderStage );
			stageData.uniforms = this.getUniforms( shaderStage );
			stageData.attributes = this.getAttributes( shaderStage );
			stageData.varyings = this.getVaryings( shaderStage );
			stageData.vars = this.getVars( shaderStage );
			stageData.structs = this.getStructs( shaderStage );
			stageData.codes = this.getCodes( shaderStage );
			stageData.transforms = this.getTransforms( shaderStage );
			stageData.flow = flow;

		}

		if ( this.material !== null ) {

			this.vertexShader = this._getGLSLVertexCode( shadersData.vertex );
			this.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );

		} else {

			this.computeShader = this._getGLSLVertexCode( shadersData.compute );

		}

	}

	getUniformFromNode( node, type, shaderStage, name = null ) {

		const uniformNode = super.getUniformFromNode( node, type, shaderStage, name );
		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

		let uniformGPU = nodeData.uniformGPU;

		if ( uniformGPU === undefined ) {

			const group = node.groupNode;
			const groupName = group.name;

			const bindings = this.getBindGroupArray( groupName, shaderStage );

			if ( type === 'texture' ) {

				uniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node, group );
				bindings.push( uniformGPU );

			} else if ( type === 'cubeTexture' ) {

				uniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group );
				bindings.push( uniformGPU );

			} else if ( type === 'texture3D' ) {

				uniformGPU = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group );
				bindings.push( uniformGPU );

			} else if ( type === 'buffer' ) {

				node.name = `NodeBuffer_${ node.id }`;
				uniformNode.name = `buffer${ node.id }`;

				const buffer = new NodeUniformBuffer( node, group );
				buffer.name = node.name;

				bindings.push( buffer );

				uniformGPU = buffer;

			} else {

				const uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );

				let uniformsGroup = uniformsStage[ groupName ];

				if ( uniformsGroup === undefined ) {

					uniformsGroup = new NodeUniformsGroup( shaderStage + '_' + groupName, group );
					//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );

					uniformsStage[ groupName ] = uniformsGroup;

					bindings.push( uniformsGroup );

				}

				uniformGPU = this.getNodeUniform( uniformNode, type );

				uniformsGroup.addUniform( uniformGPU );

			}

			nodeData.uniformGPU = uniformGPU;

		}

		return uniformNode;

	}

}

let vector2 = null;
let vector4 = null;
let color4 = null;

class Backend {

	constructor( parameters = {} ) {

		this.parameters = Object.assign( {}, parameters );
		this.data = new WeakMap();
		this.renderer = null;
		this.domElement = null;

	}

	async init( renderer ) {

		this.renderer = renderer;

	}

	// render context

	begin( /*renderContext*/ ) { }

	finish( /*renderContext*/ ) { }

	// render object

	draw( /*renderObject, info*/ ) { }

	// program

	createProgram( /*program*/ ) { }

	destroyProgram( /*program*/ ) { }

	// bindings

	createBindings( /*bingGroup, bindings*/ ) { }

	updateBindings( /*bingGroup, bindings*/ ) { }

	// pipeline

	createRenderPipeline( /*renderObject*/ ) { }

	createComputePipeline( /*computeNode, pipeline*/ ) { }

	destroyPipeline( /*pipeline*/ ) { }

	// cache key

	needsRenderUpdate( /*renderObject*/ ) { } // return Boolean ( fast test )

	getRenderCacheKey( /*renderObject*/ ) { } // return String

	// node builder

	createNodeBuilder( /*renderObject*/ ) { } // return NodeBuilder (ADD IT)

	// textures

	createSampler( /*texture*/ ) { }

	createDefaultTexture( /*texture*/ ) { }

	createTexture( /*texture*/ ) { }

	copyTextureToBuffer( /*texture, x, y, width, height*/ ) {}

	// attributes

	createAttribute( /*attribute*/ ) { }

	createIndexAttribute( /*attribute*/ ) { }

	updateAttribute( /*attribute*/ ) { }

	destroyAttribute( /*attribute*/ ) { }

	// canvas

	getContext() { }

	updateSize() { }

	// utils

	resolveTimestampAsync( /*renderContext, type*/ ) { }

	hasFeatureAsync( /*name*/ ) { } // return Boolean

	hasFeature( /*name*/ ) { } // return Boolean

	getInstanceCount( renderObject ) {

		const { object, geometry } = renderObject;

		return geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );

	}

	getDrawingBufferSize() {

		vector2 = vector2 || new Vector2();

		return this.renderer.getDrawingBufferSize( vector2 );

	}

	getScissor() {

		vector4 = vector4 || new Vector4();

		return this.renderer.getScissor( vector4 );

	}

	setScissorTest( /*boolean*/ ) { }

	getClearColor() {

		const renderer = this.renderer;

		color4 = color4 || new Color4();

		renderer.getClearColor( color4 );

		color4.getRGB( color4, this.renderer.currentColorSpace );

		return color4;

	}

	getDomElement() {

		let domElement = this.domElement;

		if ( domElement === null ) {

			domElement = ( this.parameters.canvas !== undefined ) ? this.parameters.canvas : createCanvasElement();

			// OffscreenCanvas does not have setAttribute, see #22811
			if ( 'setAttribute' in domElement ) domElement.setAttribute( 'data-engine', `three.js r${REVISION} webgpu` );

			this.domElement = domElement;

		}

		return domElement;

	}

	// resource properties

	set( object, value ) {

		this.data.set( object, value );

	}

	get( object ) {

		let map = this.data.get( object );

		if ( map === undefined ) {

			map = {};
			this.data.set( object, map );

		}

		return map;

	}

	has( object ) {

		return this.data.has( object );

	}

	delete( object ) {

		this.data.delete( object );

	}

	dispose() { }

}

let _id$1 = 0;

class DualAttributeData {

	constructor( attributeData, dualBuffer ) {

		this.buffers = [ attributeData.bufferGPU, dualBuffer ];
		this.type = attributeData.type;
		this.bufferType = attributeData.bufferType;
		this.pbo = attributeData.pbo;
		this.byteLength = attributeData.byteLength;
		this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;
		this.version = attributeData.version;
		this.isInteger = attributeData.isInteger;
		this.activeBufferIndex = 0;
		this.baseId = attributeData.id;

	}


	get id() {

		return `${ this.baseId }|${ this.activeBufferIndex }`;

	}

	get bufferGPU() {

		return this.buffers[ this.activeBufferIndex ];

	}

	get transformBuffer() {

		return this.buffers[ this.activeBufferIndex ^ 1 ];

	}

	switchBuffers() {

		this.activeBufferIndex ^= 1;

	}

}

class WebGLAttributeUtils {

	constructor( backend ) {

		this.backend = backend;

	}

	createAttribute( attribute, bufferType ) {

		const backend = this.backend;
		const { gl } = backend;

		const array = attribute.array;
		const usage = attribute.usage || gl.STATIC_DRAW;

		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
		const bufferData = backend.get( bufferAttribute );

		let bufferGPU = bufferData.bufferGPU;

		if ( bufferGPU === undefined ) {

			bufferGPU = this._createBuffer( gl, bufferType, array, usage );

			bufferData.bufferGPU = bufferGPU;
			bufferData.bufferType = bufferType;
			bufferData.version = bufferAttribute.version;

		}

		//attribute.onUploadCallback();

		let type;

		if ( array instanceof Float32Array ) {

			type = gl.FLOAT;

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				type = gl.HALF_FLOAT;

			} else {

				type = gl.UNSIGNED_SHORT;

			}

		} else if ( array instanceof Int16Array ) {

			type = gl.SHORT;

		} else if ( array instanceof Uint32Array ) {

			type = gl.UNSIGNED_INT;

		} else if ( array instanceof Int32Array ) {

			type = gl.INT;

		} else if ( array instanceof Int8Array ) {

			type = gl.BYTE;

		} else if ( array instanceof Uint8Array ) {

			type = gl.UNSIGNED_BYTE;

		} else if ( array instanceof Uint8ClampedArray ) {

			type = gl.UNSIGNED_BYTE;

		} else {

			throw new Error( 'THREE.WebGLBackend: Unsupported buffer data format: ' + array );

		}

		let attributeData = {
			bufferGPU,
			bufferType,
			type,
			byteLength: array.byteLength,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version,
			pbo: attribute.pbo,
			isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,
			id: _id$1 ++
		};

		if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {

			// create buffer for tranform feedback use
			const bufferGPUDual = this._createBuffer( gl, bufferType, array, usage );
			attributeData = new DualAttributeData( attributeData, bufferGPUDual );

		}

		backend.set( attribute, attributeData );

	}

	updateAttribute( attribute ) {

		const backend = this.backend;
		const { gl } = backend;

		const array = attribute.array;
		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
		const bufferData = backend.get( bufferAttribute );
		const bufferType = bufferData.bufferType;
		const updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;

		gl.bindBuffer( bufferType, bufferData.bufferGPU );

		if ( updateRanges.length === 0 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

				const range = updateRanges[ i ];
				gl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,
					array, range.start, range.count );

			}

			bufferAttribute.clearUpdateRanges();

		}

		gl.bindBuffer( bufferType, null );

		bufferData.version = bufferAttribute.version;

	}

	destroyAttribute( attribute ) {

		const backend = this.backend;
		const { gl } = backend;

		if ( attribute.isInterleavedBufferAttribute ) {

			backend.delete( attribute.data );

		}

		const attributeData = backend.get( attribute );

		gl.deleteBuffer( attributeData.bufferGPU );

		backend.delete( attribute );

	}

	async getArrayBufferAsync( attribute ) {

		const backend = this.backend;
		const { gl } = backend;

		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
		const { bufferGPU } = backend.get( bufferAttribute );

		const array = attribute.array;
		const byteLength = array.byteLength;

		gl.bindBuffer( gl.COPY_READ_BUFFER, bufferGPU );

		const writeBuffer = gl.createBuffer();

		gl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );
		gl.bufferData( gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ );

		gl.copyBufferSubData( gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength );

		await backend.utils._clientWaitAsync();

		const dstBuffer = new attribute.array.constructor( array.length );

		// Ensure the buffer is bound before reading
		gl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );

		gl.getBufferSubData( gl.COPY_WRITE_BUFFER, 0, dstBuffer );

		gl.deleteBuffer( writeBuffer );

		gl.bindBuffer( gl.COPY_READ_BUFFER, null );
		gl.bindBuffer( gl.COPY_WRITE_BUFFER, null );

		return dstBuffer.buffer;

	}

	_createBuffer( gl, bufferType, array, usage ) {

		const bufferGPU = gl.createBuffer();

		gl.bindBuffer( bufferType, bufferGPU );
		gl.bufferData( bufferType, array, usage );
		gl.bindBuffer( bufferType, null );

		return bufferGPU;

	}

}

let initialized$1 = false, equationToGL, factorToGL;

class WebGLState {

	constructor( backend ) {

		this.backend = backend;

		this.gl = this.backend.gl;

		this.enabled = {};
		this.currentFlipSided = null;
		this.currentCullFace = null;
		this.currentProgram = null;
		this.currentBlendingEnabled = false;
		this.currentBlending = null;
		this.currentBlendSrc = null;
		this.currentBlendDst = null;
		this.currentBlendSrcAlpha = null;
		this.currentBlendDstAlpha = null;
		this.currentPremultipledAlpha = null;
		this.currentPolygonOffsetFactor = null;
		this.currentPolygonOffsetUnits = null;
		this.currentColorMask = null;
		this.currentDepthFunc = null;
		this.currentDepthMask = null;
		this.currentStencilFunc = null;
		this.currentStencilRef = null;
		this.currentStencilFuncMask = null;
		this.currentStencilFail = null;
		this.currentStencilZFail = null;
		this.currentStencilZPass = null;
		this.currentStencilMask = null;
		this.currentLineWidth = null;
		this.currentClippingPlanes = 0;

		this.currentBoundFramebuffers = {};
		this.currentDrawbuffers = new WeakMap();

		this.maxTextures = this.gl.getParameter( this.gl.MAX_TEXTURE_IMAGE_UNITS );
		this.currentTextureSlot = null;
		this.currentBoundTextures = {};
		this.currentBoundBufferBases = {};

		if ( initialized$1 === false ) {

			this._init( this.gl );

			initialized$1 = true;

		}

	}

	_init( gl ) {

		// Store only WebGL constants here.

		equationToGL = {
			[ AddEquation ]: gl.FUNC_ADD,
			[ SubtractEquation ]: gl.FUNC_SUBTRACT,
			[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
		};

		factorToGL = {
			[ ZeroFactor ]: gl.ZERO,
			[ OneFactor ]: gl.ONE,
			[ SrcColorFactor ]: gl.SRC_COLOR,
			[ SrcAlphaFactor ]: gl.SRC_ALPHA,
			[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
			[ DstColorFactor ]: gl.DST_COLOR,
			[ DstAlphaFactor ]: gl.DST_ALPHA,
			[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
			[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
			[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
			[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA
		};

	}

	enable( id ) {

		const { enabled } = this;

		if ( enabled[ id ] !== true ) {

			this.gl.enable( id );
			enabled[ id ] = true;

		}

	}

	disable( id ) {

		const { enabled } = this;

		if ( enabled[ id ] !== false ) {

			this.gl.disable( id );
			enabled[ id ] = false;

		}

	}

	setFlipSided( flipSided ) {

		if ( this.currentFlipSided !== flipSided ) {

			const { gl } = this;

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			this.currentFlipSided = flipSided;

		}

	}

	setCullFace( cullFace ) {

		const { gl } = this;

		if ( cullFace !== CullFaceNone ) {

			this.enable( gl.CULL_FACE );

			if ( cullFace !== this.currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( gl.BACK );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( gl.FRONT );

				} else {

					gl.cullFace( gl.FRONT_AND_BACK );

				}

			}

		} else {

			this.disable( gl.CULL_FACE );

		}

		this.currentCullFace = cullFace;

	}

	setLineWidth( width ) {

		const { currentLineWidth, gl } = this;

		if ( width !== currentLineWidth ) {

			gl.lineWidth( width );

			this.currentLineWidth = width;

		}

	}


	setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		const { gl } = this;

		if ( blending === NoBlending ) {

			if ( this.currentBlendingEnabled === true ) {

				this.disable( gl.BLEND );
				this.currentBlendingEnabled = false;

			}

			return;

		}

		if ( this.currentBlendingEnabled === false ) {

			this.enable( gl.BLEND );
			this.currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha ) {

				if ( this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( gl.FUNC_ADD );

					this.currentBlendEquation = AddEquation;
					this.currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.ONE, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
							break;

						case MultiplyBlending:
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				this.currentBlendSrc = null;
				this.currentBlendDst = null;
				this.currentBlendSrcAlpha = null;
				this.currentBlendDstAlpha = null;

				this.currentBlending = blending;
				this.currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			this.currentBlendEquation = blendEquation;
			this.currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			this.currentBlendSrc = blendSrc;
			this.currentBlendDst = blendDst;
			this.currentBlendSrcAlpha = blendSrcAlpha;
			this.currentBlendDstAlpha = blendDstAlpha;

		}

		this.currentBlending = blending;
		this.currentPremultipledAlpha = false;

	}

	setColorMask( colorMask ) {

		if ( this.currentColorMask !== colorMask ) {

			this.gl.colorMask( colorMask, colorMask, colorMask, colorMask );
			this.currentColorMask = colorMask;

		}

	}

	setDepthTest( depthTest ) {

		const { gl } = this;

		if ( depthTest ) {

			this.enable( gl.DEPTH_TEST );

		} else {

			this.disable( gl.DEPTH_TEST );

		}

	}

	setDepthMask( depthMask ) {

		if ( this.currentDepthMask !== depthMask ) {

			this.gl.depthMask( depthMask );
			this.currentDepthMask = depthMask;

		}

	}

	setDepthFunc( depthFunc ) {

		if ( this.currentDepthFunc !== depthFunc ) {

			const { gl } = this;

			switch ( depthFunc ) {

				case NeverDepth:

					gl.depthFunc( gl.NEVER );
					break;

				case AlwaysDepth:

					gl.depthFunc( gl.ALWAYS );
					break;

				case LessDepth:

					gl.depthFunc( gl.LESS );
					break;

				case LessEqualDepth:

					gl.depthFunc( gl.LEQUAL );
					break;

				case EqualDepth:

					gl.depthFunc( gl.EQUAL );
					break;

				case GreaterEqualDepth:

					gl.depthFunc( gl.GEQUAL );
					break;

				case GreaterDepth:

					gl.depthFunc( gl.GREATER );
					break;

				case NotEqualDepth:

					gl.depthFunc( gl.NOTEQUAL );
					break;

				default:

					gl.depthFunc( gl.LEQUAL );

			}

			this.currentDepthFunc = depthFunc;

		}

	}

	setStencilTest( stencilTest ) {

		const { gl } = this;

		if ( stencilTest ) {

			this.enable( gl.STENCIL_TEST );

		} else {

			this.disable( gl.STENCIL_TEST );

		}

	}

	setStencilMask( stencilMask ) {

		if ( this.currentStencilMask !== stencilMask ) {

			this.gl.stencilMask( stencilMask );
			this.currentStencilMask = stencilMask;

		}

	}

	setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

		if ( this.currentStencilFunc !== stencilFunc ||
			 this.currentStencilRef !== stencilRef ||
			 this.currentStencilFuncMask !== stencilMask ) {

			this.gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

			this.currentStencilFunc = stencilFunc;
			this.currentStencilRef = stencilRef;
			this.currentStencilFuncMask = stencilMask;

		}

	}

	setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

		if ( this.currentStencilFail !== stencilFail ||
			 this.currentStencilZFail !== stencilZFail ||
			 this.currentStencilZPass !== stencilZPass ) {

			this.gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

			this.currentStencilFail = stencilFail;
			this.currentStencilZFail = stencilZFail;
			this.currentStencilZPass = stencilZPass;

		}

	}

	setMaterial( material, frontFaceCW, hardwareClippingPlanes ) {

		const { gl } = this;

		material.side === DoubleSide
			? this.disable( gl.CULL_FACE )
			: this.enable( gl.CULL_FACE );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		this.setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? this.setBlending( NoBlending )
			: this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		this.setDepthFunc( material.depthFunc );
		this.setDepthTest( material.depthTest );
		this.setDepthMask( material.depthWrite );
		this.setColorMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		this.setStencilTest( stencilWrite );
		if ( stencilWrite ) {

			this.setStencilMask( material.stencilWriteMask );
			this.setStencilFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			this.setStencilOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		this.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		material.alphaToCoverage === true && this.backend.renderer.samples > 1
			? this.enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
			: this.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

		if ( hardwareClippingPlanes > 0 ) {

			if ( this.currentClippingPlanes !== hardwareClippingPlanes ) {

				const CLIP_DISTANCE0_WEBGL = 0x3000;

				for ( let i = 0; i < 8; i ++ ) {

					if ( i < hardwareClippingPlanes ) {

						this.enable( CLIP_DISTANCE0_WEBGL + i );

					} else {

						this.disable( CLIP_DISTANCE0_WEBGL + i );

					}

				}

			}

		}

	}

	setPolygonOffset( polygonOffset, factor, units ) {

		const { gl } = this;

		if ( polygonOffset ) {

			this.enable( gl.POLYGON_OFFSET_FILL );

			if ( this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				this.currentPolygonOffsetFactor = factor;
				this.currentPolygonOffsetUnits = units;

			}

		} else {

			this.disable( gl.POLYGON_OFFSET_FILL );

		}

	}

	useProgram( program ) {

		if ( this.currentProgram !== program ) {

			this.gl.useProgram( program );

			this.currentProgram = program;

			return true;

		}

		return false;

	}

	// framebuffer


	bindFramebuffer( target, framebuffer ) {

		const { gl, currentBoundFramebuffers } = this;

		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			gl.bindFramebuffer( target, framebuffer );

			currentBoundFramebuffers[ target ] = framebuffer;

			// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

			if ( target === gl.DRAW_FRAMEBUFFER ) {

				currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

			}

			if ( target === gl.FRAMEBUFFER ) {

				currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

			}

			return true;

		}

		return false;

	}

	drawBuffers( renderContext, framebuffer ) {

		const { gl } = this;

		let drawBuffers = [];

		let needsUpdate = false;

		if ( renderContext.textures !== null ) {

			drawBuffers = this.currentDrawbuffers.get( framebuffer );

			if ( drawBuffers === undefined ) {

				drawBuffers = [];
				this.currentDrawbuffers.set( framebuffer, drawBuffers );

			}


			const textures = renderContext.textures;

			if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

				}

				drawBuffers.length = textures.length;

				needsUpdate = true;

			}


		} else {

			if ( drawBuffers[ 0 ] !== gl.BACK ) {

				drawBuffers[ 0 ] = gl.BACK;

				needsUpdate = true;

			}

		}

		if ( needsUpdate ) {

			gl.drawBuffers( drawBuffers );

		}

	}


	// texture

	activeTexture( webglSlot ) {

		const { gl, currentTextureSlot, maxTextures } = this;

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			this.currentTextureSlot = webglSlot;

		}

	}

	bindTexture( webglType, webglTexture, webglSlot ) {

		const { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;

		if ( webglSlot === undefined ) {

			if ( currentTextureSlot === null ) {

				webglSlot = gl.TEXTURE0 + maxTextures - 1;

			} else {

				webglSlot = currentTextureSlot;

			}

		}

		let boundTexture = currentBoundTextures[ webglSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ webglSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				this.currentTextureSlot = webglSlot;

			}

			gl.bindTexture( webglType, webglTexture );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	bindBufferBase( target, index, buffer ) {

		const { gl } = this;

		const key = `${target}-${index}`;

		if ( this.currentBoundBufferBases[ key ] !== buffer ) {

			gl.bindBufferBase( target, index, buffer );
			this.currentBoundBufferBases[ key ] = buffer;

			return true;

		}

		return false;

	}


	unbindTexture() {

		const { gl, currentTextureSlot, currentBoundTextures } = this;

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

}

class WebGLUtils {

	constructor( backend ) {

		this.backend = backend;

		this.gl = this.backend.gl;
		this.extensions = backend.extensions;

	}

	convert( p, colorSpace = NoColorSpace ) {

		const { gl, extensions } = this;

		let extension;

		if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
		if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;

		if ( p === ByteType ) return gl.BYTE;
		if ( p === ShortType ) return gl.SHORT;
		if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
		if ( p === IntType ) return gl.INT;
		if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
		if ( p === FloatType ) return gl.FLOAT;

		if ( p === HalfFloatType ) {

			return gl.HALF_FLOAT;

		}

		if ( p === AlphaFormat ) return gl.ALPHA;
		if ( p === RGBFormat ) return gl.RGB;
		if ( p === RGBAFormat ) return gl.RGBA;
		if ( p === LuminanceFormat ) return gl.LUMINANCE;
		if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
		if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
		if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

		// WebGL2 formats.

		if ( p === RedFormat ) return gl.RED;
		if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
		if ( p === RGFormat ) return gl.RG;
		if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
		if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

		// S3TC

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			if ( colorSpace === SRGBColorSpace ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			} else {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			}

		}

		// PVRTC

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		// ETC

		if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

			} else {

				return null;

			}

		}

		// ASTC

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				if ( p === RGBA_ASTC_4x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if ( p === RGBA_ASTC_5x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if ( p === RGBA_ASTC_5x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if ( p === RGBA_ASTC_6x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if ( p === RGBA_ASTC_6x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if ( p === RGBA_ASTC_8x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if ( p === RGBA_ASTC_8x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if ( p === RGBA_ASTC_8x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if ( p === RGBA_ASTC_10x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if ( p === RGBA_ASTC_10x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if ( p === RGBA_ASTC_10x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if ( p === RGBA_ASTC_10x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if ( p === RGBA_ASTC_12x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if ( p === RGBA_ASTC_12x12_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

			} else {

				return null;

			}

		}

		// BPTC

		if ( p === RGBA_BPTC_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

			} else {

				return null;

			}

		}

		// RGTC

		if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

			extension = extensions.get( 'EXT_texture_compression_rgtc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
				if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

			} else {

				return null;

			}

		}

		//

		if ( p === UnsignedInt248Type ) {

			return gl.UNSIGNED_INT_24_8;

		}

		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

	}

	_clientWaitAsync() {

		const { gl } = this;

		const sync = gl.fenceSync( gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );

		gl.flush();

		return new Promise( ( resolve, reject ) => {

			function test() {

				const res = gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 );

				if ( res === gl.WAIT_FAILED ) {

					gl.deleteSync( sync );

					reject();
					return;

				}

				if ( res === gl.TIMEOUT_EXPIRED ) {

					requestAnimationFrame( test );
					return;

				}

				gl.deleteSync( sync );

				resolve();

			}

			test();

		} );

	}

}

let initialized = false, wrappingToGL, filterToGL, compareToGL;

class WebGLTextureUtils {

	constructor( backend ) {

		this.backend = backend;

		this.gl = backend.gl;
		this.extensions = backend.extensions;
		this.defaultTextures = {};

		if ( initialized === false ) {

			this._init( this.gl );

			initialized = true;

		}

	}

	_init( gl ) {

		// Store only WebGL constants here.

		wrappingToGL = {
			[ RepeatWrapping ]: gl.REPEAT,
			[ ClampToEdgeWrapping ]: gl.CLAMP_TO_EDGE,
			[ MirroredRepeatWrapping ]: gl.MIRRORED_REPEAT
		};

		filterToGL = {
			[ NearestFilter ]: gl.NEAREST,
			[ NearestMipmapNearestFilter ]: gl.NEAREST_MIPMAP_NEAREST,
			[ NearestMipmapLinearFilter ]: gl.NEAREST_MIPMAP_LINEAR,

			[ LinearFilter ]: gl.LINEAR,
			[ LinearMipmapNearestFilter ]: gl.LINEAR_MIPMAP_NEAREST,
			[ LinearMipmapLinearFilter ]: gl.LINEAR_MIPMAP_LINEAR
		};

		compareToGL = {
			[ NeverCompare ]: gl.NEVER,
			[ AlwaysCompare ]: gl.ALWAYS,
			[ LessCompare ]: gl.LESS,
			[ LessEqualCompare ]: gl.LEQUAL,
			[ EqualCompare ]: gl.EQUAL,
			[ GreaterEqualCompare ]: gl.GEQUAL,
			[ GreaterCompare ]: gl.GREATER,
			[ NotEqualCompare ]: gl.NOTEQUAL
		};

	}

	filterFallback( f ) {

		const { gl } = this;

		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			return gl.NEAREST;

		}

		return gl.LINEAR;

	}

	getGLTextureType( texture ) {

		const { gl } = this;

		let glTextureType;

		if ( texture.isCubeTexture === true ) {

			glTextureType = gl.TEXTURE_CUBE_MAP;

		} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

			glTextureType = gl.TEXTURE_2D_ARRAY;

		} else if ( texture.isData3DTexture === true ) { // TODO: isCompressed3DTexture, wait for #26642

			glTextureType = gl.TEXTURE_3D;

		} else {

			glTextureType = gl.TEXTURE_2D;


		}

		return glTextureType;

	}

	getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

		const { gl, extensions } = this;

		if ( internalFormatName !== null ) {

			if ( gl[ internalFormatName ] !== undefined ) return gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === gl.RED ) {

			if ( glType === gl.FLOAT ) internalFormat = gl.R32F;
			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.R16F;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.R8I;
			if ( glType === gl.SHORT ) internalFormat = gl.R16I;
			if ( glType === gl.INT ) internalFormat = gl.R32I;

		}

		if ( glFormat === gl.RED_INTEGER ) {

			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8UI;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16UI;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.R8I;
			if ( glType === gl.SHORT ) internalFormat = gl.R16I;
			if ( glType === gl.INT ) internalFormat = gl.R32I;

		}

		if ( glFormat === gl.RG ) {

			if ( glType === gl.FLOAT ) internalFormat = gl.RG32F;
			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RG16F;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RG8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RG16I;
			if ( glType === gl.INT ) internalFormat = gl.RG32I;

		}

		if ( glFormat === gl.RG_INTEGER ) {

			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8UI;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16UI;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RG8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RG16I;
			if ( glType === gl.INT ) internalFormat = gl.RG32I;

		}

		if ( glFormat === gl.RGB ) {

			if ( glType === gl.FLOAT ) internalFormat = gl.RGB32F;
			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGB16F;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RGB8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RGB16I;
			if ( glType === gl.INT ) internalFormat = gl.RGB32I;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8 : gl.RGB8;
			if ( glType === gl.UNSIGNED_SHORT_5_6_5 ) internalFormat = gl.RGB565;
			if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;
			if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGB4;
			if ( glType === gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = gl.RGB9_E5;

		}

		if ( glFormat === gl.RGB_INTEGER ) {

			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8UI;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16UI;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RGB8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RGB16I;
			if ( glType === gl.INT ) internalFormat = gl.RGB32I;

		}

		if ( glFormat === gl.RGBA ) {

			if ( glType === gl.FLOAT ) internalFormat = gl.RGBA32F;
			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGBA16F;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;
			if ( glType === gl.INT ) internalFormat = gl.RGBA32I;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8_ALPHA8 : gl.RGBA8;
			if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGBA4;
			if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;

		}

		if ( glFormat === gl.RGBA_INTEGER ) {

			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8UI;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16UI;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;
			if ( glType === gl.INT ) internalFormat = gl.RGBA32I;

		}

		if ( glFormat === gl.DEPTH_COMPONENT ) {

			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.DEPTH24_STENCIL8;
			if ( glType === gl.FLOAT ) internalFormat = gl.DEPTH_COMPONENT32F;

		}

		if ( glFormat === gl.DEPTH_STENCIL ) {

			if ( glType === gl.UNSIGNED_INT_24_8 ) internalFormat = gl.DEPTH24_STENCIL8;

		}

		if ( internalFormat === gl.R16F || internalFormat === gl.R32F ||
			internalFormat === gl.RG16F || internalFormat === gl.RG32F ||
			internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	setTextureParameters( textureType, texture ) {

		const { gl, extensions, backend } = this;


		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		gl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
		gl.pixelStorei( gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE );

		gl.texParameteri( textureType, gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
		gl.texParameteri( textureType, gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

		if ( textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY ) {

			gl.texParameteri( textureType, gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

		}

		gl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );


		const hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;

		// follow WebGPU backend mapping for texture filtering
		const minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;

		gl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, filterToGL[ minFilter ] );

		if ( texture.compareFunction ) {

			gl.texParameteri( textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE );
			gl.texParameteri( textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			if ( texture.magFilter === NearestFilter ) return;
			if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2

			if ( texture.anisotropy > 1 ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );
				gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, backend.getMaxAnisotropy() ) );

			}

		}

	}

	createDefaultTexture( texture ) {

		const { gl, backend, defaultTextures } = this;


		const glTextureType = this.getGLTextureType( texture );

		let textureGPU = defaultTextures[ glTextureType ];

		if ( textureGPU === undefined ) {

			textureGPU = gl.createTexture();

			backend.state.bindTexture( glTextureType, textureGPU );
			gl.texParameteri( glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

			// gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			defaultTextures[ glTextureType ] = textureGPU;

		}

		backend.set( texture, {
			textureGPU,
			glTextureType,
			isDefault: true
		} );

	}

	createTexture( texture, options ) {

		const { gl, backend } = this;
		const { levels, width, height, depth } = options;

		const glFormat = backend.utils.convert( texture.format, texture.colorSpace );
		const glType = backend.utils.convert( texture.type );
		const glInternalFormat = this.getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );

		const textureGPU = gl.createTexture();
		const glTextureType = this.getGLTextureType( texture );

		backend.state.bindTexture( glTextureType, textureGPU );

		this.setTextureParameters( glTextureType, texture );

		if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

			gl.texStorage3D( gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth );

		} else if ( texture.isData3DTexture ) {

			gl.texStorage3D( gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth );

		} else if ( ! texture.isVideoTexture ) {

			gl.texStorage2D( glTextureType, levels, glInternalFormat, width, height );

		}

		backend.set( texture, {
			textureGPU,
			glTextureType,
			glFormat,
			glType,
			glInternalFormat
		} );

	}

	copyBufferToTexture( buffer, texture ) {

		const { gl, backend } = this;

		const { textureGPU, glTextureType, glFormat, glType } = backend.get( texture );

		const { width, height } = texture.source.data;

		gl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, buffer );

		backend.state.bindTexture( glTextureType, textureGPU );

		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );
		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );
		gl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, 0 );

		gl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, null );

		backend.state.unbindTexture();
		// debug
		// const framebuffer = gl.createFramebuffer();
		// gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );
		// gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );

		// const readout = new Float32Array( width * height * 4 );

		// const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );
		// const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );

		// gl.readPixels( 0, 0, width, height, altFormat, altType, readout );
		// gl.bindFramebuffer( gl.FRAMEBUFFER, null );
		// console.log( readout );

	}

	updateTexture( texture, options ) {

		const { gl } = this;
		const { width, height } = options;
		const { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get( texture );

		if ( texture.isRenderTargetTexture || ( textureGPU === undefined /* unsupported texture format */ ) )
			return;

		const getImage = ( source ) => {

			if ( source.isDataTexture ) {

				return source.image.data;

			} else if ( ( typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap ) ||
				source instanceof OffscreenCanvas ) {

				return source;

			}

			return source.data;

		};

		this.backend.state.bindTexture( glTextureType, textureGPU );

		this.setTextureParameters( glTextureType, texture );

		if ( texture.isCompressedTexture ) {

			const mipmaps = texture.mipmaps;
			const image = options.image;

			for ( let i = 0; i < mipmaps.length; i ++ ) {

				const mipmap = mipmaps[ i ];

				if ( texture.isCompressedArrayTexture ) {


					if ( texture.format !== gl.RGBA ) {

						if ( glFormat !== null ) {

							gl.compressedTexSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						gl.texSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

					}

				} else {

					if ( glFormat !== null ) {

						gl.compressedTexSubImage2D( gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

					} else {

						console.warn( 'Unsupported compressed texture format' );

					}

				}

			}


		} else if ( texture.isCubeTexture ) {

			const images = options.images;

			for ( let i = 0; i < 6; i ++ ) {

				const image = getImage( images[ i ] );

				gl.texSubImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image );

			}

		} else if ( texture.isDataArrayTexture ) {

			const image = options.image;

			gl.texSubImage3D( gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

		} else if ( texture.isData3DTexture ) {

			const image = options.image;

			gl.texSubImage3D( gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

		} else if ( texture.isVideoTexture ) {

			texture.update();

			gl.texImage2D( glTextureType, 0, glInternalFormat, glFormat, glType, options.image );


		} else {

			const image = getImage( options.image );

			gl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, image );

		}

	}

	generateMipmaps( texture ) {

		const { gl, backend } = this;
		const { textureGPU, glTextureType } = backend.get( texture );

		backend.state.bindTexture( glTextureType, textureGPU );
		gl.generateMipmap( glTextureType );

	}

	deallocateRenderBuffers( renderTarget ) {

		const { gl, backend } = this;

		// remove framebuffer reference
		if ( renderTarget ) {

			const renderContextData = backend.get( renderTarget );

			renderContextData.renderBufferStorageSetup = undefined;

			if ( renderContextData.framebuffers ) {

				for ( const cacheKey in renderContextData.framebuffers ) {

					gl.deleteFramebuffer( renderContextData.framebuffers[ cacheKey ] );

				}

				delete renderContextData.framebuffers;

			}

			if ( renderContextData.depthRenderbuffer ) {

				gl.deleteRenderbuffer( renderContextData.depthRenderbuffer );
				delete renderContextData.depthRenderbuffer;

			}

			if ( renderContextData.stencilRenderbuffer ) {

				gl.deleteRenderbuffer( renderContextData.stencilRenderbuffer );
				delete renderContextData.stencilRenderbuffer;

			}

			if ( renderContextData.msaaFrameBuffer ) {

				gl.deleteFramebuffer( renderContextData.msaaFrameBuffer );
				delete renderContextData.msaaFrameBuffer;

			}

			if ( renderContextData.msaaRenderbuffers ) {

				for ( let i = 0; i < renderContextData.msaaRenderbuffers.length; i ++ ) {

					gl.deleteRenderbuffer( renderContextData.msaaRenderbuffers[ i ] );

				}

				delete renderContextData.msaaRenderbuffers;

			}

		}

	}

	destroyTexture( texture ) {

		const { gl, backend } = this;
		const { textureGPU, renderTarget } = backend.get( texture );

		this.deallocateRenderBuffers( renderTarget );
		gl.deleteTexture( textureGPU );

		backend.delete( texture );

	}

	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

		const { gl, backend } = this;
		const { state } = this.backend;

		const { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get( dstTexture );

		let width, height, minX, minY;
		let dstX, dstY;

		if ( srcRegion !== null ) {

			width = srcRegion.max.x - srcRegion.min.x;
			height = srcRegion.max.y - srcRegion.min.y;
			minX = srcRegion.min.x;
			minY = srcRegion.min.y;

		} else {

			width = srcTexture.image.width;
			height = srcTexture.image.height;
			minX = 0;
			minY = 0;

		}

		if ( dstPosition !== null ) {

			dstX = dstPosition.x;
			dstY = dstPosition.y;

		} else {

			dstX = 0;
			dstY = 0;

		}

		state.bindTexture( glTextureType, dstTextureGPU );

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		gl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );
		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
		gl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

		const currentUnpackRowLen = gl.getParameter( gl.UNPACK_ROW_LENGTH );
		const currentUnpackImageHeight = gl.getParameter( gl.UNPACK_IMAGE_HEIGHT );
		const currentUnpackSkipPixels = gl.getParameter( gl.UNPACK_SKIP_PIXELS );
		const currentUnpackSkipRows = gl.getParameter( gl.UNPACK_SKIP_ROWS );
		const currentUnpackSkipImages = gl.getParameter( gl.UNPACK_SKIP_IMAGES );

		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;

		gl.pixelStorei( gl.UNPACK_ROW_LENGTH, image.width );
		gl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, image.height );
		gl.pixelStorei( gl.UNPACK_SKIP_PIXELS, minX );
		gl.pixelStorei( gl.UNPACK_SKIP_ROWS, minY );

		if ( srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture ) {

			const srcTextureData = backend.get( srcTexture );
			const dstTextureData = backend.get( dstTexture );

			const srcRenderContextData = backend.get( srcTextureData.renderTarget );
			const dstRenderContextData = backend.get( dstTextureData.renderTarget );

			const srcFramebuffer = srcRenderContextData.framebuffers[ srcTextureData.cacheKey ];
			const dstFramebuffer = dstRenderContextData.framebuffers[ dstTextureData.cacheKey ];

			state.bindFramebuffer( gl.READ_FRAMEBUFFER, srcFramebuffer );
			state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, dstFramebuffer );

			let mask = gl.COLOR_BUFFER_BIT;

			if ( srcTexture.isDepthTexture ) mask = gl.DEPTH_BUFFER_BIT;

			gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST );

			state.bindFramebuffer( gl.READ_FRAMEBUFFER, null );
			state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );

		} else {

			if ( srcTexture.isDataTexture ) {

				gl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data );

			} else {

				if ( srcTexture.isCompressedTexture ) {

					gl.compressedTexSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data );

				} else {

					gl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image );

				}

			}

		}

		gl.pixelStorei( gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
		gl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );
		gl.pixelStorei( gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
		gl.pixelStorei( gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );
		gl.pixelStorei( gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) gl.generateMipmap( gl.TEXTURE_2D );

		state.unbindTexture();

	}

	copyFramebufferToTexture( texture, renderContext, rectangle ) {

		const { gl } = this;
		const { state } = this.backend;

		const { textureGPU } = this.backend.get( texture );

		const { x, y, z: width, w: height } = rectangle;

		const requireDrawFrameBuffer = texture.isDepthTexture === true || ( renderContext.renderTarget && renderContext.renderTarget.samples > 0 );

		const srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.gerDrawingBufferSize().y;

		if ( requireDrawFrameBuffer ) {

			const partial = ( x !== 0 || y !== 0 );
			let mask;
			let attachment;

			if ( texture.isDepthTexture === true ) {

				mask = gl.DEPTH_BUFFER_BIT;
				attachment = gl.DEPTH_ATTACHMENT;

				if ( renderContext.stencil ) {

					mask |= gl.STENCIL_BUFFER_BIT;

				}

			} else {

				mask = gl.COLOR_BUFFER_BIT;
				attachment = gl.COLOR_ATTACHMENT0;

			}

			if ( partial ) {

				const renderTargetContextData = this.backend.get( renderContext.renderTarget );

				const fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];
				const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;

				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );
				state.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );

				const flippedY = srcHeight - y - height;

				gl.blitFramebuffer( x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST );

				state.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );

				state.bindTexture( gl.TEXTURE_2D, textureGPU );

				gl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height );

				state.unbindTexture();

			} else {

				const fb = gl.createFramebuffer();

				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );

				gl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0 );
				gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST );

				gl.deleteFramebuffer( fb );

			}

		} else {

			state.bindTexture( gl.TEXTURE_2D, textureGPU );
			gl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height );

			state.unbindTexture();

		}

		if ( texture.generateMipmaps ) this.generateMipmaps( texture );

		this.backend._setFramebuffer( renderContext );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	setupRenderBufferStorage( renderbuffer, renderContext ) {

		const { gl } = this;
		const renderTarget = renderContext.renderTarget;

		const { samples, depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;

		gl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );

		if ( depthBuffer && ! stencilBuffer ) {

			let glInternalFormat = gl.DEPTH_COMPONENT24;

			if ( samples > 0 ) {

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === gl.FLOAT ) {

						glInternalFormat = gl.DEPTH_COMPONENT32F;

					}

				}

				gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, glInternalFormat, width, height );

			} else {

				gl.renderbufferStorage( gl.RENDERBUFFER, glInternalFormat, width, height );

			}

			gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

		} else if ( depthBuffer && stencilBuffer ) {

			if ( samples > 0 ) {

				gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height );

			} else {

				gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height );

			}


			gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

		}

	}

	async copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

		const { backend, gl } = this;

		const { textureGPU, glFormat, glType } = this.backend.get( texture );

		const fb = gl.createFramebuffer();

		gl.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );

		const target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;

		gl.framebufferTexture2D( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0 );

		const typedArrayType = this._getTypedArrayType( glType );
		const bytesPerTexel = this._getBytesPerTexel( glType, glFormat );

		const elementCount = width * height;
		const byteLength = elementCount * bytesPerTexel;

		const buffer = gl.createBuffer();

		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );
		gl.bufferData( gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ );
		gl.readPixels( x, y, width, height, glFormat, glType, 0 );
		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );

		await backend.utils._clientWaitAsync();

		const dstBuffer = new typedArrayType( byteLength / typedArrayType.BYTES_PER_ELEMENT );

		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );
		gl.getBufferSubData( gl.PIXEL_PACK_BUFFER, 0, dstBuffer );
		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );

		gl.deleteFramebuffer( fb );

		return dstBuffer;

	}

	_getTypedArrayType( glType ) {

		const { gl } = this;

		if ( glType === gl.UNSIGNED_BYTE ) return Uint8Array;

		if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) return Uint16Array;
		if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) return Uint16Array;
		if ( glType === gl.UNSIGNED_SHORT_5_6_5 ) return Uint16Array;
		if ( glType === gl.UNSIGNED_SHORT ) return Uint16Array;
		if ( glType === gl.UNSIGNED_INT ) return Uint32Array;

		if ( glType === gl.HALF_FLOAT ) return Uint16Array;
		if ( glType === gl.FLOAT ) return Float32Array;

		throw new Error( `Unsupported WebGL type: ${glType}` );

	}

	_getBytesPerTexel( glType, glFormat ) {

		const { gl } = this;

		let bytesPerComponent = 0;

		if ( glType === gl.UNSIGNED_BYTE ) bytesPerComponent = 1;

		if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ||
			glType === gl.UNSIGNED_SHORT_5_5_5_1 ||
			glType === gl.UNSIGNED_SHORT_5_6_5 ||
			glType === gl.UNSIGNED_SHORT ||
			glType === gl.HALF_FLOAT ) bytesPerComponent = 2;

		if ( glType === gl.UNSIGNED_INT ||
			glType === gl.FLOAT ) bytesPerComponent = 4;

		if ( glFormat === gl.RGBA ) return bytesPerComponent * 4;
		if ( glFormat === gl.RGB ) return bytesPerComponent * 3;
		if ( glFormat === gl.ALPHA ) return bytesPerComponent;

	}

}

class WebGLExtensions {

	constructor( backend ) {

		this.backend = backend;

		this.gl = this.backend.gl;
		this.availableExtensions = this.gl.getSupportedExtensions();

		this.extensions = {};

	}

	get( name ) {

		let extension = this.extensions[ name ];

		if ( extension === undefined ) {

			extension = this.gl.getExtension( name );

			this.extensions[ name ] = extension;

		}

		return extension;

	}

	has( name ) {

		return this.availableExtensions.includes( name );

	}

}

class WebGLCapabilities {

	constructor( backend ) {

		this.backend = backend;

		this.maxAnisotropy = null;

	}

	getMaxAnisotropy() {

		if ( this.maxAnisotropy !== null ) return this.maxAnisotropy;

		const gl = this.backend.gl;
		const extensions = this.backend.extensions;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			this.maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			this.maxAnisotropy = 0;

		}

		return this.maxAnisotropy;

	}

}

const GLFeatureName = {

	'WEBGL_multi_draw': 'WEBGL_multi_draw',
	'WEBGL_compressed_texture_astc': 'texture-compression-astc',
	'WEBGL_compressed_texture_etc': 'texture-compression-etc2',
	'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',
	'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
	'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
	'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',
	'EXT_texture_compression_bptc': 'texture-compression-bptc',
	'EXT_disjoint_timer_query_webgl2': 'timestamp-query',

};

class WebGLBufferRenderer {

	constructor( backend ) {

		this.gl = backend.gl;
		this.extensions = backend.extensions;
		this.info = backend.renderer.info;
		this.mode = null;
		this.index = 0;
		this.type = null;
		this.object = null;

	}

	render( start, count ) {

		const { gl, mode, object, type, info, index } = this;

		if ( index !== 0 ) {

			gl.drawElements( mode, count, type, start );

		} else {

			gl.drawArrays( mode, start, count );

		}

		info.update( object, count, mode, 1 );

	}

	renderInstances( start, count, primcount ) {

		const { gl, mode, type, index, object, info } = this;

		if ( primcount === 0 ) return;

		if ( index !== 0 ) {

			gl.drawElementsInstanced( mode, count, type, start, primcount );

		} else {

			gl.drawArraysInstanced( mode, start, count, primcount );

		}

		info.update( object, count, mode, primcount );

	}

	renderMultiDraw( starts, counts, drawCount ) {

		const { extensions, mode, object, info } = this;

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < drawCount; i ++ ) {

				this.render( starts[ i ], counts[ i ] );

			}

		} else {

			if ( this.index !== 0 ) {

				extension.multiDrawElementsWEBGL( mode, counts, 0, this.type, starts, 0, drawCount );

			} else {

				extension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );

			}

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			info.update( object, elementCount, mode, 1 );

		}

	}

	renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

		const { extensions, mode, object, info } = this;

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < drawCount; i ++ ) {

				this.renderInstances( starts[ i ], counts[ i ], primcount[ i ] );

			}

		} else {

			if ( this.index !== 0 ) {

				extension.multiDrawElementsInstancedWEBGL( mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount );

			} else {

				extension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );

			}

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ] * primcount[ i ];

			}

			info.update( object, elementCount, mode, 1 );

		}

	}

	//

}

//

class WebGLBackend extends Backend {

	constructor( parameters = {} ) {

		super( parameters );

		this.isWebGLBackend = true;

	}

	init( renderer ) {

		super.init( renderer );

		//

		const parameters = this.parameters;

		const glContext = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgl2' );

	 	function onContextLost( event ) {

			event.preventDefault();

			const contextLossInfo = {
				api: 'WebGL',
				message: event.statusMessage || 'Unknown reason',
				reason: null,
				originalEvent: event
			};

			renderer.onDeviceLost( contextLossInfo );

		}

		this._onContextLost = onContextLost;

		renderer.domElement.addEventListener( 'webglcontextlost', onContextLost, false );

		this.gl = glContext;

		this.extensions = new WebGLExtensions( this );
		this.capabilities = new WebGLCapabilities( this );
		this.attributeUtils = new WebGLAttributeUtils( this );
		this.textureUtils = new WebGLTextureUtils( this );
		this.bufferRenderer = new WebGLBufferRenderer( this );

		this.state = new WebGLState( this );
		this.utils = new WebGLUtils( this );

		this.vaoCache = {};
		this.transformFeedbackCache = {};
		this.discard = false;
		this.trackTimestamp = ( parameters.trackTimestamp === true );

		this.extensions.get( 'EXT_color_buffer_float' );
		this.extensions.get( 'WEBGL_clip_cull_distance' );
		this.extensions.get( 'OES_texture_float_linear' );
		this.extensions.get( 'EXT_color_buffer_half_float' );
		this.extensions.get( 'WEBGL_multisampled_render_to_texture' );
		this.extensions.get( 'WEBGL_render_shared_exponent' );
		this.extensions.get( 'WEBGL_multi_draw' );

		this.disjoint = this.extensions.get( 'EXT_disjoint_timer_query_webgl2' );
		this.parallel = this.extensions.get( 'KHR_parallel_shader_compile' );

		this._knownBindings = new WeakSet();

		this._currentContext = null;

	}

	get coordinateSystem() {

		return WebGLCoordinateSystem;

	}

	async getArrayBufferAsync( attribute ) {

		return await this.attributeUtils.getArrayBufferAsync( attribute );

	}

	async waitForGPU() {

		await this.utils._clientWaitAsync();

	}

	initTimestampQuery( renderContext ) {

		if ( ! this.disjoint || ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( this.queryRunning ) {

		  if ( ! renderContextData.queryQueue ) renderContextData.queryQueue = [];
		  renderContextData.queryQueue.push( renderContext );
		  return;

		}

		if ( renderContextData.activeQuery ) {

		  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );
		  renderContextData.activeQuery = null;

		}

		renderContextData.activeQuery = this.gl.createQuery();

		if ( renderContextData.activeQuery !== null ) {

		  this.gl.beginQuery( this.disjoint.TIME_ELAPSED_EXT, renderContextData.activeQuery );
		  this.queryRunning = true;

		}

	}

	// timestamp utils

	prepareTimestampBuffer( renderContext ) {

		if ( ! this.disjoint || ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( renderContextData.activeQuery ) {

		  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );

		  if ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];
		  renderContextData.gpuQueries.push( { query: renderContextData.activeQuery } );
		  renderContextData.activeQuery = null;
		  this.queryRunning = false;

		  if ( renderContextData.queryQueue && renderContextData.queryQueue.length > 0 ) {

				const nextRenderContext = renderContextData.queryQueue.shift();
				this.initTimestampQuery( nextRenderContext );

			}

		}

	}

	async resolveTimestampAsync( renderContext, type = 'render' ) {

		if ( ! this.disjoint || ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];

		for ( let i = 0; i < renderContextData.gpuQueries.length; i ++ ) {

		  const queryInfo = renderContextData.gpuQueries[ i ];
		  const available = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE );
		  const disjoint = this.gl.getParameter( this.disjoint.GPU_DISJOINT_EXT );

		  if ( available && ! disjoint ) {

				const elapsed = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT );
				const duration = Number( elapsed ) / 1000000; // Convert nanoseconds to milliseconds
				this.gl.deleteQuery( queryInfo.query );
				renderContextData.gpuQueries.splice( i, 1 ); // Remove the processed query
				i --;
				this.renderer.info.updateTimestamp( type, duration );

			}

		}

	}

	getContext() {

		return this.gl;

	}

	beginRender( renderContext ) {

		const { gl } = this;
		const renderContextData = this.get( renderContext );

		//

		//

		this.initTimestampQuery( renderContext );

		renderContextData.previousContext = this._currentContext;
		this._currentContext = renderContext;

		this._setFramebuffer( renderContext );

		this.clear( renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false );

		//
		if ( renderContext.viewport ) {

			this.updateViewport( renderContext );

		} else {

			gl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );

		}

		if ( renderContext.scissor ) {

			const { x, y, width, height } = renderContext.scissorValue;

			gl.scissor( x, renderContext.height - height - y, width, height );

		}

		const occlusionQueryCount = renderContext.occlusionQueryCount;

		if ( occlusionQueryCount > 0 ) {

			// Get a reference to the array of objects with queries. The renderContextData property
			// can be changed by another render pass before the async reading of all previous queries complete
			renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;
			renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;

			renderContextData.lastOcclusionObject = null;
			renderContextData.occlusionQueries = new Array( occlusionQueryCount );
			renderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );
			renderContextData.occlusionQueryIndex = 0;

		}

	}

	finishRender( renderContext ) {

		const { gl, state } = this;
		const renderContextData = this.get( renderContext );
		const previousContext = renderContextData.previousContext;

		const occlusionQueryCount = renderContext.occlusionQueryCount;

		if ( occlusionQueryCount > 0 ) {

			if ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {

				gl.endQuery( gl.ANY_SAMPLES_PASSED );

			}

			this.resolveOccludedAsync( renderContext );

		}

		const textures = renderContext.textures;

		if ( textures !== null ) {

			for ( let i = 0; i < textures.length; i ++ ) {

				const texture = textures[ i ];

				if ( texture.generateMipmaps ) {

					this.generateMipmaps( texture );

				}

			}

		}

		this._currentContext = previousContext;

		if ( renderContext.textures !== null && renderContext.renderTarget ) {

			const renderTargetContextData = this.get( renderContext.renderTarget );

			const { samples } = renderContext.renderTarget;

			if ( samples > 0 ) {

				const fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];

				const mask = gl.COLOR_BUFFER_BIT;

				const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;

				const textures = renderContext.textures;

				state.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );
				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );

				for ( let i = 0; i < textures.length; i ++ ) {

					// TODO Add support for MRT

					if ( renderContext.scissor ) {

						const { x, y, width, height } = renderContext.scissorValue;

						const viewY = renderContext.height - height - y;

						gl.blitFramebuffer( x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST );
						gl.invalidateSubFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray, x, viewY, width, height );

					} else {

						gl.blitFramebuffer( 0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST );
						gl.invalidateFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray );

					}

				}

			}


		}

		if ( previousContext !== null ) {

			this._setFramebuffer( previousContext );

			if ( previousContext.viewport ) {

				this.updateViewport( previousContext );

			} else {

				gl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );

			}

		}

		this.prepareTimestampBuffer( renderContext );

	}

	resolveOccludedAsync( renderContext ) {

		const renderContextData = this.get( renderContext );

		// handle occlusion query results

		const { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;

		if ( currentOcclusionQueries && currentOcclusionQueryObjects ) {

			const occluded = new WeakSet();
			const { gl } = this;

			renderContextData.currentOcclusionQueryObjects = null;
			renderContextData.currentOcclusionQueries = null;

			const check = () => {

				let completed = 0;

				// check all queries and requeue as appropriate
				for ( let i = 0; i < currentOcclusionQueries.length; i ++ ) {

					const query = currentOcclusionQueries[ i ];

					if ( query === null ) continue;

					if ( gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE ) ) {

						if ( gl.getQueryParameter( query, gl.QUERY_RESULT ) > 0 ) occluded.add( currentOcclusionQueryObjects[ i ] );

						currentOcclusionQueries[ i ] = null;
						gl.deleteQuery( query );

						completed ++;

					}

				}

				if ( completed < currentOcclusionQueries.length ) {

					requestAnimationFrame( check );

				} else {

					renderContextData.occluded = occluded;

				}

			};

			check();

		}

	}

	isOccluded( renderContext, object ) {

		const renderContextData = this.get( renderContext );

		return renderContextData.occluded && renderContextData.occluded.has( object );

	}

	updateViewport( renderContext ) {

		const gl = this.gl;
		const { x, y, width, height } = renderContext.viewportValue;

		gl.viewport( x, renderContext.height - height - y, width, height );

	}

	setScissorTest( boolean ) {

		const gl = this.gl;

		if ( boolean ) {

			gl.enable( gl.SCISSOR_TEST );

		} else {

			gl.disable( gl.SCISSOR_TEST );

		}

	}

	clear( color, depth, stencil, descriptor = null, setFrameBuffer = true ) {

		const { gl } = this;

		if ( descriptor === null ) {

			const clearColor = this.getClearColor();

			// premultiply alpha

			clearColor.r *= clearColor.a;
			clearColor.g *= clearColor.a;
			clearColor.b *= clearColor.a;

			descriptor = {
				textures: null,
				clearColorValue: clearColor
			};

		}

		//

		let clear = 0;

		if ( color ) clear |= gl.COLOR_BUFFER_BIT;
		if ( depth ) clear |= gl.DEPTH_BUFFER_BIT;
		if ( stencil ) clear |= gl.STENCIL_BUFFER_BIT;

		if ( clear !== 0 ) {

			let clearColor;

			if ( descriptor.clearColorValue ) {

				clearColor = descriptor.clearColorValue;

			} else {

				clearColor = this.getClearColor();

				// premultiply alpha

				clearColor.r *= clearColor.a;
				clearColor.g *= clearColor.a;
				clearColor.b *= clearColor.a;

			}

			if ( depth ) this.state.setDepthMask( true );

			if ( descriptor.textures === null ) {

				gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearColor.a );
				gl.clear( clear );

			} else {

				if ( setFrameBuffer ) this._setFramebuffer( descriptor );

				if ( color ) {

					for ( let i = 0; i < descriptor.textures.length; i ++ ) {

						gl.clearBufferfv( gl.COLOR, i, [ clearColor.r, clearColor.g, clearColor.b, clearColor.a ] );

					}

				}

				if ( depth && stencil ) {

					gl.clearBufferfi( gl.DEPTH_STENCIL, 0, 1, 0 );

				} else if ( depth ) {

					gl.clearBufferfv( gl.DEPTH, 0, [ 1.0 ] );

				} else if ( stencil ) {

					gl.clearBufferiv( gl.STENCIL, 0, [ 0 ] );

				}

			}

		}

	}

	beginCompute( computeGroup ) {

		const { state, gl } = this;

		state.bindFramebuffer( gl.FRAMEBUFFER, null );
		this.initTimestampQuery( computeGroup );

	}

	compute( computeGroup, computeNode, bindings, pipeline ) {

		const { state, gl } = this;

		if ( ! this.discard ) {

			// required here to handle async behaviour of render.compute()
			gl.enable( gl.RASTERIZER_DISCARD );
			this.discard = true;

		}

		const { programGPU, transformBuffers, attributes } = this.get( pipeline );

		const vaoKey = this._getVaoKey( null, attributes );

		const vaoGPU = this.vaoCache[ vaoKey ];

		if ( vaoGPU === undefined ) {

			this._createVao( null, attributes );

		} else {

			gl.bindVertexArray( vaoGPU );

		}

		state.useProgram( programGPU );

		this._bindUniforms( bindings );

		const transformFeedbackGPU = this._getTransformFeedback( transformBuffers );

		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );
		gl.beginTransformFeedback( gl.POINTS );

		if ( attributes[ 0 ].isStorageInstancedBufferAttribute ) {

			gl.drawArraysInstanced( gl.POINTS, 0, 1, computeNode.count );

		} else {

			gl.drawArrays( gl.POINTS, 0, computeNode.count );

		}

		gl.endTransformFeedback();
		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );

		// switch active buffers

		for ( let i = 0; i < transformBuffers.length; i ++ ) {

			const dualAttributeData = transformBuffers[ i ];

			if ( dualAttributeData.pbo ) {

				this.textureUtils.copyBufferToTexture( dualAttributeData.transformBuffer, dualAttributeData.pbo );

			}

			dualAttributeData.switchBuffers();


		}

	}

	finishCompute( computeGroup ) {

		const gl = this.gl;

		this.discard = false;

		gl.disable( gl.RASTERIZER_DISCARD );

		this.prepareTimestampBuffer( computeGroup );

		if ( this._currentContext ) {

			this._setFramebuffer( this._currentContext );

		}

	}

	draw( renderObject/*, info*/ ) {

		const { object, pipeline, material, context, hardwareClippingPlanes } = renderObject;
		const { programGPU } = this.get( pipeline );

		const { gl, state } = this;

		const contextData = this.get( context );

		const drawParams = renderObject.getDrawParameters();

		if ( drawParams === null ) return;

		//

		this._bindUniforms( renderObject.getBindings() );

		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		state.setMaterial( material, frontFaceCW, hardwareClippingPlanes );

		state.useProgram( programGPU );

		//

		const renderObjectData = this.get( renderObject );

		let vaoGPU = renderObjectData.staticVao;

		if ( vaoGPU === undefined || renderObjectData.geometryId !== renderObject.geometry.id ) {

			const vaoKey = this._getVaoKey( renderObject.getIndex(), renderObject.getAttributes() );

			vaoGPU = this.vaoCache[ vaoKey ];

			if ( vaoGPU === undefined ) {

				let staticVao;

				( { vaoGPU, staticVao } = this._createVao( renderObject.getIndex(), renderObject.getAttributes() ) );

				if ( staticVao ) {

					renderObjectData.staticVao = vaoGPU;
					renderObjectData.geometryId = renderObject.geometry.id;

				}

			}

		}

		gl.bindVertexArray( vaoGPU );

		//

		const index = renderObject.getIndex();

		//

		const lastObject = contextData.lastOcclusionObject;

		if ( lastObject !== object && lastObject !== undefined ) {

			if ( lastObject !== null && lastObject.occlusionTest === true ) {

				gl.endQuery( gl.ANY_SAMPLES_PASSED );

				contextData.occlusionQueryIndex ++;

			}

			if ( object.occlusionTest === true ) {

				const query = gl.createQuery();

				gl.beginQuery( gl.ANY_SAMPLES_PASSED, query );

				contextData.occlusionQueries[ contextData.occlusionQueryIndex ] = query;
				contextData.occlusionQueryObjects[ contextData.occlusionQueryIndex ] = object;

			}

			contextData.lastOcclusionObject = object;

		}

		//
		const renderer = this.bufferRenderer;

		if ( object.isPoints ) renderer.mode = gl.POINTS;
		else if ( object.isLineSegments ) renderer.mode = gl.LINES;
		else if ( object.isLine ) renderer.mode = gl.LINE_STRIP;
		else if ( object.isLineLoop ) renderer.mode = gl.LINE_LOOP;
		else {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * this.renderer.getPixelRatio() );
				renderer.mode = gl.LINES;

			} else {

				renderer.mode = gl.TRIANGLES;

			}

		}

		//

		const { vertexCount, instanceCount } = drawParams;
		let { firstVertex } = drawParams;

		renderer.object = object;

		if ( index !== null ) {

			firstVertex *= index.array.BYTES_PER_ELEMENT;

			const indexData = this.get( index );

			renderer.index = index.count;
			renderer.type = indexData.type;

		} else {

			renderer.index = 0;

		}

		if ( object.isBatchedMesh ) {

			if ( object._multiDrawInstances !== null ) {

				renderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );

			} else if ( ! this.hasFeature( 'WEBGL_multi_draw' ) ) {

				warnOnce( 'THREE.WebGLRenderer: WEBGL_multi_draw not supported.' );

			} else {

				renderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );

			}

		} else if ( instanceCount > 1 ) {

			renderer.renderInstances( firstVertex, vertexCount, instanceCount );

		} else {

			renderer.render( firstVertex, vertexCount );

		}
		//

		gl.bindVertexArray( null );

	}

	needsRenderUpdate( /*renderObject*/ ) {

		return false;

	}

	getRenderCacheKey( /*renderObject*/ ) {

		return '';

	}

	// textures

	createDefaultTexture( texture ) {

		this.textureUtils.createDefaultTexture( texture );

	}

	createTexture( texture, options ) {

		this.textureUtils.createTexture( texture, options );

	}

	updateTexture( texture, options ) {

		this.textureUtils.updateTexture( texture, options );

	}

	generateMipmaps( texture ) {

		this.textureUtils.generateMipmaps( texture );

	}


	destroyTexture( texture ) {

		this.textureUtils.destroyTexture( texture );

	}

	copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

		return this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );

	}

	createSampler( /*texture*/ ) {

		//console.warn( 'Abstract class.' );

	}

	destroySampler() {}

	// node builder

	createNodeBuilder( object, renderer ) {

		return new GLSLNodeBuilder( object, renderer );

	}

	// program

	createProgram( program ) {

		const gl = this.gl;
		const { stage, code } = program;

		const shader = stage === 'fragment' ? gl.createShader( gl.FRAGMENT_SHADER ) : gl.createShader( gl.VERTEX_SHADER );

		gl.shaderSource( shader, code );
		gl.compileShader( shader );

		this.set( program, {
			shaderGPU: shader
		} );

	}

	destroyProgram( /*program*/ ) {

		console.warn( 'Abstract class.' );

	}

	createRenderPipeline( renderObject, promises ) {

		const gl = this.gl;
		const pipeline = renderObject.pipeline;

		// Program

		const { fragmentProgram, vertexProgram } = pipeline;

		const programGPU = gl.createProgram();

		const fragmentShader = this.get( fragmentProgram ).shaderGPU;
		const vertexShader = this.get( vertexProgram ).shaderGPU;

		gl.attachShader( programGPU, fragmentShader );
		gl.attachShader( programGPU, vertexShader );
		gl.linkProgram( programGPU );

		this.set( pipeline, {
			programGPU,
			fragmentShader,
			vertexShader
		} );

		if ( promises !== null && this.parallel ) {

			const p = new Promise( ( resolve /*, reject*/ ) => {

				const parallel = this.parallel;
				const checkStatus = () => {

					if ( gl.getProgramParameter( programGPU, parallel.COMPLETION_STATUS_KHR ) ) {

						this._completeCompile( renderObject, pipeline );
						resolve();

					} else {

						requestAnimationFrame( checkStatus );

					}

				};

				checkStatus();

			} );

			promises.push( p );

			return;

		}

		this._completeCompile( renderObject, pipeline );

	}

	_handleSource( string, errorLine ) {

		const lines = string.split( '\n' );
		const lines2 = [];

		const from = Math.max( errorLine - 6, 0 );
		const to = Math.min( errorLine + 6, lines.length );

		for ( let i = from; i < to; i ++ ) {

			const line = i + 1;
			lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

		}

		return lines2.join( '\n' );

	}

	_getShaderErrors( gl, shader, type ) {

		const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
		const errors = gl.getShaderInfoLog( shader ).trim();

		if ( status && errors === '' ) return '';

		const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
		if ( errorMatches ) {

			const errorLine = parseInt( errorMatches[ 1 ] );
			return type.toUpperCase() + '\n\n' + errors + '\n\n' + this._handleSource( gl.getShaderSource( shader ), errorLine );

		} else {

			return errors;

		}

	}

	_logProgramError( programGPU, glFragmentShader, glVertexShader ) {

		if ( this.renderer.debug.checkShaderErrors ) {

			const gl = this.gl;

			const programLog = gl.getProgramInfoLog( programGPU ).trim();

			if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {


				if ( typeof this.renderer.debug.onShaderError === 'function' ) {

					this.renderer.debug.onShaderError( gl, programGPU, glVertexShader, glFragmentShader );

				} else {

					// default error reporting

					const vertexErrors = this._getShaderErrors( gl, glVertexShader, 'vertex' );
					const fragmentErrors = this._getShaderErrors( gl, glFragmentShader, 'fragment' );

					console.error(
						'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
						'VALIDATE_STATUS ' + gl.getProgramParameter( programGPU, gl.VALIDATE_STATUS ) + '\n\n' +
						'Program Info Log: ' + programLog + '\n' +
						vertexErrors + '\n' +
						fragmentErrors
					);

				}

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

			}

		}

	}

	_completeCompile( renderObject, pipeline ) {

		const { state, gl } = this;
		const pipelineData = this.get( pipeline );
		const { programGPU, fragmentShader, vertexShader } = pipelineData;

		if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {

			this._logProgramError( programGPU, fragmentShader, vertexShader );

		}

		state.useProgram( programGPU );

		// Bindings

		const bindings = renderObject.getBindings();

		this._setupBindings( bindings, programGPU );

		//

		this.set( pipeline, {
			programGPU
		} );

	}

	createComputePipeline( computePipeline, bindings ) {

		const { state, gl } = this;

		// Program

		const fragmentProgram = {
			stage: 'fragment',
			code: '#version 300 es\nprecision highp float;\nvoid main() {}'
		};

		this.createProgram( fragmentProgram );

		const { computeProgram } = computePipeline;

		const programGPU = gl.createProgram();

		const fragmentShader = this.get( fragmentProgram ).shaderGPU;
		const vertexShader = this.get( computeProgram ).shaderGPU;

		const transforms = computeProgram.transforms;

		const transformVaryingNames = [];
		const transformAttributeNodes = [];

		for ( let i = 0; i < transforms.length; i ++ ) {

			const transform = transforms[ i ];

			transformVaryingNames.push( transform.varyingName );
			transformAttributeNodes.push( transform.attributeNode );

		}

		gl.attachShader( programGPU, fragmentShader );
		gl.attachShader( programGPU, vertexShader );

		gl.transformFeedbackVaryings(
			programGPU,
			transformVaryingNames,
			gl.SEPARATE_ATTRIBS
		);

		gl.linkProgram( programGPU );

		if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {

			this._logProgramError( programGPU, fragmentShader, vertexShader );


		}

		state.useProgram( programGPU );

		// Bindings

		this._setupBindings( bindings, programGPU );

		const attributeNodes = computeProgram.attributes;
		const attributes = [];
		const transformBuffers = [];

		for ( let i = 0; i < attributeNodes.length; i ++ ) {

			const attribute = attributeNodes[ i ].node.attribute;

			attributes.push( attribute );

			if ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

		}

		for ( let i = 0; i < transformAttributeNodes.length; i ++ ) {

			const attribute = transformAttributeNodes[ i ].attribute;

			if ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

			const attributeData = this.get( attribute );

			transformBuffers.push( attributeData );

		}

		//

		this.set( computePipeline, {
			programGPU,
			transformBuffers,
			attributes
		} );

	}

	createBindings( bindGroup, bindings ) {

		if ( this._knownBindings.has( bindings ) === false ) {

			this._knownBindings.add( bindings );

			let uniformBuffers = 0;
			let textures = 0;

			for ( const bindGroup of bindings ) {

				this.set( bindGroup, {
					textures: textures,
					uniformBuffers: uniformBuffers
				} );

				for ( const binding of bindGroup.bindings ) {

					if ( binding.isUniformBuffer ) uniformBuffers ++;
					if ( binding.isSampledTexture ) textures ++;

				}

			}

		}

		this.updateBindings( bindGroup, bindings );

	}

	updateBindings( bindGroup /*, bindings*/ ) {

		const { gl } = this;

		const bindGroupData = this.get( bindGroup );

		let i = bindGroupData.uniformBuffers;
		let t = bindGroupData.textures;

		for ( const binding of bindGroup.bindings ) {

			if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

				const data = binding.buffer;
				const bufferGPU = gl.createBuffer();

				gl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );
				gl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );

				this.set( binding, {
					index: i ++,
					bufferGPU
				} );

			} else if ( binding.isSampledTexture ) {

				const { textureGPU, glTextureType } = this.get( binding.texture );

				this.set( binding, {
					index: t ++,
					textureGPU,
					glTextureType
				} );

			}

		}

	}

	updateBinding( binding ) {

		const gl = this.gl;

		if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

			const bindingData = this.get( binding );
			const bufferGPU = bindingData.bufferGPU;
			const data = binding.buffer;

			gl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );
			gl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );

		}

	}

	// attributes

	createIndexAttribute( attribute ) {

		const gl = this.gl;

		this.attributeUtils.createAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

	}

	createAttribute( attribute ) {

		if ( this.has( attribute ) ) return;

		const gl = this.gl;

		this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

	}

	createStorageAttribute( attribute ) {

		if ( this.has( attribute ) ) return;

		const gl = this.gl;

		this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

	}

	updateAttribute( attribute ) {

		this.attributeUtils.updateAttribute( attribute );

	}

	destroyAttribute( attribute ) {

		this.attributeUtils.destroyAttribute( attribute );

	}

	updateSize() {

		//console.warn( 'Abstract class.' );

	}

	hasFeature( name ) {

		const keysMatching = Object.keys( GLFeatureName ).filter( key => GLFeatureName[ key ] === name );

		const extensions = this.extensions;

		for ( let i = 0; i < keysMatching.length; i ++ ) {

			if ( extensions.has( keysMatching[ i ] ) ) return true;

		}

		return false;

	}

	getMaxAnisotropy() {

		return this.capabilities.getMaxAnisotropy();

	}

	copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level ) {

		this.textureUtils.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );

	}

	copyFramebufferToTexture( texture, renderContext, rectangle ) {

		this.textureUtils.copyFramebufferToTexture( texture, renderContext, rectangle );

	}

	_setFramebuffer( descriptor ) {

		const { gl, state } = this;

		let currentFrameBuffer = null;

		if ( descriptor.textures !== null ) {

			const renderTarget = descriptor.renderTarget;
			const renderTargetContextData = this.get( renderTarget );
			const { samples, depthBuffer, stencilBuffer } = renderTarget;

			const isCube = renderTarget.isWebGLCubeRenderTarget === true;

			let msaaFb = renderTargetContextData.msaaFrameBuffer;
			let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;

			const cacheKey = getCacheKey( descriptor );

			let fb;

			if ( isCube ) {

				renderTargetContextData.cubeFramebuffers || ( renderTargetContextData.cubeFramebuffers = {} );

				fb = renderTargetContextData.cubeFramebuffers[ cacheKey ];

			} else {

				renderTargetContextData.framebuffers || ( renderTargetContextData.framebuffers = {} );

				fb = renderTargetContextData.framebuffers[ cacheKey ];

			}

			if ( fb === undefined ) {

				fb = gl.createFramebuffer();

				state.bindFramebuffer( gl.FRAMEBUFFER, fb );

				const textures = descriptor.textures;

				if ( isCube ) {

					renderTargetContextData.cubeFramebuffers[ cacheKey ] = fb;

					const { textureGPU } = this.get( textures[ 0 ] );

					const cubeFace = this.renderer._activeCubeFace;

					gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0 );

				} else {

					renderTargetContextData.framebuffers[ cacheKey ] = fb;

					for ( let i = 0; i < textures.length; i ++ ) {

						const texture = textures[ i ];
						const textureData = this.get( texture );
						textureData.renderTarget = descriptor.renderTarget;
						textureData.cacheKey = cacheKey; // required for copyTextureToTexture()

						const attachment = gl.COLOR_ATTACHMENT0 + i;

						gl.framebufferTexture2D( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0 );

					}

					state.drawBuffers( descriptor, fb );

				}

				if ( descriptor.depthTexture !== null ) {

					const textureData = this.get( descriptor.depthTexture );
					const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
					textureData.renderTarget = descriptor.renderTarget;
					textureData.cacheKey = cacheKey; // required for copyTextureToTexture()

					gl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );

				}

			}

			if ( samples > 0 ) {

				if ( msaaFb === undefined ) {

					const invalidationArray = [];

					msaaFb = gl.createFramebuffer();

					state.bindFramebuffer( gl.FRAMEBUFFER, msaaFb );

					const msaaRenderbuffers = [];

					const textures = descriptor.textures;

					for ( let i = 0; i < textures.length; i ++ ) {

						msaaRenderbuffers[ i ] = gl.createRenderbuffer();

						gl.bindRenderbuffer( gl.RENDERBUFFER, msaaRenderbuffers[ i ] );

						invalidationArray.push( gl.COLOR_ATTACHMENT0 + i );

						if ( depthBuffer ) {

							const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
							invalidationArray.push( depthStyle );

						}

						const texture = descriptor.textures[ i ];
						const textureData = this.get( texture );

						gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height );
						gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );


					}

					renderTargetContextData.msaaFrameBuffer = msaaFb;
					renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;

					if ( depthRenderbuffer === undefined ) {

						depthRenderbuffer = gl.createRenderbuffer();
						this.textureUtils.setupRenderBufferStorage( depthRenderbuffer, descriptor );

						renderTargetContextData.depthRenderbuffer = depthRenderbuffer;

						const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
						invalidationArray.push( depthStyle );

					}

					renderTargetContextData.invalidationArray = invalidationArray;

				}

				currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;

			} else {

				currentFrameBuffer = fb;

			}

		}

		state.bindFramebuffer( gl.FRAMEBUFFER, currentFrameBuffer );

	}


	_getVaoKey( index, attributes ) {

		let key = [];

		if ( index !== null ) {

			const indexData = this.get( index );

			key += ':' + indexData.id;

		}

		for ( let i = 0; i < attributes.length; i ++ ) {

			const attributeData = this.get( attributes[ i ] );

			key += ':' + attributeData.id;

		}

		return key;

	}

	_createVao( index, attributes ) {

		const { gl } = this;

		const vaoGPU = gl.createVertexArray();
		let key = '';

		let staticVao = true;

		gl.bindVertexArray( vaoGPU );

		if ( index !== null ) {

			const indexData = this.get( index );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU );

			key += ':' + indexData.id;

		}

		for ( let i = 0; i < attributes.length; i ++ ) {

			const attribute = attributes[ i ];
			const attributeData = this.get( attribute );

			key += ':' + attributeData.id;

			gl.bindBuffer( gl.ARRAY_BUFFER, attributeData.bufferGPU );
			gl.enableVertexAttribArray( i );

			if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) staticVao = false;

			let stride, offset;

			if ( attribute.isInterleavedBufferAttribute === true ) {

				stride = attribute.data.stride * attributeData.bytesPerElement;
				offset = attribute.offset * attributeData.bytesPerElement;

			} else {

				stride = 0;
				offset = 0;

			}

			if ( attributeData.isInteger ) {

				gl.vertexAttribIPointer( i, attribute.itemSize, attributeData.type, stride, offset );

			} else {

				gl.vertexAttribPointer( i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset );

			}

			if ( attribute.isInstancedBufferAttribute && ! attribute.isInterleavedBufferAttribute ) {

				gl.vertexAttribDivisor( i, attribute.meshPerAttribute );

			} else if ( attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer ) {

				gl.vertexAttribDivisor( i, attribute.data.meshPerAttribute );

			}

		}

		gl.bindBuffer( gl.ARRAY_BUFFER, null );

		this.vaoCache[ key ] = vaoGPU;

		return { vaoGPU, staticVao };

	}

	_getTransformFeedback( transformBuffers ) {

		let key = '';

		for ( let i = 0; i < transformBuffers.length; i ++ ) {

			key += ':' + transformBuffers[ i ].id;

		}

		let transformFeedbackGPU = this.transformFeedbackCache[ key ];

		if ( transformFeedbackGPU !== undefined ) {

			return transformFeedbackGPU;

		}

		const { gl } = this;

		transformFeedbackGPU = gl.createTransformFeedback();

		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );

		for ( let i = 0; i < transformBuffers.length; i ++ ) {

			const attributeData = transformBuffers[ i ];

			gl.bindBufferBase( gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer );

		}

		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );

		this.transformFeedbackCache[ key ] = transformFeedbackGPU;

		return transformFeedbackGPU;

	}


	_setupBindings( bindings, programGPU ) {

		const gl = this.gl;

		for ( const bindGroup of bindings ) {

			for ( const binding of bindGroup.bindings ) {

				const bindingData = this.get( binding );
				const index = bindingData.index;

				if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

					const location = gl.getUniformBlockIndex( programGPU, binding.name );
					gl.uniformBlockBinding( programGPU, location, index );

				} else if ( binding.isSampledTexture ) {

					const location = gl.getUniformLocation( programGPU, binding.name );
					gl.uniform1i( location, index );

				}

			}

		}

	}

	_bindUniforms( bindings ) {

		const { gl, state } = this;

		for ( const bindGroup of bindings ) {

			for ( const binding of bindGroup.bindings ) {

				const bindingData = this.get( binding );
				const index = bindingData.index;

				if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

					// TODO USE bindBufferRange to group multiple uniform buffers
					state.bindBufferBase( gl.UNIFORM_BUFFER, index, bindingData.bufferGPU );

				} else if ( binding.isSampledTexture ) {

					state.bindTexture( bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index );

				}

			}

		}

	}

	dispose() {

		this.renderer.domElement.removeEventListener( 'webglcontextlost', this._onContextLost );

	}

}

const GPUPrimitiveTopology = {
	PointList: 'point-list',
	LineList: 'line-list',
	LineStrip: 'line-strip',
	TriangleList: 'triangle-list',
	TriangleStrip: 'triangle-strip',
};

const GPUCompareFunction = {
	Never: 'never',
	Less: 'less',
	Equal: 'equal',
	LessEqual: 'less-equal',
	Greater: 'greater',
	NotEqual: 'not-equal',
	GreaterEqual: 'greater-equal',
	Always: 'always'
};

const GPUStoreOp = {
	Store: 'store',
	Discard: 'discard'
};

const GPULoadOp = {
	Load: 'load',
	Clear: 'clear'
};

const GPUFrontFace = {
	CCW: 'ccw',
	CW: 'cw'
};

const GPUCullMode = {
	None: 'none',
	Front: 'front',
	Back: 'back'
};

const GPUIndexFormat = {
	Uint16: 'uint16',
	Uint32: 'uint32'
};

const GPUTextureFormat = {

	// 8-bit formats

	R8Unorm: 'r8unorm',
	R8Snorm: 'r8snorm',
	R8Uint: 'r8uint',
	R8Sint: 'r8sint',

	// 16-bit formats

	R16Uint: 'r16uint',
	R16Sint: 'r16sint',
	R16Float: 'r16float',
	RG8Unorm: 'rg8unorm',
	RG8Snorm: 'rg8snorm',
	RG8Uint: 'rg8uint',
	RG8Sint: 'rg8sint',

	// 32-bit formats

	R32Uint: 'r32uint',
	R32Sint: 'r32sint',
	R32Float: 'r32float',
	RG16Uint: 'rg16uint',
	RG16Sint: 'rg16sint',
	RG16Float: 'rg16float',
	RGBA8Unorm: 'rgba8unorm',
	RGBA8UnormSRGB: 'rgba8unorm-srgb',
	RGBA8Snorm: 'rgba8snorm',
	RGBA8Uint: 'rgba8uint',
	RGBA8Sint: 'rgba8sint',
	BGRA8Unorm: 'bgra8unorm',
	BGRA8UnormSRGB: 'bgra8unorm-srgb',
	// Packed 32-bit formats
	RGB9E5UFloat: 'rgb9e5ufloat',
	RGB10A2Unorm: 'rgb10a2unorm',
	RG11B10uFloat: 'rgb10a2unorm',

	// 64-bit formats

	RG32Uint: 'rg32uint',
	RG32Sint: 'rg32sint',
	RG32Float: 'rg32float',
	RGBA16Uint: 'rgba16uint',
	RGBA16Sint: 'rgba16sint',
	RGBA16Float: 'rgba16float',

	// 128-bit formats

	RGBA32Uint: 'rgba32uint',
	RGBA32Sint: 'rgba32sint',
	RGBA32Float: 'rgba32float',

	// Depth and stencil formats

	Stencil8: 'stencil8',
	Depth16Unorm: 'depth16unorm',
	Depth24Plus: 'depth24plus',
	Depth24PlusStencil8: 'depth24plus-stencil8',
	Depth32Float: 'depth32float',

	// 'depth32float-stencil8' extension

	Depth32FloatStencil8: 'depth32float-stencil8',

	// BC compressed formats usable if 'texture-compression-bc' is both
	// supported by the device/user agent and enabled in requestDevice.

	BC1RGBAUnorm: 'bc1-rgba-unorm',
	BC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',
	BC2RGBAUnorm: 'bc2-rgba-unorm',
	BC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',
	BC3RGBAUnorm: 'bc3-rgba-unorm',
	BC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',
	BC4RUnorm: 'bc4-r-unorm',
	BC4RSnorm: 'bc4-r-snorm',
	BC5RGUnorm: 'bc5-rg-unorm',
	BC5RGSnorm: 'bc5-rg-snorm',
	BC6HRGBUFloat: 'bc6h-rgb-ufloat',
	BC6HRGBFloat: 'bc6h-rgb-float',
	BC7RGBAUnorm: 'bc7-rgba-unorm',
	BC7RGBAUnormSRGB: 'bc7-rgba-srgb',

	// ETC2 compressed formats usable if 'texture-compression-etc2' is both
	// supported by the device/user agent and enabled in requestDevice.

	ETC2RGB8Unorm: 'etc2-rgb8unorm',
	ETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',
	ETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',
	ETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',
	ETC2RGBA8Unorm: 'etc2-rgba8unorm',
	ETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',
	EACR11Unorm: 'eac-r11unorm',
	EACR11Snorm: 'eac-r11snorm',
	EACRG11Unorm: 'eac-rg11unorm',
	EACRG11Snorm: 'eac-rg11snorm',

	// ASTC compressed formats usable if 'texture-compression-astc' is both
	// supported by the device/user agent and enabled in requestDevice.

	ASTC4x4Unorm: 'astc-4x4-unorm',
	ASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',
	ASTC5x4Unorm: 'astc-5x4-unorm',
	ASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',
	ASTC5x5Unorm: 'astc-5x5-unorm',
	ASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',
	ASTC6x5Unorm: 'astc-6x5-unorm',
	ASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',
	ASTC6x6Unorm: 'astc-6x6-unorm',
	ASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',
	ASTC8x5Unorm: 'astc-8x5-unorm',
	ASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',
	ASTC8x6Unorm: 'astc-8x6-unorm',
	ASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',
	ASTC8x8Unorm: 'astc-8x8-unorm',
	ASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',
	ASTC10x5Unorm: 'astc-10x5-unorm',
	ASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',
	ASTC10x6Unorm: 'astc-10x6-unorm',
	ASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',
	ASTC10x8Unorm: 'astc-10x8-unorm',
	ASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',
	ASTC10x10Unorm: 'astc-10x10-unorm',
	ASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',
	ASTC12x10Unorm: 'astc-12x10-unorm',
	ASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',
	ASTC12x12Unorm: 'astc-12x12-unorm',
	ASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',

};

const GPUAddressMode = {
	ClampToEdge: 'clamp-to-edge',
	Repeat: 'repeat',
	MirrorRepeat: 'mirror-repeat'
};

const GPUFilterMode = {
	Linear: 'linear',
	Nearest: 'nearest'
};

const GPUBlendFactor = {
	Zero: 'zero',
	One: 'one',
	Src: 'src',
	OneMinusSrc: 'one-minus-src',
	SrcAlpha: 'src-alpha',
	OneMinusSrcAlpha: 'one-minus-src-alpha',
	Dst: 'dst',
	OneMinusDstColor: 'one-minus-dst',
	DstAlpha: 'dst-alpha',
	OneMinusDstAlpha: 'one-minus-dst-alpha',
	SrcAlphaSaturated: 'src-alpha-saturated',
	Constant: 'constant',
	OneMinusConstant: 'one-minus-constant'
};

const GPUBlendOperation = {
	Add: 'add',
	Subtract: 'subtract',
	ReverseSubtract: 'reverse-subtract',
	Min: 'min',
	Max: 'max'
};

const GPUColorWriteFlags = {
	None: 0,
	Red: 0x1,
	Green: 0x2,
	Blue: 0x4,
	Alpha: 0x8,
	All: 0xF
};

const GPUStencilOperation = {
	Keep: 'keep',
	Zero: 'zero',
	Replace: 'replace',
	Invert: 'invert',
	IncrementClamp: 'increment-clamp',
	DecrementClamp: 'decrement-clamp',
	IncrementWrap: 'increment-wrap',
	DecrementWrap: 'decrement-wrap'
};

const GPUBufferBindingType = {
	Uniform: 'uniform',
	Storage: 'storage',
	ReadOnlyStorage: 'read-only-storage'
};

const GPUStorageTextureAccess = {
	WriteOnly: 'write-only',
	ReadOnly: 'read-only',
	ReadWrite: 'read-write',
};

const GPUTextureSampleType = {
	Float: 'float',
	UnfilterableFloat: 'unfilterable-float',
	Depth: 'depth',
	SInt: 'sint',
	UInt: 'uint'
};

const GPUTextureDimension = {
	OneD: '1d',
	TwoD: '2d',
	ThreeD: '3d'
};

const GPUTextureViewDimension = {
	OneD: '1d',
	TwoD: '2d',
	TwoDArray: '2d-array',
	Cube: 'cube',
	CubeArray: 'cube-array',
	ThreeD: '3d'
};

const GPUTextureAspect = {
	All: 'all',
	StencilOnly: 'stencil-only',
	DepthOnly: 'depth-only'
};

const GPUInputStepMode = {
	Vertex: 'vertex',
	Instance: 'instance'
};

const GPUFeatureName = {
	DepthClipControl: 'depth-clip-control',
	Depth32FloatStencil8: 'depth32float-stencil8',
	TextureCompressionBC: 'texture-compression-bc',
	TextureCompressionETC2: 'texture-compression-etc2',
	TextureCompressionASTC: 'texture-compression-astc',
	TimestampQuery: 'timestamp-query',
	IndirectFirstInstance: 'indirect-first-instance',
	ShaderF16: 'shader-f16',
	RG11B10UFloat: 'rg11b10ufloat-renderable',
	BGRA8UNormStorage: 'bgra8unorm-storage',
	Float32Filterable: 'float32-filterable',
	ClipDistances: 'clip-distances',
	DualSourceBlending: 'dual-source-blending',
	Subgroups: 'subgroups'
};

class Sampler extends Binding {

	constructor( name, texture ) {

		super( name );

		this.texture = texture;
		this.version = texture ? texture.version : 0;

		this.isSampler = true;

	}

}

class NodeSampler extends Sampler {

	constructor( name, textureNode, groupNode ) {

		super( name, textureNode ? textureNode.value : null );

		this.textureNode = textureNode;
		this.groupNode = groupNode;

	}

	update() {

		this.texture = this.textureNode.value;

	}

}

class StorageBuffer extends Buffer {

	constructor( name, attribute ) {

		super( name, attribute ? attribute.array : null );

		this.attribute = attribute;

		this.isStorageBuffer = true;

	}

}

let _id = 0;

class NodeStorageBuffer extends StorageBuffer {

	constructor( nodeUniform, groupNode ) {

		super( 'StorageBuffer_' + _id ++, nodeUniform ? nodeUniform.value : null );

		this.nodeUniform = nodeUniform;
		this.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;
		this.groupNode = groupNode;

	}

	get buffer() {

		return this.nodeUniform.value;

	}

}

class WebGPUTexturePassUtils extends DataMap {

	constructor( device ) {

		super();

		this.device = device;

		const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;

		const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;

		const flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
		this.mipmapSampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );
		this.flipYSampler = device.createSampler( { minFilter: GPUFilterMode.Nearest } ); //@TODO?: Consider using textureLoad()

		// We'll need a new pipeline for every texture format used.
		this.transferPipelines = {};
		this.flipYPipelines = {};

		this.mipmapVertexShaderModule = device.createShaderModule( {
			label: 'mipmapVertex',
			code: mipmapVertexSource
		} );

		this.mipmapFragmentShaderModule = device.createShaderModule( {
			label: 'mipmapFragment',
			code: mipmapFragmentSource
		} );

		this.flipYFragmentShaderModule = device.createShaderModule( {
			label: 'flipYFragment',
			code: flipYFragmentSource
		} );

	}

	getTransferPipeline( format ) {

		let pipeline = this.transferPipelines[ format ];

		if ( pipeline === undefined ) {

			pipeline = this.device.createRenderPipeline( {
				label: `mipmap-${ format }`,
				vertex: {
					module: this.mipmapVertexShaderModule,
					entryPoint: 'main'
				},
				fragment: {
					module: this.mipmapFragmentShaderModule,
					entryPoint: 'main',
					targets: [ { format } ]
				},
				primitive: {
					topology: GPUPrimitiveTopology.TriangleStrip,
					stripIndexFormat: GPUIndexFormat.Uint32
				},
				layout: 'auto'
			} );

			this.transferPipelines[ format ] = pipeline;

		}

		return pipeline;

	}

	getFlipYPipeline( format ) {

		let pipeline = this.flipYPipelines[ format ];

		if ( pipeline === undefined ) {

			pipeline = this.device.createRenderPipeline( {
				label: `flipY-${ format }`,
				vertex: {
					module: this.mipmapVertexShaderModule,
					entryPoint: 'main'
				},
				fragment: {
					module: this.flipYFragmentShaderModule,
					entryPoint: 'main',
					targets: [ { format } ]
				},
				primitive: {
					topology: GPUPrimitiveTopology.TriangleStrip,
					stripIndexFormat: GPUIndexFormat.Uint32
				},
				layout: 'auto'
			} );

			this.flipYPipelines[ format ] = pipeline;

		}

		return pipeline;

	}

	flipY( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {

		const format = textureGPUDescriptor.format;
		const { width, height } = textureGPUDescriptor.size;

		const transferPipeline = this.getTransferPipeline( format );
		const flipYPipeline = this.getFlipYPipeline( format );

		const tempTexture = this.device.createTexture( {
			size: { width, height, depthOrArrayLayers: 1 },
			format,
			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
		} );

		const srcView = textureGPU.createView( {
			baseMipLevel: 0,
			mipLevelCount: 1,
			dimension: GPUTextureViewDimension.TwoD,
			baseArrayLayer
		} );

		const dstView = tempTexture.createView( {
			baseMipLevel: 0,
			mipLevelCount: 1,
			dimension: GPUTextureViewDimension.TwoD,
			baseArrayLayer: 0
		} );

		const commandEncoder = this.device.createCommandEncoder( {} );

		const pass = ( pipeline, sourceView, destinationView ) => {

			const bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.

			const bindGroup = this.device.createBindGroup( {
				layout: bindGroupLayout,
				entries: [ {
					binding: 0,
					resource: this.flipYSampler
				}, {
					binding: 1,
					resource: sourceView
				} ]
			} );

			const passEncoder = commandEncoder.beginRenderPass( {
				colorAttachments: [ {
					view: destinationView,
					loadOp: GPULoadOp.Clear,
					storeOp: GPUStoreOp.Store,
					clearValue: [ 0, 0, 0, 0 ]
				} ]
			} );

			passEncoder.setPipeline( pipeline );
			passEncoder.setBindGroup( 0, bindGroup );
			passEncoder.draw( 4, 1, 0, 0 );
			passEncoder.end();

		};

		pass( transferPipeline, srcView, dstView );
		pass( flipYPipeline, dstView, srcView );

		this.device.queue.submit( [ commandEncoder.finish() ] );

		tempTexture.destroy();

	}

	generateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {

		const textureData = this.get( textureGPU );

		if ( textureData.useCount === undefined ) {

			textureData.useCount = 0;
			textureData.layers = [];

		}

		const passes = textureData.layers[ baseArrayLayer ] || this._mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer );

		const commandEncoder = this.device.createCommandEncoder( {} );

		this._mipmapRunBundles( commandEncoder, passes );

		this.device.queue.submit( [ commandEncoder.finish() ] );

		if ( textureData.useCount !== 0 ) textureData.layers[ baseArrayLayer ] = passes;

		textureData.useCount ++;

	}

	_mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer ) {

		const pipeline = this.getTransferPipeline( textureGPUDescriptor.format );

		const bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.

		let srcView = textureGPU.createView( {
			baseMipLevel: 0,
			mipLevelCount: 1,
			dimension: GPUTextureViewDimension.TwoD,
			baseArrayLayer
		} );

		const passes = [];

		for ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {

			const bindGroup = this.device.createBindGroup( {
				layout: bindGroupLayout,
				entries: [ {
					binding: 0,
					resource: this.mipmapSampler
				}, {
					binding: 1,
					resource: srcView
				} ]
			} );

			const dstView = textureGPU.createView( {
				baseMipLevel: i,
				mipLevelCount: 1,
				dimension: GPUTextureViewDimension.TwoD,
				baseArrayLayer
			} );

			const passDescriptor = {
				colorAttachments: [ {
					view: dstView,
					loadOp: GPULoadOp.Clear,
					storeOp: GPUStoreOp.Store,
					clearValue: [ 0, 0, 0, 0 ]
				} ]
			};

			const passEncoder = this.device.createRenderBundleEncoder( {
				colorFormats: [ textureGPUDescriptor.format ]
			} );

			passEncoder.setPipeline( pipeline );
			passEncoder.setBindGroup( 0, bindGroup );
			passEncoder.draw( 4, 1, 0, 0 );

			passes.push( {
				renderBundles: [ passEncoder.finish() ],
				passDescriptor
			} );

			srcView = dstView;

		}

		return passes;

	}

	_mipmapRunBundles( commandEncoder, passes ) {

		const levels = passes.length;

		for ( let i = 0; i < levels; i ++ ) {

			const pass = passes[ i ];

			const passEncoder = commandEncoder.beginRenderPass( pass.passDescriptor );

			passEncoder.executeBundles( pass.renderBundles );

			passEncoder.end();

		}

	}

}

const _compareToWebGPU = {
	[ NeverCompare ]: 'never',
	[ LessCompare ]: 'less',
	[ EqualCompare ]: 'equal',
	[ LessEqualCompare ]: 'less-equal',
	[ GreaterCompare ]: 'greater',
	[ GreaterEqualCompare ]: 'greater-equal',
	[ AlwaysCompare ]: 'always',
	[ NotEqualCompare ]: 'not-equal'
};

const _flipMap = [ 0, 1, 3, 2, 4, 5 ];

class WebGPUTextureUtils {

	constructor( backend ) {

		this.backend = backend;

		this._passUtils = null;

		this.defaultTexture = {};
		this.defaultCubeTexture = {};
		this.defaultVideoFrame = null;

		this.colorBuffer = null;

		this.depthTexture = new DepthTexture();
		this.depthTexture.name = 'depthBuffer';

	}

	createSampler( texture ) {

		const backend = this.backend;
		const device = backend.device;

		const textureGPU = backend.get( texture );

		const samplerDescriptorGPU = {
			addressModeU: this._convertAddressMode( texture.wrapS ),
			addressModeV: this._convertAddressMode( texture.wrapT ),
			addressModeW: this._convertAddressMode( texture.wrapR ),
			magFilter: this._convertFilterMode( texture.magFilter ),
			minFilter: this._convertFilterMode( texture.minFilter ),
			mipmapFilter: this._convertFilterMode( texture.minFilter ),
			maxAnisotropy: 1
		};

		// anisotropy can only be used when all filter modes are set to linear.

		if ( samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear ) {

			samplerDescriptorGPU.maxAnisotropy = texture.anisotropy;

		}

		if ( texture.isDepthTexture && texture.compareFunction !== null ) {

			samplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];

		}

		textureGPU.sampler = device.createSampler( samplerDescriptorGPU );

	}

	createDefaultTexture( texture ) {

		let textureGPU;

		const format = getFormat( texture );

		if ( texture.isCubeTexture ) {

			textureGPU = this._getDefaultCubeTextureGPU( format );

		} else if ( texture.isVideoTexture ) {

			this.backend.get( texture ).externalTexture = this._getDefaultVideoFrame();

		} else {

			textureGPU = this._getDefaultTextureGPU( format );

		}

		this.backend.get( texture ).texture = textureGPU;

	}

	createTexture( texture, options = {} ) {

		const backend = this.backend;
		const textureData = backend.get( texture );

		if ( textureData.initialized ) {

			throw new Error( 'WebGPUTextureUtils: Texture already initialized.' );

		}

		if ( options.needsMipmaps === undefined ) options.needsMipmaps = false;
		if ( options.levels === undefined ) options.levels = 1;
		if ( options.depth === undefined ) options.depth = 1;

		const { width, height, depth, levels } = options;

		if ( texture.isFramebufferTexture ) {

			if ( options.renderTarget ) {

				options.format = this.backend.utils.getCurrentColorFormat( options.renderTarget );

			} else {

				options.format = this.backend.utils.getPreferredCanvasFormat();

			}

		}

		const dimension = this._getDimension( texture );
		const format = texture.internalFormat || options.format || getFormat( texture, backend.device );

		textureData.format = format;

		let sampleCount = options.sampleCount !== undefined ? options.sampleCount : 1;

		sampleCount = backend.utils.getSampleCount( sampleCount );

		const primarySampleCount = texture.isRenderTargetTexture && ! texture.isMultisampleRenderTargetTexture ? 1 : sampleCount;

		let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;

		if ( texture.isStorageTexture === true ) {

			usage |= GPUTextureUsage.STORAGE_BINDING;

		}

		if ( texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true ) {

			usage |= GPUTextureUsage.RENDER_ATTACHMENT;

		}

		const textureDescriptorGPU = {
			label: texture.name,
			size: {
				width: width,
				height: height,
				depthOrArrayLayers: depth,
			},
			mipLevelCount: levels,
			sampleCount: primarySampleCount,
			dimension: dimension,
			format: format,
			usage: usage
		};

		// texture creation

		if ( texture.isVideoTexture ) {

			const video = texture.source.data;
			const videoFrame = new VideoFrame( video );

			textureDescriptorGPU.size.width = videoFrame.displayWidth;
			textureDescriptorGPU.size.height = videoFrame.displayHeight;

			videoFrame.close();

			textureData.externalTexture = video;

		} else {

			if ( format === undefined ) {

				console.warn( 'WebGPURenderer: Texture format not supported.' );

				return this.createDefaultTexture( texture );

			}

			textureData.texture = backend.device.createTexture( textureDescriptorGPU );

		}

		if ( texture.isRenderTargetTexture && sampleCount > 1 && ! texture.isMultisampleRenderTargetTexture ) {

			const msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );

			msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';
			msaaTextureDescriptorGPU.sampleCount = sampleCount;

			textureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );

		}

		textureData.initialized = true;

		textureData.textureDescriptorGPU = textureDescriptorGPU;

	}

	destroyTexture( texture ) {

		const backend = this.backend;
		const textureData = backend.get( texture );

		if ( textureData.texture !== undefined ) textureData.texture.destroy();

		if ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();

		backend.delete( texture );

	}

	destroySampler( texture ) {

		const backend = this.backend;
		const textureData = backend.get( texture );

		delete textureData.sampler;

	}

	generateMipmaps( texture ) {

		const textureData = this.backend.get( texture );

		if ( texture.isCubeTexture ) {

			for ( let i = 0; i < 6; i ++ ) {

				this._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );

			}

		} else {

			const depth = texture.image.depth || 1;

			for ( let i = 0; i < depth; i ++ ) {

				this._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );

			}

		}

	}

	getColorBuffer() {

		if ( this.colorBuffer ) this.colorBuffer.destroy();

		const backend = this.backend;
		const { width, height } = backend.getDrawingBufferSize();

		this.colorBuffer = backend.device.createTexture( {
			label: 'colorBuffer',
			size: {
				width: width,
				height: height,
				depthOrArrayLayers: 1
			},
			sampleCount: backend.utils.getSampleCount( backend.renderer.samples ),
			format: backend.utils.getPreferredCanvasFormat(),
			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
		} );

		return this.colorBuffer;

	}

	getDepthBuffer( depth = true, stencil = false ) {

		const backend = this.backend;
		const { width, height } = backend.getDrawingBufferSize();

		const depthTexture = this.depthTexture;
		const depthTextureGPU = backend.get( depthTexture ).texture;

		let format, type;

		if ( stencil ) {

			format = DepthStencilFormat;
			type = UnsignedInt248Type;

		} else if ( depth ) {

			format = DepthFormat;
			type = UnsignedIntType;

		}

		if ( depthTextureGPU !== undefined ) {

			if ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {

				return depthTextureGPU;

			}

			this.destroyTexture( depthTexture );

		}

		depthTexture.name = 'depthBuffer';
		depthTexture.format = format;
		depthTexture.type = type;
		depthTexture.image.width = width;
		depthTexture.image.height = height;

		this.createTexture( depthTexture, { sampleCount: backend.utils.getSampleCount( backend.renderer.samples ), width, height } );

		return backend.get( depthTexture ).texture;

	}

	updateTexture( texture, options ) {

		const textureData = this.backend.get( texture );

		const { textureDescriptorGPU } = textureData;

		if ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )
			return;

		// transfer texture data

		if ( texture.isDataTexture ) {

			this._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );

		} else if ( texture.isDataArrayTexture || texture.isData3DTexture ) {

			for ( let i = 0; i < options.image.depth; i ++ ) {

				this._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i );

			}

		} else if ( texture.isCompressedTexture || texture.isCompressedArrayTexture ) {

			this._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );

		} else if ( texture.isCubeTexture ) {

			this._copyCubeMapToTexture( options.images, textureData.texture, textureDescriptorGPU, texture.flipY );

		} else if ( texture.isVideoTexture ) {

			const video = texture.source.data;

			textureData.externalTexture = video;

		} else {

			this._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );

		}

		//

		textureData.version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	async copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

		const device = this.backend.device;

		const textureData = this.backend.get( texture );
		const textureGPU = textureData.texture;
		const format = textureData.textureDescriptorGPU.format;
		const bytesPerTexel = this._getBytesPerTexel( format );

		let bytesPerRow = width * bytesPerTexel;
		bytesPerRow = Math.ceil( bytesPerRow / 256 ) * 256; // Align to 256 bytes

		const readBuffer = device.createBuffer(
			{
				size: width * height * bytesPerTexel,
				usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
			}
		);

		const encoder = device.createCommandEncoder();

		encoder.copyTextureToBuffer(
			{
				texture: textureGPU,
				origin: { x, y, z: faceIndex },
			},
			{
				buffer: readBuffer,
				bytesPerRow: bytesPerRow
			},
			{
				width: width,
				height: height
			}

		);

		const typedArrayType = this._getTypedArrayType( format );

		device.queue.submit( [ encoder.finish() ] );

		await readBuffer.mapAsync( GPUMapMode.READ );

		const buffer = readBuffer.getMappedRange();

		return new typedArrayType( buffer );

	}

	_isEnvironmentTexture( texture ) {

		const mapping = texture.mapping;

		return ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

	}

	_getDefaultTextureGPU( format ) {

		let defaultTexture = this.defaultTexture[ format ];

		if ( defaultTexture === undefined ) {

			const texture = new Texture();
			texture.minFilter = NearestFilter;
			texture.magFilter = NearestFilter;

			this.createTexture( texture, { width: 1, height: 1, format } );

			this.defaultTexture[ format ] = defaultTexture = texture;

		}

		return this.backend.get( defaultTexture ).texture;

	}

	_getDefaultCubeTextureGPU( format ) {

		let defaultCubeTexture = this.defaultTexture[ format ];

		if ( defaultCubeTexture === undefined ) {

			const texture = new CubeTexture();
			texture.minFilter = NearestFilter;
			texture.magFilter = NearestFilter;

			this.createTexture( texture, { width: 1, height: 1, depth: 6 } );

			this.defaultCubeTexture[ format ] = defaultCubeTexture = texture;

		}

		return this.backend.get( defaultCubeTexture ).texture;

	}

	_getDefaultVideoFrame() {

		let defaultVideoFrame = this.defaultVideoFrame;

		if ( defaultVideoFrame === null ) {

			const init = {
				timestamp: 0,
				codedWidth: 1,
				codedHeight: 1,
				format: 'RGBA',
			};

			this.defaultVideoFrame = defaultVideoFrame = new VideoFrame( new Uint8Array( [ 0, 0, 0, 0xff ] ), init );

		}

		return defaultVideoFrame;

	}

	_copyCubeMapToTexture( images, textureGPU, textureDescriptorGPU, flipY ) {

		for ( let i = 0; i < 6; i ++ ) {

			const image = images[ i ];

			const flipIndex = flipY === true ? _flipMap[ i ] : i;

			if ( image.isDataTexture ) {

				this._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY );

			} else {

				this._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, flipY );

			}

		}

	}

	_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY ) {

		const device = this.backend.device;

		device.queue.copyExternalImageToTexture(
			{
				source: image
			}, {
				texture: textureGPU,
				mipLevel: 0,
				origin: { x: 0, y: 0, z: originDepth }
			}, {
				width: image.width,
				height: image.height,
				depthOrArrayLayers: 1
			}
		);

		if ( flipY === true ) {

			this._flipY( textureGPU, textureDescriptorGPU, originDepth );

		}

	}

	_getPassUtils() {

		let passUtils = this._passUtils;

		if ( passUtils === null ) {

			this._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );

		}

		return passUtils;

	}

	_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {

		this._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );

	}

	_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {

		this._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );

	}

	_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0 ) {

		// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()
		// @TODO: Consider to support valid buffer layouts with other formats like RGB

		const device = this.backend.device;

		const data = image.data;

		const bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );
		const bytesPerRow = image.width * bytesPerTexel;

		device.queue.writeTexture(
			{
				texture: textureGPU,
				mipLevel: 0,
				origin: { x: 0, y: 0, z: originDepth }
			},
			data,
			{
				offset: image.width * image.height * bytesPerTexel * depth,
				bytesPerRow
			},
			{
				width: image.width,
				height: image.height,
				depthOrArrayLayers: 1
			} );

		if ( flipY === true ) {

			this._flipY( textureGPU, textureDescriptorGPU, originDepth );

		}

	}

	_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {

		// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()

		const device = this.backend.device;

		const blockData = this._getBlockData( textureDescriptorGPU.format );
		const isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;

		for ( let i = 0; i < mipmaps.length; i ++ ) {

			const mipmap = mipmaps[ i ];

			const width = mipmap.width;
			const height = mipmap.height;
			const depth = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;

			const bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;
			const bytesPerImage = bytesPerRow * Math.ceil( height / blockData.height );

			for ( let j = 0; j < depth; j ++ ) {

				device.queue.writeTexture(
					{
						texture: textureGPU,
						mipLevel: i,
						origin: { x: 0, y: 0, z: j }
					},
					mipmap.data,
					{
						offset: j * bytesPerImage,
						bytesPerRow,
						rowsPerImage: Math.ceil( height / blockData.height )
					},
					{
						width: Math.ceil( width / blockData.width ) * blockData.width,
						height: Math.ceil( height / blockData.height ) * blockData.height,
						depthOrArrayLayers: 1
					}
				);

			}

		}

	}

	_getBlockData( format ) {

		// this method is only relevant for compressed texture formats

		if ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1
		if ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3
		if ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5
		if ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1
		if ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2
		if ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)
		if ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)

		if ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };
		if ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };
		if ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };
		if ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };
		if ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };
		if ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };
		if ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };

		if ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };
		if ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };
		if ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };
		if ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };
		if ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };
		if ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };
		if ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };
		if ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };
		if ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };
		if ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };
		if ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };
		if ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };
		if ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };
		if ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };

	}

	_convertAddressMode( value ) {

		let addressMode = GPUAddressMode.ClampToEdge;

		if ( value === RepeatWrapping ) {

			addressMode = GPUAddressMode.Repeat;

		} else if ( value === MirroredRepeatWrapping ) {

			addressMode = GPUAddressMode.MirrorRepeat;

		}

		return addressMode;

	}

	_convertFilterMode( value ) {

		let filterMode = GPUFilterMode.Linear;

		if ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {

			filterMode = GPUFilterMode.Nearest;

		}

		return filterMode;

	}

	_getBytesPerTexel( format ) {

		// 8-bit formats
		if ( format === GPUTextureFormat.R8Unorm ||
			format === GPUTextureFormat.R8Snorm ||
			format === GPUTextureFormat.R8Uint ||
			format === GPUTextureFormat.R8Sint ) return 1;

		// 16-bit formats
		if ( format === GPUTextureFormat.R16Uint ||
			format === GPUTextureFormat.R16Sint ||
			format === GPUTextureFormat.R16Float ||
			format === GPUTextureFormat.RG8Unorm ||
			format === GPUTextureFormat.RG8Snorm ||
			format === GPUTextureFormat.RG8Uint ||
			format === GPUTextureFormat.RG8Sint ) return 2;

		// 32-bit formats
		if ( format === GPUTextureFormat.R32Uint ||
			format === GPUTextureFormat.R32Sint ||
			format === GPUTextureFormat.R32Float ||
			format === GPUTextureFormat.RG16Uint ||
			format === GPUTextureFormat.RG16Sint ||
			format === GPUTextureFormat.RG16Float ||
			format === GPUTextureFormat.RGBA8Unorm ||
			format === GPUTextureFormat.RGBA8UnormSRGB ||
			format === GPUTextureFormat.RGBA8Snorm ||
			format === GPUTextureFormat.RGBA8Uint ||
			format === GPUTextureFormat.RGBA8Sint ||
			format === GPUTextureFormat.BGRA8Unorm ||
			format === GPUTextureFormat.BGRA8UnormSRGB ||
			// Packed 32-bit formats
			format === GPUTextureFormat.RGB9E5UFloat ||
			format === GPUTextureFormat.RGB10A2Unorm ||
			format === GPUTextureFormat.RG11B10UFloat ||
			format === GPUTextureFormat.Depth32Float ||
			format === GPUTextureFormat.Depth24Plus ||
			format === GPUTextureFormat.Depth24PlusStencil8 ||
			format === GPUTextureFormat.Depth32FloatStencil8 ) return 4;

		// 64-bit formats
		if ( format === GPUTextureFormat.RG32Uint ||
			format === GPUTextureFormat.RG32Sint ||
			format === GPUTextureFormat.RG32Float ||
			format === GPUTextureFormat.RGBA16Uint ||
			format === GPUTextureFormat.RGBA16Sint ||
			format === GPUTextureFormat.RGBA16Float ) return 8;

		// 128-bit formats
		if ( format === GPUTextureFormat.RGBA32Uint ||
			format === GPUTextureFormat.RGBA32Sint ||
			format === GPUTextureFormat.RGBA32Float ) return 16;


	}

	_getTypedArrayType( format ) {

		if ( format === GPUTextureFormat.R8Uint ) return Uint8Array;
		if ( format === GPUTextureFormat.R8Sint ) return Int8Array;
		if ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;
		if ( format === GPUTextureFormat.R8Snorm ) return Int8Array;
		if ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;
		if ( format === GPUTextureFormat.RG8Sint ) return Int8Array;
		if ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;
		if ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;
		if ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;
		if ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;
		if ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;
		if ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;


		if ( format === GPUTextureFormat.R16Uint ) return Uint16Array;
		if ( format === GPUTextureFormat.R16Sint ) return Int16Array;
		if ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;
		if ( format === GPUTextureFormat.RG16Sint ) return Int16Array;
		if ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;
		if ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;
		if ( format === GPUTextureFormat.R16Float ) return Uint16Array;
		if ( format === GPUTextureFormat.RG16Float ) return Uint16Array;
		if ( format === GPUTextureFormat.RGBA16Float ) return Uint16Array;


		if ( format === GPUTextureFormat.R32Uint ) return Uint32Array;
		if ( format === GPUTextureFormat.R32Sint ) return Int32Array;
		if ( format === GPUTextureFormat.R32Float ) return Float32Array;
		if ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;
		if ( format === GPUTextureFormat.RG32Sint ) return Int32Array;
		if ( format === GPUTextureFormat.RG32Float ) return Float32Array;
		if ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;
		if ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;
		if ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;

		if ( format === GPUTextureFormat.BGRA8Unorm ) return Uint8Array;
		if ( format === GPUTextureFormat.BGRA8UnormSRGB ) return Uint8Array;
		if ( format === GPUTextureFormat.RGB10A2Unorm ) return Uint32Array;
		if ( format === GPUTextureFormat.RGB9E5UFloat ) return Uint32Array;
		if ( format === GPUTextureFormat.RG11B10UFloat ) return Uint32Array;

		if ( format === GPUTextureFormat.Depth32Float ) return Float32Array;
		if ( format === GPUTextureFormat.Depth24Plus ) return Uint32Array;
		if ( format === GPUTextureFormat.Depth24PlusStencil8 ) return Uint32Array;
		if ( format === GPUTextureFormat.Depth32FloatStencil8 ) return Float32Array;

	}

	_getDimension( texture ) {

		let dimension;

		if ( texture.isData3DTexture ) {

			dimension = GPUTextureDimension.ThreeD;

		} else {

			dimension = GPUTextureDimension.TwoD;

		}

		return dimension;

	}

}

function getFormat( texture, device = null ) {

	const format = texture.format;
	const type = texture.type;
	const colorSpace = texture.colorSpace;

	let formatGPU;

	if ( texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true ) {

		switch ( format ) {

			case RGBA_S3TC_DXT1_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
				break;

			case RGBA_S3TC_DXT3_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
				break;

			case RGBA_S3TC_DXT5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
				break;

			case RGB_ETC2_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
				break;

			case RGBA_ETC2_EAC_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
				break;

			case RGBA_ASTC_4x4_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
				break;

			case RGBA_ASTC_5x4_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
				break;

			case RGBA_ASTC_5x5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
				break;

			case RGBA_ASTC_6x5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
				break;

			case RGBA_ASTC_6x6_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
				break;

			case RGBA_ASTC_8x5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
				break;

			case RGBA_ASTC_8x6_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
				break;

			case RGBA_ASTC_8x8_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
				break;

			case RGBA_ASTC_10x5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
				break;

			case RGBA_ASTC_10x6_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
				break;

			case RGBA_ASTC_10x8_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
				break;

			case RGBA_ASTC_10x10_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
				break;

			case RGBA_ASTC_12x10_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
				break;

			case RGBA_ASTC_12x12_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
				break;

			case RGBAFormat:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
				break;

			default:
				console.error( 'WebGPURenderer: Unsupported texture format.', format );

		}

	} else {

		switch ( format ) {

			case RGBAFormat:

				switch ( type ) {

					case ByteType:
						formatGPU = GPUTextureFormat.RGBA8Snorm;
						break;

					case ShortType:
						formatGPU = GPUTextureFormat.RGBA16Sint;
						break;

					case UnsignedShortType:
						formatGPU = GPUTextureFormat.RGBA16Uint;
						break;
					case UnsignedIntType:
						formatGPU = GPUTextureFormat.RGBA32Uint;
						break;

					case IntType:
						formatGPU = GPUTextureFormat.RGBA32Sint;
						break;

					case UnsignedByteType:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
						break;

					case HalfFloatType:
						formatGPU = GPUTextureFormat.RGBA16Float;
						break;

					case FloatType:
						formatGPU = GPUTextureFormat.RGBA32Float;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );

				}

				break;

			case RGBFormat:

				switch ( type ) {

					case UnsignedInt5999Type:
						formatGPU = GPUTextureFormat.RGB9E5UFloat;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGBFormat.', type );

				}

				break;

			case RedFormat:

				switch ( type ) {

					case ByteType:
						formatGPU = GPUTextureFormat.R8Snorm;
						break;

					case ShortType:
						formatGPU = GPUTextureFormat.R16Sint;
						break;

					case UnsignedShortType:
						formatGPU = GPUTextureFormat.R16Uint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.R32Uint;
						break;

					case IntType:
						formatGPU = GPUTextureFormat.R32Sint;
						break;

					case UnsignedByteType:
						formatGPU = GPUTextureFormat.R8Unorm;
						break;

					case HalfFloatType:
						formatGPU = GPUTextureFormat.R16Float;
						break;

					case FloatType:
						formatGPU = GPUTextureFormat.R32Float;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );

				}

				break;

			case RGFormat:

				switch ( type ) {

					case ByteType:
						formatGPU = GPUTextureFormat.RG8Snorm;
						break;

					case ShortType:
						formatGPU = GPUTextureFormat.RG16Sint;
						break;

					case UnsignedShortType:
						formatGPU = GPUTextureFormat.RG16Uint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.RG32Uint;
						break;

					case IntType:
						formatGPU = GPUTextureFormat.RG32Sint;
						break;

					case UnsignedByteType:
						formatGPU = GPUTextureFormat.RG8Unorm;
						break;

					case HalfFloatType:
						formatGPU = GPUTextureFormat.RG16Float;
						break;

					case FloatType:
						formatGPU = GPUTextureFormat.RG32Float;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );

				}

				break;

			case DepthFormat:

				switch ( type ) {

					case UnsignedShortType:
						formatGPU = GPUTextureFormat.Depth16Unorm;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.Depth24Plus;
						break;

					case FloatType:
						formatGPU = GPUTextureFormat.Depth32Float;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );

				}

				break;

			case DepthStencilFormat:

				switch ( type ) {

					case UnsignedInt248Type:
						formatGPU = GPUTextureFormat.Depth24PlusStencil8;
						break;

					case FloatType:

						if ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {

							console.error( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.' );

						}

						formatGPU = GPUTextureFormat.Depth32FloatStencil8;

						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );

				}

				break;

			case RedIntegerFormat:

				switch ( type ) {

					case IntType:
						formatGPU = GPUTextureFormat.R32Sint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.R32Uint;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type );

				}

				break;

			case RGIntegerFormat:

				switch ( type ) {

					case IntType:
						formatGPU = GPUTextureFormat.RG32Sint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.RG32Uint;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type );

				}

				break;

			case RGBAIntegerFormat:

				switch ( type ) {

					case IntType:
						formatGPU = GPUTextureFormat.RGBA32Sint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.RGBA32Uint;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type );

				}

				break;

			default:
				console.error( 'WebGPURenderer: Unsupported texture format.', format );

		}

	}

	return formatGPU;

}

const declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i;
const propertiesRegexp = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig;

const wgslTypeLib$1 = {
	'f32': 'float',
	'i32': 'int',
	'u32': 'uint',
	'bool': 'bool',

	'vec2<f32>': 'vec2',
 	'vec2<i32>': 'ivec2',
 	'vec2<u32>': 'uvec2',
 	'vec2<bool>': 'bvec2',

	'vec2f': 'vec2',
	'vec2i': 'ivec2',
	'vec2u': 'uvec2',
	'vec2b': 'bvec2',

	'vec3<f32>': 'vec3',
	'vec3<i32>': 'ivec3',
	'vec3<u32>': 'uvec3',
	'vec3<bool>': 'bvec3',

	'vec3f': 'vec3',
	'vec3i': 'ivec3',
	'vec3u': 'uvec3',
	'vec3b': 'bvec3',

	'vec4<f32>': 'vec4',
	'vec4<i32>': 'ivec4',
	'vec4<u32>': 'uvec4',
	'vec4<bool>': 'bvec4',

	'vec4f': 'vec4',
	'vec4i': 'ivec4',
	'vec4u': 'uvec4',
	'vec4b': 'bvec4',

	'mat2x2<f32>': 'mat2',
	'mat2x2f': 'mat2',

	'mat3x3<f32>': 'mat3',
	'mat3x3f': 'mat3',

	'mat4x4<f32>': 'mat4',
	'mat4x4f': 'mat4',

	'sampler': 'sampler',

	'texture_1d': 'texture',

	'texture_2d': 'texture',
	'texture_2d_array': 'texture',
	'texture_multisampled_2d': 'cubeTexture',

	'texture_depth_2d': 'depthTexture',

	'texture_3d': 'texture3D',

	'texture_cube': 'cubeTexture',
	'texture_cube_array': 'cubeTexture',

	'texture_storage_1d': 'storageTexture',
	'texture_storage_2d': 'storageTexture',
	'texture_storage_2d_array': 'storageTexture',
	'texture_storage_3d': 'storageTexture'

};

const parse = ( source ) => {

	source = source.trim();

	const declaration = source.match( declarationRegexp );

	if ( declaration !== null && declaration.length === 4 ) {

		const inputsCode = declaration[ 2 ];
		const propsMatches = [];
		let match = null;

		while ( ( match = propertiesRegexp.exec( inputsCode ) ) !== null ) {

			propsMatches.push( { name: match[ 1 ], type: match[ 2 ] } );

		}

		// Process matches to correctly pair names and types
		const inputs = [];
		for ( let i = 0; i < propsMatches.length; i ++ ) {

			const { name, type } = propsMatches[ i ];

			let resolvedType = type;

			if ( resolvedType.startsWith( 'ptr' ) ) {

				resolvedType = 'pointer';

			} else {

				if ( resolvedType.startsWith( 'texture' ) ) {

					resolvedType = type.split( '<' )[ 0 ];

				}

				resolvedType = wgslTypeLib$1[ resolvedType ];

			}

			inputs.push( new NodeFunctionInput( resolvedType, name ) );

		}

		const blockCode = source.substring( declaration[ 0 ].length );
		const outputType = declaration[ 3 ] || 'void';

		const name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';
		const type = wgslTypeLib$1[ outputType ] || outputType;

		return {
			type,
			inputs,
			name,
			inputsCode,
			blockCode,
			outputType
		};

	} else {

		throw new Error( 'FunctionNode: Function is not a WGSL code.' );

	}

};

class WGSLNodeFunction extends NodeFunction {

	constructor( source ) {

		const { type, inputs, name, inputsCode, blockCode, outputType } = parse( source );

		super( type, inputs, name );

		this.inputsCode = inputsCode;
		this.blockCode = blockCode;
		this.outputType = outputType;

	}

	getCode( name = this.name ) {

		const outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';

		return `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ outputType }` + this.blockCode;

	}

}

class WGSLNodeParser extends NodeParser {

	parseFunction( source ) {

		return new WGSLNodeFunction( source );

	}

}

// GPUShaderStage is not defined in browsers not supporting WebGPU
const GPUShaderStage = ( typeof self !== 'undefined' ) ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };

const accessNames = {
	[ NodeAccess.READ_ONLY ]: 'read',
	[ NodeAccess.WRITE_ONLY ]: 'write',
	[ NodeAccess.READ_WRITE ]: 'read_write'
};

const wrapNames = {
	[ RepeatWrapping ]: 'repeat',
	[ ClampToEdgeWrapping ]: 'clamp',
	[ MirroredRepeatWrapping ]: 'mirror'
};

const gpuShaderStageLib = {
	'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,
	'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,
	'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4
};

const supports = {
	instance: true,
	swizzleAssign: false,
	storageBuffer: true
};

const wgslFnOpLib = {
	'^^': 'tsl_xor'
};

const wgslTypeLib = {
	float: 'f32',
	int: 'i32',
	uint: 'u32',
	bool: 'bool',
	color: 'vec3<f32>',

	vec2: 'vec2<f32>',
	ivec2: 'vec2<i32>',
	uvec2: 'vec2<u32>',
	bvec2: 'vec2<bool>',

	vec3: 'vec3<f32>',
	ivec3: 'vec3<i32>',
	uvec3: 'vec3<u32>',
	bvec3: 'vec3<bool>',

	vec4: 'vec4<f32>',
	ivec4: 'vec4<i32>',
	uvec4: 'vec4<u32>',
	bvec4: 'vec4<bool>',

	mat2: 'mat2x2<f32>',
	mat3: 'mat3x3<f32>',
	mat4: 'mat4x4<f32>'
};

const wgslCodeCache = {};

const wgslPolyfill = {
	tsl_xor: new CodeNode( 'fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }' ),
	mod_float: new CodeNode( 'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }' ),
	mod_vec2: new CodeNode( 'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }' ),
	mod_vec3: new CodeNode( 'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }' ),
	mod_vec4: new CodeNode( 'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }' ),
	equals_bool: new CodeNode( 'fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }' ),
	equals_bvec2: new CodeNode( 'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }' ),
	equals_bvec3: new CodeNode( 'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }' ),
	equals_bvec4: new CodeNode( 'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }' ),
	repeatWrapping_float: new CodeNode( 'fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }' ),
	mirrorWrapping_float: new CodeNode( 'fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }' ),
	clampWrapping_float: new CodeNode( 'fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }' ),
	biquadraticTexture: new CodeNode( /* wgsl */`
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
` )
};

const wgslMethods = {
	dFdx: 'dpdx',
	dFdy: '- dpdy',
	mod_float: 'tsl_mod_float',
	mod_vec2: 'tsl_mod_vec2',
	mod_vec3: 'tsl_mod_vec3',
	mod_vec4: 'tsl_mod_vec4',
	equals_bool: 'tsl_equals_bool',
	equals_bvec2: 'tsl_equals_bvec2',
	equals_bvec3: 'tsl_equals_bvec3',
	equals_bvec4: 'tsl_equals_bvec4',
	inversesqrt: 'inverseSqrt',
	bitcast: 'bitcast<f32>'
};

// WebGPU issue: does not support pow() with negative base on Windows

if ( typeof navigator !== 'undefined' && /Windows/g.test( navigator.userAgent ) ) {

	wgslPolyfill.pow_float = new CodeNode( 'fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }' );
	wgslPolyfill.pow_vec2 = new CodeNode( 'fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [ wgslPolyfill.pow_float ] );
	wgslPolyfill.pow_vec3 = new CodeNode( 'fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [ wgslPolyfill.pow_float ] );
	wgslPolyfill.pow_vec4 = new CodeNode( 'fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [ wgslPolyfill.pow_float ] );

	wgslMethods.pow_float = 'tsl_pow_float';
	wgslMethods.pow_vec2 = 'tsl_pow_vec2';
	wgslMethods.pow_vec3 = 'tsl_pow_vec3';
	wgslMethods.pow_vec4 = 'tsl_pow_vec4';

}

//

let diagnostics = '';

if ( ( typeof navigator !== 'undefined' && /Firefox|Deno/g.test( navigator.userAgent ) ) !== true ) {

	diagnostics += 'diagnostic( off, derivative_uniformity );\n';

}

//

class WGSLNodeBuilder extends NodeBuilder {

	constructor( object, renderer ) {

		super( object, renderer, new WGSLNodeParser() );

		this.uniformGroups = {};

		this.builtins = {};

		this.directives = {};

		this.scopedArrays = new Map();

	}

	needsToWorkingColorSpace( texture ) {

		return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;

	}

	_generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			if ( depthSnippet ) {

				return `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet } )`;

			} else {

				return `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet } )`;

			}

		} else if ( this.isFilteredTexture( texture ) ) {

			return this.generateFilteredTexture( texture, textureProperty, uvSnippet );

		} else {

			return this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0' );

		}

	}

	_generateVideoSample( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			return `textureSampleBaseClampToEdge( ${ textureProperty }, ${ textureProperty }_sampler, vec2<f32>( ${ uvSnippet }.x, 1.0 - ${ uvSnippet }.y ) )`;

		} else {

			console.error( `WebGPURenderer: THREE.VideoTexture does not support ${ shaderStage } shader.` );

		}

	}

	_generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' && this.isUnfilterable( texture ) === false ) {

			return `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;

		} else if ( this.isFilteredTexture( texture ) ) {

			return this.generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet );

		} else {

			return this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet );

		}

	}

	generateWrapFunction( texture ) {

		const functionName = `tsl_coord_${ wrapNames[ texture.wrapS ] }S_${ wrapNames[ texture.wrapT ] }T`;

		let nodeCode = wgslCodeCache[ functionName ];

		if ( nodeCode === undefined ) {

			const includes = [];

			let code = `fn ${ functionName }( coord : vec2f ) -> vec2f {\n\n\treturn vec2f(\n`;

			const addWrapSnippet = ( wrap, axis ) => {

				if ( wrap === RepeatWrapping ) {

					includes.push( wgslPolyfill.repeatWrapping_float );

					code += `\t\ttsl_repeatWrapping_float( coord.${ axis } )`;

				} else if ( wrap === ClampToEdgeWrapping ) {

					includes.push( wgslPolyfill.clampWrapping_float );

					code += `\t\ttsl_clampWrapping_float( coord.${ axis } )`;

				} else if ( wrap === MirroredRepeatWrapping ) {

					includes.push( wgslPolyfill.mirrorWrapping_float );

					code += `\t\ttsl_mirrorWrapping_float( coord.${ axis } )`;

				} else {

					code += `\t\tcoord.${ axis }`;

					console.warn( `WebGPURenderer: Unsupported texture wrap type "${ wrap }" for vertex shader.` );

				}

			};

			addWrapSnippet( texture.wrapS, 'x' );

			code += ',\n';

			addWrapSnippet( texture.wrapT, 'y' );

			code += '\n\t);\n\n}\n';

			wgslCodeCache[ functionName ] = nodeCode = new CodeNode( code, includes );

		}

		nodeCode.build( this );

		return functionName;

	}

	generateTextureDimension( texture, textureProperty, levelSnippet ) {

		const textureData = this.getDataFromNode( texture, this.shaderStage, this.globalCache );

		if ( textureData.dimensionsSnippet === undefined ) textureData.dimensionsSnippet = {};

		let textureDimensionNode = textureData.dimensionsSnippet[ levelSnippet ];

		if ( textureData.dimensionsSnippet[ levelSnippet ] === undefined ) {

			let textureDimensionsParams;

			if ( texture.isMultisampleRenderTargetTexture === true ) {

				textureDimensionsParams = textureProperty;

			} else {

				textureDimensionsParams = `${ textureProperty }, u32( ${ levelSnippet } )`;

			}

			textureDimensionNode = new VarNode( new ExpressionNode( `textureDimensions( ${ textureDimensionsParams } )`, 'uvec2' ) );

			textureData.dimensionsSnippet[ levelSnippet ] = textureDimensionNode;

		}

		return textureDimensionNode.build( this );

	}

	generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet = '0u' ) {

		this._include( 'biquadraticTexture' );

		const wrapFunction = this.generateWrapFunction( texture );
		const textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );

		return `tsl_biquadraticTexture( ${ textureProperty }, ${ wrapFunction }( ${ uvSnippet } ), ${ textureDimension }, u32( ${ levelSnippet } ) )`;

	}

	generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u' ) {

		const wrapFunction = this.generateWrapFunction( texture );
		const textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );

		const coordSnippet = `vec2u( ${ wrapFunction }( ${ uvSnippet } ) * vec2f( ${ textureDimension } ) )`;

		return this.generateTextureLoad( texture, textureProperty, coordSnippet, depthSnippet, levelSnippet );

	}

	generateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u' ) {

		if ( texture.isVideoTexture === true || texture.isStorageTexture === true ) {

			return `textureLoad( ${ textureProperty }, ${ uvIndexSnippet } )`;

		} else if ( depthSnippet ) {

			return `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, u32( ${ levelSnippet } ) )`;

		} else {

			return `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, u32( ${ levelSnippet } ) )`;

		}

	}

	generateTextureStore( texture, textureProperty, uvIndexSnippet, valueSnippet ) {

		return `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ valueSnippet } )`;

	}

	isSampleCompare( texture ) {

		return texture.isDepthTexture === true && texture.compareFunction !== null;

	}

	isUnfilterable( texture ) {

		return this.getComponentTypeFromTexture( texture ) !== 'float' ||
			( ! this.isAvailable( 'float32Filterable' ) && texture.isDataTexture === true && texture.type === FloatType ) ||
			( this.isSampleCompare( texture ) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter ) ||
			texture.isMultisampleRenderTargetTexture === true;

	}

	generateTexture( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		let snippet = null;

		if ( texture.isVideoTexture === true ) {

			snippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );

		} else if ( this.isUnfilterable( texture ) ) {

			snippet = this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage );

		} else {

			snippet = this._generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage );

		}

		return snippet;

	}

	generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			// TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy
			return `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;

		} else {

			console.error( `WebGPURenderer: THREE.TextureNode.gradient() does not support ${ shaderStage } shader.` );

		}

	}

	generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			return `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet } )`;

		} else {

			console.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );

		}

	}

	generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		let snippet = null;

		if ( texture.isVideoTexture === true ) {

			snippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );

		} else {

			snippet = this._generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage );

		}

		return snippet;

	}

	generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			return `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet } )`;

		} else {

			console.error( `WebGPURenderer: THREE.TextureNode.biasNode does not support ${ shaderStage } shader.` );

		}

	}

	getPropertyName( node, shaderStage = this.shaderStage ) {

		if ( node.isNodeVarying === true && node.needsInterpolation === true ) {

			if ( shaderStage === 'vertex' ) {

				return `varyings.${ node.name }`;

			}

		} else if ( node.isNodeUniform === true ) {

			const name = node.name;
			const type = node.type;

			if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {

				return name;

			} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {

				return `NodeBuffer_${ node.id }.${name}`;

			} else {

				return node.groupNode.name + '.' + name;

			}

		}

		return super.getPropertyName( node );

	}

	getOutputStructName() {

		return 'output';

	}

	_getUniformGroupCount( shaderStage ) {

		return Object.keys( this.uniforms[ shaderStage ] ).length;

	}

	getFunctionOperator( op ) {

		const fnOp = wgslFnOpLib[ op ];

		if ( fnOp !== undefined ) {

			this._include( fnOp );

			return fnOp;

		}

		return null;

	}

	getNodeAccess( node, shaderStage ) {

		if ( shaderStage !== 'compute' )
			return NodeAccess.READ_ONLY;

		return node.access;

	}

	getStorageAccess( node, shaderStage ) {

		return accessNames[ this.getNodeAccess( node, shaderStage ) ];

	}

	getUniformFromNode( node, type, shaderStage, name = null ) {

		const uniformNode = super.getUniformFromNode( node, type, shaderStage, name );
		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

		if ( nodeData.uniformGPU === undefined ) {

			let uniformGPU;

			const group = node.groupNode;
			const groupName = group.name;

			const bindings = this.getBindGroupArray( groupName, shaderStage );

			if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {

				let texture = null;

				const access = this.getNodeAccess( node, shaderStage );

				if ( type === 'texture' || type === 'storageTexture' ) {

					texture = new NodeSampledTexture( uniformNode.name, uniformNode.node, group, access );

				} else if ( type === 'cubeTexture' ) {

					texture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group, access );

				} else if ( type === 'texture3D' ) {

					texture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );

				}

				texture.store = node.isStorageTextureNode === true;
				texture.setVisibility( gpuShaderStageLib[ shaderStage ] );

				if ( shaderStage === 'fragment' && this.isUnfilterable( node.value ) === false && texture.store === false ) {

					const sampler = new NodeSampler( `${uniformNode.name}_sampler`, uniformNode.node, group );
					sampler.setVisibility( gpuShaderStageLib[ shaderStage ] );

					bindings.push( sampler, texture );

					uniformGPU = [ sampler, texture ];

				} else {

					bindings.push( texture );

					uniformGPU = [ texture ];

				}

			} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {

				const bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;

				const buffer = new bufferClass( node, group );
				buffer.setVisibility( gpuShaderStageLib[ shaderStage ] );

				bindings.push( buffer );

				uniformGPU = buffer;

			} else {

				const uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );

				let uniformsGroup = uniformsStage[ groupName ];

				if ( uniformsGroup === undefined ) {

					uniformsGroup = new NodeUniformsGroup( groupName, group );
					uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );

					uniformsStage[ groupName ] = uniformsGroup;

					bindings.push( uniformsGroup );

				}

				uniformGPU = this.getNodeUniform( uniformNode, type );

				uniformsGroup.addUniform( uniformGPU );

			}

			nodeData.uniformGPU = uniformGPU;

		}

		return uniformNode;

	}

	getBuiltin( name, property, type, shaderStage = this.shaderStage ) {

		const map = this.builtins[ shaderStage ] || ( this.builtins[ shaderStage ] = new Map() );

		if ( map.has( name ) === false ) {

			map.set( name, {
				name,
				property,
				type
			} );

		}

		return property;

	}

	hasBuiltin( name, shaderStage = this.shaderStage ) {

		return ( this.builtins[ shaderStage ] !== undefined && this.builtins[ shaderStage ].has( name ) );

	}

	getVertexIndex() {

		if ( this.shaderStage === 'vertex' ) {

			return this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );

		}

		return 'vertexIndex';

	}

	buildFunctionCode( shaderNode ) {

		const layout = shaderNode.layout;
		const flowData = this.flowShaderNode( shaderNode );

		const parameters = [];

		for ( const input of layout.inputs ) {

			parameters.push( input.name + ' : ' + this.getType( input.type ) );

		}

		//

		let code = `fn ${ layout.name }( ${ parameters.join( ', ' ) } ) -> ${ this.getType( layout.type ) } {
${ flowData.vars }
${ flowData.code }
`;

		if ( flowData.result ) {

			code += `\treturn ${ flowData.result };\n`;

		}

		code += '\n}\n';

		//

		return code;

	}

	getInstanceIndex() {

		if ( this.shaderStage === 'vertex' ) {

			return this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );

		}

		return 'instanceIndex';

	}

	getInvocationLocalIndex() {

		return this.getBuiltin( 'local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute' );

	}

	getSubgroupSize() {

		this.enableSubGroups();

		return this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );

	}

	getInvocationSubgroupIndex() {

		this.enableSubGroups();

		return this.getBuiltin( 'subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute' );

	}

	getSubgroupIndex() {

		this.enableSubGroups();

		return this.getBuiltin( 'subgroup_id', 'subgroupIndex', 'u32', 'attribute' );

	}

	getDrawIndex() {

		return null;

	}

	getFrontFacing() {

		return this.getBuiltin( 'front_facing', 'isFront', 'bool' );

	}

	getFragCoord() {

		return this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>' ) + '.xy';

	}

	getFragDepth() {

		return 'output.' + this.getBuiltin( 'frag_depth', 'depth', 'f32', 'output' );

	}

	getClipDistance() {

		return 'varyings.hw_clip_distances';

	}

	isFlipY() {

		return false;

	}

	enableDirective( name, shaderStage = this.shaderStage ) {

		const stage = this.directives[ shaderStage ] || ( this.directives[ shaderStage ] = new Set() );
		stage.add( name );

	}

	getDirectives( shaderStage ) {

		const snippets = [];
		const directives = this.directives[ shaderStage ];

		if ( directives !== undefined ) {

			for ( const directive of directives ) {

				snippets.push( `enable ${directive};` );

			}

		}

		return snippets.join( '\n' );

	}

	enableSubGroups() {

		this.enableDirective( 'subgroups' );

	}

	enableSubgroupsF16() {

		this.enableDirective( 'subgroups-f16' );

	}

	enableClipDistances() {

		this.enableDirective( 'clip_distances' );

	}

	enableShaderF16() {

		this.enableDirective( 'f16' );

	}

	enableDualSourceBlending() {

		this.enableDirective( 'dual_source_blending' );

	}

	enableHardwareClipping( planeCount ) {

		this.enableClipDistances();
		this.getBuiltin( 'clip_distances', 'hw_clip_distances', `array<f32, ${ planeCount } >`, 'vertex' );

	}

	getBuiltins( shaderStage ) {

		const snippets = [];
		const builtins = this.builtins[ shaderStage ];

		if ( builtins !== undefined ) {

			for ( const { name, property, type } of builtins.values() ) {

				snippets.push( `@builtin( ${name} ) ${property} : ${type}` );

			}

		}

		return snippets.join( ',\n\t' );

	}

	getScopedArray( name, scope, bufferType, bufferCount ) {

		if ( this.scopedArrays.has( name ) === false ) {

			this.scopedArrays.set( name, {
				name,
				scope,
				bufferType,
				bufferCount
			} );

		}

		return name;

	}

	getScopedArrays( shaderStage ) {

		if ( shaderStage !== 'compute' ) {

			return;

		}

		const snippets = [];

		for ( const { name, scope, bufferType, bufferCount } of this.scopedArrays.values() ) {

			const type = this.getType( bufferType );

			snippets.push( `var<${scope}> ${name}: array< ${type}, ${bufferCount} >;` );

		}

		return snippets.join( '\n' );

	}

	getAttributes( shaderStage ) {

		const snippets = [];

		if ( shaderStage === 'compute' ) {

			this.getBuiltin( 'global_invocation_id', 'id', 'vec3<u32>', 'attribute' );
			this.getBuiltin( 'workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute' );
			this.getBuiltin( 'local_invocation_id', 'localId', 'vec3<u32>', 'attribute' );
			this.getBuiltin( 'num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute' );

			if ( this.renderer.hasFeature( 'subgroups' ) ) {

				this.enableDirective( 'subgroups', shaderStage );
				this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );

			}

		}

		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

			const builtins = this.getBuiltins( 'attribute' );

			if ( builtins ) snippets.push( builtins );

			const attributes = this.getAttributesArray();

			for ( let index = 0, length = attributes.length; index < length; index ++ ) {

				const attribute = attributes[ index ];
				const name = attribute.name;
				const type = this.getType( attribute.type );

				snippets.push( `@location( ${index} ) ${ name } : ${ type }` );

			}

		}

		return snippets.join( ',\n\t' );

	}

	getStructMembers( struct ) {

		const snippets = [];
		const members = struct.getMemberTypes();

		for ( let i = 0; i < members.length; i ++ ) {

			const member = members[ i ];
			snippets.push( `\t@location( ${i} ) m${i} : ${ member }<f32>` );

		}

		const builtins = this.getBuiltins( 'output' );

		if ( builtins ) snippets.push( '\t' + builtins );

		return snippets.join( ',\n' );

	}

	getStructs( shaderStage ) {

		const snippets = [];
		const structs = this.structs[ shaderStage ];

		for ( let index = 0, length = structs.length; index < length; index ++ ) {

			const struct = structs[ index ];
			const name = struct.name;

			let snippet = `\struct ${ name } {\n`;
			snippet += this.getStructMembers( struct );
			snippet += '\n}';


			snippets.push( snippet );

			snippets.push( `\nvar<private> output : ${ name };\n\n` );

		}

		return snippets.join( '\n\n' );

	}

	getVar( type, name ) {

		return `var ${ name } : ${ this.getType( type ) }`;

	}

	getVars( shaderStage ) {

		const snippets = [];
		const vars = this.vars[ shaderStage ];

		if ( vars !== undefined ) {

			for ( const variable of vars ) {

				snippets.push( `\t${ this.getVar( variable.type, variable.name ) };` );

			}

		}

		return `\n${ snippets.join( '\n' ) }\n`;

	}

	getVaryings( shaderStage ) {

		const snippets = [];

		if ( shaderStage === 'vertex' ) {

			this.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );

		}

		if ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {

			const varyings = this.varyings;
			const vars = this.vars[ shaderStage ];

			for ( let index = 0; index < varyings.length; index ++ ) {

				const varying = varyings[ index ];

				if ( varying.needsInterpolation ) {

					let attributesSnippet = `@location( ${index} )`;

					if ( /^(int|uint|ivec|uvec)/.test( varying.type ) ) {

						attributesSnippet += ' @interpolate( flat )';


					}

					snippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );

				} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {

					vars.push( varying );

				}

			}

		}

		const builtins = this.getBuiltins( shaderStage );

		if ( builtins ) snippets.push( builtins );

		const code = snippets.join( ',\n\t' );

		return shaderStage === 'vertex' ? this._getWGSLStruct( 'VaryingsStruct', '\t' + code ) : code;

	}

	getUniforms( shaderStage ) {

		const uniforms = this.uniforms[ shaderStage ];

		const bindingSnippets = [];
		const bufferSnippets = [];
		const structSnippets = [];
		const uniformGroups = {};

		for ( const uniform of uniforms ) {

			const groupName = uniform.groupNode.name;
			const uniformIndexes = this.bindingsIndexes[ groupName ];

			if ( uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D' ) {

				const texture = uniform.node.value;

				if ( shaderStage === 'fragment' && this.isUnfilterable( texture ) === false && uniform.node.isStorageTextureNode !== true ) {

					if ( this.isSampleCompare( texture ) ) {

						bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler_comparison;` );

					} else {

						bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler;` );

					}

				}

				let textureType;

				let multisampled = '';

				if ( texture.isMultisampleRenderTargetTexture === true ) {

					multisampled = '_multisampled';

				}

				if ( texture.isCubeTexture === true ) {

					textureType = 'texture_cube<f32>';

				} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

					textureType = 'texture_2d_array<f32>';

				} else if ( texture.isDepthTexture === true ) {

					textureType = `texture_depth${multisampled}_2d`;

				} else if ( texture.isVideoTexture === true ) {

					textureType = 'texture_external';

				} else if ( texture.isData3DTexture === true ) {

					textureType = 'texture_3d<f32>';

				} else if ( uniform.node.isStorageTextureNode === true ) {

					const format = getFormat( texture );
					const access = this.getStorageAccess( uniform.node, shaderStage );

					textureType = `texture_storage_2d<${ format }, ${ access }>`;

				} else {

					const componentPrefix = this.getComponentTypeFromTexture( texture ).charAt( 0 );

					textureType = `texture${multisampled}_2d<${ componentPrefix }32>`;

				}

				bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name } : ${ textureType };` );

			} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer' ) {

				const bufferNode = uniform.node;
				const bufferType = this.getType( bufferNode.bufferType );
				const bufferCount = bufferNode.bufferCount;

				const bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';
				const bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;
				const bufferSnippet = `\t${ uniform.name } : array< ${ bufferTypeSnippet }${ bufferCountSnippet } >\n`;
				const bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${ this.getStorageAccess( bufferNode, shaderStage ) }` : 'uniform';

				bufferSnippets.push( this._getWGSLStructBinding( 'NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, uniformIndexes.binding ++, uniformIndexes.group ) );

			} else {

				const vectorType = this.getType( this.getVectorType( uniform.type ) );
				const groupName = uniform.groupNode.name;

				const group = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = {
					index: uniformIndexes.binding ++,
					id: uniformIndexes.group,
					snippets: []
				} );

				group.snippets.push( `\t${ uniform.name } : ${ vectorType }` );

			}

		}

		for ( const name in uniformGroups ) {

			const group = uniformGroups[ name ];

			structSnippets.push( this._getWGSLStructBinding( name, group.snippets.join( ',\n' ), 'uniform', group.index, group.id ) );

		}

		let code = bindingSnippets.join( '\n' );
		code += bufferSnippets.join( '\n' );
		code += structSnippets.join( '\n' );

		return code;

	}

	buildCode() {

		const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };

		this.sortBindingGroups();

		for ( const shaderStage in shadersData ) {

			const stageData = shadersData[ shaderStage ];
			stageData.uniforms = this.getUniforms( shaderStage );
			stageData.attributes = this.getAttributes( shaderStage );
			stageData.varyings = this.getVaryings( shaderStage );
			stageData.structs = this.getStructs( shaderStage );
			stageData.vars = this.getVars( shaderStage );
			stageData.codes = this.getCodes( shaderStage );
			stageData.directives = this.getDirectives( shaderStage );
			stageData.scopedArrays = this.getScopedArrays( shaderStage );

			//

			let flow = '// code\n\n';
			flow += this.flowCode[ shaderStage ];

			const flowNodes = this.flowNodes[ shaderStage ];
			const mainNode = flowNodes[ flowNodes.length - 1 ];

			const outputNode = mainNode.outputNode;
			const isOutputStruct = ( outputNode !== undefined && outputNode.isOutputStructNode === true );

			for ( const node of flowNodes ) {

				const flowSlotData = this.getFlowData( node/*, shaderStage*/ );
				const slotName = node.name;

				if ( slotName ) {

					if ( flow.length > 0 ) flow += '\n';

					flow += `\t// flow -> ${ slotName }\n\t`;

				}

				flow += `${ flowSlotData.code }\n\t`;

				if ( node === mainNode && shaderStage !== 'compute' ) {

					flow += '// result\n\n\t';

					if ( shaderStage === 'vertex' ) {

						flow += `varyings.Vertex = ${ flowSlotData.result };`;

					} else if ( shaderStage === 'fragment' ) {

						if ( isOutputStruct ) {

							stageData.returnType = outputNode.nodeType;

							flow += `return ${ flowSlotData.result };`;

						} else {

							let structSnippet = '\t@location(0) color: vec4<f32>';

							const builtins = this.getBuiltins( 'output' );

							if ( builtins ) structSnippet += ',\n\t' + builtins;

							stageData.returnType = 'OutputStruct';
							stageData.structs += this._getWGSLStruct( 'OutputStruct', structSnippet );
							stageData.structs += '\nvar<private> output : OutputStruct;\n\n';

							flow += `output.color = ${ flowSlotData.result };\n\n\treturn output;`;

						}

					}

				}

			}

			stageData.flow = flow;


		}

		if ( this.material !== null ) {

			this.vertexShader = this._getWGSLVertexCode( shadersData.vertex );
			this.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );

		} else {

			this.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );

		}

	}

	getMethod( method, output = null ) {

		let wgslMethod;

		if ( output !== null ) {

			wgslMethod = this._getWGSLMethod( method + '_' + output );

		}

		if ( wgslMethod === undefined ) {

			wgslMethod = this._getWGSLMethod( method );

		}

		return wgslMethod || method;

	}

	getType( type ) {

		return wgslTypeLib[ type ] || type;

	}

	isAvailable( name ) {

		let result = supports[ name ];

		if ( result === undefined ) {

			if ( name === 'float32Filterable' ) {

				result = this.renderer.hasFeature( 'float32-filterable' );

			} else if ( name === 'clipDistance' ) {

				result = this.renderer.hasFeature( 'clip-distances' );

			}

			supports[ name ] = result;

		}

		return result;

	}

	_getWGSLMethod( method ) {

		if ( wgslPolyfill[ method ] !== undefined ) {

			this._include( method );

		}

		return wgslMethods[ method ];

	}

	_include( name ) {

		const codeNode = wgslPolyfill[ name ];
		codeNode.build( this );

		if ( this.currentFunctionNode !== null ) {

			this.currentFunctionNode.includes.push( codeNode );

		}

		return codeNode;

	}

	_getWGSLVertexCode( shaderData ) {

		return `${ this.getSignature() }
// directives
${shaderData.directives}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return varyings;

}
`;

	}

	_getWGSLFragmentCode( shaderData ) {

		return `${ this.getSignature() }
// global
${ diagnostics }

// uniforms
${shaderData.uniforms}

// structs
${shaderData.structs}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

	}

	_getWGSLComputeCode( shaderData, workgroupSize ) {

		return `${ this.getSignature() }
// directives
${shaderData.directives}

// system
var<private> instanceIndex : u32;

// locals
${shaderData.scopedArrays}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSize} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = id.x + id.y * numWorkgroups.x * u32(${workgroupSize}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

	}

	_getWGSLStruct( name, vars ) {

		return `
struct ${name} {
${vars}
};`;

	}

	_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {

		const structName = name + 'Struct';
		const structSnippet = this._getWGSLStruct( structName, vars );

		return `${structSnippet}
@binding( ${binding} ) @group( ${group} )
var<${access}> ${name} : ${structName};`;

	}

}

class WebGPUUtils {

	constructor( backend ) {

		this.backend = backend;

	}

	getCurrentDepthStencilFormat( renderContext ) {

		let format;

		if ( renderContext.depthTexture !== null ) {

			format = this.getTextureFormatGPU( renderContext.depthTexture );

		} else if ( renderContext.depth && renderContext.stencil ) {

			format = GPUTextureFormat.Depth24PlusStencil8;

		} else if ( renderContext.depth ) {

			format = GPUTextureFormat.Depth24Plus;

		}

		return format;

	}

	getTextureFormatGPU( texture ) {

		return this.backend.get( texture ).format;

	}

	getCurrentColorFormat( renderContext ) {

		let format;

		if ( renderContext.textures !== null ) {

			format = this.getTextureFormatGPU( renderContext.textures[ 0 ] );

		} else {

			format = this.getPreferredCanvasFormat(); // default context format

		}

		return format;

	}

	getCurrentColorSpace( renderContext ) {

		if ( renderContext.textures !== null ) {

			return renderContext.textures[ 0 ].colorSpace;

		}

		return this.backend.renderer.outputColorSpace;

	}

	getPrimitiveTopology( object, material ) {

		if ( object.isPoints ) return GPUPrimitiveTopology.PointList;
		else if ( object.isLineSegments || ( object.isMesh && material.wireframe === true ) ) return GPUPrimitiveTopology.LineList;
		else if ( object.isLine ) return GPUPrimitiveTopology.LineStrip;
		else if ( object.isMesh ) return GPUPrimitiveTopology.TriangleList;

	}

	getSampleCount( sampleCount ) {

		let count = 1;

		if ( sampleCount > 1 ) {

			// WebGPU only supports power-of-two sample counts and 2 is not a valid value
			count = Math.pow( 2, Math.floor( Math.log2( sampleCount ) ) );

			if ( count === 2 ) {

				count = 4;

			}

		}

		return count;

	}

	getSampleCountRenderContext( renderContext ) {

		if ( renderContext.textures !== null ) {

			return this.getSampleCount( renderContext.sampleCount );

		}

		return this.getSampleCount( this.backend.renderer.samples );

	}

	getPreferredCanvasFormat() {

		// TODO: Remove this check when Quest 34.5 is out
		// https://github.com/mrdoob/three.js/pull/29221/files#r1731833949

		if ( navigator.userAgent.includes( 'Quest' ) ) {

			return GPUTextureFormat.BGRA8Unorm;

		} else {

			return navigator.gpu.getPreferredCanvasFormat();

		}

	}

}

const typedArraysToVertexFormatPrefix = new Map( [
	[ Int8Array, [ 'sint8', 'snorm8' ]],
	[ Uint8Array, [ 'uint8', 'unorm8' ]],
	[ Int16Array, [ 'sint16', 'snorm16' ]],
	[ Uint16Array, [ 'uint16', 'unorm16' ]],
	[ Int32Array, [ 'sint32', 'snorm32' ]],
	[ Uint32Array, [ 'uint32', 'unorm32' ]],
	[ Float32Array, [ 'float32', ]],
] );

const typedAttributeToVertexFormatPrefix = new Map( [
	[ Float16BufferAttribute, [ 'float16', ]],
] );

const typeArraysToVertexFormatPrefixForItemSize1 = new Map( [
	[ Int32Array, 'sint32' ],
	[ Int16Array, 'sint32' ], // patch for INT16
	[ Uint32Array, 'uint32' ],
	[ Uint16Array, 'uint32' ], // patch for UINT16
	[ Float32Array, 'float32' ]
] );

class WebGPUAttributeUtils {

	constructor( backend ) {

		this.backend = backend;

	}

	createAttribute( attribute, usage ) {

		const bufferAttribute = this._getBufferAttribute( attribute );

		const backend = this.backend;
		const bufferData = backend.get( bufferAttribute );

		let buffer = bufferData.buffer;

		if ( buffer === undefined ) {

			const device = backend.device;

			let array = bufferAttribute.array;

			// patch for INT16 and UINT16
			if ( attribute.normalized === false && ( array.constructor === Int16Array || array.constructor === Uint16Array ) ) {

				const tempArray = new Uint32Array( array.length );
				for ( let i = 0; i < array.length; i ++ ) {

					tempArray[ i ] = array[ i ];

				}

				array = tempArray;

			}

			bufferAttribute.array = array;

			if ( ( bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute ) && bufferAttribute.itemSize === 3 ) {

				array = new array.constructor( bufferAttribute.count * 4 );

				for ( let i = 0; i < bufferAttribute.count; i ++ ) {

					array.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );

				}

				// Update BufferAttribute
				bufferAttribute.itemSize = 4;
				bufferAttribute.array = array;

			}

			const size = array.byteLength + ( ( 4 - ( array.byteLength % 4 ) ) % 4 ); // ensure 4 byte alignment, see #20441

			buffer = device.createBuffer( {
				label: bufferAttribute.name,
				size: size,
				usage: usage,
				mappedAtCreation: true
			} );

			new array.constructor( buffer.getMappedRange() ).set( array );

			buffer.unmap();

			bufferData.buffer = buffer;

		}

	}

	updateAttribute( attribute ) {

		const bufferAttribute = this._getBufferAttribute( attribute );

		const backend = this.backend;
		const device = backend.device;

		const buffer = backend.get( bufferAttribute ).buffer;

		const array = bufferAttribute.array;
		const isTypedArray = this._isTypedArray( array );
		const updateRanges = bufferAttribute.updateRanges;

		if ( updateRanges.length === 0 ) {

			// Not using update ranges

			device.queue.writeBuffer(
				buffer,
				0,
				array,
				0
			);

		} else {

			const byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;

			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

				const range = updateRanges[ i ];

				const dataOffset = range.start * byteOffsetFactor;
				const size = range.count * byteOffsetFactor;

				device.queue.writeBuffer(
					buffer,
					0,
					array,
					dataOffset,
					size
				);

			}

			bufferAttribute.clearUpdateRanges();

		}

	}

	createShaderVertexBuffers( renderObject ) {

		const attributes = renderObject.getAttributes();
		const vertexBuffers = new Map();

		for ( let slot = 0; slot < attributes.length; slot ++ ) {

			const geometryAttribute = attributes[ slot ];
			const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
			const bufferAttribute = this._getBufferAttribute( geometryAttribute );

			let vertexBufferLayout = vertexBuffers.get( bufferAttribute );

			if ( vertexBufferLayout === undefined ) {

				let arrayStride, stepMode;

				if ( geometryAttribute.isInterleavedBufferAttribute === true ) {

					arrayStride = geometryAttribute.data.stride * bytesPerElement;
					stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;

				} else {

					arrayStride = geometryAttribute.itemSize * bytesPerElement;
					stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;

				}

				// patch for INT16 and UINT16
				if ( geometryAttribute.normalized === false && ( geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array ) ) {

					arrayStride = 4;

				}

				vertexBufferLayout = {
					arrayStride,
					attributes: [],
					stepMode
				};

				vertexBuffers.set( bufferAttribute, vertexBufferLayout );

			}

			const format = this._getVertexFormat( geometryAttribute );
			const offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;

			vertexBufferLayout.attributes.push( {
				shaderLocation: slot,
				offset,
				format
			} );

		}

		return Array.from( vertexBuffers.values() );

	}

	destroyAttribute( attribute ) {

		const backend = this.backend;
		const data = backend.get( this._getBufferAttribute( attribute ) );

		data.buffer.destroy();

		backend.delete( attribute );

	}

	async getArrayBufferAsync( attribute ) {

		const backend = this.backend;
		const device = backend.device;

		const data = backend.get( this._getBufferAttribute( attribute ) );

		const bufferGPU = data.buffer;
		const size = bufferGPU.size;

		const readBufferGPU = device.createBuffer( {
			label: attribute.name,
			size,
			usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
		} );


		const cmdEncoder = device.createCommandEncoder( {} );

		cmdEncoder.copyBufferToBuffer(
			bufferGPU,
			0,
			readBufferGPU,
			0,
			size
		);

		readBufferGPU.unmap();

		const gpuCommands = cmdEncoder.finish();
		device.queue.submit( [ gpuCommands ] );

		await readBufferGPU.mapAsync( GPUMapMode.READ );

		const arrayBuffer = readBufferGPU.getMappedRange();

		return arrayBuffer;

	}

	_getVertexFormat( geometryAttribute ) {

		const { itemSize, normalized } = geometryAttribute;
		const ArrayType = geometryAttribute.array.constructor;
		const AttributeType = geometryAttribute.constructor;

		let format;

		if ( itemSize == 1 ) {

			format = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );

		} else {

			const prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );
			const prefix = prefixOptions[ normalized ? 1 : 0 ];

			if ( prefix ) {

				const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
				const paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;
				const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;

				if ( paddedItemSize % 1 ) {

					throw new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );

				}

				format = `${prefix}x${paddedItemSize}`;

			}

		}

		if ( ! format ) {

			console.error( 'THREE.WebGPUAttributeUtils: Vertex format not supported yet.' );

		}

		return format;

	}

	_isTypedArray( array ) {

		return ArrayBuffer.isView( array ) && ! ( array instanceof DataView );

	}

	_getBufferAttribute( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return attribute;

	}

}

class WebGPUBindingUtils {

	constructor( backend ) {

		this.backend = backend;
		this.bindGroupLayoutCache = new WeakMap();

	}

	createBindingsLayout( bindGroup ) {

		const backend = this.backend;
		const device = backend.device;

		const entries = [];

		let index = 0;

		for ( const binding of bindGroup.bindings ) {

			const bindingGPU = {
				binding: index ++,
				visibility: binding.visibility
			};

			if ( binding.isUniformBuffer || binding.isStorageBuffer ) {

				const buffer = {}; // GPUBufferBindingLayout

				if ( binding.isStorageBuffer ) {

					if ( binding.visibility & 4 ) {

						// compute

						if ( binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY ) {

							buffer.type = GPUBufferBindingType.Storage;

						} else {

							buffer.type = GPUBufferBindingType.ReadOnlyStorage;

						}

					} else {

						buffer.type = GPUBufferBindingType.ReadOnlyStorage;

					}

				}

				bindingGPU.buffer = buffer;

			} else if ( binding.isSampler ) {

				const sampler = {}; // GPUSamplerBindingLayout

				if ( binding.texture.isDepthTexture ) {

					if ( binding.texture.compareFunction !== null ) {

						sampler.type = 'comparison';

					}

				}

				bindingGPU.sampler = sampler;

			} else if ( binding.isSampledTexture && binding.texture.isVideoTexture ) {

				bindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout

			} else if ( binding.isSampledTexture && binding.store ) {

				const storageTexture = {}; // GPUStorageTextureBindingLayout
				storageTexture.format = this.backend.get( binding.texture ).texture.format;

				const access = binding.access;

				if ( access === NodeAccess.READ_WRITE ) {

					storageTexture.access = GPUStorageTextureAccess.ReadWrite;

				} else if ( access === NodeAccess.WRITE_ONLY ) {

					storageTexture.access = GPUStorageTextureAccess.WriteOnly;

				} else {

					storageTexture.access = GPUStorageTextureAccess.ReadOnly;

				}

				bindingGPU.storageTexture = storageTexture;

			} else if ( binding.isSampledTexture ) {

				const texture = {}; // GPUTextureBindingLayout

				if ( binding.texture.isMultisampleRenderTargetTexture === true ) {

					texture.multisampled = true;

				}

				if ( binding.texture.isDepthTexture ) {

					texture.sampleType = GPUTextureSampleType.Depth;

				} else if ( binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture ) {

					const type = binding.texture.type;

					if ( type === IntType ) {

						texture.sampleType = GPUTextureSampleType.SInt;

					} else if ( type === UnsignedIntType ) {

						texture.sampleType = GPUTextureSampleType.UInt;

					} else if ( type === FloatType ) {

						if ( this.backend.hasFeature( 'float32-filterable' ) ) {

							texture.sampleType = GPUTextureSampleType.Float;

						} else {

							texture.sampleType = GPUTextureSampleType.UnfilterableFloat;

						}

					}

				}

				if ( binding.isSampledCubeTexture ) {

					texture.viewDimension = GPUTextureViewDimension.Cube;

				} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {

					texture.viewDimension = GPUTextureViewDimension.TwoDArray;

				} else if ( binding.isSampledTexture3D ) {

					texture.viewDimension = GPUTextureViewDimension.ThreeD;

				}

				bindingGPU.texture = texture;

			} else {

				console.error( `WebGPUBindingUtils: Unsupported binding "${ binding }".` );

			}

			entries.push( bindingGPU );

		}

		return device.createBindGroupLayout( { entries } );

	}

	createBindings( bindGroup, bindings, cacheIndex, version = 0 ) {

		const { backend, bindGroupLayoutCache } = this;
		const bindingsData = backend.get( bindGroup );

		// setup (static) binding layout and (dynamic) binding group

		let bindLayoutGPU = bindGroupLayoutCache.get( bindGroup.bindingsReference );

		if ( bindLayoutGPU === undefined ) {

			bindLayoutGPU = this.createBindingsLayout( bindGroup );
			bindGroupLayoutCache.set( bindGroup.bindingsReference, bindLayoutGPU );

		}

		let bindGroupGPU;

		if ( cacheIndex > 0 ) {

			if ( bindingsData.groups === undefined ) {

				bindingsData.groups = [];
				bindingsData.versions = [];

			}

			if ( bindingsData.versions[ cacheIndex ] === version ) {

				bindGroupGPU = bindingsData.groups[ cacheIndex ];

			}

		}

		if ( bindGroupGPU === undefined ) {

			bindGroupGPU = this.createBindGroup( bindGroup, bindLayoutGPU );

			if ( cacheIndex > 0 ) {

				bindingsData.groups[ cacheIndex ] = bindGroupGPU;
				bindingsData.versions[ cacheIndex ] = version;

			}

		}

		bindingsData.group = bindGroupGPU;
		bindingsData.layout = bindLayoutGPU;

	}

	updateBinding( binding ) {

		const backend = this.backend;
		const device = backend.device;

		const buffer = binding.buffer;
		const bufferGPU = backend.get( binding ).buffer;

		device.queue.writeBuffer( bufferGPU, 0, buffer, 0 );

	}

	createBindGroup( bindGroup, layoutGPU ) {

		const backend = this.backend;
		const device = backend.device;

		let bindingPoint = 0;
		const entriesGPU = [];

		for ( const binding of bindGroup.bindings ) {

			if ( binding.isUniformBuffer ) {

				const bindingData = backend.get( binding );

				if ( bindingData.buffer === undefined ) {

					const byteLength = binding.byteLength;

					const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;

					const bufferGPU = device.createBuffer( {
						label: 'bindingBuffer_' + binding.name,
						size: byteLength,
						usage: usage
					} );

					bindingData.buffer = bufferGPU;

				}

				entriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );

			} else if ( binding.isStorageBuffer ) {

				const bindingData = backend.get( binding );

				if ( bindingData.buffer === undefined ) {

					const attribute = binding.attribute;
					//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;

					//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer

					bindingData.buffer = backend.get( attribute ).buffer;

				}

				entriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );

			} else if ( binding.isSampler ) {

				const textureGPU = backend.get( binding.texture );

				entriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );

			} else if ( binding.isSampledTexture ) {

				const textureData = backend.get( binding.texture );

				let resourceGPU;

				if ( textureData.externalTexture !== undefined ) {

					resourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );

				} else {

					const mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;
					const propertyName = `view-${ textureData.texture.width }-${ textureData.texture.height }-${ mipLevelCount }`;

					resourceGPU = textureData[ propertyName ];

					if ( resourceGPU === undefined ) {

						const aspectGPU = GPUTextureAspect.All;

						let dimensionViewGPU;

						if ( binding.isSampledCubeTexture ) {

							dimensionViewGPU = GPUTextureViewDimension.Cube;

						} else if ( binding.isSampledTexture3D ) {

							dimensionViewGPU = GPUTextureViewDimension.ThreeD;

						} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {

							dimensionViewGPU = GPUTextureViewDimension.TwoDArray;

						} else {

							dimensionViewGPU = GPUTextureViewDimension.TwoD;

						}

						resourceGPU = textureData[ propertyName ] = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount } );

					}

				}

				entriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );

			}

			bindingPoint ++;

		}

		return device.createBindGroup( {
			label: 'bindGroup_' + bindGroup.name,
			layout: layoutGPU,
			entries: entriesGPU
		} );

	}

}

class WebGPUPipelineUtils {

	constructor( backend ) {

		this.backend = backend;

	}

	_getSampleCount( renderObjectContext ) {

		return this.backend.utils.getSampleCountRenderContext( renderObjectContext );

	}

	createRenderPipeline( renderObject, promises ) {

		const { object, material, geometry, pipeline } = renderObject;
		const { vertexProgram, fragmentProgram } = pipeline;

		const backend = this.backend;
		const device = backend.device;
		const utils = backend.utils;

		const pipelineData = backend.get( pipeline );

		// bind group layouts

		const bindGroupLayouts = [];

		for ( const bindGroup of renderObject.getBindings() ) {

			const bindingsData = backend.get( bindGroup );

			bindGroupLayouts.push( bindingsData.layout );

		}

		// vertex buffers

		const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers( renderObject );

		// blending

		let blending;

		if ( material.transparent === true && material.blending !== NoBlending ) {

			blending = this._getBlending( material );

		}

		// stencil

		let stencilFront = {};

		if ( material.stencilWrite === true ) {

			stencilFront = {
				compare: this._getStencilCompare( material ),
				failOp: this._getStencilOperation( material.stencilFail ),
				depthFailOp: this._getStencilOperation( material.stencilZFail ),
				passOp: this._getStencilOperation( material.stencilZPass )
			};

		}

		const colorWriteMask = this._getColorWriteMask( material );

		const targets = [];

		if ( renderObject.context.textures !== null ) {

			const textures = renderObject.context.textures;

			for ( let i = 0; i < textures.length; i ++ ) {

				const colorFormat = utils.getTextureFormatGPU( textures[ i ] );

				targets.push( {
					format: colorFormat,
					blend: blending,
					writeMask: colorWriteMask
				} );

			}

		} else {

			const colorFormat = utils.getCurrentColorFormat( renderObject.context );

			targets.push( {
				format: colorFormat,
				blend: blending,
				writeMask: colorWriteMask
			} );

		}

		const vertexModule = backend.get( vertexProgram ).module;
		const fragmentModule = backend.get( fragmentProgram ).module;

		const primitiveState = this._getPrimitiveState( object, geometry, material );
		const depthCompare = this._getDepthCompare( material );
		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );

		const sampleCount = this._getSampleCount( renderObject.context );

		const pipelineDescriptor = {
			label: `renderPipeline_${ material.name || material.type }_${ material.id }`,
			vertex: Object.assign( {}, vertexModule, { buffers: vertexBuffers } ),
			fragment: Object.assign( {}, fragmentModule, { targets } ),
			primitive: primitiveState,
			multisample: {
				count: sampleCount,
				alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1
			},
			layout: device.createPipelineLayout( {
				bindGroupLayouts
			} )
		};


		const depthStencil = {};
		const renderDepth = renderObject.context.depth;
		const renderStencil = renderObject.context.stencil;

		if ( renderDepth === true || renderStencil === true ) {

			if ( renderDepth === true ) {

				depthStencil.format = depthStencilFormat;
				depthStencil.depthWriteEnabled = material.depthWrite;
				depthStencil.depthCompare = depthCompare;

			}

			if ( renderStencil === true ) {

				depthStencil.stencilFront = stencilFront;
				depthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)
				depthStencil.stencilReadMask = material.stencilFuncMask;
				depthStencil.stencilWriteMask = material.stencilWriteMask;

			}

			pipelineDescriptor.depthStencil = depthStencil;

		}


		if ( promises === null ) {

			pipelineData.pipeline = device.createRenderPipeline( pipelineDescriptor );

		} else {

			const p = new Promise( ( resolve /*, reject*/ ) => {

				device.createRenderPipelineAsync( pipelineDescriptor ).then( pipeline => {

					pipelineData.pipeline = pipeline;
					resolve();

				} );

			} );

			promises.push( p );

		}

	}

	createBundleEncoder( renderContext ) {

		const backend = this.backend;
		const { utils, device } = backend;

		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderContext );
		const colorFormat = utils.getCurrentColorFormat( renderContext );
		const sampleCount = this._getSampleCount( renderContext );

		const descriptor = {
			label: 'renderBundleEncoder',
			colorFormats: [ colorFormat ],
			depthStencilFormat,
			sampleCount
		};

		return device.createRenderBundleEncoder( descriptor );

	}

	createComputePipeline( pipeline, bindings ) {

		const backend = this.backend;
		const device = backend.device;

		const computeProgram = backend.get( pipeline.computeProgram ).module;

		const pipelineGPU = backend.get( pipeline );

		// bind group layouts

		const bindGroupLayouts = [];

		for ( const bindingsGroup of bindings ) {

			const bindingsData = backend.get( bindingsGroup );

			bindGroupLayouts.push( bindingsData.layout );

		}

		pipelineGPU.pipeline = device.createComputePipeline( {
			compute: computeProgram,
			layout: device.createPipelineLayout( {
				bindGroupLayouts
			} )
		} );

	}

	_getBlending( material ) {

		let color, alpha;

		const blending = material.blending;
		const blendSrc = material.blendSrc;
		const blendDst = material.blendDst;
		const blendEquation = material.blendEquation;


		if ( blending === CustomBlending ) {

			const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;
			const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;
			const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;

			color = {
				srcFactor: this._getBlendFactor( blendSrc ),
				dstFactor: this._getBlendFactor( blendDst ),
				operation: this._getBlendOperation( blendEquation )
			};

			alpha = {
				srcFactor: this._getBlendFactor( blendSrcAlpha ),
				dstFactor: this._getBlendFactor( blendDstAlpha ),
				operation: this._getBlendOperation( blendEquationAlpha )
			};

		} else {

			const premultipliedAlpha = material.premultipliedAlpha;

			const setBlend = ( srcRGB, dstRGB, srcAlpha, dstAlpha ) => {

				color = {
					srcFactor: srcRGB,
					dstFactor: dstRGB,
					operation: GPUBlendOperation.Add
				};

				alpha = {
					srcFactor: srcAlpha,
					dstFactor: dstAlpha,
					operation: GPUBlendOperation.Add
				};

			};

			if ( premultipliedAlpha ) {

				switch ( blending ) {

					case NormalBlending:
						setBlend( GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );
						break;

					case AdditiveBlending:
						setBlend( GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );
						break;

					case SubtractiveBlending:
						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );
						break;

					case MultiplyBlending:
						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha );
						break;

				}

			} else {

				switch ( blending ) {

					case NormalBlending:
						setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );
						break;

					case AdditiveBlending:
						setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One );
						break;

					case SubtractiveBlending:
						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );
						break;

					case MultiplyBlending:
						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src );
						break;

				}

			}

		}

		if ( color !== undefined && alpha !== undefined ) {

			return { color, alpha };

		} else {

			console.error( 'THREE.WebGPURenderer: Invalid blending: ', blending );

		}

	}

	_getBlendFactor( blend ) {

		let blendFactor;

		switch ( blend ) {

			case ZeroFactor:
				blendFactor = GPUBlendFactor.Zero;
				break;

			case OneFactor:
				blendFactor = GPUBlendFactor.One;
				break;

			case SrcColorFactor:
				blendFactor = GPUBlendFactor.Src;
				break;

			case OneMinusSrcColorFactor:
				blendFactor = GPUBlendFactor.OneMinusSrc;
				break;

			case SrcAlphaFactor:
				blendFactor = GPUBlendFactor.SrcAlpha;
				break;

			case OneMinusSrcAlphaFactor:
				blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
				break;

			case DstColorFactor:
				blendFactor = GPUBlendFactor.Dst;
				break;

			case OneMinusDstColorFactor:
				blendFactor = GPUBlendFactor.OneMinusDstColor;
				break;

			case DstAlphaFactor:
				blendFactor = GPUBlendFactor.DstAlpha;
				break;

			case OneMinusDstAlphaFactor:
				blendFactor = GPUBlendFactor.OneMinusDstAlpha;
				break;

			case SrcAlphaSaturateFactor:
				blendFactor = GPUBlendFactor.SrcAlphaSaturated;
				break;

			case BlendColorFactor:
				blendFactor = GPUBlendFactor.Constant;
				break;

			case OneMinusBlendColorFactor:
				blendFactor = GPUBlendFactor.OneMinusConstant;
				break;

			default:
				console.error( 'THREE.WebGPURenderer: Blend factor not supported.', blend );

		}

		return blendFactor;

	}

	_getStencilCompare( material ) {

		let stencilCompare;

		const stencilFunc = material.stencilFunc;

		switch ( stencilFunc ) {

			case NeverStencilFunc:
				stencilCompare = GPUCompareFunction.Never;
				break;

			case AlwaysStencilFunc:
				stencilCompare = GPUCompareFunction.Always;
				break;

			case LessStencilFunc:
				stencilCompare = GPUCompareFunction.Less;
				break;

			case LessEqualStencilFunc:
				stencilCompare = GPUCompareFunction.LessEqual;
				break;

			case EqualStencilFunc:
				stencilCompare = GPUCompareFunction.Equal;
				break;

			case GreaterEqualStencilFunc:
				stencilCompare = GPUCompareFunction.GreaterEqual;
				break;

			case GreaterStencilFunc:
				stencilCompare = GPUCompareFunction.Greater;
				break;

			case NotEqualStencilFunc:
				stencilCompare = GPUCompareFunction.NotEqual;
				break;

			default:
				console.error( 'THREE.WebGPURenderer: Invalid stencil function.', stencilFunc );

		}

		return stencilCompare;

	}

	_getStencilOperation( op ) {

		let stencilOperation;

		switch ( op ) {

			case KeepStencilOp:
				stencilOperation = GPUStencilOperation.Keep;
				break;

			case ZeroStencilOp:
				stencilOperation = GPUStencilOperation.Zero;
				break;

			case ReplaceStencilOp:
				stencilOperation = GPUStencilOperation.Replace;
				break;

			case InvertStencilOp:
				stencilOperation = GPUStencilOperation.Invert;
				break;

			case IncrementStencilOp:
				stencilOperation = GPUStencilOperation.IncrementClamp;
				break;

			case DecrementStencilOp:
				stencilOperation = GPUStencilOperation.DecrementClamp;
				break;

			case IncrementWrapStencilOp:
				stencilOperation = GPUStencilOperation.IncrementWrap;
				break;

			case DecrementWrapStencilOp:
				stencilOperation = GPUStencilOperation.DecrementWrap;
				break;

			default:
				console.error( 'THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation );

		}

		return stencilOperation;

	}

	_getBlendOperation( blendEquation ) {

		let blendOperation;

		switch ( blendEquation ) {

			case AddEquation:
				blendOperation = GPUBlendOperation.Add;
				break;

			case SubtractEquation:
				blendOperation = GPUBlendOperation.Subtract;
				break;

			case ReverseSubtractEquation:
				blendOperation = GPUBlendOperation.ReverseSubtract;
				break;

			case MinEquation:
				blendOperation = GPUBlendOperation.Min;
				break;

			case MaxEquation:
				blendOperation = GPUBlendOperation.Max;
				break;

			default:
				console.error( 'THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation );

		}

		return blendOperation;

	}

	_getPrimitiveState( object, geometry, material ) {

		const descriptor = {};
		const utils = this.backend.utils;

		descriptor.topology = utils.getPrimitiveTopology( object, material );

		if ( geometry.index !== null && object.isLine === true && object.isLineSegments !== true ) {

			descriptor.stripIndexFormat = ( geometry.index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;

		}

		switch ( material.side ) {

			case FrontSide:
				descriptor.frontFace = GPUFrontFace.CCW;
				descriptor.cullMode = GPUCullMode.Back;
				break;

			case BackSide:
				descriptor.frontFace = GPUFrontFace.CCW;
				descriptor.cullMode = GPUCullMode.Front;
				break;

			case DoubleSide:
				descriptor.frontFace = GPUFrontFace.CCW;
				descriptor.cullMode = GPUCullMode.None;
				break;

			default:
				console.error( 'THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side );
				break;

		}

		return descriptor;

	}

	_getColorWriteMask( material ) {

		return ( material.colorWrite === true ) ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;

	}

	_getDepthCompare( material ) {

		let depthCompare;

		if ( material.depthTest === false ) {

			depthCompare = GPUCompareFunction.Always;

		} else {

			const depthFunc = material.depthFunc;

			switch ( depthFunc ) {

				case NeverDepth:
					depthCompare = GPUCompareFunction.Never;
					break;

				case AlwaysDepth:
					depthCompare = GPUCompareFunction.Always;
					break;

				case LessDepth:
					depthCompare = GPUCompareFunction.Less;
					break;

				case LessEqualDepth:
					depthCompare = GPUCompareFunction.LessEqual;
					break;

				case EqualDepth:
					depthCompare = GPUCompareFunction.Equal;
					break;

				case GreaterEqualDepth:
					depthCompare = GPUCompareFunction.GreaterEqual;
					break;

				case GreaterDepth:
					depthCompare = GPUCompareFunction.Greater;
					break;

				case NotEqualDepth:
					depthCompare = GPUCompareFunction.NotEqual;
					break;

				default:
					console.error( 'THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc );

			}

		}

		return depthCompare;

	}

}

/*// debugger tools
import 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';
//*/


//

class WebGPUBackend extends Backend {

	constructor( parameters = {} ) {

		super( parameters );

		this.isWebGPUBackend = true;

		// some parameters require default values other than "undefined"
		this.parameters.alpha = ( parameters.alpha === undefined ) ? true : parameters.alpha;

		this.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;

		this.trackTimestamp = ( parameters.trackTimestamp === true );

		this.device = null;
		this.context = null;
		this.colorBuffer = null;
		this.defaultRenderPassdescriptor = null;

		this.utils = new WebGPUUtils( this );
		this.attributeUtils = new WebGPUAttributeUtils( this );
		this.bindingUtils = new WebGPUBindingUtils( this );
		this.pipelineUtils = new WebGPUPipelineUtils( this );
		this.textureUtils = new WebGPUTextureUtils( this );
		this.occludedResolveCache = new Map();

	}

	async init( renderer ) {

		await super.init( renderer );

		//

		const parameters = this.parameters;

		// create the device if it is not passed with parameters

		let device;

		if ( parameters.device === undefined ) {

			const adapterOptions = {
				powerPreference: parameters.powerPreference
			};

			const adapter = ( typeof navigator !== 'undefined' ) ? await navigator.gpu.requestAdapter( adapterOptions ) : null;

			if ( adapter === null ) {

				throw new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );

			}

			// feature support

			const features = Object.values( GPUFeatureName );

			const supportedFeatures = [];

			for ( const name of features ) {

				if ( adapter.features.has( name ) ) {

					supportedFeatures.push( name );

				}

			}

			const deviceDescriptor = {
				requiredFeatures: supportedFeatures,
				requiredLimits: parameters.requiredLimits
			};

			device = await adapter.requestDevice( deviceDescriptor );

		} else {

			device = parameters.device;

		}

		device.lost.then( ( info ) => {

			const deviceLossInfo = {
				api: 'WebGPU',
				message: info.message || 'Unknown reason',
				reason: info.reason || null,
				originalEvent: info
			};

			renderer.onDeviceLost( deviceLossInfo );

		} );

		const context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );

		this.device = device;
		this.context = context;

		const alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';

		this.trackTimestamp = this.trackTimestamp && this.hasFeature( GPUFeatureName.TimestampQuery );

		this.context.configure( {
			device: this.device,
			format: this.utils.getPreferredCanvasFormat(),
			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
			alphaMode: alphaMode
		} );

		this.updateSize();

	}

	get coordinateSystem() {

		return WebGPUCoordinateSystem;

	}

	async getArrayBufferAsync( attribute ) {

		return await this.attributeUtils.getArrayBufferAsync( attribute );

	}

	getContext() {

		return this.context;

	}

	_getDefaultRenderPassDescriptor() {

		let descriptor = this.defaultRenderPassdescriptor;

		if ( descriptor === null ) {

			const renderer = this.renderer;

			descriptor = {
				colorAttachments: [ {
					view: null
				} ],
			};

			if ( this.renderer.depth === true || this.renderer.stencil === true ) {

				descriptor.depthStencilAttachment = {
					view: this.textureUtils.getDepthBuffer( renderer.depth, renderer.stencil ).createView()
				};

			}

			const colorAttachment = descriptor.colorAttachments[ 0 ];

			if ( this.renderer.samples > 0 ) {

				colorAttachment.view = this.colorBuffer.createView();

			} else {

				colorAttachment.resolveTarget = undefined;

			}

			this.defaultRenderPassdescriptor = descriptor;

		}

		const colorAttachment = descriptor.colorAttachments[ 0 ];

		if ( this.renderer.samples > 0 ) {

			colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();

		} else {

			colorAttachment.view = this.context.getCurrentTexture().createView();

		}

		return descriptor;

	}

	_getRenderPassDescriptor( renderContext ) {

		const renderTarget = renderContext.renderTarget;
		const renderTargetData = this.get( renderTarget );

		let descriptors = renderTargetData.descriptors;

		if ( descriptors === undefined ||
			renderTargetData.width !== renderTarget.width ||
			renderTargetData.height !== renderTarget.height ||
			renderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel ||
			renderTargetData.samples !== renderTarget.samples
		) {

			descriptors = {};

			renderTargetData.descriptors = descriptors;

			// dispose

			const onDispose = () => {

				renderTarget.removeEventListener( 'dispose', onDispose );

				this.delete( renderTarget );

			};

			renderTarget.addEventListener( 'dispose', onDispose );

		}

		const cacheKey = renderContext.getCacheKey();

		let descriptor = descriptors[ cacheKey ];

		if ( descriptor === undefined ) {

			const textures = renderContext.textures;
			const colorAttachments = [];

			for ( let i = 0; i < textures.length; i ++ ) {

				const textureData = this.get( textures[ i ] );

				const textureView = textureData.texture.createView( {
					baseMipLevel: renderContext.activeMipmapLevel,
					mipLevelCount: 1,
					baseArrayLayer: renderContext.activeCubeFace,
					dimension: GPUTextureViewDimension.TwoD
				} );

				let view, resolveTarget;

				if ( textureData.msaaTexture !== undefined ) {

					view = textureData.msaaTexture.createView();
					resolveTarget = textureView;

				} else {

					view = textureView;
					resolveTarget = undefined;

				}

				colorAttachments.push( {
					view,
					resolveTarget,
					loadOp: GPULoadOp.Load,
					storeOp: GPUStoreOp.Store
				} );

			}


			descriptor = {
				colorAttachments,
			};

			if ( renderContext.depth ) {

				const depthTextureData = this.get( renderContext.depthTexture );

				const depthStencilAttachment = {
					view: depthTextureData.texture.createView()
				};
				descriptor.depthStencilAttachment = depthStencilAttachment;

			}

			descriptors[ cacheKey ] = descriptor;

			renderTargetData.width = renderTarget.width;
			renderTargetData.height = renderTarget.height;
			renderTargetData.samples = renderTarget.samples;
			renderTargetData.activeMipmapLevel = renderTarget.activeMipmapLevel;

		}

		return descriptor;

	}

	beginRender( renderContext ) {

		const renderContextData = this.get( renderContext );

		const device = this.device;
		const occlusionQueryCount = renderContext.occlusionQueryCount;

		let occlusionQuerySet;

		if ( occlusionQueryCount > 0 ) {

			if ( renderContextData.currentOcclusionQuerySet ) renderContextData.currentOcclusionQuerySet.destroy();
			if ( renderContextData.currentOcclusionQueryBuffer ) renderContextData.currentOcclusionQueryBuffer.destroy();

			// Get a reference to the array of objects with queries. The renderContextData property
			// can be changed by another render pass before the buffer.mapAsyc() completes.
			renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;
			renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;
			renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;

			//

			occlusionQuerySet = device.createQuerySet( { type: 'occlusion', count: occlusionQueryCount, label: `occlusionQuerySet_${ renderContext.id }` } );

			renderContextData.occlusionQuerySet = occlusionQuerySet;
			renderContextData.occlusionQueryIndex = 0;
			renderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );

			renderContextData.lastOcclusionObject = null;

		}

		let descriptor;

		if ( renderContext.textures === null ) {

			descriptor = this._getDefaultRenderPassDescriptor();

		} else {

			descriptor = this._getRenderPassDescriptor( renderContext );

		}

		this.initTimestampQuery( renderContext, descriptor );

		descriptor.occlusionQuerySet = occlusionQuerySet;

		const depthStencilAttachment = descriptor.depthStencilAttachment;

		if ( renderContext.textures !== null ) {

			const colorAttachments = descriptor.colorAttachments;

			for ( let i = 0; i < colorAttachments.length; i ++ ) {

				const colorAttachment = colorAttachments[ i ];

				if ( renderContext.clearColor ) {

					colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };
					colorAttachment.loadOp = GPULoadOp.Clear;
					colorAttachment.storeOp = GPUStoreOp.Store;

				} else {

					colorAttachment.loadOp = GPULoadOp.Load;
					colorAttachment.storeOp = GPUStoreOp.Store;

				}

			}

		} else {

			const colorAttachment = descriptor.colorAttachments[ 0 ];

			if ( renderContext.clearColor ) {

				colorAttachment.clearValue = renderContext.clearColorValue;
				colorAttachment.loadOp = GPULoadOp.Clear;
				colorAttachment.storeOp = GPUStoreOp.Store;

			} else {

				colorAttachment.loadOp = GPULoadOp.Load;
				colorAttachment.storeOp = GPUStoreOp.Store;

			}

		}

		//

		if ( renderContext.depth ) {

			if ( renderContext.clearDepth ) {

				depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
				depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

			} else {

				depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

			}

		}

		if ( renderContext.stencil ) {

			if ( renderContext.clearStencil ) {

				depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
				depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

			} else {

				depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

			}

		}

		//

		const encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );
		const currentPass = encoder.beginRenderPass( descriptor );

		//

		renderContextData.descriptor = descriptor;
		renderContextData.encoder = encoder;
		renderContextData.currentPass = currentPass;
		renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
		renderContextData.renderBundles = [];

		//

		if ( renderContext.viewport ) {

			this.updateViewport( renderContext );

		}

		if ( renderContext.scissor ) {

			const { x, y, width, height } = renderContext.scissorValue;

			currentPass.setScissorRect( x, y, width, height );

		}

	}

	finishRender( renderContext ) {

		const renderContextData = this.get( renderContext );
		const occlusionQueryCount = renderContext.occlusionQueryCount;

		if ( renderContextData.renderBundles.length > 0 ) {

			renderContextData.currentPass.executeBundles( renderContextData.renderBundles );

		}

		if ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {

			renderContextData.currentPass.endOcclusionQuery();

		}

		renderContextData.currentPass.end();

		if ( occlusionQueryCount > 0 ) {

			const bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results

			//

			let queryResolveBuffer = this.occludedResolveCache.get( bufferSize );

			if ( queryResolveBuffer === undefined ) {

				queryResolveBuffer = this.device.createBuffer(
					{
						size: bufferSize,
						usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
					}
				);

				this.occludedResolveCache.set( bufferSize, queryResolveBuffer );

			}

			//

			const readBuffer = this.device.createBuffer(
				{
					size: bufferSize,
					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
				}
			);

			// two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined
			renderContextData.encoder.resolveQuerySet( renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0 );
			renderContextData.encoder.copyBufferToBuffer( queryResolveBuffer, 0, readBuffer, 0, bufferSize );

			renderContextData.occlusionQueryBuffer = readBuffer;

			//

			this.resolveOccludedAsync( renderContext );

		}

		this.prepareTimestampBuffer( renderContext, renderContextData.encoder );

		this.device.queue.submit( [ renderContextData.encoder.finish() ] );


		//

		if ( renderContext.textures !== null ) {

			const textures = renderContext.textures;

			for ( let i = 0; i < textures.length; i ++ ) {

				const texture = textures[ i ];

				if ( texture.generateMipmaps === true ) {

					this.textureUtils.generateMipmaps( texture );

				}

			}

		}

	}

	isOccluded( renderContext, object ) {

		const renderContextData = this.get( renderContext );

		return renderContextData.occluded && renderContextData.occluded.has( object );

	}

	async resolveOccludedAsync( renderContext ) {

		const renderContextData = this.get( renderContext );

		// handle occlusion query results

		const { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;

		if ( currentOcclusionQueryBuffer && currentOcclusionQueryObjects ) {

			const occluded = new WeakSet();

			renderContextData.currentOcclusionQueryObjects = null;
			renderContextData.currentOcclusionQueryBuffer = null;

			await currentOcclusionQueryBuffer.mapAsync( GPUMapMode.READ );

			const buffer = currentOcclusionQueryBuffer.getMappedRange();
			const results = new BigUint64Array( buffer );

			for ( let i = 0; i < currentOcclusionQueryObjects.length; i ++ ) {

				if ( results[ i ] !== BigInt( 0 ) ) {

					occluded.add( currentOcclusionQueryObjects[ i ] );

				}

			}

			currentOcclusionQueryBuffer.destroy();

			renderContextData.occluded = occluded;

		}

	}

	updateViewport( renderContext ) {

		const { currentPass } = this.get( renderContext );
		const { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;

		currentPass.setViewport( x, y, width, height, minDepth, maxDepth );

	}

	clear( color, depth, stencil, renderTargetData = null ) {

		const device = this.device;
		const renderer = this.renderer;

		let colorAttachments = [];

		let depthStencilAttachment;
		let clearValue;

		let supportsDepth;
		let supportsStencil;

		if ( color ) {

			const clearColor = this.getClearColor();

			if ( this.renderer.alpha === true ) {

				// premultiply alpha

				const a = clearColor.a;

				clearValue = { r: clearColor.r * a, g: clearColor.g * a, b: clearColor.b * a, a: a };

			} else {

				clearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };

			}

		}

		if ( renderTargetData === null ) {

			supportsDepth = renderer.depth;
			supportsStencil = renderer.stencil;

			const descriptor = this._getDefaultRenderPassDescriptor();

			if ( color ) {

				colorAttachments = descriptor.colorAttachments;

				const colorAttachment = colorAttachments[ 0 ];

				colorAttachment.clearValue = clearValue;
				colorAttachment.loadOp = GPULoadOp.Clear;
				colorAttachment.storeOp = GPUStoreOp.Store;

			}

			if ( supportsDepth || supportsStencil ) {

				depthStencilAttachment = descriptor.depthStencilAttachment;

			}

		} else {

			supportsDepth = renderTargetData.depth;
			supportsStencil = renderTargetData.stencil;

			if ( color ) {

				for ( const texture of renderTargetData.textures ) {

					const textureData = this.get( texture );
					const textureView = textureData.texture.createView();

					let view, resolveTarget;

					if ( textureData.msaaTexture !== undefined ) {

						view = textureData.msaaTexture.createView();
						resolveTarget = textureView;

					} else {

						view = textureView;
						resolveTarget = undefined;

					}

					colorAttachments.push( {
						view,
						resolveTarget,
						clearValue,
						loadOp: GPULoadOp.Clear,
						storeOp: GPUStoreOp.Store
					} );

				}

			}

			if ( supportsDepth || supportsStencil ) {

				const depthTextureData = this.get( renderTargetData.depthTexture );

				depthStencilAttachment = {
					view: depthTextureData.texture.createView()
				};

			}

		}

		//

		if ( supportsDepth ) {

			if ( depth ) {

				depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
				depthStencilAttachment.depthClearValue = renderer.getClearDepth();
				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

			} else {

				depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

			}

		}

		//

		if ( supportsStencil ) {

			if ( stencil ) {

				depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
				depthStencilAttachment.stencilClearValue = renderer.getClearStencil();
				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

			} else {

				depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

			}

		}

		//

		const encoder = device.createCommandEncoder( {} );
		const currentPass = encoder.beginRenderPass( {
			colorAttachments,
			depthStencilAttachment
		} );

		currentPass.end();

		device.queue.submit( [ encoder.finish() ] );

	}

	// compute

	beginCompute( computeGroup ) {

		const groupGPU = this.get( computeGroup );


		const descriptor = {};

		this.initTimestampQuery( computeGroup, descriptor );

		groupGPU.cmdEncoderGPU = this.device.createCommandEncoder();

		groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass( descriptor );

	}

	compute( computeGroup, computeNode, bindings, pipeline ) {

		const { passEncoderGPU } = this.get( computeGroup );

		// pipeline

		const pipelineGPU = this.get( pipeline ).pipeline;
		passEncoderGPU.setPipeline( pipelineGPU );

		// bind groups

		for ( let i = 0, l = bindings.length; i < l; i ++ ) {

			const bindGroup = bindings[ i ];
			const bindingsData = this.get( bindGroup );

			passEncoderGPU.setBindGroup( i, bindingsData.group );

		}

		const maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;

		const computeNodeData = this.get( computeNode );

		if ( computeNodeData.dispatchSize === undefined ) computeNodeData.dispatchSize = { x: 0, y: 1, z: 1 };

		const { dispatchSize } = computeNodeData;

		if ( computeNode.dispatchCount > maxComputeWorkgroupsPerDimension ) {

			dispatchSize.x = Math.min( computeNode.dispatchCount, maxComputeWorkgroupsPerDimension );
			dispatchSize.y = Math.ceil( computeNode.dispatchCount / maxComputeWorkgroupsPerDimension );

		} else {

			dispatchSize.x = computeNode.dispatchCount;

		}

		passEncoderGPU.dispatchWorkgroups(
			dispatchSize.x,
			dispatchSize.y,
			dispatchSize.z
		);

	}

	finishCompute( computeGroup ) {

		const groupData = this.get( computeGroup );

		groupData.passEncoderGPU.end();

		this.prepareTimestampBuffer( computeGroup, groupData.cmdEncoderGPU );

		this.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );

	}

	async waitForGPU() {

		await this.device.queue.onSubmittedWorkDone();

	}

	// render object

	draw( renderObject, info ) {

		const { object, context, pipeline } = renderObject;
		const bindings = renderObject.getBindings();
		const renderContextData = this.get( context );
		const pipelineGPU = this.get( pipeline ).pipeline;
		const currentSets = renderContextData.currentSets;
		const passEncoderGPU = renderContextData.currentPass;

		const drawParams = renderObject.getDrawParameters();

		if ( drawParams === null ) return;

		// pipeline

		if ( currentSets.pipeline !== pipelineGPU ) {

			passEncoderGPU.setPipeline( pipelineGPU );

			currentSets.pipeline = pipelineGPU;

		}

		// bind groups

		const currentBindingGroups = currentSets.bindingGroups;

		for ( let i = 0, l = bindings.length; i < l; i ++ ) {

			const bindGroup = bindings[ i ];
			const bindingsData = this.get( bindGroup );

			if ( currentBindingGroups[ bindGroup.index ] !== bindGroup.id ) {

				passEncoderGPU.setBindGroup( bindGroup.index, bindingsData.group );
				currentBindingGroups[ bindGroup.index ] = bindGroup.id;

			}

		}

		// attributes

		const index = renderObject.getIndex();

		const hasIndex = ( index !== null );

		// index

		if ( hasIndex === true ) {

			if ( currentSets.index !== index ) {

				const buffer = this.get( index ).buffer;
				const indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;

				passEncoderGPU.setIndexBuffer( buffer, indexFormat );

				currentSets.index = index;

			}

		}

		// vertex buffers

		const vertexBuffers = renderObject.getVertexBuffers();

		for ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {

			const vertexBuffer = vertexBuffers[ i ];

			if ( currentSets.attributes[ i ] !== vertexBuffer ) {

				const buffer = this.get( vertexBuffer ).buffer;
				passEncoderGPU.setVertexBuffer( i, buffer );

				currentSets.attributes[ i ] = vertexBuffer;

			}

		}

		// occlusion queries - handle multiple consecutive draw calls for an object

		if ( renderContextData.occlusionQuerySet !== undefined ) {

			const lastObject = renderContextData.lastOcclusionObject;

			if ( lastObject !== object ) {

				if ( lastObject !== null && lastObject.occlusionTest === true ) {

					passEncoderGPU.endOcclusionQuery();
					renderContextData.occlusionQueryIndex ++;

				}

				if ( object.occlusionTest === true ) {

					passEncoderGPU.beginOcclusionQuery( renderContextData.occlusionQueryIndex );
					renderContextData.occlusionQueryObjects[ renderContextData.occlusionQueryIndex ] = object;

				}

				renderContextData.lastOcclusionObject = object;

			}

		}

		// draw

		if ( object.isBatchedMesh === true ) {

			const starts = object._multiDrawStarts;
			const counts = object._multiDrawCounts;
			const drawCount = object._multiDrawCount;
			const drawInstances = object._multiDrawInstances;

			const bytesPerElement = hasIndex ? index.array.BYTES_PER_ELEMENT : 1;

			for ( let i = 0; i < drawCount; i ++ ) {

				const count = drawInstances ? drawInstances[ i ] : 1;
				const firstInstance = count > 1 ? 0 : i;

				passEncoderGPU.drawIndexed( counts[ i ], count, starts[ i ] / bytesPerElement, 0, firstInstance );

			}

		} else if ( hasIndex === true ) {

			const { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;

			const indirect = renderObject.getIndirect();

			if ( indirect !== null ) {

				const buffer = this.get( indirect ).buffer;

				passEncoderGPU.drawIndexedIndirect( buffer, 0 );

			} else {

				passEncoderGPU.drawIndexed( indexCount, instanceCount, firstIndex, 0, 0 );

			}

			info.update( object, indexCount, instanceCount );

		} else {

			const { vertexCount, instanceCount, firstVertex } = drawParams;

			const indirect = renderObject.getIndirect();

			if ( indirect !== null ) {

				const buffer = this.get( indirect ).buffer;

				passEncoderGPU.drawIndirect( buffer, 0 );

			} else {

				passEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );

			}

			info.update( object, vertexCount, instanceCount );

		}

	}

	// cache key

	needsRenderUpdate( renderObject ) {

		const data = this.get( renderObject );

		const { object, material } = renderObject;

		const utils = this.utils;

		const sampleCount = utils.getSampleCountRenderContext( renderObject.context );
		const colorSpace = utils.getCurrentColorSpace( renderObject.context );
		const colorFormat = utils.getCurrentColorFormat( renderObject.context );
		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );
		const primitiveTopology = utils.getPrimitiveTopology( object, material );

		let needsUpdate = false;

		if ( data.material !== material || data.materialVersion !== material.version ||
			data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||
			data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||
			data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||
			data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||
			data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||
			data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||
			data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||
			data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage ||
			data.sampleCount !== sampleCount || data.colorSpace !== colorSpace ||
			data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat ||
			data.primitiveTopology !== primitiveTopology ||
			data.clippingContextCacheKey !== renderObject.clippingContextCacheKey
		) {

			data.material = material; data.materialVersion = material.version;
			data.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;
			data.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;
			data.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;
			data.colorWrite = material.colorWrite;
			data.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;
			data.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;
			data.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;
			data.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;
			data.side = material.side; data.alphaToCoverage = material.alphaToCoverage;
			data.sampleCount = sampleCount;
			data.colorSpace = colorSpace;
			data.colorFormat = colorFormat;
			data.depthStencilFormat = depthStencilFormat;
			data.primitiveTopology = primitiveTopology;
			data.clippingContextCacheKey = renderObject.clippingContextCacheKey;

			needsUpdate = true;

		}

		return needsUpdate;

	}

	getRenderCacheKey( renderObject ) {

		const { object, material } = renderObject;

		const utils = this.utils;
		const renderContext = renderObject.context;

		return [
			material.transparent, material.blending, material.premultipliedAlpha,
			material.blendSrc, material.blendDst, material.blendEquation,
			material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,
			material.colorWrite,
			material.depthWrite, material.depthTest, material.depthFunc,
			material.stencilWrite, material.stencilFunc,
			material.stencilFail, material.stencilZFail, material.stencilZPass,
			material.stencilFuncMask, material.stencilWriteMask,
			material.side,
			utils.getSampleCountRenderContext( renderContext ),
			utils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),
			utils.getPrimitiveTopology( object, material ),
			renderObject.getGeometryCacheKey(),
			renderObject.clippingContextCacheKey
		].join();

	}

	// textures

	createSampler( texture ) {

		this.textureUtils.createSampler( texture );

	}

	destroySampler( texture ) {

		this.textureUtils.destroySampler( texture );

	}

	createDefaultTexture( texture ) {

		this.textureUtils.createDefaultTexture( texture );

	}

	createTexture( texture, options ) {

		this.textureUtils.createTexture( texture, options );

	}

	updateTexture( texture, options ) {

		this.textureUtils.updateTexture( texture, options );

	}

	generateMipmaps( texture ) {

		this.textureUtils.generateMipmaps( texture );

	}

	destroyTexture( texture ) {

		this.textureUtils.destroyTexture( texture );

	}

	copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

		return this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );

	}


	initTimestampQuery( renderContext, descriptor ) {

		if ( ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( ! renderContextData.timeStampQuerySet ) {


			const type = renderContext.isComputeNode ? 'compute' : 'render';
			const timeStampQuerySet = this.device.createQuerySet( { type: 'timestamp', count: 2, label: `timestamp_${type}_${renderContext.id}` } );

			const timestampWrites = {
				querySet: timeStampQuerySet,
				beginningOfPassWriteIndex: 0, // Write timestamp in index 0 when pass begins.
				endOfPassWriteIndex: 1, // Write timestamp in index 1 when pass ends.
			};

			Object.assign( descriptor, { timestampWrites } );

			renderContextData.timeStampQuerySet = timeStampQuerySet;

		}

	}

	// timestamp utils

	prepareTimestampBuffer( renderContext, encoder ) {

		if ( ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );


		const size = 2 * BigInt64Array.BYTES_PER_ELEMENT;

		if ( renderContextData.currentTimestampQueryBuffers === undefined ) {

			renderContextData.currentTimestampQueryBuffers = {
				resolveBuffer: this.device.createBuffer( {
					label: 'timestamp resolve buffer',
					size: size,
					usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
				} ),
				resultBuffer: this.device.createBuffer( {
					label: 'timestamp result buffer',
					size: size,
					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
				} )
			};

		}

		const { resolveBuffer, resultBuffer } = renderContextData.currentTimestampQueryBuffers;


		encoder.resolveQuerySet( renderContextData.timeStampQuerySet, 0, 2, resolveBuffer, 0 );

		if ( resultBuffer.mapState === 'unmapped' ) {

			encoder.copyBufferToBuffer( resolveBuffer, 0, resultBuffer, 0, size );

		}

	}

	async resolveTimestampAsync( renderContext, type = 'render' ) {

		if ( ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( renderContextData.currentTimestampQueryBuffers === undefined ) return;

		const { resultBuffer } = renderContextData.currentTimestampQueryBuffers;

		await this.device.queue.onSubmittedWorkDone();

		if ( resultBuffer.mapState === 'unmapped' ) {

			resultBuffer.mapAsync( GPUMapMode.READ ).then( () => {

				const times = new BigUint64Array( resultBuffer.getMappedRange() );
				const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;


				this.renderer.info.updateTimestamp( type, duration );

				resultBuffer.unmap();


			} );

		}

	}

	// node builder

	createNodeBuilder( object, renderer ) {

		return new WGSLNodeBuilder( object, renderer );

	}

	// program

	createProgram( program ) {

		const programGPU = this.get( program );

		programGPU.module = {
			module: this.device.createShaderModule( { code: program.code, label: program.stage } ),
			entryPoint: 'main'
		};

	}

	destroyProgram( program ) {

		this.delete( program );

	}

	// pipelines

	createRenderPipeline( renderObject, promises ) {

		this.pipelineUtils.createRenderPipeline( renderObject, promises );

	}

	createComputePipeline( computePipeline, bindings ) {

		this.pipelineUtils.createComputePipeline( computePipeline, bindings );

	}

	beginBundle( renderContext ) {

		const renderContextData = this.get( renderContext );

		renderContextData._currentPass = renderContextData.currentPass;
		renderContextData._currentSets = renderContextData.currentSets;

		renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
		renderContextData.currentPass = this.pipelineUtils.createBundleEncoder( renderContext );

	}

	finishBundle( renderContext, bundle ) {

		const renderContextData = this.get( renderContext );

		const bundleEncoder = renderContextData.currentPass;
		const bundleGPU = bundleEncoder.finish();

		this.get( bundle ).bundleGPU = bundleGPU;

		// restore render pass state

		renderContextData.currentSets = renderContextData._currentSets;
		renderContextData.currentPass = renderContextData._currentPass;

	}

	addBundle( renderContext, bundle ) {

		const renderContextData = this.get( renderContext );

		renderContextData.renderBundles.push( this.get( bundle ).bundleGPU );

	}

	// bindings

	createBindings( bindGroup, bindings, cacheIndex, version ) {

		this.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );

	}

	updateBindings( bindGroup, bindings, cacheIndex, version ) {

		this.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );

	}

	updateBinding( binding ) {

		this.bindingUtils.updateBinding( binding );

	}

	// attributes

	createIndexAttribute( attribute ) {

		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

	}

	createAttribute( attribute ) {

		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

	}

	createStorageAttribute( attribute ) {

		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

	}

	createIndirectStorageAttribute( attribute ) {

		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

	}

	updateAttribute( attribute ) {

		this.attributeUtils.updateAttribute( attribute );

	}

	destroyAttribute( attribute ) {

		this.attributeUtils.destroyAttribute( attribute );

	}

	// canvas

	updateSize() {

		this.colorBuffer = this.textureUtils.getColorBuffer();
		this.defaultRenderPassdescriptor = null;

	}

	// utils public

	getMaxAnisotropy() {

		return 16;

	}

	hasFeature( name ) {

		return this.device.features.has( name );

	}

	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

		let dstX = 0;
		let dstY = 0;
		let dstLayer = 0;

		let srcX = 0;
		let srcY = 0;
		let srcLayer = 0;

		let srcWidth = srcTexture.image.width;
		let srcHeight = srcTexture.image.height;

		if ( srcRegion !== null ) {

			srcX = srcRegion.x;
			srcY = srcRegion.y;
			srcLayer = srcRegion.z || 0;
			srcWidth = srcRegion.width;
			srcHeight = srcRegion.height;

		}

		if ( dstPosition !== null ) {

			dstX = dstPosition.x;
			dstY = dstPosition.y;
			dstLayer = dstPosition.z || 0;

		}

		const encoder = this.device.createCommandEncoder( { label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id } );

		const sourceGPU = this.get( srcTexture ).texture;
		const destinationGPU = this.get( dstTexture ).texture;

		encoder.copyTextureToTexture(
			{
				texture: sourceGPU,
				mipLevel: level,
				origin: { x: srcX, y: srcY, z: srcLayer }
			},
			{
				texture: destinationGPU,
				mipLevel: level,
				origin: { x: dstX, y: dstY, z: dstLayer }
			},
			[
				srcWidth,
				srcHeight,
				1
			]
		);

		this.device.queue.submit( [ encoder.finish() ] );

	}

	copyFramebufferToTexture( texture, renderContext, rectangle ) {

		const renderContextData = this.get( renderContext );

		let sourceGPU = null;

		if ( renderContext.renderTarget ) {

			if ( texture.isDepthTexture ) {

				sourceGPU = this.get( renderContext.depthTexture ).texture;

			} else {

				sourceGPU = this.get( renderContext.textures[ 0 ] ).texture;

			}

		} else {

			if ( texture.isDepthTexture ) {

				sourceGPU = this.textureUtils.getDepthBuffer( renderContext.depth, renderContext.stencil );

			} else {

				sourceGPU = this.context.getCurrentTexture();

			}

		}

		const destinationGPU = this.get( texture ).texture;

		if ( sourceGPU.format !== destinationGPU.format ) {

			console.error( 'WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format );

			return;

		}

		let encoder;

		if ( renderContextData.currentPass ) {

			renderContextData.currentPass.end();

			encoder = renderContextData.encoder;

		} else {

			encoder = this.device.createCommandEncoder( { label: 'copyFramebufferToTexture_' + texture.id } );

		}

		encoder.copyTextureToTexture(
			{
				texture: sourceGPU,
				origin: [ rectangle.x, rectangle.y, 0 ],
			},
			{
				texture: destinationGPU
			},
			[
				rectangle.z,
				rectangle.w
			]
		);

		if ( texture.generateMipmaps ) this.textureUtils.generateMipmaps( texture );

		if ( renderContextData.currentPass ) {

			const { descriptor } = renderContextData;

			for ( let i = 0; i < descriptor.colorAttachments.length; i ++ ) {

				descriptor.colorAttachments[ i ].loadOp = GPULoadOp.Load;

			}

			if ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
			if ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;

			renderContextData.currentPass = encoder.beginRenderPass( descriptor );
			renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };

			if ( renderContext.viewport ) {

				this.updateViewport( renderContext );

			}

			if ( renderContext.scissor ) {

				const { x, y, width, height } = renderContext.scissorValue;

				renderContextData.currentPass.setScissorRect( x, y, width, height );

			}

		} else {

			this.device.queue.submit( [ encoder.finish() ] );

		}

	}

}

class IESSpotLight extends SpotLight {

	constructor( color, intensity, distance, angle, penumbra, decay ) {

		super( color, intensity, distance, angle, penumbra, decay );

		this.iesMap = null;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.iesMap = source.iesMap;

		return this;

	}

}

class BasicNodeLibrary extends NodeLibrary {

	constructor() {

		super();

		this.addLight( PointLightNode, PointLight );
		this.addLight( DirectionalLightNode, DirectionalLight );
		this.addLight( RectAreaLightNode, RectAreaLight );
		this.addLight( SpotLightNode, SpotLight );
		this.addLight( AmbientLightNode, AmbientLight );
		this.addLight( HemisphereLightNode, HemisphereLight );
		this.addLight( LightProbeNode, LightProbe );
		this.addLight( IESSpotLightNode, IESSpotLight );

		this.addToneMapping( linearToneMapping, LinearToneMapping );
		this.addToneMapping( reinhardToneMapping, ReinhardToneMapping );
		this.addToneMapping( cineonToneMapping, CineonToneMapping );
		this.addToneMapping( acesFilmicToneMapping, ACESFilmicToneMapping );
		this.addToneMapping( agxToneMapping, AgXToneMapping );
		this.addToneMapping( neutralToneMapping, NeutralToneMapping );

	}

}

class WebGPURenderer extends Renderer {

	constructor( parameters = {} ) {

		let BackendClass;

		if ( parameters.forceWebGL ) {

			BackendClass = WebGLBackend;

		} else {

			BackendClass = WebGPUBackend;

			parameters.getFallback = () => {

				console.warn( 'THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.' );

				return new WebGLBackend( parameters );

			};

		}

		const backend = new BackendClass( parameters );

		super( backend, parameters );

		this.library = new BasicNodeLibrary();

		this.isWebGPURenderer = true;

	}

}

class BundleGroup extends Group {

	constructor() {

		super();

		this.isBundleGroup = true;

		this.type = 'BundleGroup';

		this.static = true;
		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

const _material = /*@__PURE__*/ new NodeMaterial();
const _quadMesh = /*@__PURE__*/ new QuadMesh( _material );

class PostProcessing {

	constructor( renderer, outputNode = vec4( 0, 0, 1, 1 ) ) {

		this.renderer = renderer;
		this.outputNode = outputNode;

		this.outputColorTransform = true;

		this.needsUpdate = true;

		_material.name = 'PostProcessing';

	}

	render() {

		this.update();

		const renderer = this.renderer;

		const toneMapping = renderer.toneMapping;
		const outputColorSpace = renderer.outputColorSpace;

		renderer.toneMapping = NoToneMapping;
		renderer.outputColorSpace = LinearSRGBColorSpace;

		//

		_quadMesh.render( renderer );

		//

		renderer.toneMapping = toneMapping;
		renderer.outputColorSpace = outputColorSpace;

	}

	update() {

		if ( this.needsUpdate === true ) {

			const renderer = this.renderer;

			const toneMapping = renderer.toneMapping;
			const outputColorSpace = renderer.outputColorSpace;

			_quadMesh.material.fragmentNode = this.outputColorTransform === true ? renderOutput( this.outputNode, toneMapping, outputColorSpace ) : this.outputNode.context( { toneMapping, outputColorSpace } );
			_quadMesh.material.needsUpdate = true;

			this.needsUpdate = false;

		}

	}

	async renderAsync() {

		this.update();

		const renderer = this.renderer;

		const toneMapping = renderer.toneMapping;
		const outputColorSpace = renderer.outputColorSpace;

		renderer.toneMapping = NoToneMapping;
		renderer.outputColorSpace = LinearSRGBColorSpace;

		//

		await _quadMesh.renderAsync( renderer );

		//

		renderer.toneMapping = toneMapping;
		renderer.outputColorSpace = outputColorSpace;

	}

}

// renderer state

function saveRendererState( renderer, state = {} ) {

	state.toneMapping = renderer.toneMapping;
	state.toneMappingExposure = renderer.toneMappingExposure;
	state.outputColorSpace = renderer.outputColorSpace;
	state.renderTarget = renderer.getRenderTarget();
	state.activeCubeFace = renderer.getActiveCubeFace();
	state.activeMipmapLevel = renderer.getActiveMipmapLevel();
	state.renderObjectFunction = renderer.getRenderObjectFunction();
	state.pixelRatio = renderer.getPixelRatio();
	state.mrt = renderer.getMRT();
	state.clearColor = renderer.getClearColor( state.clearColor || new Color() );
	state.clearAlpha = renderer.getClearAlpha();
	state.autoClear = renderer.autoClear;
	state.scissorTest = renderer.getScissorTest();

	return state;

}

function resetRendererState( renderer, state ) {

	state = saveRendererState( renderer, state );

	renderer.setMRT( null );
	renderer.setRenderObjectFunction( null );
	renderer.setClearColor( 0x000000, 1 );
	renderer.autoClear = true;

	return state;

}

function restoreRendererState( renderer, state ) {

	renderer.toneMapping = state.toneMapping;
	renderer.toneMappingExposure = state.toneMappingExposure;
	renderer.outputColorSpace = state.outputColorSpace;
	renderer.setRenderTarget( state.renderTarget, state.activeCubeFace, state.activeMipmapLevel );
	renderer.setRenderObjectFunction( state.renderObjectFunction );
	renderer.setPixelRatio( state.pixelRatio );
	renderer.setMRT( state.mrt );
	renderer.setClearColor( state.clearColor, state.clearAlpha );
	renderer.autoClear = state.autoClear;
	renderer.setScissorTest( state.scissorTest );

}

// renderer and scene state

function saveRendererAndSceneState( renderer, scene, state = {} ) {

	state = saveRendererState( renderer, state );
	state.background = scene.background;
	state.backgroundNode = scene.backgroundNode;
	state.overrideMaterial = scene.overrideMaterial;

	return state;

}

function resetRendererAndSceneState( renderer, scene, state ) {

	state = saveRendererAndSceneState( renderer, scene, state );

	scene.background = null;
	scene.backgroundNode = null;
	scene.overrideMaterial = null;

	return state;

}

function restoreRendererAndSceneState( renderer, scene, state ) {

	restoreRendererState( renderer, state );

	scene.background = state.background;
	scene.backgroundNode = state.backgroundNode;
	scene.overrideMaterial = state.overrideMaterial;

}

var PostProcessingUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	resetRendererAndSceneState: resetRendererAndSceneState,
	resetRendererState: resetRendererState,
	restoreRendererAndSceneState: restoreRendererAndSceneState,
	restoreRendererState: restoreRendererState,
	saveRendererAndSceneState: saveRendererAndSceneState,
	saveRendererState: saveRendererState
});

class StorageTexture extends Texture {

	constructor( width = 1, height = 1 ) {

		super();

		this.image = { width, height };

		this.magFilter = LinearFilter;
		this.minFilter = LinearFilter;

		this.isStorageTexture = true;

	}

}

class IndirectStorageBufferAttribute extends StorageBufferAttribute {

	constructor( array, itemSize ) {

		super( array, itemSize, Uint32Array );

		this.isIndirectStorageBufferAttribute = true;

	}

}

class NodeLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.textures = {};
		this.nodes = {};

	}

	load( url, onLoad, onProgress, onError ) {

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, ( text ) => {

			try {

				onLoad( this.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				this.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parseNodes( json ) {

		const nodes = {};

		if ( json !== undefined ) {

			for ( const nodeJSON of json ) {

				const { uuid, type } = nodeJSON;

				nodes[ uuid ] = this.createNodeFromType( type );
				nodes[ uuid ].uuid = uuid;

			}

			const meta = { nodes, textures: this.textures };

			for ( const nodeJSON of json ) {

				nodeJSON.meta = meta;

				const node = nodes[ nodeJSON.uuid ];
				node.deserialize( nodeJSON );

				delete nodeJSON.meta;

			}

		}

		return nodes;

	}

	parse( json ) {

		const node = this.createNodeFromType( json.type );
		node.uuid = json.uuid;

		const nodes = this.parseNodes( json.nodes );
		const meta = { nodes, textures: this.textures };

		json.meta = meta;

		node.deserialize( json );

		delete json.meta;

		return node;

	}

	setTextures( value ) {

		this.textures = value;
		return this;

	}

	setNodes( value ) {

		this.nodes = value;
		return this;

	}

	createNodeFromType( type ) {

		if ( this.nodes[ type ] === undefined ) {

			console.error( 'THREE.NodeLoader: Node type not found:', type );
			return float();

		}

		return nodeObject( new this.nodes[ type ]() );

	}

}

class NodeMaterialLoader extends MaterialLoader {

	constructor( manager ) {

		super( manager );

		this.nodes = {};
		this.nodeMaterials = {};

	}

	parse( json ) {

		const material = super.parse( json );

		const nodes = this.nodes;
		const inputNodes = json.inputNodes;

		for ( const property in inputNodes ) {

			const uuid = inputNodes[ property ];

			material[ property ] = nodes[ uuid ];

		}

		return material;

	}

	setNodes( value ) {

		this.nodes = value;
		return this;

	}

	setNodeMaterials( value ) {

		this.nodeMaterials = value;
		return this;

	}

	createMaterialFromType( type ) {

		const materialClass = this.nodeMaterials[ type ];

		if ( materialClass !== undefined ) {

			return new materialClass();

		}

		return super.createMaterialFromType( type );

	}

}

class NodeObjectLoader extends ObjectLoader {

	constructor( manager ) {

		super( manager );

		this.nodes = {};
		this.nodeMaterials = {};

		this._nodesJSON = null;

	}

	setNodes( value ) {

		this.nodes = value;
		return this;

	}

	setNodeMaterials( value ) {

		this.nodeMaterials = value;
		return this;

	}

	parse( json, onLoad ) {

		this._nodesJSON = json.nodes;

		const data = super.parse( json, onLoad );

		this._nodesJSON = null; // dispose

		return data;

	}

	parseNodes( json, textures ) {

		if ( json !== undefined ) {

			const loader = new NodeLoader();
			loader.setNodes( this.nodes );
			loader.setTextures( textures );

			return loader.parseNodes( json );

		}

		return {};

	}

	parseMaterials( json, textures ) {

		const materials = {};

		if ( json !== undefined ) {

			const nodes = this.parseNodes( this._nodesJSON, textures );

			const loader = new NodeMaterialLoader();
			loader.setTextures( textures );
			loader.setNodes( nodes );
			loader.setNodeMaterials( this.nodeMaterials );

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				materials[ data.uuid ] = loader.parse( data );

			}

		}

		return materials;

	}

}

class ClippingGroup extends Group {

	constructor() {

		super();

		this.isClippingGroup = true;
		this.clippingPlanes = [];
		this.enabled = true;
		this.clipIntersection = false;
		this.clipShadows = false;

	}

}

export { ACESFilmicToneMapping, AONode, AddEquation, AddOperation, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightNode, AnalyticLightNode, ArrayElementNode, AssignNode, AttributeNode, BackSide, BasicEnvironmentNode, BasicShadowMap, BatchNode, BoxGeometry, BufferAttribute, BufferAttributeNode, BufferGeometry, BufferNode, BumpMapNode, BundleGroup, BypassNode, ByteType, CacheNode, CineonToneMapping, ClampToEdgeWrapping, ClippingGroup, CodeNode, Color, ColorManagement, ColorSpaceNode, ComputeNode, ConstNode, ContextNode, ConvertNode, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureNode, CubeUVReflectionMapping, CullFaceBack, CullFaceFront, CullFaceNone, CustomBlending, DataArrayTexture, DataTexture, DecrementStencilOp, DecrementWrapStencilOp, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightNode, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicDrawUsage, EnvironmentNode, EqualCompare, EqualDepth, EqualStencilFunc, EquirectUVNode, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExpressionNode, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, FogExp2Node, FogNode, FogRangeNode, FramebufferTexture, FrontFacingNode, FrontSide, Frustum, FunctionCallNode, FunctionNode, FunctionOverloadingNode, GLSLNodeParser, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, Group, HalfFloatType, HemisphereLight, HemisphereLightNode, IESSpotLight, IESSpotLightNode, IncrementStencilOp, IncrementWrapStencilOp, IndexNode, IndirectStorageBufferAttribute, InstanceNode, InstancedBufferAttribute, InstancedInterleavedBuffer, InstancedMeshNode, InstancedPointsNodeMaterial, IntType, InterleavedBuffer, InterleavedBufferAttribute, InvertStencilOp, IrradianceNode, JoinNode, KeepStencilOp, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, LightProbe, LightProbeNode, Lighting, LightingContextNode, LightingModel, LightingNode, LightsNode, Line2NodeMaterial, LineBasicMaterial, LineBasicNodeMaterial, LineDashedMaterial, LineDashedNodeMaterial, LinearFilter, LinearMipMapLinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, Loader, LoopNode, LuminanceAlphaFormat, LuminanceFormat, MRTNode, MatcapUVNode, Material, MaterialLoader, MaterialNode, MaterialReferenceNode, MathUtils, Matrix3, Matrix4, MaxEquation, MaxMipLevelNode, Mesh, MeshBasicMaterial, MeshBasicNodeMaterial, MeshLambertMaterial, MeshLambertNodeMaterial, MeshMatcapMaterial, MeshMatcapNodeMaterial, MeshNormalMaterial, MeshNormalNodeMaterial, MeshPhongMaterial, MeshPhongNodeMaterial, MeshPhysicalMaterial, MeshPhysicalNodeMaterial, MeshSSSNodeMaterial, MeshStandardMaterial, MeshStandardNodeMaterial, MeshToonMaterial, MeshToonNodeMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, ModelNode, ModelViewProjectionNode, MorphNode, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, Node, NodeAccess, NodeAttribute, NodeBuilder, NodeCache, NodeCode, NodeFrame, NodeFunctionInput, NodeLoader, NodeMaterial, NodeMaterialLoader, NodeMaterialObserver, NodeObjectLoader, NodeShaderStage, NodeType, NodeUniform, NodeUpdateType, NodeUtils, NodeVar, NodeVarying, NormalBlending, NormalMapNode, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, Object3D, Object3DNode, ObjectLoader, ObjectSpaceNormalMap, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, OutputStructNode, PCFShadowMap, PMREMGenerator, PMREMNode, ParameterNode, PassNode, PerspectiveCamera, PhongLightingModel, PhysicalLightingModel, Plane, PointLight, PointLightNode, PointUVNode, PointsMaterial, PointsNodeMaterial, PostProcessing, PostProcessingUtils, PosterizeNode, PropertyNode, QuadMesh, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGBIntegerFormat, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RTTNode, RangeNode, RectAreaLight, RectAreaLightNode, RedFormat, RedIntegerFormat, ReferenceNode, ReflectorNode, ReinhardToneMapping, RemapNode, RenderOutputNode, RenderTarget, RendererReferenceNode, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RotateNode, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, SceneNode, ScreenNode, ScriptableNode, ScriptableValueNode, SetNode, ShadowMaterial, ShadowNode, ShadowNodeMaterial, ShortType, SkinningNode, SphereGeometry, SplitNode, SpotLight, SpotLightNode, SpriteMaterial, SpriteNodeMaterial, SpriteSheetUVNode, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StackNode, StaticDrawUsage, StorageArrayElementNode, StorageBufferAttribute, StorageBufferNode, StorageInstancedBufferAttribute, StorageTexture, StorageTextureNode, SubtractEquation, SubtractiveBlending, TSL, TangentSpaceNormalMap, TempNode, Texture, Texture3DNode, TextureNode, TextureSizeNode, ToneMappingNode, ToonOutlinePassNode, TriplanarTexturesNode, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, UniformArrayNode, UniformGroupNode, UniformNode, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, UserDataNode, VSMShadowMap, VarNode, VaryingNode, Vector2, Vector3, Vector4, VertexColorNode, ViewportDepthNode, ViewportDepthTextureNode, ViewportSharedTextureNode, ViewportTextureNode, VolumeNodeMaterial, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGPUCoordinateSystem, WebGPURenderer, ZeroFactor, ZeroStencilOp, createCanvasElement, defaultBuildStages, defaultShaderStages, shaderStages, vectorComponents };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhyZWUud2ViZ3B1Lm5vZGVzLmpzIiwic291cmNlcyI6WyIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL21hbmFnZXIvTm9kZU1hdGVyaWFsT2JzZXJ2ZXIuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Ob2RlVXRpbHMuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9jb25zdGFudHMuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Ob2RlLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL0FycmF5RWxlbWVudE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvQ29udmVydE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9UZW1wTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9Kb2luTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9TcGxpdE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvU2V0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9GbGlwTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL0lucHV0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL0NvbnN0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy90c2wvVFNMQ29yZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL1VuaWZvcm1Hcm91cE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Vbmlmb3JtTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL1Byb3BlcnR5Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL0Fzc2lnbk5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29kZS9GdW5jdGlvbkNhbGxOb2RlLmpzIiwiLi4vc3JjL25vZGVzL21hdGgvT3BlcmF0b3JOb2RlLmpzIiwiLi4vc3JjL25vZGVzL21hdGgvTWF0aE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbWF0aC9Db25kaXRpb25hbE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Db250ZXh0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL1Zhck5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9WYXJ5aW5nTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9kaXNwbGF5L0NvbG9yU3BhY2VGdW5jdGlvbnMuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9Db2xvclNwYWNlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvUmVmZXJlbmNlQmFzZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1JlbmRlcmVyUmVmZXJlbmNlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9kaXNwbGF5L1RvbmVNYXBwaW5nTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvQnVmZmVyQXR0cmlidXRlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9ncGdwdS9Db21wdXRlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL0NhY2hlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL0J5cGFzc05vZGUuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvUmVtYXBOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2NvZGUvRXhwcmVzc2lvbk5vZGUuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvRGlzY2FyZC5qcyIsIi4uL3NyYy9ub2Rlcy9kaXNwbGF5L1JlbmRlck91dHB1dE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvdHNsL1RTTEJhc2UuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9BdHRyaWJ1dGVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9VVi5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvVGV4dHVyZVNpemVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL01heE1pcExldmVsTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvVGV4dHVyZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL0NhbWVyYS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvT2JqZWN0M0ROb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9Nb2RlbE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1Bvc2l0aW9uLmpzIiwiLi4vc3JjL25vZGVzL2Rpc3BsYXkvRnJvbnRGYWNpbmdOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9Ob3JtYWwuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL01hdGVyaWFsUHJvcGVydGllcy5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvUmVmbGVjdFZlY3Rvci5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvQ3ViZVRleHR1cmVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9CdWZmZXJOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9Vbmlmb3JtQXJyYXlOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9SZWZlcmVuY2VOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbFJlZmVyZW5jZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1RhbmdlbnQuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL0JpdGFuZ2VudC5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvQWNjZXNzb3JzVXRpbHMuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9Ob3JtYWxNYXBOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2Rpc3BsYXkvQnVtcE1hcE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL01hdGVyaWFsTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvTW9kZWxWaWV3UHJvamVjdGlvbk5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9JbmRleE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL0luc3RhbmNlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvSW5zdGFuY2VkTWVzaE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL0JhdGNoTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvU2tpbm5pbmdOb2RlLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL0xvb3BOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9Nb3JwaE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvTGlnaHRpbmdOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL0FPTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9saWdodGluZy9MaWdodGluZ0NvbnRleHROb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL0lycmFkaWFuY2VOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2Rpc3BsYXkvU2NyZWVuTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9kaXNwbGF5L1ZpZXdwb3J0VGV4dHVyZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9WaWV3cG9ydERlcHRoVGV4dHVyZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9WaWV3cG9ydERlcHRoTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvQnVpbHRpbk5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL0NsaXBwaW5nTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvbWF0ZXJpYWwvZ2V0QWxwaGFIYXNoVGhyZXNob2xkLmpzIiwiLi4vc3JjL21hdGVyaWFscy9ub2Rlcy9Ob2RlTWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL0luc3RhbmNlZFBvaW50c05vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvbm9kZXMvTGluZUJhc2ljTm9kZU1hdGVyaWFsLmpzIiwiLi4vc3JjL21hdGVyaWFscy9ub2Rlcy9MaW5lRGFzaGVkTm9kZU1hdGVyaWFsLmpzIiwiLi4vc3JjL25vZGVzL2Rpc3BsYXkvVmlld3BvcnRTaGFyZWRUZXh0dXJlTm9kZS5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvbm9kZXMvTGluZTJOb2RlTWF0ZXJpYWwuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvUGFja2luZy5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvbm9kZXMvTWVzaE5vcm1hbE5vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9FcXVpcmVjdFVWTm9kZS5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0N1YmVSZW5kZXJUYXJnZXQuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvQ3ViZU1hcE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvQmFzaWNFbnZpcm9ubWVudE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvQmFzaWNMaWdodE1hcE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9MaWdodGluZ01vZGVsLmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9CYXNpY0xpZ2h0aW5nTW9kZWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL01lc2hCYXNpY05vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvQlNERi9GX1NjaGxpY2suanMiLCIuLi9zcmMvbm9kZXMvZnVuY3Rpb25zL0JTREYvQlJERl9MYW1iZXJ0LmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9QaG9uZ0xpZ2h0aW5nTW9kZWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL01lc2hMYW1iZXJ0Tm9kZU1hdGVyaWFsLmpzIiwiLi4vc3JjL21hdGVyaWFscy9ub2Rlcy9NZXNoUGhvbmdOb2RlTWF0ZXJpYWwuanMiLCIuLi9zcmMvbm9kZXMvZnVuY3Rpb25zL21hdGVyaWFsL2dldEdlb21ldHJ5Um91Z2huZXNzLmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9tYXRlcmlhbC9nZXRSb3VnaG5lc3MuanMiLCIuLi9zcmMvbm9kZXMvZnVuY3Rpb25zL0JTREYvVl9HR1hfU21pdGhDb3JyZWxhdGVkLmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9CU0RGL1ZfR0dYX1NtaXRoQ29ycmVsYXRlZF9Bbmlzb3Ryb3BpYy5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvQlNERi9EX0dHWC5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvQlNERi9EX0dHWF9Bbmlzb3Ryb3BpYy5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvQlNERi9CUkRGX0dHWC5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvQlNERi9ERkdBcHByb3guanMiLCIuLi9zcmMvbm9kZXMvZnVuY3Rpb25zL0JTREYvRW52aXJvbm1lbnRCUkRGLmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9CU0RGL1NjaGxpY2tfdG9fRjAuanMiLCIuLi9zcmMvbm9kZXMvZnVuY3Rpb25zL0JTREYvQlJERl9TaGVlbi5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvQlNERi9MVEMuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1RleHR1cmVCaWN1YmljLmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9QaHlzaWNhbExpZ2h0aW5nTW9kZWwuanMiLCIuLi9zcmMvbm9kZXMvcG1yZW0vUE1SRU1VdGlscy5qcyIsIi4uL3NyYy9ub2Rlcy9wbXJlbS9QTVJFTU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvRW52aXJvbm1lbnROb2RlLmpzIiwiLi4vc3JjL21hdGVyaWFscy9ub2Rlcy9NZXNoU3RhbmRhcmROb2RlTWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL01lc2hQaHlzaWNhbE5vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvbm9kZXMvTWVzaFNTU05vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvVG9vbkxpZ2h0aW5nTW9kZWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL01lc2hUb29uTm9kZU1hdGVyaWFsLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL01hdGNhcFVWTm9kZS5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvbm9kZXMvTWVzaE1hdGNhcE5vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvbm9kZXMvUG9pbnRzTm9kZU1hdGVyaWFsLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL1JvdGF0ZU5vZGUuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL1Nwcml0ZU5vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvU2hhZG93TWFza01vZGVsLmpzIiwiLi4vc3JjL21hdGVyaWFscy9ub2Rlcy9TaGFkb3dOb2RlTWF0ZXJpYWwuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1RleHR1cmUzRE5vZGUuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL1ZvbHVtZU5vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0FuaW1hdGlvbi5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0NoYWluTWFwLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vUmVuZGVyT2JqZWN0LmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vUmVuZGVyT2JqZWN0cy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0RhdGFNYXAuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9Db25zdGFudHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9BdHRyaWJ1dGVzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vR2VvbWV0cmllcy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0luZm8uanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9QaXBlbGluZS5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1JlbmRlclBpcGVsaW5lLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vQ29tcHV0ZVBpcGVsaW5lLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vUHJvZ3JhbW1hYmxlU3RhZ2UuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9QaXBlbGluZXMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9CaW5kaW5ncy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1JlbmRlckxpc3QuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9SZW5kZXJMaXN0cy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1JlbmRlckNvbnRleHQuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9SZW5kZXJDb250ZXh0cy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1RleHR1cmVzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vQ29sb3I0LmpzIiwiLi4vc3JjL25vZGVzL2NvcmUvUGFyYW1ldGVyTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL1N0YWNrTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL1N0cnVjdFR5cGVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2NvcmUvT3V0cHV0U3RydWN0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL01SVE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbWF0aC9IYXNoLmpzIiwiLi4vc3JjL25vZGVzL21hdGgvTWF0aFV0aWxzLmpzIiwiLi4vc3JjL25vZGVzL21hdGgvVHJpTm9pc2UzRC5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9GdW5jdGlvbk92ZXJsb2FkaW5nTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9UaW1lci5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9Pc2NpbGxhdG9ycy5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9VVlV0aWxzLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL1Nwcml0ZVV0aWxzLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL1ZpZXdwb3J0VXRpbHMuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvU3ByaXRlU2hlZXRVVk5vZGUuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvVHJpcGxhbmFyVGV4dHVyZXNOb2RlLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL1JlZmxlY3Rvck5vZGUuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9RdWFkTWVzaC5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9SVFROb2RlLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL1Bvc3RQcm9jZXNzaW5nVXRpbHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9TdG9yYWdlSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vU3RvcmFnZUJ1ZmZlckF0dHJpYnV0ZS5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9TdG9yYWdlQXJyYXlFbGVtZW50Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvU3RvcmFnZUJ1ZmZlck5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL0FycmF5cy5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvVmVydGV4Q29sb3JOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9Qb2ludFVWTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvU2NlbmVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9TdG9yYWdlVGV4dHVyZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1VzZXJEYXRhTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvVmVsb2NpdHlOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2Rpc3BsYXkvQmxlbmRNb2Rlcy5qcyIsIi4uL3NyYy9ub2Rlcy9kaXNwbGF5L0NvbG9yQWRqdXN0bWVudC5qcyIsIi4uL3NyYy9ub2Rlcy9kaXNwbGF5L1Bvc3Rlcml6ZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9QYXNzTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9kaXNwbGF5L1Rvb25PdXRsaW5lUGFzc05vZGUuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9Ub25lTWFwcGluZ0Z1bmN0aW9ucy5qcyIsIi4uL3NyYy9ub2Rlcy9jb2RlL0NvZGVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2NvZGUvRnVuY3Rpb25Ob2RlLmpzIiwiLi4vc3JjL25vZGVzL2NvZGUvU2NyaXB0YWJsZVZhbHVlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb2RlL1NjcmlwdGFibGVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2ZvZy9Gb2dOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2ZvZy9Gb2dSYW5nZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvZm9nL0ZvZ0V4cDJOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2dlb21ldHJ5L1JhbmdlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9ncGdwdS9Db21wdXRlQnVpbHRpbk5vZGUuanMiLCIuLi9zcmMvbm9kZXMvZ3BncHUvQmFycmllck5vZGUuanMiLCIuLi9zcmMvbm9kZXMvZ3BncHUvV29ya2dyb3VwSW5mb05vZGUuanMiLCIuLi9zcmMvbm9kZXMvZ3BncHUvQXRvbWljRnVuY3Rpb25Ob2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9MaWdodHMuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvTGlnaHRzTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9saWdodGluZy9TaGFkb3dOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL0FuYWx5dGljTGlnaHROb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL0xpZ2h0VXRpbHMuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvUG9pbnRTaGFkb3dOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL1BvaW50TGlnaHROb2RlLmpzIiwiLi4vc3JjL25vZGVzL3Byb2NlZHVyYWwvQ2hlY2tlci5qcyIsIi4uL3NyYy9ub2Rlcy9tYXRlcmlhbHgvbGliL214X25vaXNlLmpzIiwiLi4vc3JjL25vZGVzL21hdGVyaWFseC9saWIvbXhfaHN2LmpzIiwiLi4vc3JjL25vZGVzL21hdGVyaWFseC9saWIvbXhfdHJhbnNmb3JtX2NvbG9yLmpzIiwiLi4vc3JjL25vZGVzL21hdGVyaWFseC9NYXRlcmlhbFhOb2Rlcy5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvbWF0ZXJpYWwvZ2V0UGFyYWxsYXhDb3JyZWN0Tm9ybWFsLmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9tYXRlcmlhbC9nZXRTaElycmFkaWFuY2VBdC5qcyIsIi4uL3NyYy9ub2Rlcy9UU0wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9CYWNrZ3JvdW5kLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vQmluZEdyb3VwLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vbm9kZXMvTm9kZUJ1aWxkZXJTdGF0ZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL05vZGVBdHRyaWJ1dGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Ob2RlVW5pZm9ybS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL05vZGVWYXIuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Ob2RlVmFyeWluZy5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL05vZGVDb2RlLmpzIiwiLi4vc3JjL25vZGVzL2NvcmUvTm9kZUNhY2hlLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vVW5pZm9ybS5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL25vZGVzL05vZGVVbmlmb3JtLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vZXh0cmFzL1BNUkVNR2VuZXJhdG9yLmpzIiwiLi4vc3JjL25vZGVzL2NvcmUvTm9kZUJ1aWxkZXIuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Ob2RlRnJhbWUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Ob2RlRnVuY3Rpb25JbnB1dC5qcyIsIi4uL3NyYy9ub2Rlcy9saWdodGluZy9EaXJlY3Rpb25hbExpZ2h0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9saWdodGluZy9SZWN0QXJlYUxpZ2h0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9saWdodGluZy9TcG90TGlnaHROb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL0lFU1Nwb3RMaWdodE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvQW1iaWVudExpZ2h0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9saWdodGluZy9IZW1pc3BoZXJlTGlnaHROb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL0xpZ2h0UHJvYmVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2NvcmUvTm9kZVBhcnNlci5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL05vZGVGdW5jdGlvbi5qcyIsIi4uL3NyYy9ub2Rlcy9wYXJzZXJzL0dMU0xOb2RlRnVuY3Rpb24uanMiLCIuLi9zcmMvbm9kZXMvcGFyc2Vycy9HTFNMTm9kZVBhcnNlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL25vZGVzL05vZGVzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vQ2xpcHBpbmdDb250ZXh0LmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vUmVuZGVyQnVuZGxlLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vUmVuZGVyQnVuZGxlcy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL25vZGVzL05vZGVMaWJyYXJ5LmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vTGlnaHRpbmcuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9SZW5kZXJlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0JpbmRpbmcuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9CdWZmZXJVdGlscy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0J1ZmZlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1VuaWZvcm1CdWZmZXIuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9ub2Rlcy9Ob2RlVW5pZm9ybUJ1ZmZlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1VuaWZvcm1zR3JvdXAuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9ub2Rlcy9Ob2RlVW5pZm9ybXNHcm91cC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1NhbXBsZWRUZXh0dXJlLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vbm9kZXMvTm9kZVNhbXBsZWRUZXh0dXJlLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC1mYWxsYmFjay9ub2Rlcy9HTFNMTm9kZUJ1aWxkZXIuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9CYWNrZW5kLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC1mYWxsYmFjay91dGlscy9XZWJHTEF0dHJpYnV0ZVV0aWxzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC1mYWxsYmFjay91dGlscy9XZWJHTFN0YXRlLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC1mYWxsYmFjay91dGlscy9XZWJHTFV0aWxzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC1mYWxsYmFjay91dGlscy9XZWJHTFRleHR1cmVVdGlscy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wtZmFsbGJhY2svdXRpbHMvV2ViR0xFeHRlbnNpb25zLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC1mYWxsYmFjay91dGlscy9XZWJHTENhcGFiaWxpdGllcy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wtZmFsbGJhY2svdXRpbHMvV2ViR0xDb25zdGFudHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsLWZhbGxiYWNrL1dlYkdMQnVmZmVyUmVuZGVyZXIuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsLWZhbGxiYWNrL1dlYkdMQmFja2VuZC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ3B1L3V0aWxzL1dlYkdQVUNvbnN0YW50cy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1NhbXBsZXIuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9ub2Rlcy9Ob2RlU2FtcGxlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1N0b3JhZ2VCdWZmZXIuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9ub2Rlcy9Ob2RlU3RvcmFnZUJ1ZmZlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ3B1L3V0aWxzL1dlYkdQVVRleHR1cmVQYXNzVXRpbHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdwdS91dGlscy9XZWJHUFVUZXh0dXJlVXRpbHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdwdS9ub2Rlcy9XR1NMTm9kZUZ1bmN0aW9uLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJncHUvbm9kZXMvV0dTTE5vZGVQYXJzZXIuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdwdS9ub2Rlcy9XR1NMTm9kZUJ1aWxkZXIuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdwdS91dGlscy9XZWJHUFVVdGlscy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ3B1L3V0aWxzL1dlYkdQVUF0dHJpYnV0ZVV0aWxzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJncHUvdXRpbHMvV2ViR1BVQmluZGluZ1V0aWxzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJncHUvdXRpbHMvV2ViR1BVUGlwZWxpbmVVdGlscy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ3B1L1dlYkdQVUJhY2tlbmQuanMiLCIuLi9zcmMvbGlnaHRzL3dlYmdwdS9JRVNTcG90TGlnaHQuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdwdS9ub2Rlcy9CYXNpY05vZGVMaWJyYXJ5LmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJncHUvV2ViR1BVUmVuZGVyZXIuTm9kZXMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9CdW5kbGVHcm91cC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1Bvc3RQcm9jZXNzaW5nLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vUG9zdFByb2Nlc3NpbmdVdGlscy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1N0b3JhZ2VUZXh0dXJlLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vSW5kaXJlY3RTdG9yYWdlQnVmZmVyQXR0cmlidXRlLmpzIiwiLi4vc3JjL2xvYWRlcnMvbm9kZXMvTm9kZUxvYWRlci5qcyIsIi4uL3NyYy9sb2FkZXJzL25vZGVzL05vZGVNYXRlcmlhbExvYWRlci5qcyIsIi4uL3NyYy9sb2FkZXJzL25vZGVzL05vZGVPYmplY3RMb2FkZXIuanMiLCIuLi9zcmMvb2JqZWN0cy9DbGlwcGluZ0dyb3VwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJlZnJlc2hVbmlmb3JtcyA9IFtcblx0J2FscGhhTWFwJyxcblx0J2FscGhhVGVzdCcsXG5cdCdhbmlzb3Ryb3B5Jyxcblx0J2FuaXNvdHJvcHlNYXAnLFxuXHQnYW5pc290cm9weVJvdGF0aW9uJyxcblx0J2FvTWFwJyxcblx0J2F0dGVudWF0aW9uQ29sb3InLFxuXHQnYXR0ZW51YXRpb25EaXN0YW5jZScsXG5cdCdidW1wTWFwJyxcblx0J2NsZWFyY29hdCcsXG5cdCdjbGVhcmNvYXRNYXAnLFxuXHQnY2xlYXJjb2F0Tm9ybWFsTWFwJyxcblx0J2NsZWFyY29hdE5vcm1hbFNjYWxlJyxcblx0J2NsZWFyY29hdFJvdWdobmVzcycsXG5cdCdjb2xvcicsXG5cdCdkaXNwZXJzaW9uJyxcblx0J2Rpc3BsYWNlbWVudE1hcCcsXG5cdCdlbWlzc2l2ZScsXG5cdCdlbWlzc2l2ZU1hcCcsXG5cdCdlbnZNYXAnLFxuXHQnZ3JhZGllbnRNYXAnLFxuXHQnaW9yJyxcblx0J2lyaWRlc2NlbmNlJyxcblx0J2lyaWRlc2NlbmNlSU9SJyxcblx0J2lyaWRlc2NlbmNlTWFwJyxcblx0J2lyaWRlc2NlbmNlVGhpY2tuZXNzTWFwJyxcblx0J2xpZ2h0TWFwJyxcblx0J21hcCcsXG5cdCdtYXRjYXAnLFxuXHQnbWV0YWxuZXNzJyxcblx0J21ldGFsbmVzc01hcCcsXG5cdCdub3JtYWxNYXAnLFxuXHQnbm9ybWFsU2NhbGUnLFxuXHQnb3BhY2l0eScsXG5cdCdyb3VnaG5lc3MnLFxuXHQncm91Z2huZXNzTWFwJyxcblx0J3NoZWVuJyxcblx0J3NoZWVuQ29sb3InLFxuXHQnc2hlZW5Db2xvck1hcCcsXG5cdCdzaGVlblJvdWdobmVzc01hcCcsXG5cdCdzaGluaW5lc3MnLFxuXHQnc3BlY3VsYXInLFxuXHQnc3BlY3VsYXJDb2xvcicsXG5cdCdzcGVjdWxhckNvbG9yTWFwJyxcblx0J3NwZWN1bGFySW50ZW5zaXR5Jyxcblx0J3NwZWN1bGFySW50ZW5zaXR5TWFwJyxcblx0J3NwZWN1bGFyTWFwJyxcblx0J3RoaWNrbmVzcycsXG5cdCd0cmFuc21pc3Npb24nLFxuXHQndHJhbnNtaXNzaW9uTWFwJ1xuXTtcblxuY2xhc3MgTm9kZU1hdGVyaWFsT2JzZXJ2ZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBidWlsZGVyICkge1xuXG5cdFx0dGhpcy5yZW5kZXJPYmplY3RzID0gbmV3IFdlYWtNYXAoKTtcblx0XHR0aGlzLmhhc05vZGUgPSB0aGlzLmNvbnRhaW5zTm9kZSggYnVpbGRlciApO1xuXHRcdHRoaXMuaGFzQW5pbWF0aW9uID0gYnVpbGRlci5vYmplY3QuaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZTtcblx0XHR0aGlzLnJlZnJlc2hVbmlmb3JtcyA9IHJlZnJlc2hVbmlmb3Jtcztcblx0XHR0aGlzLnJlbmRlcklkID0gMDtcblxuXHR9XG5cblx0Zmlyc3RJbml0aWFsaXphdGlvbiggcmVuZGVyT2JqZWN0ICkge1xuXG5cdFx0Y29uc3QgaGFzSW5pdGlhbGl6ZWQgPSB0aGlzLnJlbmRlck9iamVjdHMuaGFzKCByZW5kZXJPYmplY3QgKTtcblxuXHRcdGlmICggaGFzSW5pdGlhbGl6ZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHR0aGlzLmdldFJlbmRlck9iamVjdERhdGEoIHJlbmRlck9iamVjdCApO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0Z2V0UmVuZGVyT2JqZWN0RGF0YSggcmVuZGVyT2JqZWN0ICkge1xuXG5cdFx0bGV0IGRhdGEgPSB0aGlzLnJlbmRlck9iamVjdHMuZ2V0KCByZW5kZXJPYmplY3QgKTtcblxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCB7IGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0IH0gPSByZW5kZXJPYmplY3Q7XG5cblx0XHRcdGRhdGEgPSB7XG5cdFx0XHRcdG1hdGVyaWFsOiB0aGlzLmdldE1hdGVyaWFsRGF0YSggbWF0ZXJpYWwgKSxcblx0XHRcdFx0Z2VvbWV0cnk6IHtcblx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB0aGlzLmdldEF0dHJpYnV0ZXNEYXRhKCBnZW9tZXRyeS5hdHRyaWJ1dGVzICksXG5cdFx0XHRcdFx0aW5kZXhWZXJzaW9uOiBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmluZGV4LnZlcnNpb24gOiBudWxsLFxuXHRcdFx0XHRcdGRyYXdSYW5nZTogeyBzdGFydDogZ2VvbWV0cnkuZHJhd1JhbmdlLnN0YXJ0LCBjb3VudDogZ2VvbWV0cnkuZHJhd1JhbmdlLmNvdW50IH1cblx0XHRcdFx0fSxcblx0XHRcdFx0d29ybGRNYXRyaXg6IG9iamVjdC5tYXRyaXhXb3JsZC5jbG9uZSgpXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIG9iamVjdC5jZW50ZXIgKSB7XG5cblx0XHRcdFx0ZGF0YS5jZW50ZXIgPSBvYmplY3QuY2VudGVyLmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzICkge1xuXG5cdFx0XHRcdGRhdGEubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5zbGljZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVuZGVyT2JqZWN0LmJ1bmRsZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRkYXRhLnZlcnNpb24gPSByZW5kZXJPYmplY3QuYnVuZGxlLnZlcnNpb247XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkYXRhLm1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDAgKSB7XG5cblx0XHRcdFx0Y29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByZW5kZXJPYmplY3QuY29udGV4dDtcblxuXHRcdFx0XHRkYXRhLmJ1ZmZlcldpZHRoID0gd2lkdGg7XG5cdFx0XHRcdGRhdGEuYnVmZmVySGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucmVuZGVyT2JqZWN0cy5zZXQoIHJlbmRlck9iamVjdCwgZGF0YSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGdldEF0dHJpYnV0ZXNEYXRhKCBhdHRyaWJ1dGVzICkge1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlc0RhdGEgPSB7fTtcblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHRhdHRyaWJ1dGVzRGF0YVsgbmFtZSBdID0ge1xuXHRcdFx0XHR2ZXJzaW9uOiBhdHRyaWJ1dGUudmVyc2lvblxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJ1dGVzRGF0YTtcblxuXHR9XG5cblx0Y29udGFpbnNOb2RlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBidWlsZGVyLm1hdGVyaWFsO1xuXG5cdFx0Zm9yICggY29uc3QgcHJvcGVydHkgaW4gbWF0ZXJpYWwgKSB7XG5cblx0XHRcdGlmICggbWF0ZXJpYWxbIHByb3BlcnR5IF0gJiYgbWF0ZXJpYWxbIHByb3BlcnR5IF0uaXNOb2RlIClcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIGJ1aWxkZXIucmVuZGVyZXIubm9kZXMubW9kZWxWaWV3TWF0cml4ICE9PSBudWxsIHx8IGJ1aWxkZXIucmVuZGVyZXIubm9kZXMubW9kZWxOb3JtYWxWaWV3TWF0cml4ICE9PSBudWxsIClcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRnZXRNYXRlcmlhbERhdGEoIG1hdGVyaWFsICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHt9O1xuXG5cdFx0Zm9yICggY29uc3QgcHJvcGVydHkgb2YgdGhpcy5yZWZyZXNoVW5pZm9ybXMgKSB7XG5cblx0XHRcdGNvbnN0IHZhbHVlID0gbWF0ZXJpYWxbIHByb3BlcnR5IF07XG5cblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY2xvbmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIHZhbHVlLmlzVGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGRhdGFbIHByb3BlcnR5IF0gPSB7IGlkOiB2YWx1ZS5pZCwgdmVyc2lvbjogdmFsdWUudmVyc2lvbiB9O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRkYXRhWyBwcm9wZXJ0eSBdID0gdmFsdWUuY2xvbmUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZGF0YVsgcHJvcGVydHkgXSA9IHZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZXF1YWxzKCByZW5kZXJPYmplY3QgKSB7XG5cblx0XHRjb25zdCB7IG9iamVjdCwgbWF0ZXJpYWwsIGdlb21ldHJ5IH0gPSByZW5kZXJPYmplY3Q7XG5cblx0XHRjb25zdCByZW5kZXJPYmplY3REYXRhID0gdGhpcy5nZXRSZW5kZXJPYmplY3REYXRhKCByZW5kZXJPYmplY3QgKTtcblxuXHRcdC8vIHdvcmxkIG1hdHJpeFxuXG5cdFx0aWYgKCByZW5kZXJPYmplY3REYXRhLndvcmxkTWF0cml4LmVxdWFscyggb2JqZWN0Lm1hdHJpeFdvcmxkICkgIT09IHRydWUgKSB7XG5cblx0XHRcdHJlbmRlck9iamVjdERhdGEud29ybGRNYXRyaXguY29weSggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdC8vIG1hdGVyaWFsXG5cblx0XHRjb25zdCBtYXRlcmlhbERhdGEgPSByZW5kZXJPYmplY3REYXRhLm1hdGVyaWFsO1xuXG5cdFx0Zm9yICggY29uc3QgcHJvcGVydHkgaW4gbWF0ZXJpYWxEYXRhICkge1xuXG5cdFx0XHRjb25zdCB2YWx1ZSA9IG1hdGVyaWFsRGF0YVsgcHJvcGVydHkgXTtcblx0XHRcdGNvbnN0IG10bFZhbHVlID0gbWF0ZXJpYWxbIHByb3BlcnR5IF07XG5cblx0XHRcdGlmICggdmFsdWUuZXF1YWxzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZS5lcXVhbHMoIG10bFZhbHVlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0dmFsdWUuY29weSggbXRsVmFsdWUgKTtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG10bFZhbHVlLmlzVGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRpZiAoIHZhbHVlLmlkICE9PSBtdGxWYWx1ZS5pZCB8fCB2YWx1ZS52ZXJzaW9uICE9PSBtdGxWYWx1ZS52ZXJzaW9uICkge1xuXG5cdFx0XHRcdFx0dmFsdWUuaWQgPSBtdGxWYWx1ZS5pZDtcblx0XHRcdFx0XHR2YWx1ZS52ZXJzaW9uID0gbXRsVmFsdWUudmVyc2lvbjtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlICE9PSBtdGxWYWx1ZSApIHtcblxuXHRcdFx0XHRtYXRlcmlhbERhdGFbIHByb3BlcnR5IF0gPSBtdGxWYWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxEYXRhLnRyYW5zbWlzc2lvbiA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmVuZGVyT2JqZWN0LmNvbnRleHQ7XG5cblx0XHRcdGlmICggcmVuZGVyT2JqZWN0RGF0YS5idWZmZXJXaWR0aCAhPT0gd2lkdGggfHwgcmVuZGVyT2JqZWN0RGF0YS5idWZmZXJIZWlnaHQgIT09IGhlaWdodCApIHtcblxuXHRcdFx0XHRyZW5kZXJPYmplY3REYXRhLmJ1ZmZlcldpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHJlbmRlck9iamVjdERhdGEuYnVmZmVySGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2VvbWV0cnlcblxuXHRcdGNvbnN0IHN0b3JlZEdlb21ldHJ5RGF0YSA9IHJlbmRlck9iamVjdERhdGEuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdFx0Y29uc3Qgc3RvcmVkQXR0cmlidXRlcyA9IHN0b3JlZEdlb21ldHJ5RGF0YS5hdHRyaWJ1dGVzO1xuXG5cdFx0Y29uc3Qgc3RvcmVkQXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyggc3RvcmVkQXR0cmlidXRlcyApO1xuXHRcdGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKCBhdHRyaWJ1dGVzICk7XG5cblx0XHRpZiAoIHN0b3JlZEF0dHJpYnV0ZU5hbWVzLmxlbmd0aCAhPT0gY3VycmVudEF0dHJpYnV0ZU5hbWVzLmxlbmd0aCApIHtcblxuXHRcdFx0cmVuZGVyT2JqZWN0RGF0YS5nZW9tZXRyeS5hdHRyaWJ1dGVzID0gdGhpcy5nZXRBdHRyaWJ1dGVzRGF0YSggYXR0cmlidXRlcyApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29tcGFyZSBlYWNoIGF0dHJpYnV0ZVxuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBvZiBzdG9yZWRBdHRyaWJ1dGVOYW1lcyApIHtcblxuXHRcdFx0Y29uc3Qgc3RvcmVkQXR0cmlidXRlRGF0YSA9IHN0b3JlZEF0dHJpYnV0ZXNbIG5hbWUgXTtcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBhdHRyaWJ1dGUgd2FzIHJlbW92ZWRcblx0XHRcdFx0ZGVsZXRlIHN0b3JlZEF0dHJpYnV0ZXNbIG5hbWUgXTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3RvcmVkQXR0cmlidXRlRGF0YS52ZXJzaW9uICE9PSBhdHRyaWJ1dGUudmVyc2lvbiApIHtcblxuXHRcdFx0XHRzdG9yZWRBdHRyaWJ1dGVEYXRhLnZlcnNpb24gPSBhdHRyaWJ1dGUudmVyc2lvbjtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBjaGVjayBpbmRleFxuXG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBzdG9yZWRJbmRleFZlcnNpb24gPSBzdG9yZWRHZW9tZXRyeURhdGEuaW5kZXhWZXJzaW9uO1xuXHRcdGNvbnN0IGN1cnJlbnRJbmRleFZlcnNpb24gPSBpbmRleCA/IGluZGV4LnZlcnNpb24gOiBudWxsO1xuXG5cdFx0aWYgKCBzdG9yZWRJbmRleFZlcnNpb24gIT09IGN1cnJlbnRJbmRleFZlcnNpb24gKSB7XG5cblx0XHRcdHN0b3JlZEdlb21ldHJ5RGF0YS5pbmRleFZlcnNpb24gPSBjdXJyZW50SW5kZXhWZXJzaW9uO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgZHJhd1JhbmdlXG5cblx0XHRpZiAoIHN0b3JlZEdlb21ldHJ5RGF0YS5kcmF3UmFuZ2Uuc3RhcnQgIT09IGdlb21ldHJ5LmRyYXdSYW5nZS5zdGFydCB8fCBzdG9yZWRHZW9tZXRyeURhdGEuZHJhd1JhbmdlLmNvdW50ICE9PSBnZW9tZXRyeS5kcmF3UmFuZ2UuY291bnQgKSB7XG5cblx0XHRcdHN0b3JlZEdlb21ldHJ5RGF0YS5kcmF3UmFuZ2Uuc3RhcnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2Uuc3RhcnQ7XG5cdFx0XHRzdG9yZWRHZW9tZXRyeURhdGEuZHJhd1JhbmdlLmNvdW50ID0gZ2VvbWV0cnkuZHJhd1JhbmdlLmNvdW50O1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbW9ycGggdGFyZ2V0c1xuXG5cdFx0aWYgKCByZW5kZXJPYmplY3REYXRhLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApIHtcblxuXHRcdFx0bGV0IG1vcnBoQ2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCByZW5kZXJPYmplY3REYXRhLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCByZW5kZXJPYmplY3REYXRhLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9PSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gKSB7XG5cblx0XHRcdFx0XHRtb3JwaENoYW5nZWQgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1vcnBoQ2hhbmdlZCApIHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY2VudGVyXG5cblx0XHRpZiAoIHJlbmRlck9iamVjdERhdGEuY2VudGVyICkge1xuXG5cdFx0XHRpZiAoIHJlbmRlck9iamVjdERhdGEuY2VudGVyLmVxdWFscyggb2JqZWN0LmNlbnRlciApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRyZW5kZXJPYmplY3REYXRhLmNlbnRlci5jb3B5KCBvYmplY3QuY2VudGVyICk7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1bmRsZVxuXG5cdFx0aWYgKCByZW5kZXJPYmplY3QuYnVuZGxlICE9PSBudWxsICkge1xuXG5cdFx0XHRyZW5kZXJPYmplY3REYXRhLnZlcnNpb24gPSByZW5kZXJPYmplY3QuYnVuZGxlLnZlcnNpb247XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0bmVlZHNSZWZyZXNoKCByZW5kZXJPYmplY3QsIG5vZGVGcmFtZSApIHtcblxuXHRcdGlmICggdGhpcy5oYXNOb2RlIHx8IHRoaXMuaGFzQW5pbWF0aW9uIHx8IHRoaXMuZmlyc3RJbml0aWFsaXphdGlvbiggcmVuZGVyT2JqZWN0ICkgKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRjb25zdCB7IHJlbmRlcklkIH0gPSBub2RlRnJhbWU7XG5cblx0XHRpZiAoIHRoaXMucmVuZGVySWQgIT09IHJlbmRlcklkICkge1xuXG5cdFx0XHR0aGlzLnJlbmRlcklkID0gcmVuZGVySWQ7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaXNTdGF0aWMgPSByZW5kZXJPYmplY3Qub2JqZWN0LnN0YXRpYyA9PT0gdHJ1ZTtcblx0XHRjb25zdCBpc0J1bmRsZSA9IHJlbmRlck9iamVjdC5idW5kbGUgIT09IG51bGwgJiYgcmVuZGVyT2JqZWN0LmJ1bmRsZS5zdGF0aWMgPT09IHRydWUgJiYgdGhpcy5nZXRSZW5kZXJPYmplY3REYXRhKCByZW5kZXJPYmplY3QgKS52ZXJzaW9uID09PSByZW5kZXJPYmplY3QuYnVuZGxlLnZlcnNpb247XG5cblx0XHRpZiAoIGlzU3RhdGljIHx8IGlzQnVuZGxlIClcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdGNvbnN0IG5vdEVxdWFsID0gdGhpcy5lcXVhbHMoIHJlbmRlck9iamVjdCApICE9PSB0cnVlO1xuXG5cdFx0cmV0dXJuIG5vdEVxdWFsO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlTWF0ZXJpYWxPYnNlcnZlcjtcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vbWF0aC9Db2xvci5qcyc7XG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRyaXgzLmpzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi8uLi9tYXRoL01hdHJpeDQuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xuXG4vLyBjeXJiNTMgKGMpIDIwMTggYnJ5YyAoZ2l0aHViLmNvbS9icnljKS4gTGljZW5zZTogUHVibGljIGRvbWFpbi4gQXR0cmlidXRpb24gYXBwcmVjaWF0ZWQuXG4vLyBBIGZhc3QgYW5kIHNpbXBsZSA2NC1iaXQgKG9yIDUzLWJpdCkgc3RyaW5nIGhhc2ggZnVuY3Rpb24gd2l0aCBkZWNlbnQgY29sbGlzaW9uIHJlc2lzdGFuY2UuXG4vLyBMYXJnZWx5IGluc3BpcmVkIGJ5IE11cm11ckhhc2gyLzMsIGJ1dCB3aXRoIGEgZm9jdXMgb24gc3BlZWQvc2ltcGxpY2l0eS5cbi8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NjE2NDYxL2dlbmVyYXRlLWEtaGFzaC1mcm9tLXN0cmluZy1pbi1qYXZhc2NyaXB0LzUyMTcxNDgwIzUyMTcxNDgwXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYnJ5Yy9jb2RlL2Jsb2IvbWFzdGVyL2pzaGFzaC9leHBlcmltZW50YWwvY3lyYjUzLmpzXG5mdW5jdGlvbiBjeXJiNTMoIHZhbHVlLCBzZWVkID0gMCApIHtcblxuXHRsZXQgaDEgPSAweGRlYWRiZWVmIF4gc2VlZCwgaDIgPSAweDQxYzZjZTU3IF4gc2VlZDtcblxuXHRpZiAoIHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIHZhbDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFsID0gdmFsdWVbIGkgXTtcblx0XHRcdGgxID0gTWF0aC5pbXVsKCBoMSBeIHZhbCwgMjY1NDQzNTc2MSApO1xuXHRcdFx0aDIgPSBNYXRoLmltdWwoIGgyIF4gdmFsLCAxNTk3MzM0Njc3ICk7XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgY2g7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNoID0gdmFsdWUuY2hhckNvZGVBdCggaSApO1xuXHRcdFx0aDEgPSBNYXRoLmltdWwoIGgxIF4gY2gsIDI2NTQ0MzU3NjEgKTtcblx0XHRcdGgyID0gTWF0aC5pbXVsKCBoMiBeIGNoLCAxNTk3MzM0Njc3ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGgxID0gTWF0aC5pbXVsKCBoMSBeICggaDEgPj4+IDE2ICksIDIyNDY4MjI1MDcgKTtcblx0aDEgXj0gTWF0aC5pbXVsKCBoMiBeICggaDIgPj4+IDEzICksIDMyNjY0ODk5MDkgKTtcblx0aDIgPSBNYXRoLmltdWwoIGgyIF4gKCBoMiA+Pj4gMTYgKSwgMjI0NjgyMjUwNyApO1xuXHRoMiBePSBNYXRoLmltdWwoIGgxIF4gKCBoMSA+Pj4gMTMgKSwgMzI2NjQ4OTkwOSApO1xuXG5cdHJldHVybiA0Mjk0OTY3Mjk2ICogKCAyMDk3MTUxICYgaDIgKSArICggaDEgPj4+IDAgKTtcblxufVxuXG5leHBvcnQgY29uc3QgaGFzaFN0cmluZyA9ICggc3RyICkgPT4gY3lyYjUzKCBzdHIgKTtcbmV4cG9ydCBjb25zdCBoYXNoQXJyYXkgPSAoIGFycmF5ICkgPT4gY3lyYjUzKCBhcnJheSApO1xuZXhwb3J0IGNvbnN0IGhhc2ggPSAoIC4uLnBhcmFtcyApID0+IGN5cmI1MyggcGFyYW1zICk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYWNoZUtleSggb2JqZWN0LCBmb3JjZSA9IGZhbHNlICkge1xuXG5cdGNvbnN0IHZhbHVlcyA9IFtdO1xuXG5cdGlmICggb2JqZWN0LmlzTm9kZSA9PT0gdHJ1ZSApIHtcblxuXHRcdHZhbHVlcy5wdXNoKCBvYmplY3QuaWQgKTtcblx0XHRvYmplY3QgPSBvYmplY3QuZ2V0U2VsZigpO1xuXG5cdH1cblxuXHRmb3IgKCBjb25zdCB7IHByb3BlcnR5LCBjaGlsZE5vZGUgfSBvZiBnZXROb2RlQ2hpbGRyZW4oIG9iamVjdCApICkge1xuXG5cdFx0dmFsdWVzLnB1c2goIHZhbHVlcywgY3lyYjUzKCBwcm9wZXJ0eS5zbGljZSggMCwgLSA0ICkgKSwgY2hpbGROb2RlLmdldENhY2hlS2V5KCBmb3JjZSApICk7XG5cblx0fVxuXG5cdHJldHVybiBjeXJiNTMoIHZhbHVlcyApO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiogZ2V0Tm9kZUNoaWxkcmVuKCBub2RlLCB0b0pTT04gPSBmYWxzZSApIHtcblxuXHRmb3IgKCBjb25zdCBwcm9wZXJ0eSBpbiBub2RlICkge1xuXG5cdFx0Ly8gSWdub3JlIHByaXZhdGUgcHJvcGVydGllcy5cblx0XHRpZiAoIHByb3BlcnR5LnN0YXJ0c1dpdGgoICdfJyApID09PSB0cnVlICkgY29udGludWU7XG5cblx0XHRjb25zdCBvYmplY3QgPSBub2RlWyBwcm9wZXJ0eSBdO1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmplY3QgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IG9iamVjdFsgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQgJiYgKCBjaGlsZC5pc05vZGUgPT09IHRydWUgfHwgdG9KU09OICYmIHR5cGVvZiBjaGlsZC50b0pTT04gPT09ICdmdW5jdGlvbicgKSApIHtcblxuXHRcdFx0XHRcdHlpZWxkIHsgcHJvcGVydHksIGluZGV4OiBpLCBjaGlsZE5vZGU6IGNoaWxkIH07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgJiYgb2JqZWN0LmlzTm9kZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0eWllbGQgeyBwcm9wZXJ0eSwgY2hpbGROb2RlOiBvYmplY3QgfTtcblxuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCBzdWJQcm9wZXJ0eSBpbiBvYmplY3QgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBvYmplY3RbIHN1YlByb3BlcnR5IF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZCAmJiAoIGNoaWxkLmlzTm9kZSA9PT0gdHJ1ZSB8fCB0b0pTT04gJiYgdHlwZW9mIGNoaWxkLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyApICkge1xuXG5cdFx0XHRcdFx0eWllbGQgeyBwcm9wZXJ0eSwgaW5kZXg6IHN1YlByb3BlcnR5LCBjaGlsZE5vZGU6IGNoaWxkIH07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmNvbnN0IHR5cGVGcm9tTGVuZ3RoID0gLypAX19QVVJFX18qLyBuZXcgTWFwKCBbXG5cdFsgMSwgJ2Zsb2F0JyBdLFxuXHRbIDIsICd2ZWMyJyBdLFxuXHRbIDMsICd2ZWMzJyBdLFxuXHRbIDQsICd2ZWM0JyBdLFxuXHRbIDksICdtYXQzJyBdLFxuXHRbIDE2LCAnbWF0NCcgXVxuXSApO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZUZyb21MZW5ndGgoIGxlbmd0aCApIHtcblxuXHRyZXR1cm4gdHlwZUZyb21MZW5ndGguZ2V0KCBsZW5ndGggKTtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVuZ3RoRnJvbVR5cGUoIHR5cGUgKSB7XG5cblx0aWYgKCAvZmxvYXR8aW50fHVpbnQvLnRlc3QoIHR5cGUgKSApIHJldHVybiAxO1xuXHRpZiAoIC92ZWMyLy50ZXN0KCB0eXBlICkgKSByZXR1cm4gMjtcblx0aWYgKCAvdmVjMy8udGVzdCggdHlwZSApICkgcmV0dXJuIDM7XG5cdGlmICggL3ZlYzQvLnRlc3QoIHR5cGUgKSApIHJldHVybiA0O1xuXHRpZiAoIC9tYXQzLy50ZXN0KCB0eXBlICkgKSByZXR1cm4gOTtcblx0aWYgKCAvbWF0NC8udGVzdCggdHlwZSApICkgcmV0dXJuIDE2O1xuXG5cdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UU0w6IFVuc3VwcG9ydGVkIHR5cGU6JywgdHlwZSApO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZVR5cGUoIHZhbHVlICkge1xuXG5cdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCApIHJldHVybiBudWxsO1xuXG5cdGNvbnN0IHR5cGVPZiA9IHR5cGVvZiB2YWx1ZTtcblxuXHRpZiAoIHZhbHVlLmlzTm9kZSA9PT0gdHJ1ZSApIHtcblxuXHRcdHJldHVybiAnbm9kZSc7XG5cblx0fSBlbHNlIGlmICggdHlwZU9mID09PSAnbnVtYmVyJyApIHtcblxuXHRcdHJldHVybiAnZmxvYXQnO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVPZiA9PT0gJ2Jvb2xlYW4nICkge1xuXG5cdFx0cmV0dXJuICdib29sJztcblxuXHR9IGVsc2UgaWYgKCB0eXBlT2YgPT09ICdzdHJpbmcnICkge1xuXG5cdFx0cmV0dXJuICdzdHJpbmcnO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVPZiA9PT0gJ2Z1bmN0aW9uJyApIHtcblxuXHRcdHJldHVybiAnc2hhZGVyJztcblxuXHR9IGVsc2UgaWYgKCB2YWx1ZS5pc1ZlY3RvcjIgPT09IHRydWUgKSB7XG5cblx0XHRyZXR1cm4gJ3ZlYzInO1xuXG5cdH0gZWxzZSBpZiAoIHZhbHVlLmlzVmVjdG9yMyA9PT0gdHJ1ZSApIHtcblxuXHRcdHJldHVybiAndmVjMyc7XG5cblx0fSBlbHNlIGlmICggdmFsdWUuaXNWZWN0b3I0ID09PSB0cnVlICkge1xuXG5cdFx0cmV0dXJuICd2ZWM0JztcblxuXHR9IGVsc2UgaWYgKCB2YWx1ZS5pc01hdHJpeDMgPT09IHRydWUgKSB7XG5cblx0XHRyZXR1cm4gJ21hdDMnO1xuXG5cdH0gZWxzZSBpZiAoIHZhbHVlLmlzTWF0cml4NCA9PT0gdHJ1ZSApIHtcblxuXHRcdHJldHVybiAnbWF0NCc7XG5cblx0fSBlbHNlIGlmICggdmFsdWUuaXNDb2xvciA9PT0gdHJ1ZSApIHtcblxuXHRcdHJldHVybiAnY29sb3InO1xuXG5cdH0gZWxzZSBpZiAoIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgKSB7XG5cblx0XHRyZXR1cm4gJ0FycmF5QnVmZmVyJztcblxuXHR9XG5cblx0cmV0dXJuIG51bGw7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlRnJvbVR5cGUoIHR5cGUsIC4uLnBhcmFtcyApIHtcblxuXHRjb25zdCBsYXN0NCA9IHR5cGUgPyB0eXBlLnNsaWNlKCAtIDQgKSA6IHVuZGVmaW5lZDtcblxuXHRpZiAoIHBhcmFtcy5sZW5ndGggPT09IDEgKSB7IC8vIGVuc3VyZSBzYW1lIGJlaGF2aW91ciBhcyBpbiBOb2RlQnVpbGRlci5mb3JtYXQoKVxuXG5cdFx0aWYgKCBsYXN0NCA9PT0gJ3ZlYzInICkgcGFyYW1zID0gWyBwYXJhbXNbIDAgXSwgcGFyYW1zWyAwIF0gXTtcblx0XHRlbHNlIGlmICggbGFzdDQgPT09ICd2ZWMzJyApIHBhcmFtcyA9IFsgcGFyYW1zWyAwIF0sIHBhcmFtc1sgMCBdLCBwYXJhbXNbIDAgXSBdO1xuXHRcdGVsc2UgaWYgKCBsYXN0NCA9PT0gJ3ZlYzQnICkgcGFyYW1zID0gWyBwYXJhbXNbIDAgXSwgcGFyYW1zWyAwIF0sIHBhcmFtc1sgMCBdLCBwYXJhbXNbIDAgXSBdO1xuXG5cdH1cblxuXHRpZiAoIHR5cGUgPT09ICdjb2xvcicgKSB7XG5cblx0XHRyZXR1cm4gbmV3IENvbG9yKCAuLi5wYXJhbXMgKTtcblxuXHR9IGVsc2UgaWYgKCBsYXN0NCA9PT0gJ3ZlYzInICkge1xuXG5cdFx0cmV0dXJuIG5ldyBWZWN0b3IyKCAuLi5wYXJhbXMgKTtcblxuXHR9IGVsc2UgaWYgKCBsYXN0NCA9PT0gJ3ZlYzMnICkge1xuXG5cdFx0cmV0dXJuIG5ldyBWZWN0b3IzKCAuLi5wYXJhbXMgKTtcblxuXHR9IGVsc2UgaWYgKCBsYXN0NCA9PT0gJ3ZlYzQnICkge1xuXG5cdFx0cmV0dXJuIG5ldyBWZWN0b3I0KCAuLi5wYXJhbXMgKTtcblxuXHR9IGVsc2UgaWYgKCBsYXN0NCA9PT0gJ21hdDMnICkge1xuXG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgzKCAuLi5wYXJhbXMgKTtcblxuXHR9IGVsc2UgaWYgKCBsYXN0NCA9PT0gJ21hdDQnICkge1xuXG5cdFx0cmV0dXJuIG5ldyBNYXRyaXg0KCAuLi5wYXJhbXMgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlID09PSAnYm9vbCcgKSB7XG5cblx0XHRyZXR1cm4gcGFyYW1zWyAwIF0gfHwgZmFsc2U7XG5cblx0fSBlbHNlIGlmICggKCB0eXBlID09PSAnZmxvYXQnICkgfHwgKCB0eXBlID09PSAnaW50JyApIHx8ICggdHlwZSA9PT0gJ3VpbnQnICkgKSB7XG5cblx0XHRyZXR1cm4gcGFyYW1zWyAwIF0gfHwgMDtcblxuXHR9IGVsc2UgaWYgKCB0eXBlID09PSAnc3RyaW5nJyApIHtcblxuXHRcdHJldHVybiBwYXJhbXNbIDAgXSB8fCAnJztcblxuXHR9IGVsc2UgaWYgKCB0eXBlID09PSAnQXJyYXlCdWZmZXInICkge1xuXG5cdFx0cmV0dXJuIGJhc2U2NFRvQXJyYXlCdWZmZXIoIHBhcmFtc1sgMCBdICk7XG5cblx0fVxuXG5cdHJldHVybiBudWxsO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0KCBhcnJheUJ1ZmZlciApIHtcblxuXHRsZXQgY2hhcnMgPSAnJztcblxuXHRjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KCBhcnJheUJ1ZmZlciApO1xuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArKyApIHtcblxuXHRcdGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGFycmF5WyBpIF0gKTtcblxuXHR9XG5cblx0cmV0dXJuIGJ0b2EoIGNoYXJzICk7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvQXJyYXlCdWZmZXIoIGJhc2U2NCApIHtcblxuXHRyZXR1cm4gVWludDhBcnJheS5mcm9tKCBhdG9iKCBiYXNlNjQgKSwgYyA9PiBjLmNoYXJDb2RlQXQoIDAgKSApLmJ1ZmZlcjtcblxufVxuIiwiZXhwb3J0IGNvbnN0IE5vZGVTaGFkZXJTdGFnZSA9IHtcblx0VkVSVEVYOiAndmVydGV4Jyxcblx0RlJBR01FTlQ6ICdmcmFnbWVudCdcbn07XG5cbmV4cG9ydCBjb25zdCBOb2RlVXBkYXRlVHlwZSA9IHtcblx0Tk9ORTogJ25vbmUnLFxuXHRGUkFNRTogJ2ZyYW1lJyxcblx0UkVOREVSOiAncmVuZGVyJyxcblx0T0JKRUNUOiAnb2JqZWN0J1xufTtcblxuZXhwb3J0IGNvbnN0IE5vZGVUeXBlID0ge1xuXHRCT09MRUFOOiAnYm9vbCcsXG5cdElOVEVHRVI6ICdpbnQnLFxuXHRGTE9BVDogJ2Zsb2F0Jyxcblx0VkVDVE9SMjogJ3ZlYzInLFxuXHRWRUNUT1IzOiAndmVjMycsXG5cdFZFQ1RPUjQ6ICd2ZWM0Jyxcblx0TUFUUklYMjogJ21hdDInLFxuXHRNQVRSSVgzOiAnbWF0MycsXG5cdE1BVFJJWDQ6ICdtYXQ0J1xufTtcblxuZXhwb3J0IGNvbnN0IE5vZGVBY2Nlc3MgPSB7XG5cdFJFQURfT05MWTogJ3JlYWRPbmx5Jyxcblx0V1JJVEVfT05MWTogJ3dyaXRlT25seScsXG5cdFJFQURfV1JJVEU6ICdyZWFkV3JpdGUnLFxufTtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRTaGFkZXJTdGFnZXMgPSBbICdmcmFnbWVudCcsICd2ZXJ0ZXgnIF07XG5leHBvcnQgY29uc3QgZGVmYXVsdEJ1aWxkU3RhZ2VzID0gWyAnc2V0dXAnLCAnYW5hbHl6ZScsICdnZW5lcmF0ZScgXTtcbmV4cG9ydCBjb25zdCBzaGFkZXJTdGFnZXMgPSBbIC4uLmRlZmF1bHRTaGFkZXJTdGFnZXMsICdjb21wdXRlJyBdO1xuZXhwb3J0IGNvbnN0IHZlY3RvckNvbXBvbmVudHMgPSBbICd4JywgJ3knLCAneicsICd3JyBdO1xuIiwiaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBnZXROb2RlQ2hpbGRyZW4sIGdldENhY2hlS2V5IH0gZnJvbSAnLi9Ob2RlVXRpbHMuanMnO1xuXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuLi8uLi9jb3JlL0V2ZW50RGlzcGF0Y2hlci5qcyc7XG5pbXBvcnQgeyBNYXRoVXRpbHMgfSBmcm9tICcuLi8uLi9tYXRoL01hdGhVdGlscy5qcyc7XG5cbmxldCBfbm9kZUlkID0gMDtcblxuY2xhc3MgTm9kZSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIG5vZGVUeXBlID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLm5vZGVUeXBlID0gbm9kZVR5cGU7XG5cblx0XHR0aGlzLnVwZGF0ZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5OT05FO1xuXHRcdHRoaXMudXBkYXRlQmVmb3JlVHlwZSA9IE5vZGVVcGRhdGVUeXBlLk5PTkU7XG5cdFx0dGhpcy51cGRhdGVBZnRlclR5cGUgPSBOb2RlVXBkYXRlVHlwZS5OT05FO1xuXG5cdFx0dGhpcy51dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblxuXHRcdHRoaXMuX2NhY2hlS2V5ID0gbnVsbDtcblx0XHR0aGlzLl9jYWNoZUtleVZlcnNpb24gPSAwO1xuXG5cdFx0dGhpcy5nbG9iYWwgPSBmYWxzZTtcblxuXHRcdHRoaXMuaXNOb2RlID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX25vZGVJZCArKyB9ICk7XG5cblx0fVxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZTtcblxuXHR9XG5cblx0b25VcGRhdGUoIGNhbGxiYWNrLCB1cGRhdGVUeXBlICkge1xuXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gdXBkYXRlVHlwZTtcblx0XHR0aGlzLnVwZGF0ZSA9IGNhbGxiYWNrLmJpbmQoIHRoaXMuZ2V0U2VsZigpICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0b25GcmFtZVVwZGF0ZSggY2FsbGJhY2sgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5vblVwZGF0ZSggY2FsbGJhY2ssIE5vZGVVcGRhdGVUeXBlLkZSQU1FICk7XG5cblx0fVxuXG5cdG9uUmVuZGVyVXBkYXRlKCBjYWxsYmFjayApIHtcblxuXHRcdHJldHVybiB0aGlzLm9uVXBkYXRlKCBjYWxsYmFjaywgTm9kZVVwZGF0ZVR5cGUuUkVOREVSICk7XG5cblx0fVxuXG5cdG9uT2JqZWN0VXBkYXRlKCBjYWxsYmFjayApIHtcblxuXHRcdHJldHVybiB0aGlzLm9uVXBkYXRlKCBjYWxsYmFjaywgTm9kZVVwZGF0ZVR5cGUuT0JKRUNUICk7XG5cblx0fVxuXG5cdG9uUmVmZXJlbmNlKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMudXBkYXRlUmVmZXJlbmNlID0gY2FsbGJhY2suYmluZCggdGhpcy5nZXRTZWxmKCkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRTZWxmKCkge1xuXG5cdFx0Ly8gUmV0dXJucyBub24tbm9kZSBvYmplY3QuXG5cblx0XHRyZXR1cm4gdGhpcy5zZWxmIHx8IHRoaXM7XG5cblx0fVxuXG5cdHVwZGF0ZVJlZmVyZW5jZSggLypzdGF0ZSovICkge1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGlzR2xvYmFsKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdHJldHVybiB0aGlzLmdsb2JhbDtcblxuXHR9XG5cblx0KiBnZXRDaGlsZHJlbigpIHtcblxuXHRcdGZvciAoIGNvbnN0IHsgY2hpbGROb2RlIH0gb2YgZ2V0Tm9kZUNoaWxkcmVuKCB0aGlzICkgKSB7XG5cblx0XHRcdHlpZWxkIGNoaWxkTm9kZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG5cdH1cblxuXHR0cmF2ZXJzZSggY2FsbGJhY2sgKSB7XG5cblx0XHRjYWxsYmFjayggdGhpcyApO1xuXG5cdFx0Zm9yICggY29uc3QgY2hpbGROb2RlIG9mIHRoaXMuZ2V0Q2hpbGRyZW4oKSApIHtcblxuXHRcdFx0Y2hpbGROb2RlLnRyYXZlcnNlKCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRnZXRDYWNoZUtleSggZm9yY2UgPSBmYWxzZSApIHtcblxuXHRcdGZvcmNlID0gZm9yY2UgfHwgdGhpcy52ZXJzaW9uICE9PSB0aGlzLl9jYWNoZUtleVZlcnNpb247XG5cblx0XHRpZiAoIGZvcmNlID09PSB0cnVlIHx8IHRoaXMuX2NhY2hlS2V5ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl9jYWNoZUtleSA9IGdldENhY2hlS2V5KCB0aGlzLCBmb3JjZSApO1xuXHRcdFx0dGhpcy5fY2FjaGVLZXlWZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX2NhY2hlS2V5O1xuXG5cdH1cblxuXHRnZXRTY29wZSgpIHtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRIYXNoKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdHJldHVybiB0aGlzLnV1aWQ7XG5cblx0fVxuXG5cdGdldFVwZGF0ZVR5cGUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy51cGRhdGVUeXBlO1xuXG5cdH1cblxuXHRnZXRVcGRhdGVCZWZvcmVUeXBlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlQmVmb3JlVHlwZTtcblxuXHR9XG5cblx0Z2V0VXBkYXRlQWZ0ZXJUeXBlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlQWZ0ZXJUeXBlO1xuXG5cdH1cblxuXHRnZXRFbGVtZW50VHlwZSggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cdFx0Y29uc3QgZWxlbWVudFR5cGUgPSBidWlsZGVyLmdldEVsZW1lbnRUeXBlKCB0eXBlICk7XG5cblx0XHRyZXR1cm4gZWxlbWVudFR5cGU7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3Qgbm9kZVByb3BlcnRpZXMgPSBidWlsZGVyLmdldE5vZGVQcm9wZXJ0aWVzKCB0aGlzICk7XG5cblx0XHRpZiAoIG5vZGVQcm9wZXJ0aWVzLm91dHB1dE5vZGUgKSB7XG5cblx0XHRcdHJldHVybiBub2RlUHJvcGVydGllcy5vdXRwdXROb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlVHlwZTtcblxuXHR9XG5cblx0Z2V0U2hhcmVkKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgaGFzaCA9IHRoaXMuZ2V0SGFzaCggYnVpbGRlciApO1xuXHRcdGNvbnN0IG5vZGVGcm9tSGFzaCA9IGJ1aWxkZXIuZ2V0Tm9kZUZyb21IYXNoKCBoYXNoICk7XG5cblx0XHRyZXR1cm4gbm9kZUZyb21IYXNoIHx8IHRoaXM7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3Qgbm9kZVByb3BlcnRpZXMgPSBidWlsZGVyLmdldE5vZGVQcm9wZXJ0aWVzKCB0aGlzICk7XG5cblx0XHRsZXQgaW5kZXggPSAwO1xuXG5cdFx0Zm9yICggY29uc3QgY2hpbGROb2RlIG9mIHRoaXMuZ2V0Q2hpbGRyZW4oKSApIHtcblxuXHRcdFx0bm9kZVByb3BlcnRpZXNbICdub2RlJyArIGluZGV4ICsrIF0gPSBjaGlsZE5vZGU7XG5cblx0XHR9XG5cblx0XHQvLyByZXR1cm4gYSBvdXRwdXROb2RlIGlmIGV4aXN0c1xuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHRhbmFseXplKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgdXNhZ2VDb3VudCA9IGJ1aWxkZXIuaW5jcmVhc2VVc2FnZSggdGhpcyApO1xuXG5cdFx0aWYgKCB1c2FnZUNvdW50ID09PSAxICkge1xuXG5cdFx0XHQvLyBub2RlIGZsb3cgY2hpbGRyZW5cblxuXHRcdFx0Y29uc3Qgbm9kZVByb3BlcnRpZXMgPSBidWlsZGVyLmdldE5vZGVQcm9wZXJ0aWVzKCB0aGlzICk7XG5cblx0XHRcdGZvciAoIGNvbnN0IGNoaWxkTm9kZSBvZiBPYmplY3QudmFsdWVzKCBub2RlUHJvcGVydGllcyApICkge1xuXG5cdFx0XHRcdGlmICggY2hpbGROb2RlICYmIGNoaWxkTm9kZS5pc05vZGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRjaGlsZE5vZGUuYnVpbGQoIGJ1aWxkZXIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcblxuXHRcdGNvbnN0IHsgb3V0cHV0Tm9kZSB9ID0gYnVpbGRlci5nZXROb2RlUHJvcGVydGllcyggdGhpcyApO1xuXG5cdFx0aWYgKCBvdXRwdXROb2RlICYmIG91dHB1dE5vZGUuaXNOb2RlID09PSB0cnVlICkge1xuXG5cdFx0XHRyZXR1cm4gb3V0cHV0Tm9kZS5idWlsZCggYnVpbGRlciwgb3V0cHV0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZUJlZm9yZSggLypmcmFtZSovICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xuXG5cdH1cblxuXHR1cGRhdGVBZnRlciggLypmcmFtZSovICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xuXG5cdH1cblxuXHR1cGRhdGUoIC8qZnJhbWUqLyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGZ1bmN0aW9uLicgKTtcblxuXHR9XG5cblx0YnVpbGQoIGJ1aWxkZXIsIG91dHB1dCA9IG51bGwgKSB7XG5cblx0XHRjb25zdCByZWZOb2RlID0gdGhpcy5nZXRTaGFyZWQoIGJ1aWxkZXIgKTtcblxuXHRcdGlmICggdGhpcyAhPT0gcmVmTm9kZSApIHtcblxuXHRcdFx0cmV0dXJuIHJlZk5vZGUuYnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApO1xuXG5cdFx0fVxuXG5cdFx0YnVpbGRlci5hZGROb2RlKCB0aGlzICk7XG5cdFx0YnVpbGRlci5hZGRDaGFpbiggdGhpcyApO1xuXG5cdFx0LyogQnVpbGQgc3RhZ2VzIGV4cGVjdGVkIHJlc3VsdHM6XG5cdFx0XHQtIFwic2V0dXBcIlx0XHQtPiBOb2RlXG5cdFx0XHQtIFwiYW5hbHl6ZVwiXHRcdC0+IG51bGxcblx0XHRcdC0gXCJnZW5lcmF0ZVwiXHQtPiBTdHJpbmdcblx0XHQqL1xuXHRcdGxldCByZXN1bHQgPSBudWxsO1xuXG5cdFx0Y29uc3QgYnVpbGRTdGFnZSA9IGJ1aWxkZXIuZ2V0QnVpbGRTdGFnZSgpO1xuXG5cdFx0aWYgKCBidWlsZFN0YWdlID09PSAnc2V0dXAnICkge1xuXG5cdFx0XHR0aGlzLnVwZGF0ZVJlZmVyZW5jZSggYnVpbGRlciApO1xuXG5cdFx0XHRjb25zdCBwcm9wZXJ0aWVzID0gYnVpbGRlci5nZXROb2RlUHJvcGVydGllcyggdGhpcyApO1xuXG5cdFx0XHRpZiAoIHByb3BlcnRpZXMuaW5pdGlhbGl6ZWQgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc3RhY2tOb2Rlc0JlZm9yZVNldHVwID0gYnVpbGRlci5zdGFjay5ub2Rlcy5sZW5ndGg7XG5cblx0XHRcdFx0cHJvcGVydGllcy5pbml0aWFsaXplZCA9IHRydWU7XG5cdFx0XHRcdHByb3BlcnRpZXMub3V0cHV0Tm9kZSA9IHRoaXMuc2V0dXAoIGJ1aWxkZXIgKTtcblxuXHRcdFx0XHRpZiAoIHByb3BlcnRpZXMub3V0cHV0Tm9kZSAhPT0gbnVsbCAmJiBidWlsZGVyLnN0YWNrLm5vZGVzLmxlbmd0aCAhPT0gc3RhY2tOb2Rlc0JlZm9yZVNldHVwICkge1xuXG5cdFx0XHRcdFx0Ly8gISEgbm8gb3V0cHV0Tm9kZSAhIVxuXHRcdFx0XHRcdC8vcHJvcGVydGllcy5vdXRwdXROb2RlID0gYnVpbGRlci5zdGFjaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggY29uc3QgY2hpbGROb2RlIG9mIE9iamVjdC52YWx1ZXMoIHByb3BlcnRpZXMgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY2hpbGROb2RlICYmIGNoaWxkTm9kZS5pc05vZGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdGNoaWxkTm9kZS5idWlsZCggYnVpbGRlciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggYnVpbGRTdGFnZSA9PT0gJ2FuYWx5emUnICkge1xuXG5cdFx0XHR0aGlzLmFuYWx5emUoIGJ1aWxkZXIgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGJ1aWxkU3RhZ2UgPT09ICdnZW5lcmF0ZScgKSB7XG5cblx0XHRcdGNvbnN0IGlzR2VuZXJhdGVPbmNlID0gdGhpcy5nZW5lcmF0ZS5sZW5ndGggPT09IDE7XG5cblx0XHRcdGlmICggaXNHZW5lcmF0ZU9uY2UgKSB7XG5cblx0XHRcdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblx0XHRcdFx0Y29uc3Qgbm9kZURhdGEgPSBidWlsZGVyLmdldERhdGFGcm9tTm9kZSggdGhpcyApO1xuXG5cdFx0XHRcdHJlc3VsdCA9IG5vZGVEYXRhLnNuaXBwZXQ7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHJlc3VsdCA9IHRoaXMuZ2VuZXJhdGUoIGJ1aWxkZXIgKSB8fCAnJztcblxuXHRcdFx0XHRcdG5vZGVEYXRhLnNuaXBwZXQgPSByZXN1bHQ7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZURhdGEuZmxvd0NvZGVzICE9PSB1bmRlZmluZWQgJiYgYnVpbGRlci5jb250ZXh0Lm5vZGVCbG9jayAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0YnVpbGRlci5hZGRGbG93Q29kZUhpZXJhcmNoeSggdGhpcywgYnVpbGRlci5jb250ZXh0Lm5vZGVCbG9jayApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgPSBidWlsZGVyLmZvcm1hdCggcmVzdWx0LCB0eXBlLCBvdXRwdXQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXN1bHQgPSB0aGlzLmdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB8fCAnJztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0YnVpbGRlci5yZW1vdmVDaGFpbiggdGhpcyApO1xuXHRcdGJ1aWxkZXIuYWRkU2VxdWVudGlhbE5vZGUoIHRoaXMgKTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGdldFNlcmlhbGl6ZUNoaWxkcmVuKCkge1xuXG5cdFx0cmV0dXJuIGdldE5vZGVDaGlsZHJlbiggdGhpcyApO1xuXG5cdH1cblxuXHRzZXJpYWxpemUoIGpzb24gKSB7XG5cblx0XHRjb25zdCBub2RlQ2hpbGRyZW4gPSB0aGlzLmdldFNlcmlhbGl6ZUNoaWxkcmVuKCk7XG5cblx0XHRjb25zdCBpbnB1dE5vZGVzID0ge307XG5cblx0XHRmb3IgKCBjb25zdCB7IHByb3BlcnR5LCBpbmRleCwgY2hpbGROb2RlIH0gb2Ygbm9kZUNoaWxkcmVuICkge1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpbnB1dE5vZGVzWyBwcm9wZXJ0eSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpbnB1dE5vZGVzWyBwcm9wZXJ0eSBdID0gTnVtYmVyLmlzSW50ZWdlciggaW5kZXggKSA/IFtdIDoge307XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlucHV0Tm9kZXNbIHByb3BlcnR5IF1bIGluZGV4IF0gPSBjaGlsZE5vZGUudG9KU09OKCBqc29uLm1ldGEgKS51dWlkO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlucHV0Tm9kZXNbIHByb3BlcnR5IF0gPSBjaGlsZE5vZGUudG9KU09OKCBqc29uLm1ldGEgKS51dWlkO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIE9iamVjdC5rZXlzKCBpbnB1dE5vZGVzICkubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0anNvbi5pbnB1dE5vZGVzID0gaW5wdXROb2RlcztcblxuXHRcdH1cblxuXHR9XG5cblx0ZGVzZXJpYWxpemUoIGpzb24gKSB7XG5cblx0XHRpZiAoIGpzb24uaW5wdXROb2RlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBub2RlcyA9IGpzb24ubWV0YS5ub2RlcztcblxuXHRcdFx0Zm9yICggY29uc3QgcHJvcGVydHkgaW4ganNvbi5pbnB1dE5vZGVzICkge1xuXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgganNvbi5pbnB1dE5vZGVzWyBwcm9wZXJ0eSBdICkgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBpbnB1dEFycmF5ID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCBjb25zdCB1dWlkIG9mIGpzb24uaW5wdXROb2Rlc1sgcHJvcGVydHkgXSApIHtcblxuXHRcdFx0XHRcdFx0aW5wdXRBcnJheS5wdXNoKCBub2Rlc1sgdXVpZCBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzWyBwcm9wZXJ0eSBdID0gaW5wdXRBcnJheTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YganNvbi5pbnB1dE5vZGVzWyBwcm9wZXJ0eSBdID09PSAnb2JqZWN0JyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGlucHV0T2JqZWN0ID0ge307XG5cblx0XHRcdFx0XHRmb3IgKCBjb25zdCBzdWJQcm9wZXJ0eSBpbiBqc29uLmlucHV0Tm9kZXNbIHByb3BlcnR5IF0gKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHV1aWQgPSBqc29uLmlucHV0Tm9kZXNbIHByb3BlcnR5IF1bIHN1YlByb3BlcnR5IF07XG5cblx0XHRcdFx0XHRcdGlucHV0T2JqZWN0WyBzdWJQcm9wZXJ0eSBdID0gbm9kZXNbIHV1aWQgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXNbIHByb3BlcnR5IF0gPSBpbnB1dE9iamVjdDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc3QgdXVpZCA9IGpzb24uaW5wdXROb2Rlc1sgcHJvcGVydHkgXTtcblxuXHRcdFx0XHRcdHRoaXNbIHByb3BlcnR5IF0gPSBub2Rlc1sgdXVpZCBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHRjb25zdCB7IHV1aWQsIHR5cGUgfSA9IHRoaXM7XG5cdFx0Y29uc3QgaXNSb290ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XG5cblx0XHRpZiAoIGlzUm9vdCApIHtcblxuXHRcdFx0bWV0YSA9IHtcblx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRpbWFnZXM6IHt9LFxuXHRcdFx0XHRub2Rlczoge31cblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHQvLyBzZXJpYWxpemVcblxuXHRcdGxldCBkYXRhID0gbWV0YS5ub2Rlc1sgdXVpZCBdO1xuXG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGRhdGEgPSB7XG5cdFx0XHRcdHV1aWQsXG5cdFx0XHRcdHR5cGUsXG5cdFx0XHRcdG1ldGEsXG5cdFx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdFx0dmVyc2lvbjogNC42LFxuXHRcdFx0XHRcdHR5cGU6ICdOb2RlJyxcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdOb2RlLnRvSlNPTidcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCBpc1Jvb3QgIT09IHRydWUgKSBtZXRhLm5vZGVzWyBkYXRhLnV1aWQgXSA9IGRhdGE7XG5cblx0XHRcdHRoaXMuc2VyaWFsaXplKCBkYXRhICk7XG5cblx0XHRcdGRlbGV0ZSBkYXRhLm1ldGE7XG5cblx0XHR9XG5cblx0XHQvLyBUT0RPOiBDb3BpZWQgZnJvbSBPYmplY3QzRC50b0pTT05cblxuXHRcdGZ1bmN0aW9uIGV4dHJhY3RGcm9tQ2FjaGUoIGNhY2hlICkge1xuXG5cdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggY29uc3Qga2V5IGluIGNhY2hlICkge1xuXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBjYWNoZVsga2V5IF07XG5cdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuXHRcdFx0XHR2YWx1ZXMucHVzaCggZGF0YSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzUm9vdCApIHtcblxuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XG5cdFx0XHRjb25zdCBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xuXHRcdFx0Y29uc3Qgbm9kZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm5vZGVzICk7XG5cblx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIGRhdGEudGV4dHVyZXMgPSB0ZXh0dXJlcztcblx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBkYXRhLmltYWdlcyA9IGltYWdlcztcblx0XHRcdGlmICggbm9kZXMubGVuZ3RoID4gMCApIGRhdGEubm9kZXMgPSBub2RlcztcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlO1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcblxuY2xhc3MgQXJyYXlFbGVtZW50Tm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnQXJyYXlFbGVtZW50Tm9kZSc7XG5cblx0fSAvLyBAVE9ETzogSWYgZXh0ZW5kaW5nIGZyb20gVGVtcE5vZGUgaXQgYnJlYWtzIHdlYmdwdV9jb21wdXRlXG5cblx0Y29uc3RydWN0b3IoIG5vZGUsIGluZGV4Tm9kZSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLm5vZGUgPSBub2RlO1xuXHRcdHRoaXMuaW5kZXhOb2RlID0gaW5kZXhOb2RlO1xuXG5cdFx0dGhpcy5pc0FycmF5RWxlbWVudE5vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLm5vZGUuZ2V0RWxlbWVudFR5cGUoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBub2RlU25pcHBldCA9IHRoaXMubm9kZS5idWlsZCggYnVpbGRlciApO1xuXHRcdGNvbnN0IGluZGV4U25pcHBldCA9IHRoaXMuaW5kZXhOb2RlLmJ1aWxkKCBidWlsZGVyLCAndWludCcgKTtcblxuXHRcdHJldHVybiBgJHtub2RlU25pcHBldH1bICR7aW5kZXhTbmlwcGV0fSBdYDtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXJyYXlFbGVtZW50Tm9kZTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5cbmNsYXNzIENvbnZlcnROb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdDb252ZXJ0Tm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBub2RlLCBjb252ZXJ0VG8gKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcblx0XHR0aGlzLmNvbnZlcnRUbyA9IGNvbnZlcnRUbztcblxuXHR9XG5cblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCByZXF1ZXN0VHlwZSA9IHRoaXMubm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXG5cdFx0bGV0IGNvbnZlcnRUbyA9IG51bGw7XG5cblx0XHRmb3IgKCBjb25zdCBvdmVybG9hZGluZ1R5cGUgb2YgdGhpcy5jb252ZXJ0VG8uc3BsaXQoICd8JyApICkge1xuXG5cdFx0XHRpZiAoIGNvbnZlcnRUbyA9PT0gbnVsbCB8fCBidWlsZGVyLmdldFR5cGVMZW5ndGgoIHJlcXVlc3RUeXBlICkgPT09IGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggb3ZlcmxvYWRpbmdUeXBlICkgKSB7XG5cblx0XHRcdFx0Y29udmVydFRvID0gb3ZlcmxvYWRpbmdUeXBlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY29udmVydFRvO1xuXG5cdH1cblxuXHRzZXJpYWxpemUoIGRhdGEgKSB7XG5cblx0XHRzdXBlci5zZXJpYWxpemUoIGRhdGEgKTtcblxuXHRcdGRhdGEuY29udmVydFRvID0gdGhpcy5jb252ZXJ0VG87XG5cblx0fVxuXG5cdGRlc2VyaWFsaXplKCBkYXRhICkge1xuXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcblxuXHRcdHRoaXMuY29udmVydFRvID0gZGF0YS5jb252ZXJ0VG87XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XG5cblx0XHRjb25zdCBub2RlID0gdGhpcy5ub2RlO1xuXHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0XHRjb25zdCBzbmlwcGV0ID0gbm9kZS5idWlsZCggYnVpbGRlciwgdHlwZSApO1xuXG5cdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBzbmlwcGV0LCB0eXBlLCBvdXRwdXQgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udmVydE5vZGU7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuL05vZGUuanMnO1xuXG5jbGFzcyBUZW1wTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnVGVtcE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggdHlwZSApIHtcblxuXHRcdHN1cGVyKCB0eXBlICk7XG5cblx0XHR0aGlzLmlzVGVtcE5vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRoYXNEZXBlbmRlbmNpZXMoIGJ1aWxkZXIgKSB7XG5cblx0XHRyZXR1cm4gYnVpbGRlci5nZXREYXRhRnJvbU5vZGUoIHRoaXMgKS51c2FnZUNvdW50ID4gMTtcblxuXHR9XG5cblx0YnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApIHtcblxuXHRcdGNvbnN0IGJ1aWxkU3RhZ2UgPSBidWlsZGVyLmdldEJ1aWxkU3RhZ2UoKTtcblxuXHRcdGlmICggYnVpbGRTdGFnZSA9PT0gJ2dlbmVyYXRlJyApIHtcblxuXHRcdFx0Y29uc3QgdHlwZSA9IGJ1aWxkZXIuZ2V0VmVjdG9yVHlwZSggdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciwgb3V0cHV0ICkgKTtcblx0XHRcdGNvbnN0IG5vZGVEYXRhID0gYnVpbGRlci5nZXREYXRhRnJvbU5vZGUoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBub2RlRGF0YS5wcm9wZXJ0eU5hbWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIG5vZGVEYXRhLnByb3BlcnR5TmFtZSwgdHlwZSwgb3V0cHV0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgIT09ICd2b2lkJyAmJiBvdXRwdXQgIT09ICd2b2lkJyAmJiB0aGlzLmhhc0RlcGVuZGVuY2llcyggYnVpbGRlciApICkge1xuXG5cdFx0XHRcdGNvbnN0IHNuaXBwZXQgPSBzdXBlci5idWlsZCggYnVpbGRlciwgdHlwZSApO1xuXG5cdFx0XHRcdGNvbnN0IG5vZGVWYXIgPSBidWlsZGVyLmdldFZhckZyb21Ob2RlKCB0aGlzLCBudWxsLCB0eXBlICk7XG5cdFx0XHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0UHJvcGVydHlOYW1lKCBub2RlVmFyICk7XG5cblx0XHRcdFx0YnVpbGRlci5hZGRMaW5lRmxvd0NvZGUoIGAke3Byb3BlcnR5TmFtZX0gPSAke3NuaXBwZXR9YCwgdGhpcyApO1xuXG5cdFx0XHRcdG5vZGVEYXRhLnNuaXBwZXQgPSBzbmlwcGV0O1xuXHRcdFx0XHRub2RlRGF0YS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG5cblx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBub2RlRGF0YS5wcm9wZXJ0eU5hbWUsIHR5cGUsIG91dHB1dCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc3VwZXIuYnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBUZW1wTm9kZTtcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcblxuY2xhc3MgSm9pbk5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdKb2luTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBub2RlcyA9IFtdLCBub2RlVHlwZSA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggbm9kZVR5cGUgKTtcblxuXHRcdHRoaXMubm9kZXMgPSBub2RlcztcblxuXHR9XG5cblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IG51bGwgKSB7XG5cblx0XHRcdHJldHVybiBidWlsZGVyLmdldFZlY3RvclR5cGUoIHRoaXMubm9kZVR5cGUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBidWlsZGVyLmdldFR5cGVGcm9tTGVuZ3RoKCB0aGlzLm5vZGVzLnJlZHVjZSggKCBjb3VudCwgY3VyICkgPT4gY291bnQgKyBidWlsZGVyLmdldFR5cGVMZW5ndGgoIGN1ci5nZXROb2RlVHlwZSggYnVpbGRlciApICksIDAgKSApO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xuXG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblx0XHRjb25zdCBub2RlcyA9IHRoaXMubm9kZXM7XG5cblx0XHRjb25zdCBwcmltaXRpdmVUeXBlID0gYnVpbGRlci5nZXRDb21wb25lbnRUeXBlKCB0eXBlICk7XG5cblx0XHRjb25zdCBzbmlwcGV0VmFsdWVzID0gW107XG5cblx0XHRmb3IgKCBjb25zdCBpbnB1dCBvZiBub2RlcyApIHtcblxuXHRcdFx0bGV0IGlucHV0U25pcHBldCA9IGlucHV0LmJ1aWxkKCBidWlsZGVyICk7XG5cblx0XHRcdGNvbnN0IGlucHV0UHJpbWl0aXZlVHlwZSA9IGJ1aWxkZXIuZ2V0Q29tcG9uZW50VHlwZSggaW5wdXQuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSApO1xuXG5cdFx0XHRpZiAoIGlucHV0UHJpbWl0aXZlVHlwZSAhPT0gcHJpbWl0aXZlVHlwZSApIHtcblxuXHRcdFx0XHRpbnB1dFNuaXBwZXQgPSBidWlsZGVyLmZvcm1hdCggaW5wdXRTbmlwcGV0LCBpbnB1dFByaW1pdGl2ZVR5cGUsIHByaW1pdGl2ZVR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzbmlwcGV0VmFsdWVzLnB1c2goIGlucHV0U25pcHBldCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc25pcHBldCA9IGAkeyBidWlsZGVyLmdldFR5cGUoIHR5cGUgKSB9KCAkeyBzbmlwcGV0VmFsdWVzLmpvaW4oICcsICcgKSB9IClgO1xuXG5cdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBzbmlwcGV0LCB0eXBlLCBvdXRwdXQgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSm9pbk5vZGU7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xuaW1wb3J0IHsgdmVjdG9yQ29tcG9uZW50cyB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcblxuY29uc3Qgc3RyaW5nVmVjdG9yQ29tcG9uZW50cyA9IHZlY3RvckNvbXBvbmVudHMuam9pbiggJycgKTtcblxuY2xhc3MgU3BsaXROb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdTcGxpdE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3Rvciggbm9kZSwgY29tcG9uZW50cyA9ICd4JyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLm5vZGUgPSBub2RlO1xuXHRcdHRoaXMuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG5cblx0XHR0aGlzLmlzU3BsaXROb2RlID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0VmVjdG9yTGVuZ3RoKCkge1xuXG5cdFx0bGV0IHZlY3Rvckxlbmd0aCA9IHRoaXMuY29tcG9uZW50cy5sZW5ndGg7XG5cblx0XHRmb3IgKCBjb25zdCBjIG9mIHRoaXMuY29tcG9uZW50cyApIHtcblxuXHRcdFx0dmVjdG9yTGVuZ3RoID0gTWF0aC5tYXgoIHZlY3RvckNvbXBvbmVudHMuaW5kZXhPZiggYyApICsgMSwgdmVjdG9yTGVuZ3RoICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdmVjdG9yTGVuZ3RoO1xuXG5cdH1cblxuXHRnZXRDb21wb25lbnRUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0cmV0dXJuIGJ1aWxkZXIuZ2V0Q29tcG9uZW50VHlwZSggdGhpcy5ub2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgKTtcblxuXHR9XG5cblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRyZXR1cm4gYnVpbGRlci5nZXRUeXBlRnJvbUxlbmd0aCggdGhpcy5jb21wb25lbnRzLmxlbmd0aCwgdGhpcy5nZXRDb21wb25lbnRUeXBlKCBidWlsZGVyICkgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcblxuXHRcdGNvbnN0IG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0Y29uc3Qgbm9kZVR5cGVMZW5ndGggPSBidWlsZGVyLmdldFR5cGVMZW5ndGgoIG5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSApO1xuXG5cdFx0bGV0IHNuaXBwZXQgPSBudWxsO1xuXG5cdFx0aWYgKCBub2RlVHlwZUxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdGxldCB0eXBlID0gbnVsbDtcblxuXHRcdFx0Y29uc3QgY29tcG9uZW50c0xlbmd0aCA9IHRoaXMuZ2V0VmVjdG9yTGVuZ3RoKCk7XG5cblx0XHRcdGlmICggY29tcG9uZW50c0xlbmd0aCA+PSBub2RlVHlwZUxlbmd0aCApIHtcblxuXHRcdFx0XHQvLyBuZWVkZWQgZXhwYW5kIHRoZSBpbnB1dCBub2RlXG5cblx0XHRcdFx0dHlwZSA9IGJ1aWxkZXIuZ2V0VHlwZUZyb21MZW5ndGgoIHRoaXMuZ2V0VmVjdG9yTGVuZ3RoKCksIHRoaXMuZ2V0Q29tcG9uZW50VHlwZSggYnVpbGRlciApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgbm9kZVNuaXBwZXQgPSBub2RlLmJ1aWxkKCBidWlsZGVyLCB0eXBlICk7XG5cblx0XHRcdGlmICggdGhpcy5jb21wb25lbnRzLmxlbmd0aCA9PT0gbm9kZVR5cGVMZW5ndGggJiYgdGhpcy5jb21wb25lbnRzID09PSBzdHJpbmdWZWN0b3JDb21wb25lbnRzLnNsaWNlKCAwLCB0aGlzLmNvbXBvbmVudHMubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Ly8gdW5uZWNlc3Nhcnkgc3dpenpsZVxuXG5cdFx0XHRcdHNuaXBwZXQgPSBidWlsZGVyLmZvcm1hdCggbm9kZVNuaXBwZXQsIHR5cGUsIG91dHB1dCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHNuaXBwZXQgPSBidWlsZGVyLmZvcm1hdCggYCR7bm9kZVNuaXBwZXR9LiR7dGhpcy5jb21wb25lbnRzfWAsIHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSwgb3V0cHV0ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGlnbm9yZSAuY29tcG9uZW50cyBpZiAubm9kZSByZXR1cm5zIGZsb2F0L2ludGVnZXJcblxuXHRcdFx0c25pcHBldCA9IG5vZGUuYnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNuaXBwZXQ7XG5cblx0fVxuXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcblxuXHRcdHN1cGVyLnNlcmlhbGl6ZSggZGF0YSApO1xuXG5cdFx0ZGF0YS5jb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzO1xuXG5cdH1cblxuXHRkZXNlcmlhbGl6ZSggZGF0YSApIHtcblxuXHRcdHN1cGVyLmRlc2VyaWFsaXplKCBkYXRhICk7XG5cblx0XHR0aGlzLmNvbXBvbmVudHMgPSBkYXRhLmNvbXBvbmVudHM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNwbGl0Tm9kZTtcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcbmltcG9ydCB7IHZlY3RvckNvbXBvbmVudHMgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XG5cbmNsYXNzIFNldE5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdTZXROb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHNvdXJjZU5vZGUsIGNvbXBvbmVudHMsIHRhcmdldE5vZGUgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gc291cmNlTm9kZTtcblx0XHR0aGlzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuXHRcdHRoaXMudGFyZ2V0Tm9kZSA9IHRhcmdldE5vZGU7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc291cmNlTm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHsgc291cmNlTm9kZSwgY29tcG9uZW50cywgdGFyZ2V0Tm9kZSB9ID0gdGhpcztcblxuXHRcdGNvbnN0IHNvdXJjZVR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cdFx0Y29uc3QgdGFyZ2V0VHlwZSA9IGJ1aWxkZXIuZ2V0VHlwZUZyb21MZW5ndGgoIGNvbXBvbmVudHMubGVuZ3RoLCB0YXJnZXROb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgKTtcblxuXHRcdGNvbnN0IHRhcmdldFNuaXBwZXQgPSB0YXJnZXROb2RlLmJ1aWxkKCBidWlsZGVyLCB0YXJnZXRUeXBlICk7XG5cdFx0Y29uc3Qgc291cmNlU25pcHBldCA9IHNvdXJjZU5vZGUuYnVpbGQoIGJ1aWxkZXIsIHNvdXJjZVR5cGUgKTtcblxuXHRcdGNvbnN0IGxlbmd0aCA9IGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggc291cmNlVHlwZSApO1xuXHRcdGNvbnN0IHNuaXBwZXRWYWx1ZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY29tcG9uZW50ID0gdmVjdG9yQ29tcG9uZW50c1sgaSBdO1xuXG5cdFx0XHRpZiAoIGNvbXBvbmVudCA9PT0gY29tcG9uZW50c1sgMCBdICkge1xuXG5cdFx0XHRcdHNuaXBwZXRWYWx1ZXMucHVzaCggdGFyZ2V0U25pcHBldCApO1xuXG5cdFx0XHRcdGkgKz0gY29tcG9uZW50cy5sZW5ndGggLSAxO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHNuaXBwZXRWYWx1ZXMucHVzaCggc291cmNlU25pcHBldCArICcuJyArIGNvbXBvbmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYCR7IGJ1aWxkZXIuZ2V0VHlwZSggc291cmNlVHlwZSApIH0oICR7IHNuaXBwZXRWYWx1ZXMuam9pbiggJywgJyApIH0gKWA7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNldE5vZGU7XG4iLCJpbXBvcnQgVGVtcE5vZGUgZnJvbSAnLi4vY29yZS9UZW1wTm9kZS5qcyc7XG5pbXBvcnQgeyB2ZWN0b3JDb21wb25lbnRzIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xuXG5jbGFzcyBGbGlwTm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0ZsaXBOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHNvdXJjZU5vZGUsIGNvbXBvbmVudHMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gc291cmNlTm9kZTtcblx0XHR0aGlzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLnNvdXJjZU5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCB7IGNvbXBvbmVudHMsIHNvdXJjZU5vZGUgfSA9IHRoaXM7XG5cblx0XHRjb25zdCBzb3VyY2VUeXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXHRcdGNvbnN0IHNvdXJjZVNuaXBwZXQgPSBzb3VyY2VOb2RlLmJ1aWxkKCBidWlsZGVyICk7XG5cblx0XHRjb25zdCBzb3VyY2VDYWNoZSA9IGJ1aWxkZXIuZ2V0VmFyRnJvbU5vZGUoIHRoaXMgKTtcblx0XHRjb25zdCBzb3VyY2VQcm9wZXJ0eSA9IGJ1aWxkZXIuZ2V0UHJvcGVydHlOYW1lKCBzb3VyY2VDYWNoZSApO1xuXG5cdFx0YnVpbGRlci5hZGRMaW5lRmxvd0NvZGUoIHNvdXJjZVByb3BlcnR5ICsgJyA9ICcgKyBzb3VyY2VTbmlwcGV0LCB0aGlzICk7XG5cblx0XHRjb25zdCBsZW5ndGggPSBidWlsZGVyLmdldFR5cGVMZW5ndGgoIHNvdXJjZVR5cGUgKTtcblx0XHRjb25zdCBzbmlwcGV0VmFsdWVzID0gW107XG5cblx0XHRsZXQgY29tcG9uZW50SW5kZXggPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjb21wb25lbnQgPSB2ZWN0b3JDb21wb25lbnRzWyBpIF07XG5cblx0XHRcdGlmICggY29tcG9uZW50ID09PSBjb21wb25lbnRzWyBjb21wb25lbnRJbmRleCBdICkge1xuXG5cdFx0XHRcdHNuaXBwZXRWYWx1ZXMucHVzaCggJzEuMCAtICcgKyAoIHNvdXJjZVByb3BlcnR5ICsgJy4nICsgY29tcG9uZW50ICkgKTtcblxuXHRcdFx0XHRjb21wb25lbnRJbmRleCArKztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzbmlwcGV0VmFsdWVzLnB1c2goIHNvdXJjZVByb3BlcnR5ICsgJy4nICsgY29tcG9uZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBgJHsgYnVpbGRlci5nZXRUeXBlKCBzb3VyY2VUeXBlICkgfSggJHsgc25pcHBldFZhbHVlcy5qb2luKCAnLCAnICkgfSApYDtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmxpcE5vZGU7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuL05vZGUuanMnO1xuaW1wb3J0IHsgZ2V0VmFsdWVUeXBlLCBnZXRWYWx1ZUZyb21UeXBlLCBhcnJheUJ1ZmZlclRvQmFzZTY0IH0gZnJvbSAnLi9Ob2RlVXRpbHMuanMnO1xuXG5jbGFzcyBJbnB1dE5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0lucHV0Tm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCB2YWx1ZSwgbm9kZVR5cGUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoIG5vZGVUeXBlICk7XG5cblx0XHR0aGlzLmlzSW5wdXROb2RlID0gdHJ1ZTtcblxuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHR0aGlzLnByZWNpc2lvbiA9IG51bGw7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0cmV0dXJuIGdldFZhbHVlVHlwZSggdGhpcy52YWx1ZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubm9kZVR5cGU7XG5cblx0fVxuXG5cdGdldElucHV0VHlwZSggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0fVxuXG5cdHNldFByZWNpc2lvbiggcHJlY2lzaW9uICkge1xuXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb247XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2VyaWFsaXplKCBkYXRhICkge1xuXG5cdFx0c3VwZXIuc2VyaWFsaXplKCBkYXRhICk7XG5cblx0XHRkYXRhLnZhbHVlID0gdGhpcy52YWx1ZTtcblxuXHRcdGlmICggdGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLnRvQXJyYXkgKSBkYXRhLnZhbHVlID0gdGhpcy52YWx1ZS50b0FycmF5KCk7XG5cblx0XHRkYXRhLnZhbHVlVHlwZSA9IGdldFZhbHVlVHlwZSggdGhpcy52YWx1ZSApO1xuXHRcdGRhdGEubm9kZVR5cGUgPSB0aGlzLm5vZGVUeXBlO1xuXG5cdFx0aWYgKCBkYXRhLnZhbHVlVHlwZSA9PT0gJ0FycmF5QnVmZmVyJyApIGRhdGEudmFsdWUgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KCBkYXRhLnZhbHVlICk7XG5cblx0XHRkYXRhLnByZWNpc2lvbiA9IHRoaXMucHJlY2lzaW9uO1xuXG5cdH1cblxuXHRkZXNlcmlhbGl6ZSggZGF0YSApIHtcblxuXHRcdHN1cGVyLmRlc2VyaWFsaXplKCBkYXRhICk7XG5cblx0XHR0aGlzLm5vZGVUeXBlID0gZGF0YS5ub2RlVHlwZTtcblx0XHR0aGlzLnZhbHVlID0gQXJyYXkuaXNBcnJheSggZGF0YS52YWx1ZSApID8gZ2V0VmFsdWVGcm9tVHlwZSggZGF0YS52YWx1ZVR5cGUsIC4uLmRhdGEudmFsdWUgKSA6IGRhdGEudmFsdWU7XG5cblx0XHR0aGlzLnByZWNpc2lvbiA9IGRhdGEucHJlY2lzaW9uIHx8IG51bGw7XG5cblx0XHRpZiAoIHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5mcm9tQXJyYXkgKSB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5mcm9tQXJyYXkoIGRhdGEudmFsdWUgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGUoIC8qYnVpbGRlciwgb3V0cHV0Ki8gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdBYnN0cmFjdCBmdW5jdGlvbi4nICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0Tm9kZTtcbiIsImltcG9ydCBJbnB1dE5vZGUgZnJvbSAnLi9JbnB1dE5vZGUuanMnO1xuXG5jbGFzcyBDb25zdE5vZGUgZXh0ZW5kcyBJbnB1dE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnQ29uc3ROb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHZhbHVlLCBub2RlVHlwZSA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggdmFsdWUsIG5vZGVUeXBlICk7XG5cblx0XHR0aGlzLmlzQ29uc3ROb2RlID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2VuZXJhdGVDb25zdCggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiBidWlsZGVyLmdlbmVyYXRlQ29uc3QoIHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSwgdGhpcy52YWx1ZSApO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xuXG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggdGhpcy5nZW5lcmF0ZUNvbnN0KCBidWlsZGVyICksIHR5cGUsIG91dHB1dCApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25zdE5vZGU7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xuaW1wb3J0IEFycmF5RWxlbWVudE5vZGUgZnJvbSAnLi4vdXRpbHMvQXJyYXlFbGVtZW50Tm9kZS5qcyc7XG5pbXBvcnQgQ29udmVydE5vZGUgZnJvbSAnLi4vdXRpbHMvQ29udmVydE5vZGUuanMnO1xuaW1wb3J0IEpvaW5Ob2RlIGZyb20gJy4uL3V0aWxzL0pvaW5Ob2RlLmpzJztcbmltcG9ydCBTcGxpdE5vZGUgZnJvbSAnLi4vdXRpbHMvU3BsaXROb2RlLmpzJztcbmltcG9ydCBTZXROb2RlIGZyb20gJy4uL3V0aWxzL1NldE5vZGUuanMnO1xuaW1wb3J0IEZsaXBOb2RlIGZyb20gJy4uL3V0aWxzL0ZsaXBOb2RlLmpzJztcbmltcG9ydCBDb25zdE5vZGUgZnJvbSAnLi4vY29yZS9Db25zdE5vZGUuanMnO1xuaW1wb3J0IHsgZ2V0VmFsdWVGcm9tVHlwZSwgZ2V0VmFsdWVUeXBlIH0gZnJvbSAnLi4vY29yZS9Ob2RlVXRpbHMuanMnO1xuXG4vL1xuXG5sZXQgY3VycmVudFN0YWNrID0gbnVsbDtcblxuY29uc3QgTm9kZUVsZW1lbnRzID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkTWV0aG9kQ2hhaW5pbmcoIG5hbWUsIG5vZGVFbGVtZW50ICkge1xuXG5cdGlmICggTm9kZUVsZW1lbnRzLmhhcyggbmFtZSApICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCBgUmVkZWZpbml0aW9uIG9mIG1ldGhvZCBjaGFpbmluZyAkeyBuYW1lIH1gICk7XG5cdFx0cmV0dXJuO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBub2RlRWxlbWVudCAhPT0gJ2Z1bmN0aW9uJyApIHRocm93IG5ldyBFcnJvciggYE5vZGUgZWxlbWVudCAkeyBuYW1lIH0gaXMgbm90IGEgZnVuY3Rpb25gICk7XG5cblx0Tm9kZUVsZW1lbnRzLnNldCggbmFtZSwgbm9kZUVsZW1lbnQgKTtcblxufVxuXG5jb25zdCBwYXJzZVN3aXp6bGUgPSAoIHByb3BzICkgPT4gcHJvcHMucmVwbGFjZSggL3J8cy9nLCAneCcgKS5yZXBsYWNlKCAvZ3x0L2csICd5JyApLnJlcGxhY2UoIC9ifHAvZywgJ3onICkucmVwbGFjZSggL2F8cS9nLCAndycgKTtcbmNvbnN0IHBhcnNlU3dpenpsZUFuZFNvcnQgPSAoIHByb3BzICkgPT4gcGFyc2VTd2l6emxlKCBwcm9wcyApLnNwbGl0KCAnJyApLnNvcnQoKS5qb2luKCAnJyApO1xuXG5jb25zdCBzaGFkZXJOb2RlSGFuZGxlciA9IHtcblxuXHRzZXR1cCggTm9kZUNsb3N1cmUsIHBhcmFtcyApIHtcblxuXHRcdGNvbnN0IGlucHV0cyA9IHBhcmFtcy5zaGlmdCgpO1xuXG5cdFx0cmV0dXJuIE5vZGVDbG9zdXJlKCBub2RlT2JqZWN0cyggaW5wdXRzICksIC4uLnBhcmFtcyApO1xuXG5cdH0sXG5cblx0Z2V0KCBub2RlLCBwcm9wLCBub2RlT2JqICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgbm9kZVsgcHJvcCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggbm9kZS5pc1N0YWNrTm9kZSAhPT0gdHJ1ZSAmJiBwcm9wID09PSAnYXNzaWduJyApIHtcblxuXHRcdFx0XHRyZXR1cm4gKCAuLi5wYXJhbXMgKSA9PiB7XG5cblx0XHRcdFx0XHRjdXJyZW50U3RhY2suYXNzaWduKCBub2RlT2JqLCAuLi5wYXJhbXMgKTtcblxuXHRcdFx0XHRcdHJldHVybiBub2RlT2JqO1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdH0gZWxzZSBpZiAoIE5vZGVFbGVtZW50cy5oYXMoIHByb3AgKSApIHtcblxuXHRcdFx0XHRjb25zdCBub2RlRWxlbWVudCA9IE5vZGVFbGVtZW50cy5nZXQoIHByb3AgKTtcblxuXHRcdFx0XHRyZXR1cm4gbm9kZS5pc1N0YWNrTm9kZSA/ICggLi4ucGFyYW1zICkgPT4gbm9kZU9iai5hZGQoIG5vZGVFbGVtZW50KCAuLi5wYXJhbXMgKSApIDogKCAuLi5wYXJhbXMgKSA9PiBub2RlRWxlbWVudCggbm9kZU9iaiwgLi4ucGFyYW1zICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHByb3AgPT09ICdzZWxmJyApIHtcblxuXHRcdFx0XHRyZXR1cm4gbm9kZTtcblxuXHRcdFx0fSBlbHNlIGlmICggcHJvcC5lbmRzV2l0aCggJ0Fzc2lnbicgKSAmJiBOb2RlRWxlbWVudHMuaGFzKCBwcm9wLnNsaWNlKCAwLCBwcm9wLmxlbmd0aCAtICdBc3NpZ24nLmxlbmd0aCApICkgKSB7XG5cblx0XHRcdFx0Y29uc3Qgbm9kZUVsZW1lbnQgPSBOb2RlRWxlbWVudHMuZ2V0KCBwcm9wLnNsaWNlKCAwLCBwcm9wLmxlbmd0aCAtICdBc3NpZ24nLmxlbmd0aCApICk7XG5cblx0XHRcdFx0cmV0dXJuIG5vZGUuaXNTdGFja05vZGUgPyAoIC4uLnBhcmFtcyApID0+IG5vZGVPYmouYXNzaWduKCBwYXJhbXNbIDAgXSwgbm9kZUVsZW1lbnQoIC4uLnBhcmFtcyApICkgOiAoIC4uLnBhcmFtcyApID0+IG5vZGVPYmouYXNzaWduKCBub2RlRWxlbWVudCggbm9kZU9iaiwgLi4ucGFyYW1zICkgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggL15beHl6d3JnYmFzdHBxXXsxLDR9JC8udGVzdCggcHJvcCApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdC8vIGFjY2Vzc2luZyBwcm9wZXJ0aWVzICggc3dpenpsZSApXG5cblx0XHRcdFx0cHJvcCA9IHBhcnNlU3dpenpsZSggcHJvcCApO1xuXG5cdFx0XHRcdHJldHVybiBub2RlT2JqZWN0KCBuZXcgU3BsaXROb2RlKCBub2RlT2JqLCBwcm9wICkgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggL15zZXRbWFlaV1JHQkFTVFBRXXsxLDR9JC8udGVzdCggcHJvcCApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdC8vIHNldCBwcm9wZXJ0aWVzICggc3dpenpsZSApIGFuZCBzb3J0IHRvIHh5encgc2VxdWVuY2VcblxuXHRcdFx0XHRwcm9wID0gcGFyc2VTd2l6emxlQW5kU29ydCggcHJvcC5zbGljZSggMyApLnRvTG93ZXJDYXNlKCkgKTtcblxuXHRcdFx0XHRyZXR1cm4gKCB2YWx1ZSApID0+IG5vZGVPYmplY3QoIG5ldyBTZXROb2RlKCBub2RlLCBwcm9wLCB2YWx1ZSApICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIC9eZmxpcFtYWVpXUkdCQVNUUFFdezEsNH0kLy50ZXN0KCBwcm9wICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Ly8gc2V0IHByb3BlcnRpZXMgKCBzd2l6emxlICkgYW5kIHNvcnQgdG8geHl6dyBzZXF1ZW5jZVxuXG5cdFx0XHRcdHByb3AgPSBwYXJzZVN3aXp6bGVBbmRTb3J0KCBwcm9wLnNsaWNlKCA0ICkudG9Mb3dlckNhc2UoKSApO1xuXG5cdFx0XHRcdHJldHVybiAoKSA9PiBub2RlT2JqZWN0KCBuZXcgRmxpcE5vZGUoIG5vZGVPYmplY3QoIG5vZGUgKSwgcHJvcCApICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHByb3AgPT09ICd3aWR0aCcgfHwgcHJvcCA9PT0gJ2hlaWdodCcgfHwgcHJvcCA9PT0gJ2RlcHRoJyApIHtcblxuXHRcdFx0XHQvLyBhY2Nlc3NpbmcgcHJvcGVydHlcblxuXHRcdFx0XHRpZiAoIHByb3AgPT09ICd3aWR0aCcgKSBwcm9wID0gJ3gnO1xuXHRcdFx0XHRlbHNlIGlmICggcHJvcCA9PT0gJ2hlaWdodCcgKSBwcm9wID0gJ3knO1xuXHRcdFx0XHRlbHNlIGlmICggcHJvcCA9PT0gJ2RlcHRoJyApIHByb3AgPSAneic7XG5cblx0XHRcdFx0cmV0dXJuIG5vZGVPYmplY3QoIG5ldyBTcGxpdE5vZGUoIG5vZGUsIHByb3AgKSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCAvXlxcZCskLy50ZXN0KCBwcm9wICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Ly8gYWNjZXNzaW5nIGFycmF5XG5cblx0XHRcdFx0cmV0dXJuIG5vZGVPYmplY3QoIG5ldyBBcnJheUVsZW1lbnROb2RlKCBub2RlT2JqLCBuZXcgQ29uc3ROb2RlKCBOdW1iZXIoIHByb3AgKSwgJ3VpbnQnICkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUmVmbGVjdC5nZXQoIG5vZGUsIHByb3AsIG5vZGVPYmogKTtcblxuXHR9LFxuXG5cdHNldCggbm9kZSwgcHJvcCwgdmFsdWUsIG5vZGVPYmogKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyAmJiBub2RlWyBwcm9wIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gc2V0dGluZyBwcm9wZXJ0aWVzXG5cblx0XHRcdGlmICggL15beHl6d3JnYmFzdHBxXXsxLDR9JC8udGVzdCggcHJvcCApID09PSB0cnVlIHx8IHByb3AgPT09ICd3aWR0aCcgfHwgcHJvcCA9PT0gJ2hlaWdodCcgfHwgcHJvcCA9PT0gJ2RlcHRoJyB8fCAvXlxcZCskLy50ZXN0KCBwcm9wICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0bm9kZU9ialsgcHJvcCBdLmFzc2lnbiggdmFsdWUgKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFJlZmxlY3Quc2V0KCBub2RlLCBwcm9wLCB2YWx1ZSwgbm9kZU9iaiApO1xuXG5cdH1cblxufTtcblxuY29uc3Qgbm9kZU9iamVjdHNDYWNoZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBub2RlQnVpbGRlckZ1bmN0aW9uc0NhY2hlTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuY29uc3QgU2hhZGVyTm9kZU9iamVjdCA9IGZ1bmN0aW9uICggb2JqLCBhbHRUeXBlID0gbnVsbCApIHtcblxuXHRjb25zdCB0eXBlID0gZ2V0VmFsdWVUeXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09ICdub2RlJyApIHtcblxuXHRcdGxldCBub2RlT2JqZWN0ID0gbm9kZU9iamVjdHNDYWNoZU1hcC5nZXQoIG9iaiApO1xuXG5cdFx0aWYgKCBub2RlT2JqZWN0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG5vZGVPYmplY3QgPSBuZXcgUHJveHkoIG9iaiwgc2hhZGVyTm9kZUhhbmRsZXIgKTtcblxuXHRcdFx0bm9kZU9iamVjdHNDYWNoZU1hcC5zZXQoIG9iaiwgbm9kZU9iamVjdCApO1xuXHRcdFx0bm9kZU9iamVjdHNDYWNoZU1hcC5zZXQoIG5vZGVPYmplY3QsIG5vZGVPYmplY3QgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlT2JqZWN0O1xuXG5cdH0gZWxzZSBpZiAoICggYWx0VHlwZSA9PT0gbnVsbCAmJiAoIHR5cGUgPT09ICdmbG9hdCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nICkgKSB8fCAoIHR5cGUgJiYgdHlwZSAhPT0gJ3NoYWRlcicgJiYgdHlwZSAhPT0gJ3N0cmluZycgKSApIHtcblxuXHRcdHJldHVybiBub2RlT2JqZWN0KCBnZXRDb25zdE5vZGUoIG9iaiwgYWx0VHlwZSApICk7XG5cblx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ3NoYWRlcicgKSB7XG5cblx0XHRyZXR1cm4gRm4oIG9iaiApO1xuXG5cdH1cblxuXHRyZXR1cm4gb2JqO1xuXG59O1xuXG5jb25zdCBTaGFkZXJOb2RlT2JqZWN0cyA9IGZ1bmN0aW9uICggb2JqZWN0cywgYWx0VHlwZSA9IG51bGwgKSB7XG5cblx0Zm9yICggY29uc3QgbmFtZSBpbiBvYmplY3RzICkge1xuXG5cdFx0b2JqZWN0c1sgbmFtZSBdID0gbm9kZU9iamVjdCggb2JqZWN0c1sgbmFtZSBdLCBhbHRUeXBlICk7XG5cblx0fVxuXG5cdHJldHVybiBvYmplY3RzO1xuXG59O1xuXG5jb25zdCBTaGFkZXJOb2RlQXJyYXkgPSBmdW5jdGlvbiAoIGFycmF5LCBhbHRUeXBlID0gbnVsbCApIHtcblxuXHRjb25zdCBsZW4gPSBhcnJheS5sZW5ndGg7XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbGVuOyBpICsrICkge1xuXG5cdFx0YXJyYXlbIGkgXSA9IG5vZGVPYmplY3QoIGFycmF5WyBpIF0sIGFsdFR5cGUgKTtcblxuXHR9XG5cblx0cmV0dXJuIGFycmF5O1xuXG59O1xuXG5jb25zdCBTaGFkZXJOb2RlUHJveHkgPSBmdW5jdGlvbiAoIE5vZGVDbGFzcywgc2NvcGUgPSBudWxsLCBmYWN0b3IgPSBudWxsLCBzZXR0aW5ncyA9IG51bGwgKSB7XG5cblx0Y29uc3QgYXNzaWduTm9kZSA9ICggbm9kZSApID0+IG5vZGVPYmplY3QoIHNldHRpbmdzICE9PSBudWxsID8gT2JqZWN0LmFzc2lnbiggbm9kZSwgc2V0dGluZ3MgKSA6IG5vZGUgKTtcblxuXHRpZiAoIHNjb3BlID09PSBudWxsICkge1xuXG5cdFx0cmV0dXJuICggLi4ucGFyYW1zICkgPT4ge1xuXG5cdFx0XHRyZXR1cm4gYXNzaWduTm9kZSggbmV3IE5vZGVDbGFzcyggLi4ubm9kZUFycmF5KCBwYXJhbXMgKSApICk7XG5cblx0XHR9O1xuXG5cdH0gZWxzZSBpZiAoIGZhY3RvciAhPT0gbnVsbCApIHtcblxuXHRcdGZhY3RvciA9IG5vZGVPYmplY3QoIGZhY3RvciApO1xuXG5cdFx0cmV0dXJuICggLi4ucGFyYW1zICkgPT4ge1xuXG5cdFx0XHRyZXR1cm4gYXNzaWduTm9kZSggbmV3IE5vZGVDbGFzcyggc2NvcGUsIC4uLm5vZGVBcnJheSggcGFyYW1zICksIGZhY3RvciApICk7XG5cblx0XHR9O1xuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm4gKCAuLi5wYXJhbXMgKSA9PiB7XG5cblx0XHRcdHJldHVybiBhc3NpZ25Ob2RlKCBuZXcgTm9kZUNsYXNzKCBzY29wZSwgLi4ubm9kZUFycmF5KCBwYXJhbXMgKSApICk7XG5cblx0XHR9O1xuXG5cdH1cblxufTtcblxuY29uc3QgU2hhZGVyTm9kZUltbXV0YWJsZSA9IGZ1bmN0aW9uICggTm9kZUNsYXNzLCAuLi5wYXJhbXMgKSB7XG5cblx0cmV0dXJuIG5vZGVPYmplY3QoIG5ldyBOb2RlQ2xhc3MoIC4uLm5vZGVBcnJheSggcGFyYW1zICkgKSApO1xuXG59O1xuXG5jbGFzcyBTaGFkZXJDYWxsTm9kZUludGVybmFsIGV4dGVuZHMgTm9kZSB7XG5cblx0Y29uc3RydWN0b3IoIHNoYWRlck5vZGUsIGlucHV0Tm9kZXMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5zaGFkZXJOb2RlID0gc2hhZGVyTm9kZTtcblx0XHR0aGlzLmlucHV0Tm9kZXMgPSBpbnB1dE5vZGVzO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLnNoYWRlck5vZGUubm9kZVR5cGUgfHwgdGhpcy5nZXRPdXRwdXROb2RlKCBidWlsZGVyICkuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0Y2FsbCggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHsgc2hhZGVyTm9kZSwgaW5wdXROb2RlcyB9ID0gdGhpcztcblxuXHRcdGNvbnN0IHByb3BlcnRpZXMgPSBidWlsZGVyLmdldE5vZGVQcm9wZXJ0aWVzKCBzaGFkZXJOb2RlICk7XG5cdFx0aWYgKCBwcm9wZXJ0aWVzLm9uY2VPdXRwdXQgKSByZXR1cm4gcHJvcGVydGllcy5vbmNlT3V0cHV0O1xuXG5cdFx0Ly9cblxuXHRcdGxldCByZXN1bHQgPSBudWxsO1xuXG5cdFx0aWYgKCBzaGFkZXJOb2RlLmxheW91dCApIHtcblxuXHRcdFx0bGV0IGZ1bmN0aW9uTm9kZXNDYWNoZU1hcCA9IG5vZGVCdWlsZGVyRnVuY3Rpb25zQ2FjaGVNYXAuZ2V0KCBidWlsZGVyLmNvbnN0cnVjdG9yICk7XG5cblx0XHRcdGlmICggZnVuY3Rpb25Ob2Rlc0NhY2hlTWFwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0ZnVuY3Rpb25Ob2Rlc0NhY2hlTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdFx0XHRub2RlQnVpbGRlckZ1bmN0aW9uc0NhY2hlTWFwLnNldCggYnVpbGRlci5jb25zdHJ1Y3RvciwgZnVuY3Rpb25Ob2Rlc0NhY2hlTWFwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IGZ1bmN0aW9uTm9kZSA9IGZ1bmN0aW9uTm9kZXNDYWNoZU1hcC5nZXQoIHNoYWRlck5vZGUgKTtcblxuXHRcdFx0aWYgKCBmdW5jdGlvbk5vZGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmdW5jdGlvbk5vZGUgPSBub2RlT2JqZWN0KCBidWlsZGVyLmJ1aWxkRnVuY3Rpb25Ob2RlKCBzaGFkZXJOb2RlICkgKTtcblxuXHRcdFx0XHRmdW5jdGlvbk5vZGVzQ2FjaGVNYXAuc2V0KCBzaGFkZXJOb2RlLCBmdW5jdGlvbk5vZGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1aWxkZXIuY3VycmVudEZ1bmN0aW9uTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRidWlsZGVyLmN1cnJlbnRGdW5jdGlvbk5vZGUuaW5jbHVkZXMucHVzaCggZnVuY3Rpb25Ob2RlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmVzdWx0ID0gbm9kZU9iamVjdCggZnVuY3Rpb25Ob2RlLmNhbGwoIGlucHV0Tm9kZXMgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QganNGdW5jID0gc2hhZGVyTm9kZS5qc0Z1bmM7XG5cdFx0XHRjb25zdCBvdXRwdXROb2RlID0gaW5wdXROb2RlcyAhPT0gbnVsbCA/IGpzRnVuYyggaW5wdXROb2RlcywgYnVpbGRlciApIDoganNGdW5jKCBidWlsZGVyICk7XG5cblx0XHRcdHJlc3VsdCA9IG5vZGVPYmplY3QoIG91dHB1dE5vZGUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggc2hhZGVyTm9kZS5vbmNlICkge1xuXG5cdFx0XHRwcm9wZXJ0aWVzLm9uY2VPdXRwdXQgPSByZXN1bHQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRnZXRPdXRwdXROb2RlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgcHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcblxuXHRcdGlmICggcHJvcGVydGllcy5vdXRwdXROb2RlID09PSBudWxsICkge1xuXG5cdFx0XHRwcm9wZXJ0aWVzLm91dHB1dE5vZGUgPSB0aGlzLnNldHVwT3V0cHV0KCBidWlsZGVyICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvcGVydGllcy5vdXRwdXROb2RlO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLmdldE91dHB1dE5vZGUoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0c2V0dXBPdXRwdXQoIGJ1aWxkZXIgKSB7XG5cblx0XHRidWlsZGVyLmFkZFN0YWNrKCk7XG5cblx0XHRidWlsZGVyLnN0YWNrLm91dHB1dE5vZGUgPSB0aGlzLmNhbGwoIGJ1aWxkZXIgKTtcblxuXHRcdHJldHVybiBidWlsZGVyLnJlbW92ZVN0YWNrKCk7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XG5cblx0XHRjb25zdCBvdXRwdXROb2RlID0gdGhpcy5nZXRPdXRwdXROb2RlKCBidWlsZGVyICk7XG5cblx0XHRyZXR1cm4gb3V0cHV0Tm9kZS5idWlsZCggYnVpbGRlciwgb3V0cHV0ICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFNoYWRlck5vZGVJbnRlcm5hbCBleHRlbmRzIE5vZGUge1xuXG5cdGNvbnN0cnVjdG9yKCBqc0Z1bmMsIG5vZGVUeXBlICkge1xuXG5cdFx0c3VwZXIoIG5vZGVUeXBlICk7XG5cblx0XHR0aGlzLmpzRnVuYyA9IGpzRnVuYztcblx0XHR0aGlzLmxheW91dCA9IG51bGw7XG5cblx0XHR0aGlzLmdsb2JhbCA9IHRydWU7XG5cblx0XHR0aGlzLm9uY2UgPSBmYWxzZTtcblxuXHR9XG5cblx0c2V0TGF5b3V0KCBsYXlvdXQgKSB7XG5cblx0XHR0aGlzLmxheW91dCA9IGxheW91dDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjYWxsKCBpbnB1dHMgPSBudWxsICkge1xuXG5cdFx0bm9kZU9iamVjdHMoIGlucHV0cyApO1xuXG5cdFx0cmV0dXJuIG5vZGVPYmplY3QoIG5ldyBTaGFkZXJDYWxsTm9kZUludGVybmFsKCB0aGlzLCBpbnB1dHMgKSApO1xuXG5cdH1cblxuXHRzZXR1cCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmNhbGwoKTtcblxuXHR9XG5cbn1cblxuY29uc3QgYm9vbHMgPSBbIGZhbHNlLCB0cnVlIF07XG5jb25zdCB1aW50cyA9IFsgMCwgMSwgMiwgMyBdO1xuY29uc3QgaW50cyA9IFsgLSAxLCAtIDIgXTtcbmNvbnN0IGZsb2F0cyA9IFsgMC41LCAxLjUsIDEgLyAzLCAxZS02LCAxZTYsIE1hdGguUEksIE1hdGguUEkgKiAyLCAxIC8gTWF0aC5QSSwgMiAvIE1hdGguUEksIDEgLyAoIE1hdGguUEkgKiAyICksIE1hdGguUEkgLyAyIF07XG5cbmNvbnN0IGJvb2xzQ2FjaGVNYXAgPSBuZXcgTWFwKCk7XG5mb3IgKCBjb25zdCBib29sIG9mIGJvb2xzICkgYm9vbHNDYWNoZU1hcC5zZXQoIGJvb2wsIG5ldyBDb25zdE5vZGUoIGJvb2wgKSApO1xuXG5jb25zdCB1aW50c0NhY2hlTWFwID0gbmV3IE1hcCgpO1xuZm9yICggY29uc3QgdWludCBvZiB1aW50cyApIHVpbnRzQ2FjaGVNYXAuc2V0KCB1aW50LCBuZXcgQ29uc3ROb2RlKCB1aW50LCAndWludCcgKSApO1xuXG5jb25zdCBpbnRzQ2FjaGVNYXAgPSBuZXcgTWFwKCBbIC4uLnVpbnRzQ2FjaGVNYXAgXS5tYXAoIGVsID0+IG5ldyBDb25zdE5vZGUoIGVsLnZhbHVlLCAnaW50JyApICkgKTtcbmZvciAoIGNvbnN0IGludCBvZiBpbnRzICkgaW50c0NhY2hlTWFwLnNldCggaW50LCBuZXcgQ29uc3ROb2RlKCBpbnQsICdpbnQnICkgKTtcblxuY29uc3QgZmxvYXRzQ2FjaGVNYXAgPSBuZXcgTWFwKCBbIC4uLmludHNDYWNoZU1hcCBdLm1hcCggZWwgPT4gbmV3IENvbnN0Tm9kZSggZWwudmFsdWUgKSApICk7XG5mb3IgKCBjb25zdCBmbG9hdCBvZiBmbG9hdHMgKSBmbG9hdHNDYWNoZU1hcC5zZXQoIGZsb2F0LCBuZXcgQ29uc3ROb2RlKCBmbG9hdCApICk7XG5mb3IgKCBjb25zdCBmbG9hdCBvZiBmbG9hdHMgKSBmbG9hdHNDYWNoZU1hcC5zZXQoIC0gZmxvYXQsIG5ldyBDb25zdE5vZGUoIC0gZmxvYXQgKSApO1xuXG5jb25zdCBjYWNoZU1hcHMgPSB7IGJvb2w6IGJvb2xzQ2FjaGVNYXAsIHVpbnQ6IHVpbnRzQ2FjaGVNYXAsIGludHM6IGludHNDYWNoZU1hcCwgZmxvYXQ6IGZsb2F0c0NhY2hlTWFwIH07XG5cbmNvbnN0IGNvbnN0Tm9kZXNDYWNoZU1hcCA9IG5ldyBNYXAoIFsgLi4uYm9vbHNDYWNoZU1hcCwgLi4uZmxvYXRzQ2FjaGVNYXAgXSApO1xuXG5jb25zdCBnZXRDb25zdE5vZGUgPSAoIHZhbHVlLCB0eXBlICkgPT4ge1xuXG5cdGlmICggY29uc3ROb2Rlc0NhY2hlTWFwLmhhcyggdmFsdWUgKSApIHtcblxuXHRcdHJldHVybiBjb25zdE5vZGVzQ2FjaGVNYXAuZ2V0KCB2YWx1ZSApO1xuXG5cdH0gZWxzZSBpZiAoIHZhbHVlLmlzTm9kZSA9PT0gdHJ1ZSApIHtcblxuXHRcdHJldHVybiB2YWx1ZTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0cmV0dXJuIG5ldyBDb25zdE5vZGUoIHZhbHVlLCB0eXBlICk7XG5cblx0fVxuXG59O1xuXG5jb25zdCBzYWZlR2V0Tm9kZVR5cGUgPSAoIG5vZGUgKSA9PiB7XG5cblx0dHJ5IHtcblxuXHRcdHJldHVybiBub2RlLmdldE5vZGVUeXBlKCk7XG5cblx0fSBjYXRjaCAoIF8gKSB7XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdH1cblxufTtcblxuY29uc3QgQ29udmVydFR5cGUgPSBmdW5jdGlvbiAoIHR5cGUsIGNhY2hlTWFwID0gbnVsbCApIHtcblxuXHRyZXR1cm4gKCAuLi5wYXJhbXMgKSA9PiB7XG5cblx0XHRpZiAoIHBhcmFtcy5sZW5ndGggPT09IDAgfHwgKCAhIFsgJ2Jvb2wnLCAnZmxvYXQnLCAnaW50JywgJ3VpbnQnIF0uaW5jbHVkZXMoIHR5cGUgKSAmJiBwYXJhbXMuZXZlcnkoIHBhcmFtID0+IHR5cGVvZiBwYXJhbSAhPT0gJ29iamVjdCcgKSApICkge1xuXG5cdFx0XHRwYXJhbXMgPSBbIGdldFZhbHVlRnJvbVR5cGUoIHR5cGUsIC4uLnBhcmFtcyApIF07XG5cblx0XHR9XG5cblx0XHRpZiAoIHBhcmFtcy5sZW5ndGggPT09IDEgJiYgY2FjaGVNYXAgIT09IG51bGwgJiYgY2FjaGVNYXAuaGFzKCBwYXJhbXNbIDAgXSApICkge1xuXG5cdFx0XHRyZXR1cm4gbm9kZU9iamVjdCggY2FjaGVNYXAuZ2V0KCBwYXJhbXNbIDAgXSApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHBhcmFtcy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGUgPSBnZXRDb25zdE5vZGUoIHBhcmFtc1sgMCBdLCB0eXBlICk7XG5cdFx0XHRpZiAoIHNhZmVHZXROb2RlVHlwZSggbm9kZSApID09PSB0eXBlICkgcmV0dXJuIG5vZGVPYmplY3QoIG5vZGUgKTtcblx0XHRcdHJldHVybiBub2RlT2JqZWN0KCBuZXcgQ29udmVydE5vZGUoIG5vZGUsIHR5cGUgKSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgbm9kZXMgPSBwYXJhbXMubWFwKCBwYXJhbSA9PiBnZXRDb25zdE5vZGUoIHBhcmFtICkgKTtcblx0XHRyZXR1cm4gbm9kZU9iamVjdCggbmV3IEpvaW5Ob2RlKCBub2RlcywgdHlwZSApICk7XG5cblx0fTtcblxufTtcblxuLy8gZXhwb3J0c1xuXG5leHBvcnQgY29uc3QgZGVmaW5lZCA9ICggdiApID0+IHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiB2ICE9PSBudWxsID8gdi52YWx1ZSA6IHY7IC8vIFRPRE86IHJlbW92ZSBib29sZWFuIGNvbnZlcnNpb24gYW5kIGRlZmluZWQgZnVuY3Rpb25cblxuLy8gdXRpbHNcblxuZXhwb3J0IGNvbnN0IGdldENvbnN0Tm9kZVR5cGUgPSAoIHZhbHVlICkgPT4gKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsICkgPyAoIHZhbHVlLm5vZGVUeXBlIHx8IHZhbHVlLmNvbnZlcnRUbyB8fCAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IG51bGwgKSApIDogbnVsbDtcblxuLy8gc2hhZGVyIG5vZGUgYmFzZVxuXG5leHBvcnQgZnVuY3Rpb24gU2hhZGVyTm9kZSgganNGdW5jLCBub2RlVHlwZSApIHtcblxuXHRyZXR1cm4gbmV3IFByb3h5KCBuZXcgU2hhZGVyTm9kZUludGVybmFsKCBqc0Z1bmMsIG5vZGVUeXBlICksIHNoYWRlck5vZGVIYW5kbGVyICk7XG5cbn1cblxuZXhwb3J0IGNvbnN0IG5vZGVPYmplY3QgPSAoIHZhbCwgYWx0VHlwZSA9IG51bGwgKSA9PiAvKiBuZXcgKi8gU2hhZGVyTm9kZU9iamVjdCggdmFsLCBhbHRUeXBlICk7XG5leHBvcnQgY29uc3Qgbm9kZU9iamVjdHMgPSAoIHZhbCwgYWx0VHlwZSA9IG51bGwgKSA9PiBuZXcgU2hhZGVyTm9kZU9iamVjdHMoIHZhbCwgYWx0VHlwZSApO1xuZXhwb3J0IGNvbnN0IG5vZGVBcnJheSA9ICggdmFsLCBhbHRUeXBlID0gbnVsbCApID0+IG5ldyBTaGFkZXJOb2RlQXJyYXkoIHZhbCwgYWx0VHlwZSApO1xuZXhwb3J0IGNvbnN0IG5vZGVQcm94eSA9ICggLi4ucGFyYW1zICkgPT4gbmV3IFNoYWRlck5vZGVQcm94eSggLi4ucGFyYW1zICk7XG5leHBvcnQgY29uc3Qgbm9kZUltbXV0YWJsZSA9ICggLi4ucGFyYW1zICkgPT4gbmV3IFNoYWRlck5vZGVJbW11dGFibGUoIC4uLnBhcmFtcyApO1xuXG5leHBvcnQgY29uc3QgRm4gPSAoIGpzRnVuYywgbm9kZVR5cGUgKSA9PiB7XG5cblx0Y29uc3Qgc2hhZGVyTm9kZSA9IG5ldyBTaGFkZXJOb2RlKCBqc0Z1bmMsIG5vZGVUeXBlICk7XG5cblx0Y29uc3QgZm4gPSAoIC4uLnBhcmFtcyApID0+IHtcblxuXHRcdGxldCBpbnB1dHM7XG5cblx0XHRub2RlT2JqZWN0cyggcGFyYW1zICk7XG5cblx0XHRpZiAoIHBhcmFtc1sgMCBdICYmIHBhcmFtc1sgMCBdLmlzTm9kZSApIHtcblxuXHRcdFx0aW5wdXRzID0gWyAuLi5wYXJhbXMgXTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlucHV0cyA9IHBhcmFtc1sgMCBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNoYWRlck5vZGUuY2FsbCggaW5wdXRzICk7XG5cblx0fTtcblxuXHRmbi5zaGFkZXJOb2RlID0gc2hhZGVyTm9kZTtcblxuXHRmbi5zZXRMYXlvdXQgPSAoIGxheW91dCApID0+IHtcblxuXHRcdHNoYWRlck5vZGUuc2V0TGF5b3V0KCBsYXlvdXQgKTtcblxuXHRcdHJldHVybiBmbjtcblxuXHR9O1xuXG5cdGZuLm9uY2UgPSAoKSA9PiB7XG5cblx0XHRzaGFkZXJOb2RlLm9uY2UgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIGZuO1xuXG5cdH07XG5cblx0cmV0dXJuIGZuO1xuXG59O1xuXG5leHBvcnQgY29uc3QgdHNsRm4gPSAoIC4uLnBhcmFtcyApID0+IHsgLy8gQGRlcHJlY2F0ZWQsIHIxNjhcblxuXHRjb25zb2xlLndhcm4oICdUU0wuU2hhZGVyTm9kZTogdHNsRm4oKSBoYXMgYmVlbiByZW5hbWVkIHRvIEZuKCkuJyApO1xuXHRyZXR1cm4gRm4oIC4uLnBhcmFtcyApO1xuXG59O1xuXG4vL1xuXG5hZGRNZXRob2RDaGFpbmluZyggJ3RvR2xvYmFsJywgKCBub2RlICkgPT4ge1xuXG5cdG5vZGUuZ2xvYmFsID0gdHJ1ZTtcblxuXHRyZXR1cm4gbm9kZTtcblxufSApO1xuXG4vL1xuXG5leHBvcnQgY29uc3Qgc2V0Q3VycmVudFN0YWNrID0gKCBzdGFjayApID0+IHtcblxuXHRpZiAoIGN1cnJlbnRTdGFjayA9PT0gc3RhY2sgKSB7XG5cblx0XHQvL3Rocm93IG5ldyBFcnJvciggJ1N0YWNrIGFscmVhZHkgZGVmaW5lZC4nICk7XG5cblx0fVxuXG5cdGN1cnJlbnRTdGFjayA9IHN0YWNrO1xuXG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFN0YWNrID0gKCkgPT4gY3VycmVudFN0YWNrO1xuXG5leHBvcnQgY29uc3QgSWYgPSAoIC4uLnBhcmFtcyApID0+IGN1cnJlbnRTdGFjay5JZiggLi4ucGFyYW1zICk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQoIG5vZGUgKSB7XG5cblx0aWYgKCBjdXJyZW50U3RhY2sgKSBjdXJyZW50U3RhY2suYWRkKCBub2RlICk7XG5cblx0cmV0dXJuIG5vZGU7XG5cbn1cblxuYWRkTWV0aG9kQ2hhaW5pbmcoICdhcHBlbmQnLCBhcHBlbmQgKTtcblxuLy8gdHlwZXNcblxuZXhwb3J0IGNvbnN0IGNvbG9yID0gbmV3IENvbnZlcnRUeXBlKCAnY29sb3InICk7XG5cbmV4cG9ydCBjb25zdCBmbG9hdCA9IG5ldyBDb252ZXJ0VHlwZSggJ2Zsb2F0JywgY2FjaGVNYXBzLmZsb2F0ICk7XG5leHBvcnQgY29uc3QgaW50ID0gbmV3IENvbnZlcnRUeXBlKCAnaW50JywgY2FjaGVNYXBzLmludHMgKTtcbmV4cG9ydCBjb25zdCB1aW50ID0gbmV3IENvbnZlcnRUeXBlKCAndWludCcsIGNhY2hlTWFwcy51aW50ICk7XG5leHBvcnQgY29uc3QgYm9vbCA9IG5ldyBDb252ZXJ0VHlwZSggJ2Jvb2wnLCBjYWNoZU1hcHMuYm9vbCApO1xuXG5leHBvcnQgY29uc3QgdmVjMiA9IG5ldyBDb252ZXJ0VHlwZSggJ3ZlYzInICk7XG5leHBvcnQgY29uc3QgaXZlYzIgPSBuZXcgQ29udmVydFR5cGUoICdpdmVjMicgKTtcbmV4cG9ydCBjb25zdCB1dmVjMiA9IG5ldyBDb252ZXJ0VHlwZSggJ3V2ZWMyJyApO1xuZXhwb3J0IGNvbnN0IGJ2ZWMyID0gbmV3IENvbnZlcnRUeXBlKCAnYnZlYzInICk7XG5cbmV4cG9ydCBjb25zdCB2ZWMzID0gbmV3IENvbnZlcnRUeXBlKCAndmVjMycgKTtcbmV4cG9ydCBjb25zdCBpdmVjMyA9IG5ldyBDb252ZXJ0VHlwZSggJ2l2ZWMzJyApO1xuZXhwb3J0IGNvbnN0IHV2ZWMzID0gbmV3IENvbnZlcnRUeXBlKCAndXZlYzMnICk7XG5leHBvcnQgY29uc3QgYnZlYzMgPSBuZXcgQ29udmVydFR5cGUoICdidmVjMycgKTtcblxuZXhwb3J0IGNvbnN0IHZlYzQgPSBuZXcgQ29udmVydFR5cGUoICd2ZWM0JyApO1xuZXhwb3J0IGNvbnN0IGl2ZWM0ID0gbmV3IENvbnZlcnRUeXBlKCAnaXZlYzQnICk7XG5leHBvcnQgY29uc3QgdXZlYzQgPSBuZXcgQ29udmVydFR5cGUoICd1dmVjNCcgKTtcbmV4cG9ydCBjb25zdCBidmVjNCA9IG5ldyBDb252ZXJ0VHlwZSggJ2J2ZWM0JyApO1xuXG5leHBvcnQgY29uc3QgbWF0MiA9IG5ldyBDb252ZXJ0VHlwZSggJ21hdDInICk7XG5leHBvcnQgY29uc3QgbWF0MyA9IG5ldyBDb252ZXJ0VHlwZSggJ21hdDMnICk7XG5leHBvcnQgY29uc3QgbWF0NCA9IG5ldyBDb252ZXJ0VHlwZSggJ21hdDQnICk7XG5cbmV4cG9ydCBjb25zdCBzdHJpbmcgPSAoIHZhbHVlID0gJycgKSA9PiBub2RlT2JqZWN0KCBuZXcgQ29uc3ROb2RlKCB2YWx1ZSwgJ3N0cmluZycgKSApO1xuZXhwb3J0IGNvbnN0IGFycmF5QnVmZmVyID0gKCB2YWx1ZSApID0+IG5vZGVPYmplY3QoIG5ldyBDb25zdE5vZGUoIHZhbHVlLCAnQXJyYXlCdWZmZXInICkgKTtcblxuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b0NvbG9yJywgY29sb3IgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAndG9GbG9hdCcsIGZsb2F0ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3RvSW50JywgaW50ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3RvVWludCcsIHVpbnQgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAndG9Cb29sJywgYm9vbCApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b1ZlYzInLCB2ZWMyICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3RvSVZlYzInLCBpdmVjMiApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b1VWZWMyJywgdXZlYzIgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAndG9CVmVjMicsIGJ2ZWMyICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3RvVmVjMycsIHZlYzMgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAndG9JVmVjMycsIGl2ZWMzICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3RvVVZlYzMnLCB1dmVjMyApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b0JWZWMzJywgYnZlYzMgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAndG9WZWM0JywgdmVjNCApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b0lWZWM0JywgaXZlYzQgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAndG9VVmVjNCcsIHV2ZWM0ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3RvQlZlYzQnLCBidmVjNCApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b01hdDInLCBtYXQyICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3RvTWF0MycsIG1hdDMgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAndG9NYXQ0JywgbWF0NCApO1xuXG4vLyBiYXNpYyBub2Rlc1xuXG5leHBvcnQgY29uc3QgZWxlbWVudCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBBcnJheUVsZW1lbnROb2RlICk7XG5leHBvcnQgY29uc3QgY29udmVydCA9ICggbm9kZSwgdHlwZXMgKSA9PiBub2RlT2JqZWN0KCBuZXcgQ29udmVydE5vZGUoIG5vZGVPYmplY3QoIG5vZGUgKSwgdHlwZXMgKSApO1xuZXhwb3J0IGNvbnN0IHNwbGl0ID0gKCBub2RlLCBjaGFubmVscyApID0+IG5vZGVPYmplY3QoIG5ldyBTcGxpdE5vZGUoIG5vZGVPYmplY3QoIG5vZGUgKSwgY2hhbm5lbHMgKSApO1xuXG5hZGRNZXRob2RDaGFpbmluZyggJ2VsZW1lbnQnLCBlbGVtZW50ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2NvbnZlcnQnLCBjb252ZXJ0ICk7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuL05vZGUuanMnO1xuXG5jbGFzcyBVbmlmb3JtR3JvdXBOb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdVbmlmb3JtR3JvdXBOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIG5hbWUsIHNoYXJlZCA9IGZhbHNlLCBvcmRlciA9IDEgKSB7XG5cblx0XHRzdXBlciggJ3N0cmluZycgKTtcblxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblxuXHRcdHRoaXMuc2hhcmVkID0gc2hhcmVkO1xuXHRcdHRoaXMub3JkZXIgPSBvcmRlcjtcblx0XHR0aGlzLmlzVW5pZm9ybUdyb3VwID0gdHJ1ZTtcblxuXHR9XG5cblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0fVxuXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcblxuXHRcdHN1cGVyLnNlcmlhbGl6ZSggZGF0YSApO1xuXG5cdFx0ZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXHRcdGRhdGEudmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcblx0XHRkYXRhLnNoYXJlZCA9IHRoaXMuc2hhcmVkO1xuXG5cdH1cblxuXHRkZXNlcmlhbGl6ZSggZGF0YSApIHtcblxuXHRcdHN1cGVyLmRlc2VyaWFsaXplKCBkYXRhICk7XG5cblx0XHR0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG5cdFx0dGhpcy52ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xuXHRcdHRoaXMuc2hhcmVkID0gZGF0YS5zaGFyZWQ7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFVuaWZvcm1Hcm91cE5vZGU7XG5cbmV4cG9ydCBjb25zdCB1bmlmb3JtR3JvdXAgPSAoIG5hbWUgKSA9PiBuZXcgVW5pZm9ybUdyb3VwTm9kZSggbmFtZSApO1xuZXhwb3J0IGNvbnN0IHNoYXJlZFVuaWZvcm1Hcm91cCA9ICggbmFtZSwgb3JkZXIgPSAwICkgPT4gbmV3IFVuaWZvcm1Hcm91cE5vZGUoIG5hbWUsIHRydWUsIG9yZGVyICk7XG5cbmV4cG9ydCBjb25zdCBmcmFtZUdyb3VwID0gLypAX19QVVJFX18qLyBzaGFyZWRVbmlmb3JtR3JvdXAoICdmcmFtZScgKTtcbmV4cG9ydCBjb25zdCByZW5kZXJHcm91cCA9IC8qQF9fUFVSRV9fKi8gc2hhcmVkVW5pZm9ybUdyb3VwKCAncmVuZGVyJyApO1xuZXhwb3J0IGNvbnN0IG9iamVjdEdyb3VwID0gLypAX19QVVJFX18qLyB1bmlmb3JtR3JvdXAoICdvYmplY3QnICk7XG4iLCJpbXBvcnQgSW5wdXROb2RlIGZyb20gJy4vSW5wdXROb2RlLmpzJztcbmltcG9ydCB7IG9iamVjdEdyb3VwIH0gZnJvbSAnLi9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcbmltcG9ydCB7IG5vZGVPYmplY3QsIGdldENvbnN0Tm9kZVR5cGUgfSBmcm9tICcuLi90c2wvVFNMQ29yZS5qcyc7XG5cbmNsYXNzIFVuaWZvcm1Ob2RlIGV4dGVuZHMgSW5wdXROb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1VuaWZvcm1Ob2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHZhbHVlLCBub2RlVHlwZSA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggdmFsdWUsIG5vZGVUeXBlICk7XG5cblx0XHR0aGlzLmlzVW5pZm9ybU5vZGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0dGhpcy5ncm91cE5vZGUgPSBvYmplY3RHcm91cDtcblxuXHR9XG5cblx0bGFiZWwoIG5hbWUgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEdyb3VwKCBncm91cCApIHtcblxuXHRcdHRoaXMuZ3JvdXBOb2RlID0gZ3JvdXA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0R3JvdXAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ncm91cE5vZGU7XG5cblx0fVxuXG5cdGdldFVuaWZvcm1IYXNoKCBidWlsZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0SGFzaCggYnVpbGRlciApO1xuXG5cdH1cblxuXHRvblVwZGF0ZSggY2FsbGJhY2ssIHVwZGF0ZVR5cGUgKSB7XG5cblx0XHRjb25zdCBzZWxmID0gdGhpcy5nZXRTZWxmKCk7XG5cblx0XHRjYWxsYmFjayA9IGNhbGxiYWNrLmJpbmQoIHNlbGYgKTtcblxuXHRcdHJldHVybiBzdXBlci5vblVwZGF0ZSggKCBmcmFtZSApID0+IHtcblxuXHRcdFx0Y29uc3QgdmFsdWUgPSBjYWxsYmFjayggZnJhbWUsIHNlbGYgKTtcblxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdCBcdH0sIHVwZGF0ZVR5cGUgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcblxuXHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0XHRjb25zdCBoYXNoID0gdGhpcy5nZXRVbmlmb3JtSGFzaCggYnVpbGRlciApO1xuXG5cdFx0bGV0IHNoYXJlZE5vZGUgPSBidWlsZGVyLmdldE5vZGVGcm9tSGFzaCggaGFzaCApO1xuXG5cdFx0aWYgKCBzaGFyZWROb2RlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJ1aWxkZXIuc2V0SGFzaE5vZGUoIHRoaXMsIGhhc2ggKTtcblxuXHRcdFx0c2hhcmVkTm9kZSA9IHRoaXM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBzaGFyZWROb2RlVHlwZSA9IHNoYXJlZE5vZGUuZ2V0SW5wdXRUeXBlKCBidWlsZGVyICk7XG5cblx0XHRjb25zdCBub2RlVW5pZm9ybSA9IGJ1aWxkZXIuZ2V0VW5pZm9ybUZyb21Ob2RlKCBzaGFyZWROb2RlLCBzaGFyZWROb2RlVHlwZSwgYnVpbGRlci5zaGFkZXJTdGFnZSwgdGhpcy5uYW1lIHx8IGJ1aWxkZXIuY29udGV4dC5sYWJlbCApO1xuXHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0UHJvcGVydHlOYW1lKCBub2RlVW5pZm9ybSApO1xuXG5cdFx0aWYgKCBidWlsZGVyLmNvbnRleHQubGFiZWwgIT09IHVuZGVmaW5lZCApIGRlbGV0ZSBidWlsZGVyLmNvbnRleHQubGFiZWw7XG5cblx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIHByb3BlcnR5TmFtZSwgdHlwZSwgb3V0cHV0ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFVuaWZvcm1Ob2RlO1xuXG5leHBvcnQgY29uc3QgdW5pZm9ybSA9ICggYXJnMSwgYXJnMiApID0+IHtcblxuXHRjb25zdCBub2RlVHlwZSA9IGdldENvbnN0Tm9kZVR5cGUoIGFyZzIgfHwgYXJnMSApO1xuXG5cdC8vIEBUT0RPOiBnZXQgQ29uc3ROb2RlIGZyb20gLnRyYXZlcnNlKCkgaW4gdGhlIGZ1dHVyZVxuXHRjb25zdCB2YWx1ZSA9ICggYXJnMSAmJiBhcmcxLmlzTm9kZSA9PT0gdHJ1ZSApID8gKCBhcmcxLm5vZGUgJiYgYXJnMS5ub2RlLnZhbHVlICkgfHwgYXJnMS52YWx1ZSA6IGFyZzE7XG5cblx0cmV0dXJuIG5vZGVPYmplY3QoIG5ldyBVbmlmb3JtTm9kZSggdmFsdWUsIG5vZGVUeXBlICkgKTtcblxufTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlSW1tdXRhYmxlLCBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuXG5jbGFzcyBQcm9wZXJ0eU5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1Byb3BlcnR5Tm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBub2RlVHlwZSwgbmFtZSA9IG51bGwsIHZhcnlpbmcgPSBmYWxzZSApIHtcblxuXHRcdHN1cGVyKCBub2RlVHlwZSApO1xuXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR0aGlzLnZhcnlpbmcgPSB2YXJ5aW5nO1xuXG5cdFx0dGhpcy5pc1Byb3BlcnR5Tm9kZSA9IHRydWU7XG5cblx0fVxuXG5cdGdldEhhc2goIGJ1aWxkZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5uYW1lIHx8IHN1cGVyLmdldEhhc2goIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0aXNHbG9iYWwoIC8qYnVpbGRlciovICkge1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xuXG5cdFx0bGV0IG5vZGVWYXI7XG5cblx0XHRpZiAoIHRoaXMudmFyeWluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0bm9kZVZhciA9IGJ1aWxkZXIuZ2V0VmFyeWluZ0Zyb21Ob2RlKCB0aGlzLCB0aGlzLm5hbWUgKTtcblx0XHRcdG5vZGVWYXIubmVlZHNJbnRlcnBvbGF0aW9uID0gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG5vZGVWYXIgPSBidWlsZGVyLmdldFZhckZyb21Ob2RlKCB0aGlzLCB0aGlzLm5hbWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBidWlsZGVyLmdldFByb3BlcnR5TmFtZSggbm9kZVZhciApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQcm9wZXJ0eU5vZGU7XG5cbmV4cG9ydCBjb25zdCBwcm9wZXJ0eSA9ICggdHlwZSwgbmFtZSApID0+IG5vZGVPYmplY3QoIG5ldyBQcm9wZXJ0eU5vZGUoIHR5cGUsIG5hbWUgKSApO1xuZXhwb3J0IGNvbnN0IHZhcnlpbmdQcm9wZXJ0eSA9ICggdHlwZSwgbmFtZSApID0+IG5vZGVPYmplY3QoIG5ldyBQcm9wZXJ0eU5vZGUoIHR5cGUsIG5hbWUsIHRydWUgKSApO1xuXG5leHBvcnQgY29uc3QgZGlmZnVzZUNvbG9yID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICd2ZWM0JywgJ0RpZmZ1c2VDb2xvcicgKTtcbmV4cG9ydCBjb25zdCBlbWlzc2l2ZSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAndmVjMycsICdFbWlzc2l2ZUNvbG9yJyApO1xuZXhwb3J0IGNvbnN0IHJvdWdobmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAnUm91Z2huZXNzJyApO1xuZXhwb3J0IGNvbnN0IG1ldGFsbmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAnTWV0YWxuZXNzJyApO1xuZXhwb3J0IGNvbnN0IGNsZWFyY29hdCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAnQ2xlYXJjb2F0JyApO1xuZXhwb3J0IGNvbnN0IGNsZWFyY29hdFJvdWdobmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAnQ2xlYXJjb2F0Um91Z2huZXNzJyApO1xuZXhwb3J0IGNvbnN0IHNoZWVuID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICd2ZWMzJywgJ1NoZWVuJyApO1xuZXhwb3J0IGNvbnN0IHNoZWVuUm91Z2huZXNzID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdTaGVlblJvdWdobmVzcycgKTtcbmV4cG9ydCBjb25zdCBpcmlkZXNjZW5jZSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAnSXJpZGVzY2VuY2UnICk7XG5leHBvcnQgY29uc3QgaXJpZGVzY2VuY2VJT1IgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ0lyaWRlc2NlbmNlSU9SJyApO1xuZXhwb3J0IGNvbnN0IGlyaWRlc2NlbmNlVGhpY2tuZXNzID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdJcmlkZXNjZW5jZVRoaWNrbmVzcycgKTtcbmV4cG9ydCBjb25zdCBhbHBoYVQgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ0FscGhhVCcgKTtcbmV4cG9ydCBjb25zdCBhbmlzb3Ryb3B5ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdBbmlzb3Ryb3B5JyApO1xuZXhwb3J0IGNvbnN0IGFuaXNvdHJvcHlUID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICd2ZWMzJywgJ0FuaXNvdHJvcHlUJyApO1xuZXhwb3J0IGNvbnN0IGFuaXNvdHJvcHlCID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICd2ZWMzJywgJ0FuaXNvdHJvcHlCJyApO1xuZXhwb3J0IGNvbnN0IHNwZWN1bGFyQ29sb3IgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2NvbG9yJywgJ1NwZWN1bGFyQ29sb3InICk7XG5leHBvcnQgY29uc3Qgc3BlY3VsYXJGOTAgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ1NwZWN1bGFyRjkwJyApO1xuZXhwb3J0IGNvbnN0IHNoaW5pbmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAnU2hpbmluZXNzJyApO1xuZXhwb3J0IGNvbnN0IG91dHB1dCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAndmVjNCcsICdPdXRwdXQnICk7XG5leHBvcnQgY29uc3QgZGFzaFNpemUgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ2Rhc2hTaXplJyApO1xuZXhwb3J0IGNvbnN0IGdhcFNpemUgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ2dhcFNpemUnICk7XG5leHBvcnQgY29uc3QgcG9pbnRXaWR0aCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAncG9pbnRXaWR0aCcgKTtcbmV4cG9ydCBjb25zdCBpb3IgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ0lPUicgKTtcbmV4cG9ydCBjb25zdCB0cmFuc21pc3Npb24gPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ1RyYW5zbWlzc2lvbicgKTtcbmV4cG9ydCBjb25zdCB0aGlja25lc3MgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ1RoaWNrbmVzcycgKTtcbmV4cG9ydCBjb25zdCBhdHRlbnVhdGlvbkRpc3RhbmNlID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdBdHRlbnVhdGlvbkRpc3RhbmNlJyApO1xuZXhwb3J0IGNvbnN0IGF0dGVudWF0aW9uQ29sb3IgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2NvbG9yJywgJ0F0dGVudWF0aW9uQ29sb3InICk7XG5leHBvcnQgY29uc3QgZGlzcGVyc2lvbiA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAnRGlzcGVyc2lvbicgKTtcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcbmltcG9ydCB7IGFkZE1ldGhvZENoYWluaW5nLCBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQ29yZS5qcyc7XG5pbXBvcnQgeyB2ZWN0b3JDb21wb25lbnRzIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xuXG5jbGFzcyBBc3NpZ25Ob2RlIGV4dGVuZHMgVGVtcE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnQXNzaWduTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCB0YXJnZXROb2RlLCBzb3VyY2VOb2RlICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudGFyZ2V0Tm9kZSA9IHRhcmdldE5vZGU7XG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gc291cmNlTm9kZTtcblxuXHR9XG5cblx0aGFzRGVwZW5kZW5jaWVzKCkge1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSggYnVpbGRlciwgb3V0cHV0ICkge1xuXG5cdFx0cmV0dXJuIG91dHB1dCAhPT0gJ3ZvaWQnID8gdGhpcy50YXJnZXROb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgOiAndm9pZCc7XG5cblx0fVxuXG5cdG5lZWRzU3BsaXRBc3NpZ24oIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCB7IHRhcmdldE5vZGUgfSA9IHRoaXM7XG5cblx0XHRpZiAoIGJ1aWxkZXIuaXNBdmFpbGFibGUoICdzd2l6emxlQXNzaWduJyApID09PSBmYWxzZSAmJiB0YXJnZXROb2RlLmlzU3BsaXROb2RlICYmIHRhcmdldE5vZGUuY29tcG9uZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRjb25zdCB0YXJnZXRMZW5ndGggPSBidWlsZGVyLmdldFR5cGVMZW5ndGgoIHRhcmdldE5vZGUubm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApICk7XG5cdFx0XHRjb25zdCBhc3NpZ25EaWZlcmVudFZlY3RvciA9IHZlY3RvckNvbXBvbmVudHMuam9pbiggJycgKS5zbGljZSggMCwgdGFyZ2V0TGVuZ3RoICkgIT09IHRhcmdldE5vZGUuY29tcG9uZW50cztcblxuXHRcdFx0cmV0dXJuIGFzc2lnbkRpZmVyZW50VmVjdG9yO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xuXG5cdFx0Y29uc3QgeyB0YXJnZXROb2RlLCBzb3VyY2VOb2RlIH0gPSB0aGlzO1xuXG5cdFx0Y29uc3QgbmVlZHNTcGxpdEFzc2lnbiA9IHRoaXMubmVlZHNTcGxpdEFzc2lnbiggYnVpbGRlciApO1xuXG5cdFx0Y29uc3QgdGFyZ2V0VHlwZSA9IHRhcmdldE5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHRcdGNvbnN0IHRhcmdldCA9IHRhcmdldE5vZGUuY29udGV4dCggeyBhc3NpZ246IHRydWUgfSApLmJ1aWxkKCBidWlsZGVyICk7XG5cdFx0Y29uc3Qgc291cmNlID0gc291cmNlTm9kZS5idWlsZCggYnVpbGRlciwgdGFyZ2V0VHlwZSApO1xuXG5cdFx0Y29uc3Qgc291cmNlVHlwZSA9IHNvdXJjZU5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHRcdGNvbnN0IG5vZGVEYXRhID0gYnVpbGRlci5nZXREYXRhRnJvbU5vZGUoIHRoaXMgKTtcblxuXHRcdC8vXG5cblx0XHRsZXQgc25pcHBldDtcblxuXHRcdGlmICggbm9kZURhdGEuaW5pdGlhbGl6ZWQgPT09IHRydWUgKSB7XG5cblx0XHRcdGlmICggb3V0cHV0ICE9PSAndm9pZCcgKSB7XG5cblx0XHRcdFx0c25pcHBldCA9IHRhcmdldDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggbmVlZHNTcGxpdEFzc2lnbiApIHtcblxuXHRcdFx0Y29uc3Qgc291cmNlVmFyID0gYnVpbGRlci5nZXRWYXJGcm9tTm9kZSggdGhpcywgbnVsbCwgdGFyZ2V0VHlwZSApO1xuXHRcdFx0Y29uc3Qgc291cmNlUHJvcGVydHkgPSBidWlsZGVyLmdldFByb3BlcnR5TmFtZSggc291cmNlVmFyICk7XG5cblx0XHRcdGJ1aWxkZXIuYWRkTGluZUZsb3dDb2RlKCBgJHsgc291cmNlUHJvcGVydHkgfSA9ICR7IHNvdXJjZSB9YCwgdGhpcyApO1xuXG5cdFx0XHRjb25zdCB0YXJnZXRSb290ID0gdGFyZ2V0Tm9kZS5ub2RlLmNvbnRleHQoIHsgYXNzaWduOiB0cnVlIH0gKS5idWlsZCggYnVpbGRlciApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0YXJnZXROb2RlLmNvbXBvbmVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNvbXBvbmVudCA9IHRhcmdldE5vZGUuY29tcG9uZW50c1sgaSBdO1xuXG5cdFx0XHRcdGJ1aWxkZXIuYWRkTGluZUZsb3dDb2RlKCBgJHsgdGFyZ2V0Um9vdCB9LiR7IGNvbXBvbmVudCB9ID0gJHsgc291cmNlUHJvcGVydHkgfVsgJHsgaSB9IF1gLCB0aGlzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvdXRwdXQgIT09ICd2b2lkJyApIHtcblxuXHRcdFx0XHRzbmlwcGV0ID0gdGFyZ2V0O1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzbmlwcGV0ID0gYCR7IHRhcmdldCB9ID0gJHsgc291cmNlIH1gO1xuXG5cdFx0XHRpZiAoIG91dHB1dCA9PT0gJ3ZvaWQnIHx8IHNvdXJjZVR5cGUgPT09ICd2b2lkJyApIHtcblxuXHRcdFx0XHRidWlsZGVyLmFkZExpbmVGbG93Q29kZSggc25pcHBldCwgdGhpcyApO1xuXG5cdFx0XHRcdGlmICggb3V0cHV0ICE9PSAndm9pZCcgKSB7XG5cblx0XHRcdFx0XHRzbmlwcGV0ID0gdGFyZ2V0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0bm9kZURhdGEuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBzbmlwcGV0LCB0YXJnZXRUeXBlLCBvdXRwdXQgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXNzaWduTm9kZTtcblxuZXhwb3J0IGNvbnN0IGFzc2lnbiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBBc3NpZ25Ob2RlICk7XG5cbmFkZE1ldGhvZENoYWluaW5nKCAnYXNzaWduJywgYXNzaWduICk7XG4iLCJpbXBvcnQgVGVtcE5vZGUgZnJvbSAnLi4vY29yZS9UZW1wTm9kZS5qcyc7XG5pbXBvcnQgeyBhZGRNZXRob2RDaGFpbmluZywgbm9kZUFycmF5LCBub2RlT2JqZWN0LCBub2RlT2JqZWN0cyB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcblxuY2xhc3MgRnVuY3Rpb25DYWxsTm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0Z1bmN0aW9uQ2FsbE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggZnVuY3Rpb25Ob2RlID0gbnVsbCwgcGFyYW1ldGVycyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuZnVuY3Rpb25Ob2RlID0gZnVuY3Rpb25Ob2RlO1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG5cblx0fVxuXG5cdHNldFBhcmFtZXRlcnMoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFBhcmFtZXRlcnMoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLmZ1bmN0aW9uTm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHBhcmFtcyA9IFtdO1xuXG5cdFx0Y29uc3QgZnVuY3Rpb25Ob2RlID0gdGhpcy5mdW5jdGlvbk5vZGU7XG5cblx0XHRjb25zdCBpbnB1dHMgPSBmdW5jdGlvbk5vZGUuZ2V0SW5wdXRzKCBidWlsZGVyICk7XG5cdFx0Y29uc3QgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdGNvbnN0IGdlbmVyYXRlSW5wdXQgPSAoIG5vZGUsIGlucHV0Tm9kZSApID0+IHtcblxuXHRcdFx0Y29uc3QgdHlwZSA9IGlucHV0Tm9kZS50eXBlO1xuXHRcdFx0Y29uc3QgcG9pbnRlciA9IHR5cGUgPT09ICdwb2ludGVyJztcblxuXHRcdFx0bGV0IG91dHB1dDtcblxuXHRcdFx0aWYgKCBwb2ludGVyICkgb3V0cHV0ID0gJyYnICsgbm9kZS5idWlsZCggYnVpbGRlciApO1xuXHRcdFx0ZWxzZSBvdXRwdXQgPSBub2RlLmJ1aWxkKCBidWlsZGVyLCB0eXBlICk7XG5cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cblx0XHR9O1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBwYXJhbWV0ZXJzICkgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHBhcmFtcy5wdXNoKCBnZW5lcmF0ZUlucHV0KCBwYXJhbWV0ZXJzWyBpIF0sIGlucHV0c1sgaSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Zm9yICggY29uc3QgaW5wdXROb2RlIG9mIGlucHV0cyApIHtcblxuXHRcdFx0XHRjb25zdCBub2RlID0gcGFyYW1ldGVyc1sgaW5wdXROb2RlLm5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIG5vZGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHBhcmFtcy5wdXNoKCBnZW5lcmF0ZUlucHV0KCBub2RlLCBpbnB1dE5vZGUgKSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBGdW5jdGlvbkNhbGxOb2RlOiBJbnB1dCAnJHtpbnB1dE5vZGUubmFtZX0nIG5vdCBmb3VuZCBpbiBGdW5jdGlvbk5vZGUuYCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25Ob2RlLmJ1aWxkKCBidWlsZGVyLCAncHJvcGVydHknICk7XG5cblx0XHRyZXR1cm4gYCR7ZnVuY3Rpb25OYW1lfSggJHtwYXJhbXMuam9pbiggJywgJyApfSApYDtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRnVuY3Rpb25DYWxsTm9kZTtcblxuZXhwb3J0IGNvbnN0IGNhbGwgPSAoIGZ1bmMsIC4uLnBhcmFtcyApID0+IHtcblxuXHRwYXJhbXMgPSBwYXJhbXMubGVuZ3RoID4gMSB8fCAoIHBhcmFtc1sgMCBdICYmIHBhcmFtc1sgMCBdLmlzTm9kZSA9PT0gdHJ1ZSApID8gbm9kZUFycmF5KCBwYXJhbXMgKSA6IG5vZGVPYmplY3RzKCBwYXJhbXNbIDAgXSApO1xuXG5cdHJldHVybiBub2RlT2JqZWN0KCBuZXcgRnVuY3Rpb25DYWxsTm9kZSggbm9kZU9iamVjdCggZnVuYyApLCBwYXJhbXMgKSApO1xuXG59O1xuXG5hZGRNZXRob2RDaGFpbmluZyggJ2NhbGwnLCBjYWxsICk7XG4iLCJpbXBvcnQgVGVtcE5vZGUgZnJvbSAnLi4vY29yZS9UZW1wTm9kZS5qcyc7XG5pbXBvcnQgeyBhZGRNZXRob2RDaGFpbmluZywgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuXG5jbGFzcyBPcGVyYXRvck5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdPcGVyYXRvck5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3Rvciggb3AsIGFOb2RlLCBiTm9kZSwgLi4ucGFyYW1zICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdGlmICggcGFyYW1zLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGxldCBmaW5hbE9wID0gbmV3IE9wZXJhdG9yTm9kZSggb3AsIGFOb2RlLCBiTm9kZSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoIC0gMTsgaSArKyApIHtcblxuXHRcdFx0XHRmaW5hbE9wID0gbmV3IE9wZXJhdG9yTm9kZSggb3AsIGZpbmFsT3AsIHBhcmFtc1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YU5vZGUgPSBmaW5hbE9wO1xuXHRcdFx0Yk5vZGUgPSBwYXJhbXNbIHBhcmFtcy5sZW5ndGggLSAxIF07XG5cblx0XHR9XG5cblx0XHR0aGlzLm9wID0gb3A7XG5cdFx0dGhpcy5hTm9kZSA9IGFOb2RlO1xuXHRcdHRoaXMuYk5vZGUgPSBiTm9kZTtcblxuXHR9XG5cblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcblxuXHRcdGNvbnN0IG9wID0gdGhpcy5vcDtcblxuXHRcdGNvbnN0IGFOb2RlID0gdGhpcy5hTm9kZTtcblx0XHRjb25zdCBiTm9kZSA9IHRoaXMuYk5vZGU7XG5cblx0XHRjb25zdCB0eXBlQSA9IGFOb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cdFx0Y29uc3QgdHlwZUIgPSB0eXBlb2YgYk5vZGUgIT09ICd1bmRlZmluZWQnID8gYk5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSA6IG51bGw7XG5cblx0XHRpZiAoIHR5cGVBID09PSAndm9pZCcgfHwgdHlwZUIgPT09ICd2b2lkJyApIHtcblxuXHRcdFx0cmV0dXJuICd2b2lkJztcblxuXHRcdH0gZWxzZSBpZiAoIG9wID09PSAnJScgKSB7XG5cblx0XHRcdHJldHVybiB0eXBlQTtcblxuXHRcdH0gZWxzZSBpZiAoIG9wID09PSAnficgfHwgb3AgPT09ICcmJyB8fCBvcCA9PT0gJ3wnIHx8IG9wID09PSAnXicgfHwgb3AgPT09ICc+PicgfHwgb3AgPT09ICc8PCcgKSB7XG5cblx0XHRcdHJldHVybiBidWlsZGVyLmdldEludGVnZXJUeXBlKCB0eXBlQSApO1xuXG5cdFx0fSBlbHNlIGlmICggb3AgPT09ICchJyB8fCBvcCA9PT0gJz09JyB8fCBvcCA9PT0gJyYmJyB8fCBvcCA9PT0gJ3x8JyB8fCBvcCA9PT0gJ15eJyApIHtcblxuXHRcdFx0cmV0dXJuICdib29sJztcblxuXHRcdH0gZWxzZSBpZiAoIG9wID09PSAnPCcgfHwgb3AgPT09ICc+JyB8fCBvcCA9PT0gJzw9JyB8fCBvcCA9PT0gJz49JyApIHtcblxuXHRcdFx0Y29uc3QgdHlwZUxlbmd0aCA9IG91dHB1dCA/IGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggb3V0cHV0ICkgOiBNYXRoLm1heCggYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCB0eXBlQSApLCBidWlsZGVyLmdldFR5cGVMZW5ndGgoIHR5cGVCICkgKTtcblxuXHRcdFx0cmV0dXJuIHR5cGVMZW5ndGggPiAxID8gYGJ2ZWMkeyB0eXBlTGVuZ3RoIH1gIDogJ2Jvb2wnO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCB0eXBlQSA9PT0gJ2Zsb2F0JyAmJiBidWlsZGVyLmlzTWF0cml4KCB0eXBlQiApICkge1xuXG5cdFx0XHRcdHJldHVybiB0eXBlQjtcblxuXHRcdFx0fSBlbHNlIGlmICggYnVpbGRlci5pc01hdHJpeCggdHlwZUEgKSAmJiBidWlsZGVyLmlzVmVjdG9yKCB0eXBlQiApICkge1xuXG5cdFx0XHRcdC8vIG1hdHJpeCB4IHZlY3RvclxuXG5cdFx0XHRcdHJldHVybiBidWlsZGVyLmdldFZlY3RvckZyb21NYXRyaXgoIHR5cGVBICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGJ1aWxkZXIuaXNWZWN0b3IoIHR5cGVBICkgJiYgYnVpbGRlci5pc01hdHJpeCggdHlwZUIgKSApIHtcblxuXHRcdFx0XHQvLyB2ZWN0b3IgeCBtYXRyaXhcblxuXHRcdFx0XHRyZXR1cm4gYnVpbGRlci5nZXRWZWN0b3JGcm9tTWF0cml4KCB0eXBlQiApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBidWlsZGVyLmdldFR5cGVMZW5ndGgoIHR5cGVCICkgPiBidWlsZGVyLmdldFR5cGVMZW5ndGgoIHR5cGVBICkgKSB7XG5cblx0XHRcdFx0Ly8gYW55dHlwZSB4IGFueXR5cGU6IHVzZSB0aGUgZ3JlYXRlciBsZW5ndGggdmVjdG9yXG5cblx0XHRcdFx0cmV0dXJuIHR5cGVCO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0eXBlQTtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcblxuXHRcdGNvbnN0IG9wID0gdGhpcy5vcDtcblxuXHRcdGNvbnN0IGFOb2RlID0gdGhpcy5hTm9kZTtcblx0XHRjb25zdCBiTm9kZSA9IHRoaXMuYk5vZGU7XG5cblx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciwgb3V0cHV0ICk7XG5cblx0XHRsZXQgdHlwZUEgPSBudWxsO1xuXHRcdGxldCB0eXBlQiA9IG51bGw7XG5cblx0XHRpZiAoIHR5cGUgIT09ICd2b2lkJyApIHtcblxuXHRcdFx0dHlwZUEgPSBhTm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXHRcdFx0dHlwZUIgPSB0eXBlb2YgYk5vZGUgIT09ICd1bmRlZmluZWQnID8gYk5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSA6IG51bGw7XG5cblx0XHRcdGlmICggb3AgPT09ICc8JyB8fCBvcCA9PT0gJz4nIHx8IG9wID09PSAnPD0nIHx8IG9wID09PSAnPj0nIHx8IG9wID09PSAnPT0nICkge1xuXG5cdFx0XHRcdGlmICggYnVpbGRlci5pc1ZlY3RvciggdHlwZUEgKSApIHtcblxuXHRcdFx0XHRcdHR5cGVCID0gdHlwZUE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZUEgIT09IHR5cGVCICkge1xuXG5cdFx0XHRcdFx0dHlwZUEgPSB0eXBlQiA9ICdmbG9hdCc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvcCA9PT0gJz4+JyB8fCBvcCA9PT0gJzw8JyApIHtcblxuXHRcdFx0XHR0eXBlQSA9IHR5cGU7XG5cdFx0XHRcdHR5cGVCID0gYnVpbGRlci5jaGFuZ2VDb21wb25lbnRUeXBlKCB0eXBlQiwgJ3VpbnQnICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGJ1aWxkZXIuaXNNYXRyaXgoIHR5cGVBICkgJiYgYnVpbGRlci5pc1ZlY3RvciggdHlwZUIgKSApIHtcblxuXHRcdFx0XHQvLyBtYXRyaXggeCB2ZWN0b3JcblxuXHRcdFx0XHR0eXBlQiA9IGJ1aWxkZXIuZ2V0VmVjdG9yRnJvbU1hdHJpeCggdHlwZUEgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggYnVpbGRlci5pc1ZlY3RvciggdHlwZUEgKSAmJiBidWlsZGVyLmlzTWF0cml4KCB0eXBlQiApICkge1xuXG5cdFx0XHRcdC8vIHZlY3RvciB4IG1hdHJpeFxuXG5cdFx0XHRcdHR5cGVBID0gYnVpbGRlci5nZXRWZWN0b3JGcm9tTWF0cml4KCB0eXBlQiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGFueXR5cGUgeCBhbnl0eXBlXG5cblx0XHRcdFx0dHlwZUEgPSB0eXBlQiA9IHR5cGU7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHR5cGVBID0gdHlwZUIgPSB0eXBlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYSA9IGFOb2RlLmJ1aWxkKCBidWlsZGVyLCB0eXBlQSApO1xuXHRcdGNvbnN0IGIgPSB0eXBlb2YgYk5vZGUgIT09ICd1bmRlZmluZWQnID8gYk5vZGUuYnVpbGQoIGJ1aWxkZXIsIHR5cGVCICkgOiBudWxsO1xuXG5cdFx0Y29uc3Qgb3V0cHV0TGVuZ3RoID0gYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBvdXRwdXQgKTtcblx0XHRjb25zdCBmbk9wU25pcHBldCA9IGJ1aWxkZXIuZ2V0RnVuY3Rpb25PcGVyYXRvciggb3AgKTtcblxuXHRcdGlmICggb3V0cHV0ICE9PSAndm9pZCcgKSB7XG5cblx0XHRcdGlmICggb3AgPT09ICc8JyAmJiBvdXRwdXRMZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdGlmICggYnVpbGRlci51c2VDb21wYXJpc29uTWV0aG9kICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgJHsgYnVpbGRlci5nZXRNZXRob2QoICdsZXNzVGhhbicsIG91dHB1dCApIH0oICR7IGEgfSwgJHsgYiB9IClgLCB0eXBlLCBvdXRwdXQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgKCAkeyBhIH0gPCAkeyBiIH0gKWAsIHR5cGUsIG91dHB1dCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggb3AgPT09ICc8PScgJiYgb3V0cHV0TGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRpZiAoIGJ1aWxkZXIudXNlQ29tcGFyaXNvbk1ldGhvZCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggYCR7IGJ1aWxkZXIuZ2V0TWV0aG9kKCAnbGVzc1RoYW5FcXVhbCcsIG91dHB1dCApIH0oICR7IGEgfSwgJHsgYiB9IClgLCB0eXBlLCBvdXRwdXQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgKCAkeyBhIH0gPD0gJHsgYiB9IClgLCB0eXBlLCBvdXRwdXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9wID09PSAnPicgJiYgb3V0cHV0TGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRpZiAoIGJ1aWxkZXIudXNlQ29tcGFyaXNvbk1ldGhvZCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggYCR7IGJ1aWxkZXIuZ2V0TWV0aG9kKCAnZ3JlYXRlclRoYW4nLCBvdXRwdXQgKSB9KCAkeyBhIH0sICR7IGIgfSApYCwgdHlwZSwgb3V0cHV0ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggYCggJHsgYSB9ID4gJHsgYiB9IClgLCB0eXBlLCBvdXRwdXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9wID09PSAnPj0nICYmIG91dHB1dExlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0aWYgKCBidWlsZGVyLnVzZUNvbXBhcmlzb25NZXRob2QgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIGAkeyBidWlsZGVyLmdldE1ldGhvZCggJ2dyZWF0ZXJUaGFuRXF1YWwnLCBvdXRwdXQgKSB9KCAkeyBhIH0sICR7IGIgfSApYCwgdHlwZSwgb3V0cHV0ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggYCggJHsgYSB9ID49ICR7IGIgfSApYCwgdHlwZSwgb3V0cHV0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvcCA9PT0gJyEnIHx8IG9wID09PSAnficgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgKCR7b3B9JHthfSlgLCB0eXBlQSwgb3V0cHV0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZuT3BTbmlwcGV0ICkge1xuXG5cdFx0XHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggYCR7IGZuT3BTbmlwcGV0IH0oICR7IGEgfSwgJHsgYiB9IClgLCB0eXBlLCBvdXRwdXQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIGAoICR7IGEgfSAkeyBvcCB9ICR7IGIgfSApYCwgdHlwZSwgb3V0cHV0ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHR5cGVBICE9PSAndm9pZCcgKSB7XG5cblx0XHRcdGlmICggZm5PcFNuaXBwZXQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgJHsgZm5PcFNuaXBwZXQgfSggJHsgYSB9LCAkeyBiIH0gKWAsIHR5cGUsIG91dHB1dCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggYCR7IGEgfSAkeyBvcCB9ICR7IGIgfWAsIHR5cGUsIG91dHB1dCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcblxuXHRcdHN1cGVyLnNlcmlhbGl6ZSggZGF0YSApO1xuXG5cdFx0ZGF0YS5vcCA9IHRoaXMub3A7XG5cblx0fVxuXG5cdGRlc2VyaWFsaXplKCBkYXRhICkge1xuXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcblxuXHRcdHRoaXMub3AgPSBkYXRhLm9wO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBPcGVyYXRvck5vZGU7XG5cbmV4cG9ydCBjb25zdCBhZGQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnKycgKTtcbmV4cG9ydCBjb25zdCBzdWIgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnLScgKTtcbmV4cG9ydCBjb25zdCBtdWwgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnKicgKTtcbmV4cG9ydCBjb25zdCBkaXYgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnLycgKTtcbmV4cG9ydCBjb25zdCBtb2RJbnQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnJScgKTtcbmV4cG9ydCBjb25zdCBlcXVhbCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICc9PScgKTtcbmV4cG9ydCBjb25zdCBub3RFcXVhbCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICchPScgKTtcbmV4cG9ydCBjb25zdCBsZXNzVGhhbiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICc8JyApO1xuZXhwb3J0IGNvbnN0IGdyZWF0ZXJUaGFuID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE9wZXJhdG9yTm9kZSwgJz4nICk7XG5leHBvcnQgY29uc3QgbGVzc1RoYW5FcXVhbCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICc8PScgKTtcbmV4cG9ydCBjb25zdCBncmVhdGVyVGhhbkVxdWFsID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE9wZXJhdG9yTm9kZSwgJz49JyApO1xuZXhwb3J0IGNvbnN0IGFuZCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICcmJicgKTtcbmV4cG9ydCBjb25zdCBvciA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICd8fCcgKTtcbmV4cG9ydCBjb25zdCBub3QgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnIScgKTtcbmV4cG9ydCBjb25zdCB4b3IgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnXl4nICk7XG5leHBvcnQgY29uc3QgYml0QW5kID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE9wZXJhdG9yTm9kZSwgJyYnICk7XG5leHBvcnQgY29uc3QgYml0Tm90ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE9wZXJhdG9yTm9kZSwgJ34nICk7XG5leHBvcnQgY29uc3QgYml0T3IgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnfCcgKTtcbmV4cG9ydCBjb25zdCBiaXRYb3IgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnXicgKTtcbmV4cG9ydCBjb25zdCBzaGlmdExlZnQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnPDwnICk7XG5leHBvcnQgY29uc3Qgc2hpZnRSaWdodCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICc+PicgKTtcblxuYWRkTWV0aG9kQ2hhaW5pbmcoICdhZGQnLCBhZGQgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnc3ViJywgc3ViICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ211bCcsIG11bCApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdkaXYnLCBkaXYgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnbW9kSW50JywgbW9kSW50ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2VxdWFsJywgZXF1YWwgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnbm90RXF1YWwnLCBub3RFcXVhbCApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdsZXNzVGhhbicsIGxlc3NUaGFuICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2dyZWF0ZXJUaGFuJywgZ3JlYXRlclRoYW4gKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnbGVzc1RoYW5FcXVhbCcsIGxlc3NUaGFuRXF1YWwgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnZ3JlYXRlclRoYW5FcXVhbCcsIGdyZWF0ZXJUaGFuRXF1YWwgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnYW5kJywgYW5kICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ29yJywgb3IgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnbm90Jywgbm90ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3hvcicsIHhvciApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdiaXRBbmQnLCBiaXRBbmQgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnYml0Tm90JywgYml0Tm90ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2JpdE9yJywgYml0T3IgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnYml0WG9yJywgYml0WG9yICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3NoaWZ0TGVmdCcsIHNoaWZ0TGVmdCApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdzaGlmdFJpZ2h0Jywgc2hpZnRSaWdodCApO1xuXG5cbmV4cG9ydCBjb25zdCByZW1haW5kZXIgPSAoIC4uLnBhcmFtcyApID0+IHsgLy8gQGRlcHJlY2F0ZWQsIHIxNjhcblxuXHRjb25zb2xlLndhcm4oICdUU0wuT3BlcmF0b3JOb2RlOiAucmVtYWluZGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubW9kSW50KCkuJyApO1xuXHRyZXR1cm4gbW9kSW50KCAuLi5wYXJhbXMgKTtcblxufTtcblxuYWRkTWV0aG9kQ2hhaW5pbmcoICdyZW1haW5kZXInLCByZW1haW5kZXIgKTtcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcbmltcG9ydCB7IHN1YiwgbXVsLCBkaXYgfSBmcm9tICcuL09wZXJhdG9yTm9kZS5qcyc7XG5pbXBvcnQgeyBhZGRNZXRob2RDaGFpbmluZywgbm9kZU9iamVjdCwgbm9kZVByb3h5LCBmbG9hdCwgdmVjMiwgdmVjMywgdmVjNCwgRm4gfSBmcm9tICcuLi90c2wvVFNMQ29yZS5qcyc7XG5cbmNsYXNzIE1hdGhOb2RlIGV4dGVuZHMgVGVtcE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnTWF0aE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggbWV0aG9kLCBhTm9kZSwgYk5vZGUgPSBudWxsLCBjTm9kZSA9IG51bGwgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5tZXRob2QgPSBtZXRob2Q7XG5cblx0XHR0aGlzLmFOb2RlID0gYU5vZGU7XG5cdFx0dGhpcy5iTm9kZSA9IGJOb2RlO1xuXHRcdHRoaXMuY05vZGUgPSBjTm9kZTtcblxuXHR9XG5cblx0Z2V0SW5wdXRUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgYVR5cGUgPSB0aGlzLmFOb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cdFx0Y29uc3QgYlR5cGUgPSB0aGlzLmJOb2RlID8gdGhpcy5iTm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApIDogbnVsbDtcblx0XHRjb25zdCBjVHlwZSA9IHRoaXMuY05vZGUgPyB0aGlzLmNOb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgOiBudWxsO1xuXG5cdFx0Y29uc3QgYUxlbiA9IGJ1aWxkZXIuaXNNYXRyaXgoIGFUeXBlICkgPyAwIDogYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBhVHlwZSApO1xuXHRcdGNvbnN0IGJMZW4gPSBidWlsZGVyLmlzTWF0cml4KCBiVHlwZSApID8gMCA6IGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggYlR5cGUgKTtcblx0XHRjb25zdCBjTGVuID0gYnVpbGRlci5pc01hdHJpeCggY1R5cGUgKSA/IDAgOiBidWlsZGVyLmdldFR5cGVMZW5ndGgoIGNUeXBlICk7XG5cblx0XHRpZiAoIGFMZW4gPiBiTGVuICYmIGFMZW4gPiBjTGVuICkge1xuXG5cdFx0XHRyZXR1cm4gYVR5cGU7XG5cblx0XHR9IGVsc2UgaWYgKCBiTGVuID4gY0xlbiApIHtcblxuXHRcdFx0cmV0dXJuIGJUeXBlO1xuXG5cdFx0fSBlbHNlIGlmICggY0xlbiA+IGFMZW4gKSB7XG5cblx0XHRcdHJldHVybiBjVHlwZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhVHlwZTtcblxuXHR9XG5cblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZDtcblxuXHRcdGlmICggbWV0aG9kID09PSBNYXRoTm9kZS5MRU5HVEggfHwgbWV0aG9kID09PSBNYXRoTm9kZS5ESVNUQU5DRSB8fCBtZXRob2QgPT09IE1hdGhOb2RlLkRPVCApIHtcblxuXHRcdFx0cmV0dXJuICdmbG9hdCc7XG5cblx0XHR9IGVsc2UgaWYgKCBtZXRob2QgPT09IE1hdGhOb2RlLkNST1NTICkge1xuXG5cdFx0XHRyZXR1cm4gJ3ZlYzMnO1xuXG5cdFx0fSBlbHNlIGlmICggbWV0aG9kID09PSBNYXRoTm9kZS5BTEwgKSB7XG5cblx0XHRcdHJldHVybiAnYm9vbCc7XG5cblx0XHR9IGVsc2UgaWYgKCBtZXRob2QgPT09IE1hdGhOb2RlLkVRVUFMUyApIHtcblxuXHRcdFx0cmV0dXJuIGJ1aWxkZXIuY2hhbmdlQ29tcG9uZW50VHlwZSggdGhpcy5hTm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApLCAnYm9vbCcgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1ldGhvZCA9PT0gTWF0aE5vZGUuTU9EICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5hTm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0SW5wdXRUeXBlKCBidWlsZGVyICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XG5cblx0XHRjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZDtcblxuXHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cdFx0Y29uc3QgaW5wdXRUeXBlID0gdGhpcy5nZXRJbnB1dFR5cGUoIGJ1aWxkZXIgKTtcblxuXHRcdGNvbnN0IGEgPSB0aGlzLmFOb2RlO1xuXHRcdGNvbnN0IGIgPSB0aGlzLmJOb2RlO1xuXHRcdGNvbnN0IGMgPSB0aGlzLmNOb2RlO1xuXG5cdFx0Y29uc3QgaXNXZWJHTCA9IGJ1aWxkZXIucmVuZGVyZXIuaXNXZWJHTFJlbmRlcmVyID09PSB0cnVlO1xuXG5cdFx0aWYgKCBtZXRob2QgPT09IE1hdGhOb2RlLlRSQU5TRk9STV9ESVJFQ1RJT04gKSB7XG5cblx0XHRcdC8vIGRpciBjYW4gYmUgZWl0aGVyIGEgZGlyZWN0aW9uIHZlY3RvciBvciBhIG5vcm1hbCB2ZWN0b3Jcblx0XHRcdC8vIHVwcGVyLWxlZnQgM3gzIG9mIG1hdHJpeCBpcyBhc3N1bWVkIHRvIGJlIG9ydGhvZ29uYWxcblxuXHRcdFx0bGV0IHRBID0gYTtcblx0XHRcdGxldCB0QiA9IGI7XG5cblx0XHRcdGlmICggYnVpbGRlci5pc01hdHJpeCggdEEuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSApICkge1xuXG5cdFx0XHRcdHRCID0gdmVjNCggdmVjMyggdEIgKSwgMC4wICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dEEgPSB2ZWM0KCB2ZWMzKCB0QSApLCAwLjAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtdWxOb2RlID0gbXVsKCB0QSwgdEIgKS54eXo7XG5cblx0XHRcdHJldHVybiBub3JtYWxpemUoIG11bE5vZGUgKS5idWlsZCggYnVpbGRlciwgb3V0cHV0ICk7XG5cblx0XHR9IGVsc2UgaWYgKCBtZXRob2QgPT09IE1hdGhOb2RlLk5FR0FURSApIHtcblxuXHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCAnKCAtICcgKyBhLmJ1aWxkKCBidWlsZGVyLCBpbnB1dFR5cGUgKSArICcgKScsIHR5cGUsIG91dHB1dCApO1xuXG5cdFx0fSBlbHNlIGlmICggbWV0aG9kID09PSBNYXRoTm9kZS5PTkVfTUlOVVMgKSB7XG5cblx0XHRcdHJldHVybiBzdWIoIDEuMCwgYSApLmJ1aWxkKCBidWlsZGVyLCBvdXRwdXQgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1ldGhvZCA9PT0gTWF0aE5vZGUuUkVDSVBST0NBTCApIHtcblxuXHRcdFx0cmV0dXJuIGRpdiggMS4wLCBhICkuYnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApO1xuXG5cdFx0fSBlbHNlIGlmICggbWV0aG9kID09PSBNYXRoTm9kZS5ESUZGRVJFTkNFICkge1xuXG5cdFx0XHRyZXR1cm4gYWJzKCBzdWIoIGEsIGIgKSApLmJ1aWxkKCBidWlsZGVyLCBvdXRwdXQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHBhcmFtcyA9IFtdO1xuXG5cdFx0XHRpZiAoIG1ldGhvZCA9PT0gTWF0aE5vZGUuQ1JPU1MgfHwgbWV0aG9kID09PSBNYXRoTm9kZS5NT0QgKSB7XG5cblx0XHRcdFx0cGFyYW1zLnB1c2goXG5cdFx0XHRcdFx0YS5idWlsZCggYnVpbGRlciwgdHlwZSApLFxuXHRcdFx0XHRcdGIuYnVpbGQoIGJ1aWxkZXIsIHR5cGUgKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBpc1dlYkdMICYmIG1ldGhvZCA9PT0gTWF0aE5vZGUuU1RFUCApIHtcblxuXHRcdFx0XHRwYXJhbXMucHVzaChcblx0XHRcdFx0XHRhLmJ1aWxkKCBidWlsZGVyLCBidWlsZGVyLmdldFR5cGVMZW5ndGgoIGEuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSApID09PSAxID8gJ2Zsb2F0JyA6IGlucHV0VHlwZSApLFxuXHRcdFx0XHRcdGIuYnVpbGQoIGJ1aWxkZXIsIGlucHV0VHlwZSApXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoICggaXNXZWJHTCAmJiAoIG1ldGhvZCA9PT0gTWF0aE5vZGUuTUlOIHx8IG1ldGhvZCA9PT0gTWF0aE5vZGUuTUFYICkgKSB8fCBtZXRob2QgPT09IE1hdGhOb2RlLk1PRCApIHtcblxuXHRcdFx0XHRwYXJhbXMucHVzaChcblx0XHRcdFx0XHRhLmJ1aWxkKCBidWlsZGVyLCBpbnB1dFR5cGUgKSxcblx0XHRcdFx0XHRiLmJ1aWxkKCBidWlsZGVyLCBidWlsZGVyLmdldFR5cGVMZW5ndGgoIGIuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSApID09PSAxID8gJ2Zsb2F0JyA6IGlucHV0VHlwZSApXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1ldGhvZCA9PT0gTWF0aE5vZGUuUkVGUkFDVCApIHtcblxuXHRcdFx0XHRwYXJhbXMucHVzaChcblx0XHRcdFx0XHRhLmJ1aWxkKCBidWlsZGVyLCBpbnB1dFR5cGUgKSxcblx0XHRcdFx0XHRiLmJ1aWxkKCBidWlsZGVyLCBpbnB1dFR5cGUgKSxcblx0XHRcdFx0XHRjLmJ1aWxkKCBidWlsZGVyLCAnZmxvYXQnIClcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWV0aG9kID09PSBNYXRoTm9kZS5NSVggKSB7XG5cblx0XHRcdFx0cGFyYW1zLnB1c2goXG5cdFx0XHRcdFx0YS5idWlsZCggYnVpbGRlciwgaW5wdXRUeXBlICksXG5cdFx0XHRcdFx0Yi5idWlsZCggYnVpbGRlciwgaW5wdXRUeXBlICksXG5cdFx0XHRcdFx0Yy5idWlsZCggYnVpbGRlciwgYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBjLmdldE5vZGVUeXBlKCBidWlsZGVyICkgKSA9PT0gMSA/ICdmbG9hdCcgOiBpbnB1dFR5cGUgKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHBhcmFtcy5wdXNoKCBhLmJ1aWxkKCBidWlsZGVyLCBpbnB1dFR5cGUgKSApO1xuXHRcdFx0XHRpZiAoIGIgIT09IG51bGwgKSBwYXJhbXMucHVzaCggYi5idWlsZCggYnVpbGRlciwgaW5wdXRUeXBlICkgKTtcblx0XHRcdFx0aWYgKCBjICE9PSBudWxsICkgcGFyYW1zLnB1c2goIGMuYnVpbGQoIGJ1aWxkZXIsIGlucHV0VHlwZSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgJHsgYnVpbGRlci5nZXRNZXRob2QoIG1ldGhvZCwgdHlwZSApIH0oICR7cGFyYW1zLmpvaW4oICcsICcgKX0gKWAsIHR5cGUsIG91dHB1dCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXJpYWxpemUoIGRhdGEgKSB7XG5cblx0XHRzdXBlci5zZXJpYWxpemUoIGRhdGEgKTtcblxuXHRcdGRhdGEubWV0aG9kID0gdGhpcy5tZXRob2Q7XG5cblx0fVxuXG5cdGRlc2VyaWFsaXplKCBkYXRhICkge1xuXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcblxuXHRcdHRoaXMubWV0aG9kID0gZGF0YS5tZXRob2Q7XG5cblx0fVxuXG59XG5cbi8vIDEgaW5wdXRcblxuTWF0aE5vZGUuQUxMID0gJ2FsbCc7XG5NYXRoTm9kZS5BTlkgPSAnYW55Jztcbk1hdGhOb2RlLkVRVUFMUyA9ICdlcXVhbHMnO1xuXG5NYXRoTm9kZS5SQURJQU5TID0gJ3JhZGlhbnMnO1xuTWF0aE5vZGUuREVHUkVFUyA9ICdkZWdyZWVzJztcbk1hdGhOb2RlLkVYUCA9ICdleHAnO1xuTWF0aE5vZGUuRVhQMiA9ICdleHAyJztcbk1hdGhOb2RlLkxPRyA9ICdsb2cnO1xuTWF0aE5vZGUuTE9HMiA9ICdsb2cyJztcbk1hdGhOb2RlLlNRUlQgPSAnc3FydCc7XG5NYXRoTm9kZS5JTlZFUlNFX1NRUlQgPSAnaW52ZXJzZXNxcnQnO1xuTWF0aE5vZGUuRkxPT1IgPSAnZmxvb3InO1xuTWF0aE5vZGUuQ0VJTCA9ICdjZWlsJztcbk1hdGhOb2RlLk5PUk1BTElaRSA9ICdub3JtYWxpemUnO1xuTWF0aE5vZGUuRlJBQ1QgPSAnZnJhY3QnO1xuTWF0aE5vZGUuU0lOID0gJ3Npbic7XG5NYXRoTm9kZS5DT1MgPSAnY29zJztcbk1hdGhOb2RlLlRBTiA9ICd0YW4nO1xuTWF0aE5vZGUuQVNJTiA9ICdhc2luJztcbk1hdGhOb2RlLkFDT1MgPSAnYWNvcyc7XG5NYXRoTm9kZS5BVEFOID0gJ2F0YW4nO1xuTWF0aE5vZGUuQUJTID0gJ2Ficyc7XG5NYXRoTm9kZS5TSUdOID0gJ3NpZ24nO1xuTWF0aE5vZGUuTEVOR1RIID0gJ2xlbmd0aCc7XG5NYXRoTm9kZS5ORUdBVEUgPSAnbmVnYXRlJztcbk1hdGhOb2RlLk9ORV9NSU5VUyA9ICdvbmVNaW51cyc7XG5NYXRoTm9kZS5ERkRYID0gJ2RGZHgnO1xuTWF0aE5vZGUuREZEWSA9ICdkRmR5Jztcbk1hdGhOb2RlLlJPVU5EID0gJ3JvdW5kJztcbk1hdGhOb2RlLlJFQ0lQUk9DQUwgPSAncmVjaXByb2NhbCc7XG5NYXRoTm9kZS5UUlVOQyA9ICd0cnVuYyc7XG5NYXRoTm9kZS5GV0lEVEggPSAnZndpZHRoJztcbk1hdGhOb2RlLkJJVENBU1QgPSAnYml0Y2FzdCc7XG5NYXRoTm9kZS5UUkFOU1BPU0UgPSAndHJhbnNwb3NlJztcblxuLy8gMiBpbnB1dHNcblxuTWF0aE5vZGUuQVRBTjIgPSAnYXRhbjInO1xuTWF0aE5vZGUuTUlOID0gJ21pbic7XG5NYXRoTm9kZS5NQVggPSAnbWF4Jztcbk1hdGhOb2RlLk1PRCA9ICdtb2QnO1xuTWF0aE5vZGUuU1RFUCA9ICdzdGVwJztcbk1hdGhOb2RlLlJFRkxFQ1QgPSAncmVmbGVjdCc7XG5NYXRoTm9kZS5ESVNUQU5DRSA9ICdkaXN0YW5jZSc7XG5NYXRoTm9kZS5ESUZGRVJFTkNFID0gJ2RpZmZlcmVuY2UnO1xuTWF0aE5vZGUuRE9UID0gJ2RvdCc7XG5NYXRoTm9kZS5DUk9TUyA9ICdjcm9zcyc7XG5NYXRoTm9kZS5QT1cgPSAncG93Jztcbk1hdGhOb2RlLlRSQU5TRk9STV9ESVJFQ1RJT04gPSAndHJhbnNmb3JtRGlyZWN0aW9uJztcblxuLy8gMyBpbnB1dHNcblxuTWF0aE5vZGUuTUlYID0gJ21peCc7XG5NYXRoTm9kZS5DTEFNUCA9ICdjbGFtcCc7XG5NYXRoTm9kZS5SRUZSQUNUID0gJ3JlZnJhY3QnO1xuTWF0aE5vZGUuU01PT1RIU1RFUCA9ICdzbW9vdGhzdGVwJztcbk1hdGhOb2RlLkZBQ0VGT1JXQVJEID0gJ2ZhY2Vmb3J3YXJkJztcblxuZXhwb3J0IGRlZmF1bHQgTWF0aE5vZGU7XG5cbmV4cG9ydCBjb25zdCBFUFNJTE9OID0gLypAX19QVVJFX18qLyBmbG9hdCggMWUtNiApO1xuZXhwb3J0IGNvbnN0IElORklOSVRZID0gLypAX19QVVJFX18qLyBmbG9hdCggMWU2ICk7XG5leHBvcnQgY29uc3QgUEkgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCBNYXRoLlBJICk7XG5leHBvcnQgY29uc3QgUEkyID0gLypAX19QVVJFX18qLyBmbG9hdCggTWF0aC5QSSAqIDIgKTtcblxuZXhwb3J0IGNvbnN0IGFsbCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuQUxMICk7XG5leHBvcnQgY29uc3QgYW55ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5BTlkgKTtcbmV4cG9ydCBjb25zdCBlcXVhbHMgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkVRVUFMUyApO1xuXG5leHBvcnQgY29uc3QgcmFkaWFucyA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuUkFESUFOUyApO1xuZXhwb3J0IGNvbnN0IGRlZ3JlZXMgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkRFR1JFRVMgKTtcbmV4cG9ydCBjb25zdCBleHAgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkVYUCApO1xuZXhwb3J0IGNvbnN0IGV4cDIgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkVYUDIgKTtcbmV4cG9ydCBjb25zdCBsb2cgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkxPRyApO1xuZXhwb3J0IGNvbnN0IGxvZzIgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkxPRzIgKTtcbmV4cG9ydCBjb25zdCBzcXJ0ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5TUVJUICk7XG5leHBvcnQgY29uc3QgaW52ZXJzZVNxcnQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLklOVkVSU0VfU1FSVCApO1xuZXhwb3J0IGNvbnN0IGZsb29yID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5GTE9PUiApO1xuZXhwb3J0IGNvbnN0IGNlaWwgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkNFSUwgKTtcbmV4cG9ydCBjb25zdCBub3JtYWxpemUgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLk5PUk1BTElaRSApO1xuZXhwb3J0IGNvbnN0IGZyYWN0ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5GUkFDVCApO1xuZXhwb3J0IGNvbnN0IHNpbiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuU0lOICk7XG5leHBvcnQgY29uc3QgY29zID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5DT1MgKTtcbmV4cG9ydCBjb25zdCB0YW4gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlRBTiApO1xuZXhwb3J0IGNvbnN0IGFzaW4gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkFTSU4gKTtcbmV4cG9ydCBjb25zdCBhY29zID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5BQ09TICk7XG5leHBvcnQgY29uc3QgYXRhbiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuQVRBTiApO1xuZXhwb3J0IGNvbnN0IGFicyA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuQUJTICk7XG5leHBvcnQgY29uc3Qgc2lnbiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuU0lHTiApO1xuZXhwb3J0IGNvbnN0IGxlbmd0aCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuTEVOR1RIICk7XG5leHBvcnQgY29uc3QgbmVnYXRlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5ORUdBVEUgKTtcbmV4cG9ydCBjb25zdCBvbmVNaW51cyA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuT05FX01JTlVTICk7XG5leHBvcnQgY29uc3QgZEZkeCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuREZEWCApO1xuZXhwb3J0IGNvbnN0IGRGZHkgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkRGRFkgKTtcbmV4cG9ydCBjb25zdCByb3VuZCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuUk9VTkQgKTtcbmV4cG9ydCBjb25zdCByZWNpcHJvY2FsID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5SRUNJUFJPQ0FMICk7XG5leHBvcnQgY29uc3QgdHJ1bmMgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlRSVU5DICk7XG5leHBvcnQgY29uc3QgZndpZHRoID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5GV0lEVEggKTtcbmV4cG9ydCBjb25zdCBiaXRjYXN0ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5CSVRDQVNUICk7XG5leHBvcnQgY29uc3QgdHJhbnNwb3NlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5UUkFOU1BPU0UgKTtcblxuZXhwb3J0IGNvbnN0IGF0YW4yID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5BVEFOMiApO1xuZXhwb3J0IGNvbnN0IG1pbiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuTUlOICk7XG5leHBvcnQgY29uc3QgbWF4ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5NQVggKTtcbmV4cG9ydCBjb25zdCBtb2QgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLk1PRCApO1xuZXhwb3J0IGNvbnN0IHN0ZXAgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlNURVAgKTtcbmV4cG9ydCBjb25zdCByZWZsZWN0ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5SRUZMRUNUICk7XG5leHBvcnQgY29uc3QgZGlzdGFuY2UgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkRJU1RBTkNFICk7XG5leHBvcnQgY29uc3QgZGlmZmVyZW5jZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuRElGRkVSRU5DRSApO1xuZXhwb3J0IGNvbnN0IGRvdCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuRE9UICk7XG5leHBvcnQgY29uc3QgY3Jvc3MgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkNST1NTICk7XG5leHBvcnQgY29uc3QgcG93ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5QT1cgKTtcbmV4cG9ydCBjb25zdCBwb3cyID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5QT1csIDIgKTtcbmV4cG9ydCBjb25zdCBwb3czID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5QT1csIDMgKTtcbmV4cG9ydCBjb25zdCBwb3c0ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5QT1csIDQgKTtcbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1EaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlRSQU5TRk9STV9ESVJFQ1RJT04gKTtcblxuZXhwb3J0IGNvbnN0IGNicnQgPSAoIGEgKSA9PiBtdWwoIHNpZ24oIGEgKSwgcG93KCBhYnMoIGEgKSwgMS4wIC8gMy4wICkgKTtcbmV4cG9ydCBjb25zdCBsZW5ndGhTcSA9ICggYSApID0+IGRvdCggYSwgYSApO1xuZXhwb3J0IGNvbnN0IG1peCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuTUlYICk7XG5leHBvcnQgY29uc3QgY2xhbXAgPSAoIHZhbHVlLCBsb3cgPSAwLCBoaWdoID0gMSApID0+IG5vZGVPYmplY3QoIG5ldyBNYXRoTm9kZSggTWF0aE5vZGUuQ0xBTVAsIG5vZGVPYmplY3QoIHZhbHVlICksIG5vZGVPYmplY3QoIGxvdyApLCBub2RlT2JqZWN0KCBoaWdoICkgKSApO1xuZXhwb3J0IGNvbnN0IHNhdHVyYXRlID0gKCB2YWx1ZSApID0+IGNsYW1wKCB2YWx1ZSApO1xuZXhwb3J0IGNvbnN0IHJlZnJhY3QgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlJFRlJBQ1QgKTtcbmV4cG9ydCBjb25zdCBzbW9vdGhzdGVwID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5TTU9PVEhTVEVQICk7XG5leHBvcnQgY29uc3QgZmFjZUZvcndhcmQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkZBQ0VGT1JXQVJEICk7XG5cbmV4cG9ydCBjb25zdCByYW5kID0gLypAX19QVVJFX18qLyBGbiggKCBbIHV2IF0gKSA9PiB7XG5cblx0Y29uc3QgYSA9IDEyLjk4OTgsIGIgPSA3OC4yMzMsIGMgPSA0Mzc1OC41NDUzO1xuXHRjb25zdCBkdCA9IGRvdCggdXYueHksIHZlYzIoIGEsIGIgKSApLCBzbiA9IG1vZCggZHQsIFBJICk7XG5cblx0cmV0dXJuIGZyYWN0KCBzaW4oIHNuICkubXVsKCBjICkgKTtcblxufSApO1xuXG5leHBvcnQgY29uc3QgbWl4RWxlbWVudCA9ICggdCwgZTEsIGUyICkgPT4gbWl4KCBlMSwgZTIsIHQgKTtcbmV4cG9ydCBjb25zdCBzbW9vdGhzdGVwRWxlbWVudCA9ICggeCwgbG93LCBoaWdoICkgPT4gc21vb3Roc3RlcCggbG93LCBoaWdoLCB4ICk7XG5cbmFkZE1ldGhvZENoYWluaW5nKCAnYWxsJywgYWxsICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2FueScsIGFueSApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdlcXVhbHMnLCBlcXVhbHMgKTtcblxuYWRkTWV0aG9kQ2hhaW5pbmcoICdyYWRpYW5zJywgcmFkaWFucyApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdkZWdyZWVzJywgZGVncmVlcyApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdleHAnLCBleHAgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnZXhwMicsIGV4cDIgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnbG9nJywgbG9nICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2xvZzInLCBsb2cyICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3NxcnQnLCBzcXJ0ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2ludmVyc2VTcXJ0JywgaW52ZXJzZVNxcnQgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnZmxvb3InLCBmbG9vciApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdjZWlsJywgY2VpbCApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdub3JtYWxpemUnLCBub3JtYWxpemUgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnZnJhY3QnLCBmcmFjdCApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdzaW4nLCBzaW4gKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnY29zJywgY29zICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3RhbicsIHRhbiApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdhc2luJywgYXNpbiApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdhY29zJywgYWNvcyApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdhdGFuJywgYXRhbiApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdhYnMnLCBhYnMgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnc2lnbicsIHNpZ24gKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnbGVuZ3RoJywgbGVuZ3RoICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2xlbmd0aFNxJywgbGVuZ3RoU3EgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnbmVnYXRlJywgbmVnYXRlICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ29uZU1pbnVzJywgb25lTWludXMgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnZEZkeCcsIGRGZHggKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnZEZkeScsIGRGZHkgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAncm91bmQnLCByb3VuZCApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdyZWNpcHJvY2FsJywgcmVjaXByb2NhbCApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICd0cnVuYycsIHRydW5jICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2Z3aWR0aCcsIGZ3aWR0aCApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdhdGFuMicsIGF0YW4yICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ21pbicsIG1pbiApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdtYXgnLCBtYXggKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnbW9kJywgbW9kICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3N0ZXAnLCBzdGVwICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3JlZmxlY3QnLCByZWZsZWN0ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2Rpc3RhbmNlJywgZGlzdGFuY2UgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnZG90JywgZG90ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2Nyb3NzJywgY3Jvc3MgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAncG93JywgcG93ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3BvdzInLCBwb3cyICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3BvdzMnLCBwb3czICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3BvdzQnLCBwb3c0ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3RyYW5zZm9ybURpcmVjdGlvbicsIHRyYW5zZm9ybURpcmVjdGlvbiApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdtaXgnLCBtaXhFbGVtZW50ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2NsYW1wJywgY2xhbXAgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAncmVmcmFjdCcsIHJlZnJhY3QgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnc21vb3Roc3RlcCcsIHNtb290aHN0ZXBFbGVtZW50ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2ZhY2VGb3J3YXJkJywgZmFjZUZvcndhcmQgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnZGlmZmVyZW5jZScsIGRpZmZlcmVuY2UgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnc2F0dXJhdGUnLCBzYXR1cmF0ZSApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICdjYnJ0JywgY2JydCApO1xuYWRkTWV0aG9kQ2hhaW5pbmcoICd0cmFuc3Bvc2UnLCB0cmFuc3Bvc2UgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAncmFuZCcsIHJhbmQgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBwcm9wZXJ0eSB9IGZyb20gJy4uL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcbmltcG9ydCB7IGFkZE1ldGhvZENoYWluaW5nLCBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQ29yZS5qcyc7XG5cbmNsYXNzIENvbmRpdGlvbmFsTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnQ29uZGl0aW9uYWxOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGNvbmROb2RlLCBpZk5vZGUsIGVsc2VOb2RlID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmNvbmROb2RlID0gY29uZE5vZGU7XG5cblx0XHR0aGlzLmlmTm9kZSA9IGlmTm9kZTtcblx0XHR0aGlzLmVsc2VOb2RlID0gZWxzZU5vZGU7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgaWZUeXBlID0gdGhpcy5pZk5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHRcdGlmICggdGhpcy5lbHNlTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgZWxzZVR5cGUgPSB0aGlzLmVsc2VOb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0XHRcdGlmICggYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBlbHNlVHlwZSApID4gYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBpZlR5cGUgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gZWxzZVR5cGU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBpZlR5cGU7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgY29uZE5vZGUgPSB0aGlzLmNvbmROb2RlLmNhY2hlKCk7XG5cdFx0Y29uc3QgaWZOb2RlID0gdGhpcy5pZk5vZGUuY2FjaGUoKTtcblx0XHRjb25zdCBlbHNlTm9kZSA9IHRoaXMuZWxzZU5vZGUgPyB0aGlzLmVsc2VOb2RlLmNhY2hlKCkgOiBudWxsO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGN1cnJlbnROb2RlQmxvY2sgPSBidWlsZGVyLmNvbnRleHQubm9kZUJsb2NrO1xuXG5cdFx0YnVpbGRlci5nZXREYXRhRnJvbU5vZGUoIGlmTm9kZSApLnBhcmVudE5vZGVCbG9jayA9IGN1cnJlbnROb2RlQmxvY2s7XG5cdFx0aWYgKCBlbHNlTm9kZSAhPT0gbnVsbCApIGJ1aWxkZXIuZ2V0RGF0YUZyb21Ob2RlKCBlbHNlTm9kZSApLnBhcmVudE5vZGVCbG9jayA9IGN1cnJlbnROb2RlQmxvY2s7XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgcHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcblx0XHRwcm9wZXJ0aWVzLmNvbmROb2RlID0gY29uZE5vZGU7XG5cdFx0cHJvcGVydGllcy5pZk5vZGUgPSBpZk5vZGUuY29udGV4dCggeyBub2RlQmxvY2s6IGlmTm9kZSB9ICk7XG5cdFx0cHJvcGVydGllcy5lbHNlTm9kZSA9IGVsc2VOb2RlID8gZWxzZU5vZGUuY29udGV4dCggeyBub2RlQmxvY2s6IGVsc2VOb2RlIH0gKSA6IG51bGw7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XG5cblx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXG5cdFx0Y29uc3Qgbm9kZURhdGEgPSBidWlsZGVyLmdldERhdGFGcm9tTm9kZSggdGhpcyApO1xuXG5cdFx0aWYgKCBub2RlRGF0YS5ub2RlUHJvcGVydHkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIG5vZGVEYXRhLm5vZGVQcm9wZXJ0eTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHsgY29uZE5vZGUsIGlmTm9kZSwgZWxzZU5vZGUgfSA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcblxuXHRcdGNvbnN0IG5lZWRzT3V0cHV0ID0gb3V0cHV0ICE9PSAndm9pZCc7XG5cdFx0Y29uc3Qgbm9kZVByb3BlcnR5ID0gbmVlZHNPdXRwdXQgPyBwcm9wZXJ0eSggdHlwZSApLmJ1aWxkKCBidWlsZGVyICkgOiAnJztcblxuXHRcdG5vZGVEYXRhLm5vZGVQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblxuXHRcdGNvbnN0IG5vZGVTbmlwcGV0ID0gY29uZE5vZGUuYnVpbGQoIGJ1aWxkZXIsICdib29sJyApO1xuXG5cdFx0YnVpbGRlci5hZGRGbG93Q29kZSggYFxcbiR7IGJ1aWxkZXIudGFiIH1pZiAoICR7IG5vZGVTbmlwcGV0IH0gKSB7XFxuXFxuYCApLmFkZEZsb3dUYWIoKTtcblxuXHRcdGxldCBpZlNuaXBwZXQgPSBpZk5vZGUuYnVpbGQoIGJ1aWxkZXIsIHR5cGUgKTtcblxuXHRcdGlmICggaWZTbmlwcGV0ICkge1xuXG5cdFx0XHRpZiAoIG5lZWRzT3V0cHV0ICkge1xuXG5cdFx0XHRcdGlmU25pcHBldCA9IG5vZGVQcm9wZXJ0eSArICcgPSAnICsgaWZTbmlwcGV0ICsgJzsnO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmU25pcHBldCA9ICdyZXR1cm4gJyArIGlmU25pcHBldCArICc7JztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0YnVpbGRlci5yZW1vdmVGbG93VGFiKCkuYWRkRmxvd0NvZGUoIGJ1aWxkZXIudGFiICsgJ1xcdCcgKyBpZlNuaXBwZXQgKyAnXFxuXFxuJyArIGJ1aWxkZXIudGFiICsgJ30nICk7XG5cblx0XHRpZiAoIGVsc2VOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRidWlsZGVyLmFkZEZsb3dDb2RlKCAnIGVsc2Uge1xcblxcbicgKS5hZGRGbG93VGFiKCk7XG5cblx0XHRcdGxldCBlbHNlU25pcHBldCA9IGVsc2VOb2RlLmJ1aWxkKCBidWlsZGVyLCB0eXBlICk7XG5cblx0XHRcdGlmICggZWxzZVNuaXBwZXQgKSB7XG5cblx0XHRcdFx0aWYgKCBuZWVkc091dHB1dCApIHtcblxuXHRcdFx0XHRcdGVsc2VTbmlwcGV0ID0gbm9kZVByb3BlcnR5ICsgJyA9ICcgKyBlbHNlU25pcHBldCArICc7JztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZWxzZVNuaXBwZXQgPSAncmV0dXJuICcgKyBlbHNlU25pcHBldCArICc7JztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0YnVpbGRlci5yZW1vdmVGbG93VGFiKCkuYWRkRmxvd0NvZGUoIGJ1aWxkZXIudGFiICsgJ1xcdCcgKyBlbHNlU25pcHBldCArICdcXG5cXG4nICsgYnVpbGRlci50YWIgKyAnfVxcblxcbicgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGJ1aWxkZXIuYWRkRmxvd0NvZGUoICdcXG5cXG4nICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIG5vZGVQcm9wZXJ0eSwgdHlwZSwgb3V0cHV0ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmRpdGlvbmFsTm9kZTtcblxuZXhwb3J0IGNvbnN0IHNlbGVjdCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBDb25kaXRpb25hbE5vZGUgKTtcblxuYWRkTWV0aG9kQ2hhaW5pbmcoICdzZWxlY3QnLCBzZWxlY3QgKTtcblxuLy9cblxuZXhwb3J0IGNvbnN0IGNvbmQgPSAoIC4uLnBhcmFtcyApID0+IHsgLy8gQGRlcHJlY2F0ZWQsIHIxNjhcblxuXHRjb25zb2xlLndhcm4oICdUU0wuQ29uZGl0aW9uYWxOb2RlOiBjb25kKCkgaGFzIGJlZW4gcmVuYW1lZCB0byBzZWxlY3QoKS4nICk7XG5cdHJldHVybiBzZWxlY3QoIC4uLnBhcmFtcyApO1xuXG59O1xuXG5hZGRNZXRob2RDaGFpbmluZyggJ2NvbmQnLCBjb25kICk7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuL05vZGUuanMnO1xuaW1wb3J0IHsgYWRkTWV0aG9kQ2hhaW5pbmcsIG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcblxuY2xhc3MgQ29udGV4dE5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0NvbnRleHROb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIG5vZGUsIHZhbHVlID0ge30gKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0NvbnRleHROb2RlID0gdHJ1ZTtcblxuXHRcdHRoaXMubm9kZSA9IG5vZGU7XG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG5cdH1cblxuXHRnZXRTY29wZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLm5vZGUuZ2V0U2NvcGUoKTtcblxuXHR9XG5cblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0fVxuXG5cdGFuYWx5emUoIGJ1aWxkZXIgKSB7XG5cblx0XHR0aGlzLm5vZGUuYnVpbGQoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBwcmV2aW91c0NvbnRleHQgPSBidWlsZGVyLmdldENvbnRleHQoKTtcblxuXHRcdGJ1aWxkZXIuc2V0Q29udGV4dCggeyAuLi5idWlsZGVyLmNvbnRleHQsIC4uLnRoaXMudmFsdWUgfSApO1xuXG5cdFx0Y29uc3Qgbm9kZSA9IHRoaXMubm9kZS5idWlsZCggYnVpbGRlciApO1xuXG5cdFx0YnVpbGRlci5zZXRDb250ZXh0KCBwcmV2aW91c0NvbnRleHQgKTtcblxuXHRcdHJldHVybiBub2RlO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xuXG5cdFx0Y29uc3QgcHJldmlvdXNDb250ZXh0ID0gYnVpbGRlci5nZXRDb250ZXh0KCk7XG5cblx0XHRidWlsZGVyLnNldENvbnRleHQoIHsgLi4uYnVpbGRlci5jb250ZXh0LCAuLi50aGlzLnZhbHVlIH0gKTtcblxuXHRcdGNvbnN0IHNuaXBwZXQgPSB0aGlzLm5vZGUuYnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApO1xuXG5cdFx0YnVpbGRlci5zZXRDb250ZXh0KCBwcmV2aW91c0NvbnRleHQgKTtcblxuXHRcdHJldHVybiBzbmlwcGV0O1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250ZXh0Tm9kZTtcblxuZXhwb3J0IGNvbnN0IGNvbnRleHQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggQ29udGV4dE5vZGUgKTtcbmV4cG9ydCBjb25zdCBsYWJlbCA9ICggbm9kZSwgbmFtZSApID0+IGNvbnRleHQoIG5vZGUsIHsgbGFiZWw6IG5hbWUgfSApO1xuXG5hZGRNZXRob2RDaGFpbmluZyggJ2NvbnRleHQnLCBjb250ZXh0ICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ2xhYmVsJywgbGFiZWwgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyBhZGRNZXRob2RDaGFpbmluZywgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuXG5jbGFzcyBWYXJOb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdWYXJOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIG5vZGUsIG5hbWUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMubm9kZSA9IG5vZGU7XG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblxuXHRcdHRoaXMuZ2xvYmFsID0gdHJ1ZTtcblxuXHRcdHRoaXMuaXNWYXJOb2RlID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0SGFzaCggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLm5hbWUgfHwgc3VwZXIuZ2V0SGFzaCggYnVpbGRlciApO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLm5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCB7IG5vZGUsIG5hbWUgfSA9IHRoaXM7XG5cblx0XHRjb25zdCBub2RlVmFyID0gYnVpbGRlci5nZXRWYXJGcm9tTm9kZSggdGhpcywgbmFtZSwgYnVpbGRlci5nZXRWZWN0b3JUeXBlKCB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICkgKSApO1xuXG5cdFx0Y29uc3QgcHJvcGVydHlOYW1lID0gYnVpbGRlci5nZXRQcm9wZXJ0eU5hbWUoIG5vZGVWYXIgKTtcblxuXHRcdGNvbnN0IHNuaXBwZXQgPSBub2RlLmJ1aWxkKCBidWlsZGVyLCBub2RlVmFyLnR5cGUgKTtcblxuXHRcdGJ1aWxkZXIuYWRkTGluZUZsb3dDb2RlKCBgJHtwcm9wZXJ0eU5hbWV9ID0gJHtzbmlwcGV0fWAsIHRoaXMgKTtcblxuXHRcdHJldHVybiBwcm9wZXJ0eU5hbWU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZhck5vZGU7XG5cbmNvbnN0IGNyZWF0ZVZhciA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBWYXJOb2RlICk7XG5cbmFkZE1ldGhvZENoYWluaW5nKCAndG9WYXInLCAoIC4uLnBhcmFtcyApID0+IGNyZWF0ZVZhciggLi4ucGFyYW1zICkuYXBwZW5kKCkgKTtcblxuLy8gRGVwcmVjYXRlZFxuXG5leHBvcnQgY29uc3QgdGVtcCA9ICggbm9kZSApID0+IHsgLy8gQGRlcHJlY2F0ZWQsIHIxNzBcblxuXHRjb25zb2xlLndhcm4oICdUU0w6IFwidGVtcFwiIGlzIGRlcHJlY2F0ZWQuIFVzZSBcIi50b1ZhcigpXCIgaW5zdGVhZC4nICk7XG5cblx0cmV0dXJuIGNyZWF0ZVZhciggbm9kZSApO1xuXG59O1xuXG5hZGRNZXRob2RDaGFpbmluZyggJ3RlbXAnLCB0ZW1wICk7XG5cbiIsImltcG9ydCBOb2RlIGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyBOb2RlU2hhZGVyU3RhZ2UgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBhZGRNZXRob2RDaGFpbmluZywgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuXG5jbGFzcyBWYXJ5aW5nTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnVmFyeWluZ05vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3Rvciggbm9kZSwgbmFtZSA9IG51bGwgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXG5cdFx0dGhpcy5pc1ZhcnlpbmdOb2RlID0gdHJ1ZTtcblxuXHR9XG5cblx0aXNHbG9iYWwoKSB7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0SGFzaCggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLm5hbWUgfHwgc3VwZXIuZ2V0SGFzaCggYnVpbGRlciApO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcblxuXHRcdC8vIFZhcnlpbmdOb2RlIGlzIGF1dG8gdHlwZVxuXG5cdFx0cmV0dXJuIHRoaXMubm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXG5cdH1cblxuXHRzZXR1cFZhcnlpbmcoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBwcm9wZXJ0aWVzID0gYnVpbGRlci5nZXROb2RlUHJvcGVydGllcyggdGhpcyApO1xuXG5cdFx0bGV0IHZhcnlpbmcgPSBwcm9wZXJ0aWVzLnZhcnlpbmc7XG5cblx0XHRpZiAoIHZhcnlpbmcgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgbmFtZSA9IHRoaXMubmFtZTtcblx0XHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0XHRcdHByb3BlcnRpZXMudmFyeWluZyA9IHZhcnlpbmcgPSBidWlsZGVyLmdldFZhcnlpbmdGcm9tTm9kZSggdGhpcywgbmFtZSwgdHlwZSApO1xuXHRcdFx0cHJvcGVydGllcy5ub2RlID0gdGhpcy5ub2RlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBjaGVjayBpZiB0aGUgdmFyeWluZyBjYW4gYmUgb3B0aW1pemVkIGZvciBhIHZhcmlhYmxlXG5cdFx0dmFyeWluZy5uZWVkc0ludGVycG9sYXRpb24gfHwgKCB2YXJ5aW5nLm5lZWRzSW50ZXJwb2xhdGlvbiA9ICggYnVpbGRlci5zaGFkZXJTdGFnZSA9PT0gJ2ZyYWdtZW50JyApICk7XG5cblx0XHRyZXR1cm4gdmFyeWluZztcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHR0aGlzLnNldHVwVmFyeWluZyggYnVpbGRlciApO1xuXG5cdH1cblxuXHRhbmFseXplKCBidWlsZGVyICkge1xuXG5cdFx0dGhpcy5zZXR1cFZhcnlpbmcoIGJ1aWxkZXIgKTtcblxuXHRcdHJldHVybiB0aGlzLm5vZGUuYW5hbHl6ZSggYnVpbGRlciApO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHByb3BlcnRpZXMgPSBidWlsZGVyLmdldE5vZGVQcm9wZXJ0aWVzKCB0aGlzICk7XG5cdFx0Y29uc3QgdmFyeWluZyA9IHRoaXMuc2V0dXBWYXJ5aW5nKCBidWlsZGVyICk7XG5cblx0XHRpZiAoIHByb3BlcnRpZXMucHJvcGVydHlOYW1lID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cdFx0XHRjb25zdCBwcm9wZXJ0eU5hbWUgPSBidWlsZGVyLmdldFByb3BlcnR5TmFtZSggdmFyeWluZywgTm9kZVNoYWRlclN0YWdlLlZFUlRFWCApO1xuXG5cdFx0XHQvLyBmb3JjZSBub2RlIHJ1biBpbiB2ZXJ0ZXggc3RhZ2Vcblx0XHRcdGJ1aWxkZXIuZmxvd05vZGVGcm9tU2hhZGVyU3RhZ2UoIE5vZGVTaGFkZXJTdGFnZS5WRVJURVgsIHRoaXMubm9kZSwgdHlwZSwgcHJvcGVydHlOYW1lICk7XG5cblx0XHRcdHByb3BlcnRpZXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJ1aWxkZXIuZ2V0UHJvcGVydHlOYW1lKCB2YXJ5aW5nICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZhcnlpbmdOb2RlO1xuXG5leHBvcnQgY29uc3QgdmFyeWluZyA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBWYXJ5aW5nTm9kZSApO1xuXG5hZGRNZXRob2RDaGFpbmluZyggJ3ZhcnlpbmcnLCB2YXJ5aW5nICk7XG4iLCJpbXBvcnQgeyBtaXggfSBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJztcbmltcG9ydCB7IEZuIH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuXG5leHBvcnQgY29uc3Qgc1JHQlRyYW5zZmVyRU9URiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBjb2xvciBdICkgPT4ge1xuXG5cdGNvbnN0IGEgPSBjb2xvci5tdWwoIDAuOTQ3ODY3Mjk4NiApLmFkZCggMC4wNTIxMzI3MDE0ICkucG93KCAyLjQgKTtcblx0Y29uc3QgYiA9IGNvbG9yLm11bCggMC4wNzczOTkzODA4ICk7XG5cdGNvbnN0IGZhY3RvciA9IGNvbG9yLmxlc3NUaGFuRXF1YWwoIDAuMDQwNDUgKTtcblxuXHRjb25zdCByZ2JSZXN1bHQgPSBtaXgoIGEsIGIsIGZhY3RvciApO1xuXG5cdHJldHVybiByZ2JSZXN1bHQ7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ3NSR0JUcmFuc2ZlckVPVEYnLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzMnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3Qgc1JHQlRyYW5zZmVyT0VURiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBjb2xvciBdICkgPT4ge1xuXG5cdGNvbnN0IGEgPSBjb2xvci5wb3coIDAuNDE2NjYgKS5tdWwoIDEuMDU1ICkuc3ViKCAwLjA1NSApO1xuXHRjb25zdCBiID0gY29sb3IubXVsKCAxMi45MiApO1xuXHRjb25zdCBmYWN0b3IgPSBjb2xvci5sZXNzVGhhbkVxdWFsKCAwLjAwMzEzMDggKTtcblxuXHRjb25zdCByZ2JSZXN1bHQgPSBtaXgoIGEsIGIsIGZhY3RvciApO1xuXG5cdHJldHVybiByZ2JSZXN1bHQ7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ3NSR0JUcmFuc2Zlck9FVEYnLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzMnIH1cblx0XVxufSApO1xuIiwiaW1wb3J0IFRlbXBOb2RlIGZyb20gJy4uL2NvcmUvVGVtcE5vZGUuanMnO1xuaW1wb3J0IHsgYWRkTWV0aG9kQ2hhaW5pbmcsIG1hdDMsIG5vZGVPYmplY3QsIHZlYzQgfSBmcm9tICcuLi90c2wvVFNMQ29yZS5qcyc7XG5cbmltcG9ydCB7IFNSR0JUcmFuc2ZlciB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBDb2xvck1hbmFnZW1lbnQgfSBmcm9tICcuLi8uLi9tYXRoL0NvbG9yTWFuYWdlbWVudC5qcyc7XG5pbXBvcnQgeyBzUkdCVHJhbnNmZXJFT1RGLCBzUkdCVHJhbnNmZXJPRVRGIH0gZnJvbSAnLi9Db2xvclNwYWNlRnVuY3Rpb25zLmpzJztcbmltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi8uLi9tYXRoL01hdHJpeDMuanMnO1xuXG5jb25zdCBXT1JLSU5HX0NPTE9SX1NQQUNFID0gJ1dvcmtpbmdDb2xvclNwYWNlJztcbmNvbnN0IE9VVFBVVF9DT0xPUl9TUEFDRSA9ICdPdXRwdXRDb2xvclNwYWNlJztcblxuY2xhc3MgQ29sb3JTcGFjZU5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdDb2xvclNwYWNlTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBjb2xvck5vZGUsIHNvdXJjZSwgdGFyZ2V0ICkge1xuXG5cdFx0c3VwZXIoICd2ZWM0JyApO1xuXG5cdFx0dGhpcy5jb2xvck5vZGUgPSBjb2xvck5vZGU7XG5cdFx0dGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cblx0fVxuXG5cdHJlc29sdmVDb2xvclNwYWNlKCBidWlsZGVyLCBjb2xvclNwYWNlICkge1xuXG5cdFx0aWYgKCBjb2xvclNwYWNlID09PSBXT1JLSU5HX0NPTE9SX1NQQUNFICkge1xuXG5cdFx0XHRyZXR1cm4gQ29sb3JNYW5hZ2VtZW50LndvcmtpbmdDb2xvclNwYWNlO1xuXG5cdFx0fSBlbHNlIGlmICggY29sb3JTcGFjZSA9PT0gT1VUUFVUX0NPTE9SX1NQQUNFICkge1xuXG5cdFx0XHRyZXR1cm4gYnVpbGRlci5jb250ZXh0Lm91dHB1dENvbG9yU3BhY2UgfHwgYnVpbGRlci5yZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbG9yU3BhY2U7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgeyBjb2xvck5vZGUgfSA9IHRoaXM7XG5cblx0XHRjb25zdCBzb3VyY2UgPSB0aGlzLnJlc29sdmVDb2xvclNwYWNlKCBidWlsZGVyLCB0aGlzLnNvdXJjZSApO1xuXHRcdGNvbnN0IHRhcmdldCA9IHRoaXMucmVzb2x2ZUNvbG9yU3BhY2UoIGJ1aWxkZXIsIHRoaXMudGFyZ2V0ICk7XG5cblx0XHRsZXQgb3V0cHV0Tm9kZSA9IGNvbG9yTm9kZTtcblxuXHRcdGlmICggQ29sb3JNYW5hZ2VtZW50LmVuYWJsZWQgPT09IGZhbHNlIHx8IHNvdXJjZSA9PT0gdGFyZ2V0IHx8ICEgc291cmNlIHx8ICEgdGFyZ2V0ICkge1xuXG5cdFx0XHRyZXR1cm4gb3V0cHV0Tm9kZTtcblxuXHRcdH1cblxuXHRcdGlmICggQ29sb3JNYW5hZ2VtZW50LmdldFRyYW5zZmVyKCBzb3VyY2UgKSA9PT0gU1JHQlRyYW5zZmVyICkge1xuXG5cdFx0XHRvdXRwdXROb2RlID0gdmVjNCggc1JHQlRyYW5zZmVyRU9URiggb3V0cHV0Tm9kZS5yZ2IgKSwgb3V0cHV0Tm9kZS5hICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIENvbG9yTWFuYWdlbWVudC5nZXRQcmltYXJpZXMoIHNvdXJjZSApICE9PSBDb2xvck1hbmFnZW1lbnQuZ2V0UHJpbWFyaWVzKCB0YXJnZXQgKSApIHtcblxuXHRcdFx0b3V0cHV0Tm9kZSA9IHZlYzQoXG5cdFx0XHRcdG1hdDMoIENvbG9yTWFuYWdlbWVudC5fZ2V0TWF0cml4KCBuZXcgTWF0cml4MygpLCBzb3VyY2UsIHRhcmdldCApICkubXVsKCBvdXRwdXROb2RlLnJnYiApLFxuXHRcdFx0XHRvdXRwdXROb2RlLmFcblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIENvbG9yTWFuYWdlbWVudC5nZXRUcmFuc2ZlciggdGFyZ2V0ICkgPT09IFNSR0JUcmFuc2ZlciApIHtcblxuXHRcdFx0b3V0cHV0Tm9kZSA9IHZlYzQoIHNSR0JUcmFuc2Zlck9FVEYoIG91dHB1dE5vZGUucmdiICksIG91dHB1dE5vZGUuYSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dE5vZGU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbG9yU3BhY2VOb2RlO1xuXG5leHBvcnQgY29uc3QgdG9PdXRwdXRDb2xvclNwYWNlID0gKCBub2RlICkgPT4gbm9kZU9iamVjdCggbmV3IENvbG9yU3BhY2VOb2RlKCBub2RlT2JqZWN0KCBub2RlICksIFdPUktJTkdfQ09MT1JfU1BBQ0UsIE9VVFBVVF9DT0xPUl9TUEFDRSApICk7XG5leHBvcnQgY29uc3QgdG9Xb3JraW5nQ29sb3JTcGFjZSA9ICggbm9kZSApID0+IG5vZGVPYmplY3QoIG5ldyBDb2xvclNwYWNlTm9kZSggbm9kZU9iamVjdCggbm9kZSApLCBPVVRQVVRfQ09MT1JfU1BBQ0UsIFdPUktJTkdfQ09MT1JfU1BBQ0UgKSApO1xuXG5leHBvcnQgY29uc3Qgd29ya2luZ1RvQ29sb3JTcGFjZSA9ICggbm9kZSwgY29sb3JTcGFjZSApID0+IG5vZGVPYmplY3QoIG5ldyBDb2xvclNwYWNlTm9kZSggbm9kZU9iamVjdCggbm9kZSApLCBXT1JLSU5HX0NPTE9SX1NQQUNFLCBjb2xvclNwYWNlICkgKTtcbmV4cG9ydCBjb25zdCBjb2xvclNwYWNlVG9Xb3JraW5nID0gKCBub2RlLCBjb2xvclNwYWNlICkgPT4gbm9kZU9iamVjdCggbmV3IENvbG9yU3BhY2VOb2RlKCBub2RlT2JqZWN0KCBub2RlICksIGNvbG9yU3BhY2UsIFdPUktJTkdfQ09MT1JfU1BBQ0UgKSApO1xuXG5leHBvcnQgY29uc3QgY29udmVydENvbG9yU3BhY2UgPSAoIG5vZGUsIHNvdXJjZUNvbG9yU3BhY2UsIHRhcmdldENvbG9yU3BhY2UgKSA9PiBub2RlT2JqZWN0KCBuZXcgQ29sb3JTcGFjZU5vZGUoIG5vZGVPYmplY3QoIG5vZGUgKSwgc291cmNlQ29sb3JTcGFjZSwgdGFyZ2V0Q29sb3JTcGFjZSApICk7XG5cbmFkZE1ldGhvZENoYWluaW5nKCAndG9PdXRwdXRDb2xvclNwYWNlJywgdG9PdXRwdXRDb2xvclNwYWNlICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3RvV29ya2luZ0NvbG9yU3BhY2UnLCB0b1dvcmtpbmdDb2xvclNwYWNlICk7XG5cbmFkZE1ldGhvZENoYWluaW5nKCAnd29ya2luZ1RvQ29sb3JTcGFjZScsIHdvcmtpbmdUb0NvbG9yU3BhY2UgKTtcbmFkZE1ldGhvZENoYWluaW5nKCAnY29sb3JTcGFjZVRvV29ya2luZycsIGNvbG9yU3BhY2VUb1dvcmtpbmcgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcbmltcG9ydCB7IG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQ29yZS5qcyc7XG5pbXBvcnQgQXJyYXlFbGVtZW50Tm9kZSBmcm9tICcuLi91dGlscy9BcnJheUVsZW1lbnROb2RlLmpzJztcblxuY2xhc3MgUmVmZXJlbmNlRWxlbWVudE5vZGUgZXh0ZW5kcyBBcnJheUVsZW1lbnROb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1JlZmVyZW5jZUVsZW1lbnROb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHJlZmVyZW5jZU5vZGUsIGluZGV4Tm9kZSApIHtcblxuXHRcdHN1cGVyKCByZWZlcmVuY2VOb2RlLCBpbmRleE5vZGUgKTtcblxuXHRcdHRoaXMucmVmZXJlbmNlTm9kZSA9IHJlZmVyZW5jZU5vZGU7XG5cblx0XHR0aGlzLmlzUmVmZXJlbmNlRWxlbWVudE5vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnJlZmVyZW5jZU5vZGUudW5pZm9ybVR5cGU7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3Qgc25pcHBldCA9IHN1cGVyLmdlbmVyYXRlKCBidWlsZGVyICk7XG5cdFx0Y29uc3QgYXJyYXlUeXBlID0gdGhpcy5yZWZlcmVuY2VOb2RlLmdldE5vZGVUeXBlKCk7XG5cdFx0Y29uc3QgZWxlbWVudFR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCk7XG5cblx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIHNuaXBwZXQsIGFycmF5VHlwZSwgZWxlbWVudFR5cGUgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgUmVmZXJlbmNlQmFzZU5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1JlZmVyZW5jZUJhc2VOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHByb3BlcnR5LCB1bmlmb3JtVHlwZSwgb2JqZWN0ID0gbnVsbCwgY291bnQgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcblx0XHR0aGlzLnVuaWZvcm1UeXBlID0gdW5pZm9ybVR5cGU7XG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0dGhpcy5jb3VudCA9IGNvdW50O1xuXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydHkuc3BsaXQoICcuJyApO1xuXHRcdHRoaXMucmVmZXJlbmNlID0gb2JqZWN0O1xuXHRcdHRoaXMubm9kZSA9IG51bGw7XG5cdFx0dGhpcy5ncm91cCA9IG51bGw7XG5cblx0XHR0aGlzLnVwZGF0ZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5PQkpFQ1Q7XG5cblx0fVxuXG5cdHNldEdyb3VwKCBncm91cCApIHtcblxuXHRcdHRoaXMuZ3JvdXAgPSBncm91cDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlbGVtZW50KCBpbmRleE5vZGUgKSB7XG5cblx0XHRyZXR1cm4gbm9kZU9iamVjdCggbmV3IFJlZmVyZW5jZUVsZW1lbnROb2RlKCB0aGlzLCBub2RlT2JqZWN0KCBpbmRleE5vZGUgKSApICk7XG5cblx0fVxuXG5cdHNldE5vZGVUeXBlKCB1bmlmb3JtVHlwZSApIHtcblxuXHRcdGNvbnN0IG5vZGUgPSB1bmlmb3JtKCBudWxsLCB1bmlmb3JtVHlwZSApLmdldFNlbGYoKTtcblxuXHRcdGlmICggdGhpcy5ncm91cCAhPT0gbnVsbCApIHtcblxuXHRcdFx0bm9kZS5zZXRHcm91cCggdGhpcy5ncm91cCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcblxuXHR9XG5cblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9kZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy51cGRhdGVSZWZlcmVuY2UoIGJ1aWxkZXIgKTtcblx0XHRcdHRoaXMudXBkYXRlVmFsdWUoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0Z2V0VmFsdWVGcm9tUmVmZXJlbmNlKCBvYmplY3QgPSB0aGlzLnJlZmVyZW5jZSApIHtcblxuXHRcdGNvbnN0IHsgcHJvcGVydGllcyB9ID0gdGhpcztcblxuXHRcdGxldCB2YWx1ZSA9IG9iamVjdFsgcHJvcGVydGllc1sgMCBdIF07XG5cblx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFsdWUgPSB2YWx1ZVsgcHJvcGVydGllc1sgaSBdIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cblx0fVxuXG5cdHVwZGF0ZVJlZmVyZW5jZSggc3RhdGUgKSB7XG5cblx0XHR0aGlzLnJlZmVyZW5jZSA9IHRoaXMub2JqZWN0ICE9PSBudWxsID8gdGhpcy5vYmplY3QgOiBzdGF0ZS5vYmplY3Q7XG5cblx0XHRyZXR1cm4gdGhpcy5yZWZlcmVuY2U7XG5cblx0fVxuXG5cdHNldHVwKCkge1xuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXMubm9kZTtcblxuXHR9XG5cblx0dXBkYXRlKCAvKmZyYW1lKi8gKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVZhbHVlKCk7XG5cblx0fVxuXG5cdHVwZGF0ZVZhbHVlKCkge1xuXG5cdFx0aWYgKCB0aGlzLm5vZGUgPT09IG51bGwgKSB0aGlzLnNldE5vZGVUeXBlKCB0aGlzLnVuaWZvcm1UeXBlICk7XG5cblx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVGcm9tUmVmZXJlbmNlKCk7XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cblx0XHRcdHRoaXMubm9kZS5hcnJheSA9IHZhbHVlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5ub2RlLnZhbHVlID0gdmFsdWU7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlZmVyZW5jZUJhc2VOb2RlO1xuXG5leHBvcnQgY29uc3QgcmVmZXJlbmNlID0gKCBuYW1lLCB0eXBlLCBvYmplY3QgKSA9PiBub2RlT2JqZWN0KCBuZXcgUmVmZXJlbmNlQmFzZU5vZGUoIG5hbWUsIHR5cGUsIG9iamVjdCApICk7XG5leHBvcnQgY29uc3QgcmVmZXJlbmNlQnVmZmVyID0gKCBuYW1lLCB0eXBlLCBjb3VudCwgb2JqZWN0ICkgPT4gbm9kZU9iamVjdCggbmV3IFJlZmVyZW5jZUJhc2VOb2RlKCBuYW1lLCB0eXBlLCBvYmplY3QsIGNvdW50ICkgKTtcbiIsImltcG9ydCBSZWZlcmVuY2VCYXNlTm9kZSBmcm9tICcuL1JlZmVyZW5jZUJhc2VOb2RlLmpzJztcbmltcG9ydCB7IG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQ29yZS5qcyc7XG5pbXBvcnQgeyByZW5kZXJHcm91cCB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybUdyb3VwTm9kZS5qcyc7XG5cbmNsYXNzIFJlbmRlcmVyUmVmZXJlbmNlTm9kZSBleHRlbmRzIFJlZmVyZW5jZUJhc2VOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1JlbmRlcmVyUmVmZXJlbmNlTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBwcm9wZXJ0eSwgaW5wdXRUeXBlLCByZW5kZXJlciA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggcHJvcGVydHksIGlucHV0VHlwZSwgcmVuZGVyZXIgKTtcblxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuXHRcdHRoaXMuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XG5cblx0fVxuXG5cdHVwZGF0ZVJlZmVyZW5jZSggc3RhdGUgKSB7XG5cblx0XHR0aGlzLnJlZmVyZW5jZSA9IHRoaXMucmVuZGVyZXIgIT09IG51bGwgPyB0aGlzLnJlbmRlcmVyIDogc3RhdGUucmVuZGVyZXI7XG5cblx0XHRyZXR1cm4gdGhpcy5yZWZlcmVuY2U7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlcmVyUmVmZXJlbmNlTm9kZTtcblxuZXhwb3J0IGNvbnN0IHJlbmRlcmVyUmVmZXJlbmNlID0gKCBuYW1lLCB0eXBlLCByZW5kZXJlciApID0+IG5vZGVPYmplY3QoIG5ldyBSZW5kZXJlclJlZmVyZW5jZU5vZGUoIG5hbWUsIHR5cGUsIHJlbmRlcmVyICkgKTtcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcbmltcG9ydCB7IGFkZE1ldGhvZENoYWluaW5nLCBub2RlT2JqZWN0LCB2ZWM0IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuaW1wb3J0IHsgcmVuZGVyZXJSZWZlcmVuY2UgfSBmcm9tICcuLi9hY2Nlc3NvcnMvUmVuZGVyZXJSZWZlcmVuY2VOb2RlLmpzJztcblxuaW1wb3J0IHsgTm9Ub25lTWFwcGluZyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBoYXNoIH0gZnJvbSAnLi4vY29yZS9Ob2RlVXRpbHMuanMnO1xuXG5jbGFzcyBUb25lTWFwcGluZ05vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdUb25lTWFwcGluZ05vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggdG9uZU1hcHBpbmcsIGV4cG9zdXJlTm9kZSA9IHRvbmVNYXBwaW5nRXhwb3N1cmUsIGNvbG9yTm9kZSA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggJ3ZlYzMnICk7XG5cblx0XHR0aGlzLnRvbmVNYXBwaW5nID0gdG9uZU1hcHBpbmc7XG5cblx0XHR0aGlzLmV4cG9zdXJlTm9kZSA9IGV4cG9zdXJlTm9kZTtcblx0XHR0aGlzLmNvbG9yTm9kZSA9IGNvbG9yTm9kZTtcblxuXHR9XG5cblx0Z2V0Q2FjaGVLZXkoKSB7XG5cblx0XHRyZXR1cm4gaGFzaCggc3VwZXIuZ2V0Q2FjaGVLZXkoKSwgdGhpcy50b25lTWFwcGluZyApO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IGNvbG9yTm9kZSA9IHRoaXMuY29sb3JOb2RlIHx8IGJ1aWxkZXIuY29udGV4dC5jb2xvcjtcblx0XHRjb25zdCB0b25lTWFwcGluZyA9IHRoaXMudG9uZU1hcHBpbmc7XG5cblx0XHRpZiAoIHRvbmVNYXBwaW5nID09PSBOb1RvbmVNYXBwaW5nICkgcmV0dXJuIGNvbG9yTm9kZTtcblxuXHRcdGxldCBvdXRwdXROb2RlID0gbnVsbDtcblxuXHRcdGNvbnN0IHRvbmVNYXBwaW5nRm4gPSBidWlsZGVyLnJlbmRlcmVyLmxpYnJhcnkuZ2V0VG9uZU1hcHBpbmdGdW5jdGlvbiggdG9uZU1hcHBpbmcgKTtcblxuXHRcdGlmICggdG9uZU1hcHBpbmdGbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0b3V0cHV0Tm9kZSA9IHZlYzQoIHRvbmVNYXBwaW5nRm4oIGNvbG9yTm9kZS5yZ2IsIHRoaXMuZXhwb3N1cmVOb2RlICksIGNvbG9yTm9kZS5hICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVG9uZU1hcHBpbmdOb2RlOiBVbnN1cHBvcnRlZCBUb25lIE1hcHBpbmcgY29uZmlndXJhdGlvbi4nLCB0b25lTWFwcGluZyApO1xuXG5cdFx0XHRvdXRwdXROb2RlID0gY29sb3JOb2RlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dE5vZGU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvbmVNYXBwaW5nTm9kZTtcblxuZXhwb3J0IGNvbnN0IHRvbmVNYXBwaW5nID0gKCBtYXBwaW5nLCBleHBvc3VyZSwgY29sb3IgKSA9PiBub2RlT2JqZWN0KCBuZXcgVG9uZU1hcHBpbmdOb2RlKCBtYXBwaW5nLCBub2RlT2JqZWN0KCBleHBvc3VyZSApLCBub2RlT2JqZWN0KCBjb2xvciApICkgKTtcbmV4cG9ydCBjb25zdCB0b25lTWFwcGluZ0V4cG9zdXJlID0gLypAX19QVVJFX18qLyByZW5kZXJlclJlZmVyZW5jZSggJ3RvbmVNYXBwaW5nRXhwb3N1cmUnLCAnZmxvYXQnICk7XG5cbmFkZE1ldGhvZENoYWluaW5nKCAndG9uZU1hcHBpbmcnLCAoIGNvbG9yLCBtYXBwaW5nLCBleHBvc3VyZSApID0+IHRvbmVNYXBwaW5nKCBtYXBwaW5nLCBleHBvc3VyZSwgY29sb3IgKSApO1xuIiwiaW1wb3J0IElucHV0Tm9kZSBmcm9tICcuLi9jb3JlL0lucHV0Tm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlT2JqZWN0LCBhZGRNZXRob2RDaGFpbmluZyB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcbmltcG9ydCB7IHZhcnlpbmcgfSBmcm9tICcuLi9jb3JlL1ZhcnlpbmdOb2RlLmpzJztcblxuaW1wb3J0IHsgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9jb3JlL0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IEludGVybGVhdmVkQnVmZmVyIH0gZnJvbSAnLi4vLi4vY29yZS9JbnRlcmxlYXZlZEJ1ZmZlci5qcyc7XG5pbXBvcnQgeyBTdGF0aWNEcmF3VXNhZ2UsIER5bmFtaWNEcmF3VXNhZ2UgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuXG5jbGFzcyBCdWZmZXJBdHRyaWJ1dGVOb2RlIGV4dGVuZHMgSW5wdXROb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0J1ZmZlckF0dHJpYnV0ZU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIGJ1ZmZlclR5cGUgPSBudWxsLCBidWZmZXJTdHJpZGUgPSAwLCBidWZmZXJPZmZzZXQgPSAwICkge1xuXG5cdFx0c3VwZXIoIHZhbHVlLCBidWZmZXJUeXBlICk7XG5cblx0XHR0aGlzLmlzQnVmZmVyTm9kZSA9IHRydWU7XG5cblx0XHR0aGlzLmJ1ZmZlclR5cGUgPSBidWZmZXJUeXBlO1xuXHRcdHRoaXMuYnVmZmVyU3RyaWRlID0gYnVmZmVyU3RyaWRlO1xuXHRcdHRoaXMuYnVmZmVyT2Zmc2V0ID0gYnVmZmVyT2Zmc2V0O1xuXG5cdFx0dGhpcy51c2FnZSA9IFN0YXRpY0RyYXdVc2FnZTtcblx0XHR0aGlzLmluc3RhbmNlZCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5hdHRyaWJ1dGUgPSBudWxsO1xuXG5cdFx0dGhpcy5nbG9iYWwgPSB0cnVlO1xuXG5cdFx0aWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc0J1ZmZlckF0dHJpYnV0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy5hdHRyaWJ1dGUgPSB2YWx1ZTtcblx0XHRcdHRoaXMudXNhZ2UgPSB2YWx1ZS51c2FnZTtcblx0XHRcdHRoaXMuaW5zdGFuY2VkID0gdmFsdWUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldEhhc2goIGJ1aWxkZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuYnVmZmVyU3RyaWRlID09PSAwICYmIHRoaXMuYnVmZmVyT2Zmc2V0ID09PSAwICkge1xuXG5cdFx0XHRsZXQgYnVmZmVyRGF0YSA9IGJ1aWxkZXIuZ2xvYmFsQ2FjaGUuZ2V0RGF0YSggdGhpcy52YWx1ZSApO1xuXG5cdFx0XHRpZiAoIGJ1ZmZlckRhdGEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRidWZmZXJEYXRhID0ge1xuXHRcdFx0XHRcdG5vZGU6IHRoaXNcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRidWlsZGVyLmdsb2JhbENhY2hlLnNldERhdGEoIHRoaXMudmFsdWUsIGJ1ZmZlckRhdGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVmZmVyRGF0YS5ub2RlLnV1aWQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy51dWlkO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcblxuXHRcdGlmICggdGhpcy5idWZmZXJUeXBlID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJ1ZmZlclR5cGUgPSBidWlsZGVyLmdldFR5cGVGcm9tQXR0cmlidXRlKCB0aGlzLmF0dHJpYnV0ZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYnVmZmVyVHlwZTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuYXR0cmlidXRlICE9PSBudWxsICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblx0XHRjb25zdCBhcnJheSA9IHRoaXMudmFsdWU7XG5cdFx0Y29uc3QgaXRlbVNpemUgPSBidWlsZGVyLmdldFR5cGVMZW5ndGgoIHR5cGUgKTtcblx0XHRjb25zdCBzdHJpZGUgPSB0aGlzLmJ1ZmZlclN0cmlkZSB8fCBpdGVtU2l6ZTtcblx0XHRjb25zdCBvZmZzZXQgPSB0aGlzLmJ1ZmZlck9mZnNldDtcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IGFycmF5LmlzSW50ZXJsZWF2ZWRCdWZmZXIgPT09IHRydWUgPyBhcnJheSA6IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlciggYXJyYXksIHN0cmlkZSApO1xuXHRcdGNvbnN0IGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0ICk7XG5cblx0XHRidWZmZXIuc2V0VXNhZ2UoIHRoaXMudXNhZ2UgKTtcblxuXHRcdHRoaXMuYXR0cmlidXRlID0gYnVmZmVyQXR0cmlidXRlO1xuXHRcdHRoaXMuYXR0cmlidXRlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gdGhpcy5pbnN0YW5jZWQ7IC8vIEBUT0RPOiBBZGQgYSBwb3NzaWJsZTogSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGVcblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBub2RlVHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHRcdGNvbnN0IG5vZGVBdHRyaWJ1dGUgPSBidWlsZGVyLmdldEJ1ZmZlckF0dHJpYnV0ZUZyb21Ob2RlKCB0aGlzLCBub2RlVHlwZSApO1xuXHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0UHJvcGVydHlOYW1lKCBub2RlQXR0cmlidXRlICk7XG5cblx0XHRsZXQgb3V0cHV0ID0gbnVsbDtcblxuXHRcdGlmICggYnVpbGRlci5zaGFkZXJTdGFnZSA9PT0gJ3ZlcnRleCcgfHwgYnVpbGRlci5zaGFkZXJTdGFnZSA9PT0gJ2NvbXB1dGUnICkge1xuXG5cdFx0XHR0aGlzLm5hbWUgPSBwcm9wZXJ0eU5hbWU7XG5cblx0XHRcdG91dHB1dCA9IHByb3BlcnR5TmFtZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IG5vZGVWYXJ5aW5nID0gdmFyeWluZyggdGhpcyApO1xuXG5cdFx0XHRvdXRwdXQgPSBub2RlVmFyeWluZy5idWlsZCggYnVpbGRlciwgbm9kZVR5cGUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0fVxuXG5cdGdldElucHV0VHlwZSggLypidWlsZGVyKi8gKSB7XG5cblx0XHRyZXR1cm4gJ2J1ZmZlckF0dHJpYnV0ZSc7XG5cblx0fVxuXG5cdHNldFVzYWdlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudXNhZ2UgPSB2YWx1ZTtcblxuXHRcdGlmICggdGhpcy5hdHRyaWJ1dGUgJiYgdGhpcy5hdHRyaWJ1dGUuaXNCdWZmZXJBdHRyaWJ1dGUgPT09IHRydWUgKSB7XG5cblx0XHRcdHRoaXMuYXR0cmlidXRlLnVzYWdlID0gdmFsdWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0SW5zdGFuY2VkKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuaW5zdGFuY2VkID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnVmZmVyQXR0cmlidXRlTm9kZTtcblxuZXhwb3J0IGNvbnN0IGJ1ZmZlckF0dHJpYnV0ZSA9ICggYXJyYXksIHR5cGUsIHN0cmlkZSwgb2Zmc2V0ICkgPT4gbm9kZU9iamVjdCggbmV3IEJ1ZmZlckF0dHJpYnV0ZU5vZGUoIGFycmF5LCB0eXBlLCBzdHJpZGUsIG9mZnNldCApICk7XG5leHBvcnQgY29uc3QgZHluYW1pY0J1ZmZlckF0dHJpYnV0ZSA9ICggYXJyYXksIHR5cGUsIHN0cmlkZSwgb2Zmc2V0ICkgPT4gYnVmZmVyQXR0cmlidXRlKCBhcnJheSwgdHlwZSwgc3RyaWRlLCBvZmZzZXQgKS5zZXRVc2FnZSggRHluYW1pY0RyYXdVc2FnZSApO1xuXG5leHBvcnQgY29uc3QgaW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gKCBhcnJheSwgdHlwZSwgc3RyaWRlLCBvZmZzZXQgKSA9PiBidWZmZXJBdHRyaWJ1dGUoIGFycmF5LCB0eXBlLCBzdHJpZGUsIG9mZnNldCApLnNldEluc3RhbmNlZCggdHJ1ZSApO1xuZXhwb3J0IGNvbnN0IGluc3RhbmNlZER5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgPSAoIGFycmF5LCB0eXBlLCBzdHJpZGUsIG9mZnNldCApID0+IGR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCB0eXBlLCBzdHJpZGUsIG9mZnNldCApLnNldEluc3RhbmNlZCggdHJ1ZSApO1xuXG5hZGRNZXRob2RDaGFpbmluZyggJ3RvQXR0cmlidXRlJywgKCBidWZmZXJOb2RlICkgPT4gYnVmZmVyQXR0cmlidXRlKCBidWZmZXJOb2RlLnZhbHVlICkgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGFkZE1ldGhvZENoYWluaW5nLCBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuXG5jbGFzcyBDb21wdXRlTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnQ29tcHV0ZU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggY29tcHV0ZU5vZGUsIGNvdW50LCB3b3JrZ3JvdXBTaXplID0gWyA2NCBdICkge1xuXG5cdFx0c3VwZXIoICd2b2lkJyApO1xuXG5cdFx0dGhpcy5pc0NvbXB1dGVOb2RlID0gdHJ1ZTtcblxuXHRcdHRoaXMuY29tcHV0ZU5vZGUgPSBjb21wdXRlTm9kZTtcblxuXHRcdHRoaXMuY291bnQgPSBjb3VudDtcblx0XHR0aGlzLndvcmtncm91cFNpemUgPSB3b3JrZ3JvdXBTaXplO1xuXHRcdHRoaXMuZGlzcGF0Y2hDb3VudCA9IDA7XG5cblx0XHR0aGlzLnZlcnNpb24gPSAxO1xuXHRcdHRoaXMudXBkYXRlQmVmb3JlVHlwZSA9IE5vZGVVcGRhdGVUeXBlLk9CSkVDVDtcblxuXHRcdHRoaXMub25Jbml0RnVuY3Rpb24gPSBudWxsO1xuXG5cdFx0dGhpcy51cGRhdGVEaXNwYXRjaENvdW50KCk7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0fVxuXG5cdHVwZGF0ZURpc3BhdGNoQ291bnQoKSB7XG5cblx0XHRjb25zdCB7IGNvdW50LCB3b3JrZ3JvdXBTaXplIH0gPSB0aGlzO1xuXG5cdFx0bGV0IHNpemUgPSB3b3JrZ3JvdXBTaXplWyAwIF07XG5cblx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPCB3b3JrZ3JvdXBTaXplLmxlbmd0aDsgaSArKyApXG5cdFx0XHRzaXplICo9IHdvcmtncm91cFNpemVbIGkgXTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hDb3VudCA9IE1hdGguY2VpbCggY291bnQgLyBzaXplICk7XG5cblx0fVxuXG5cdG9uSW5pdCggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLm9uSW5pdEZ1bmN0aW9uID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dXBkYXRlQmVmb3JlKCB7IHJlbmRlcmVyIH0gKSB7XG5cblx0XHRyZW5kZXJlci5jb21wdXRlKCB0aGlzICk7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgeyBzaGFkZXJTdGFnZSB9ID0gYnVpbGRlcjtcblxuXHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICdjb21wdXRlJyApIHtcblxuXHRcdFx0Y29uc3Qgc25pcHBldCA9IHRoaXMuY29tcHV0ZU5vZGUuYnVpbGQoIGJ1aWxkZXIsICd2b2lkJyApO1xuXG5cdFx0XHRpZiAoIHNuaXBwZXQgIT09ICcnICkge1xuXG5cdFx0XHRcdGJ1aWxkZXIuYWRkTGluZUZsb3dDb2RlKCBzbmlwcGV0LCB0aGlzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcHV0ZU5vZGU7XG5cbmV4cG9ydCBjb25zdCBjb21wdXRlID0gKCBub2RlLCBjb3VudCwgd29ya2dyb3VwU2l6ZSApID0+IG5vZGVPYmplY3QoIG5ldyBDb21wdXRlTm9kZSggbm9kZU9iamVjdCggbm9kZSApLCBjb3VudCwgd29ya2dyb3VwU2l6ZSApICk7XG5cbmFkZE1ldGhvZENoYWluaW5nKCAnY29tcHV0ZScsIGNvbXB1dGUgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyBhZGRNZXRob2RDaGFpbmluZywgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcblxuY2xhc3MgQ2FjaGVOb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdDYWNoZU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3Rvciggbm9kZSwgcGFyZW50ID0gdHJ1ZSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLm5vZGUgPSBub2RlO1xuXHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG5cdFx0dGhpcy5pc0NhY2hlTm9kZSA9IHRydWU7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXG5cdH1cblxuXHRidWlsZCggYnVpbGRlciwgLi4ucGFyYW1zICkge1xuXG5cdFx0Y29uc3QgcHJldmlvdXNDYWNoZSA9IGJ1aWxkZXIuZ2V0Q2FjaGUoKTtcblx0XHRjb25zdCBjYWNoZSA9IGJ1aWxkZXIuZ2V0Q2FjaGVGcm9tTm9kZSggdGhpcywgdGhpcy5wYXJlbnQgKTtcblxuXHRcdGJ1aWxkZXIuc2V0Q2FjaGUoIGNhY2hlICk7XG5cblx0XHRjb25zdCBkYXRhID0gdGhpcy5ub2RlLmJ1aWxkKCBidWlsZGVyLCAuLi5wYXJhbXMgKTtcblxuXHRcdGJ1aWxkZXIuc2V0Q2FjaGUoIHByZXZpb3VzQ2FjaGUgKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDYWNoZU5vZGU7XG5cbmV4cG9ydCBjb25zdCBjYWNoZSA9ICggbm9kZSwgLi4ucGFyYW1zICkgPT4gbm9kZU9iamVjdCggbmV3IENhY2hlTm9kZSggbm9kZU9iamVjdCggbm9kZSApLCAuLi5wYXJhbXMgKSApO1xuXG5hZGRNZXRob2RDaGFpbmluZyggJ2NhY2hlJywgY2FjaGUgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyBhZGRNZXRob2RDaGFpbmluZywgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuXG5jbGFzcyBCeXBhc3NOb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdCeXBhc3NOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHJldHVybk5vZGUsIGNhbGxOb2RlICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNCeXBhc3NOb2RlID0gdHJ1ZTtcblxuXHRcdHRoaXMub3V0cHV0Tm9kZSA9IHJldHVybk5vZGU7XG5cdFx0dGhpcy5jYWxsTm9kZSA9IGNhbGxOb2RlO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLm91dHB1dE5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBzbmlwcGV0ID0gdGhpcy5jYWxsTm9kZS5idWlsZCggYnVpbGRlciwgJ3ZvaWQnICk7XG5cblx0XHRpZiAoIHNuaXBwZXQgIT09ICcnICkge1xuXG5cdFx0XHRidWlsZGVyLmFkZExpbmVGbG93Q29kZSggc25pcHBldCwgdGhpcyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMub3V0cHV0Tm9kZS5idWlsZCggYnVpbGRlciApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCeXBhc3NOb2RlO1xuXG5leHBvcnQgY29uc3QgYnlwYXNzID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEJ5cGFzc05vZGUgKTtcblxuYWRkTWV0aG9kQ2hhaW5pbmcoICdieXBhc3MnLCBieXBhc3MgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBmbG9hdCwgYWRkTWV0aG9kQ2hhaW5pbmcsIG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcblxuY2xhc3MgUmVtYXBOb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdSZW1hcE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3Rvciggbm9kZSwgaW5Mb3dOb2RlLCBpbkhpZ2hOb2RlLCBvdXRMb3dOb2RlID0gZmxvYXQoIDAgKSwgb3V0SGlnaE5vZGUgPSBmbG9hdCggMSApICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMubm9kZSA9IG5vZGU7XG5cdFx0dGhpcy5pbkxvd05vZGUgPSBpbkxvd05vZGU7XG5cdFx0dGhpcy5pbkhpZ2hOb2RlID0gaW5IaWdoTm9kZTtcblx0XHR0aGlzLm91dExvd05vZGUgPSBvdXRMb3dOb2RlO1xuXHRcdHRoaXMub3V0SGlnaE5vZGUgPSBvdXRIaWdoTm9kZTtcblxuXHRcdHRoaXMuZG9DbGFtcCA9IHRydWU7XG5cblx0fVxuXG5cdHNldHVwKCkge1xuXG5cdFx0Y29uc3QgeyBub2RlLCBpbkxvd05vZGUsIGluSGlnaE5vZGUsIG91dExvd05vZGUsIG91dEhpZ2hOb2RlLCBkb0NsYW1wIH0gPSB0aGlzO1xuXG5cdFx0bGV0IHQgPSBub2RlLnN1YiggaW5Mb3dOb2RlICkuZGl2KCBpbkhpZ2hOb2RlLnN1YiggaW5Mb3dOb2RlICkgKTtcblxuXHRcdGlmICggZG9DbGFtcCA9PT0gdHJ1ZSApIHQgPSB0LmNsYW1wKCk7XG5cblx0XHRyZXR1cm4gdC5tdWwoIG91dEhpZ2hOb2RlLnN1Yiggb3V0TG93Tm9kZSApICkuYWRkKCBvdXRMb3dOb2RlICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbWFwTm9kZTtcblxuZXhwb3J0IGNvbnN0IHJlbWFwID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFJlbWFwTm9kZSwgbnVsbCwgbnVsbCwgeyBkb0NsYW1wOiBmYWxzZSB9ICk7XG5leHBvcnQgY29uc3QgcmVtYXBDbGFtcCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBSZW1hcE5vZGUgKTtcblxuYWRkTWV0aG9kQ2hhaW5pbmcoICdyZW1hcCcsIHJlbWFwICk7XG5hZGRNZXRob2RDaGFpbmluZyggJ3JlbWFwQ2xhbXAnLCByZW1hcENsYW1wICk7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuXG5jbGFzcyBFeHByZXNzaW9uTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnRXhwcmVzc2lvbk5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3Rvciggc25pcHBldCA9ICcnLCBub2RlVHlwZSA9ICd2b2lkJyApIHtcblxuXHRcdHN1cGVyKCBub2RlVHlwZSApO1xuXG5cdFx0dGhpcy5zbmlwcGV0ID0gc25pcHBldDtcblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcblxuXHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cdFx0Y29uc3Qgc25pcHBldCA9IHRoaXMuc25pcHBldDtcblxuXHRcdGlmICggdHlwZSA9PT0gJ3ZvaWQnICkge1xuXG5cdFx0XHRidWlsZGVyLmFkZExpbmVGbG93Q29kZSggc25pcHBldCwgdGhpcyApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgKCAkeyBzbmlwcGV0IH0gKWAsIHR5cGUsIG91dHB1dCApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBFeHByZXNzaW9uTm9kZTtcblxuZXhwb3J0IGNvbnN0IGV4cHJlc3Npb24gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggRXhwcmVzc2lvbk5vZGUgKTtcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJy4uL21hdGgvQ29uZGl0aW9uYWxOb2RlLmpzJztcbmltcG9ydCB7IGV4cHJlc3Npb24gfSBmcm9tICcuLi9jb2RlL0V4cHJlc3Npb25Ob2RlLmpzJztcbmltcG9ydCB7IGFkZE1ldGhvZENoYWluaW5nIH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuXG5leHBvcnQgY29uc3QgRGlzY2FyZCA9ICggY29uZGl0aW9uYWwgKSA9PiAoIGNvbmRpdGlvbmFsID8gc2VsZWN0KCBjb25kaXRpb25hbCwgZXhwcmVzc2lvbiggJ2Rpc2NhcmQnICkgKSA6IGV4cHJlc3Npb24oICdkaXNjYXJkJyApICkuYXBwZW5kKCk7XG5leHBvcnQgY29uc3QgUmV0dXJuID0gKCkgPT4gZXhwcmVzc2lvbiggJ3JldHVybicgKS5hcHBlbmQoKTtcblxuYWRkTWV0aG9kQ2hhaW5pbmcoICdkaXNjYXJkJywgRGlzY2FyZCApO1xuIiwiaW1wb3J0IFRlbXBOb2RlIGZyb20gJy4uL2NvcmUvVGVtcE5vZGUuanMnO1xuaW1wb3J0IHsgYWRkTWV0aG9kQ2hhaW5pbmcsIG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQ29yZS5qcyc7XG5cbmltcG9ydCB7IE5vQ29sb3JTcGFjZSwgTm9Ub25lTWFwcGluZyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBDb2xvck1hbmFnZW1lbnQgfSBmcm9tICcuLi8uLi9tYXRoL0NvbG9yTWFuYWdlbWVudC5qcyc7XG5cbmNsYXNzIFJlbmRlck91dHB1dE5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdSZW5kZXJPdXRwdXROb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yTm9kZSwgdG9uZU1hcHBpbmcsIG91dHB1dENvbG9yU3BhY2UgKSB7XG5cblx0XHRzdXBlciggJ3ZlYzQnICk7XG5cblx0XHR0aGlzLmNvbG9yTm9kZSA9IGNvbG9yTm9kZTtcblx0XHR0aGlzLnRvbmVNYXBwaW5nID0gdG9uZU1hcHBpbmc7XG5cdFx0dGhpcy5vdXRwdXRDb2xvclNwYWNlID0gb3V0cHV0Q29sb3JTcGFjZTtcblxuXHRcdHRoaXMuaXNSZW5kZXJPdXRwdXQgPSB0cnVlO1xuXG5cdH1cblxuXHRzZXR1cCggeyBjb250ZXh0IH0gKSB7XG5cblx0XHRsZXQgb3V0cHV0Tm9kZSA9IHRoaXMuY29sb3JOb2RlIHx8IGNvbnRleHQuY29sb3I7XG5cblx0XHQvLyB0b25lIG1hcHBpbmdcblxuXHRcdGNvbnN0IHRvbmVNYXBwaW5nID0gKCB0aGlzLnRvbmVNYXBwaW5nICE9PSBudWxsID8gdGhpcy50b25lTWFwcGluZyA6IGNvbnRleHQudG9uZU1hcHBpbmcgKSB8fCBOb1RvbmVNYXBwaW5nO1xuXHRcdGNvbnN0IG91dHB1dENvbG9yU3BhY2UgPSAoIHRoaXMub3V0cHV0Q29sb3JTcGFjZSAhPT0gbnVsbCA/IHRoaXMub3V0cHV0Q29sb3JTcGFjZSA6IGNvbnRleHQub3V0cHV0Q29sb3JTcGFjZSApIHx8IE5vQ29sb3JTcGFjZTtcblxuXHRcdGlmICggdG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSB7XG5cblx0XHRcdG91dHB1dE5vZGUgPSBvdXRwdXROb2RlLnRvbmVNYXBwaW5nKCB0b25lTWFwcGluZyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gd29ya2luZyB0byBvdXRwdXQgY29sb3Igc3BhY2VcblxuXHRcdGlmICggb3V0cHV0Q29sb3JTcGFjZSAhPT0gTm9Db2xvclNwYWNlICYmIG91dHB1dENvbG9yU3BhY2UgIT09IENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZSApIHtcblxuXHRcdFx0b3V0cHV0Tm9kZSA9IG91dHB1dE5vZGUud29ya2luZ1RvQ29sb3JTcGFjZSggb3V0cHV0Q29sb3JTcGFjZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dE5vZGU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlck91dHB1dE5vZGU7XG5cbmV4cG9ydCBjb25zdCByZW5kZXJPdXRwdXQgPSAoIGNvbG9yLCB0b25lTWFwcGluZyA9IG51bGwsIG91dHB1dENvbG9yU3BhY2UgPSBudWxsICkgPT4gbm9kZU9iamVjdCggbmV3IFJlbmRlck91dHB1dE5vZGUoIG5vZGVPYmplY3QoIGNvbG9yICksIHRvbmVNYXBwaW5nLCBvdXRwdXRDb2xvclNwYWNlICkgKTtcblxuYWRkTWV0aG9kQ2hhaW5pbmcoICdyZW5kZXJPdXRwdXQnLCByZW5kZXJPdXRwdXQgKTtcbiIsIi8vIE5vbi1QVVJFIGV4cG9ydHMgbGlzdCwgc2lkZS1lZmZlY3RzIGFyZSByZXF1aXJlZCBoZXJlLlxuLy8gVFNMIEJhc2UgU3ludGF4XG5cbmV4cG9ydCAqIGZyb20gJy4vVFNMQ29yZS5qcyc7IC8vIGZsb2F0KCksIHZlYzIoKSwgdmVjMygpLCB2ZWM0KCksIG1hdDMoKSwgbWF0NCgpLCBGbigpLCBJZigpLCBlbGVtZW50KCksIG5vZGVPYmplY3QoKSwgbm9kZVByb3h5KCksIC4uLlxuZXhwb3J0ICogZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7IC8vIHVuaWZvcm0oKVxuZXhwb3J0ICogZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnOyAvLyBwcm9wZXJ0eSgpICA8LT4gVE9ETzogU2VwZXJhdGUgTWF0ZXJpYWwgUHJvcGVydGllcyBpbiBvdGhlciBmaWxlXG5leHBvcnQgKiBmcm9tICcuLi9jb3JlL0Fzc2lnbk5vZGUuanMnOyAvLyAuYXNzaWduKClcbmV4cG9ydCAqIGZyb20gJy4uL2NvZGUvRnVuY3Rpb25DYWxsTm9kZS5qcyc7IC8vIC5jYWxsKClcbmV4cG9ydCAqIGZyb20gJy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJzsgLy8gLmFkZCgpLCAuc3ViKCksIC4uLlxuZXhwb3J0ICogZnJvbSAnLi4vbWF0aC9NYXRoTm9kZS5qcyc7IC8vIGFicygpLCBmbG9vcigpLCAuLi5cbmV4cG9ydCAqIGZyb20gJy4uL21hdGgvQ29uZGl0aW9uYWxOb2RlLmpzJzsgLy8gc2VsZWN0KCksIC4uLlxuZXhwb3J0ICogZnJvbSAnLi4vY29yZS9Db250ZXh0Tm9kZS5qcyc7IC8vIC5jb250ZXh0KClcbmV4cG9ydCAqIGZyb20gJy4uL2NvcmUvVmFyTm9kZS5qcyc7IC8vIC52YXIoKSAtPiBUT0RPOiBNYXliZSByZW5hbWUgLnRvVmFyKCkgLT4gLnZhcigpXG5leHBvcnQgKiBmcm9tICcuLi9jb3JlL1ZhcnlpbmdOb2RlLmpzJzsgLy8gdmFyeWluZygpIC0+IFRPRE86IEFkZCB2ZXJ0ZXhTdGFnZSgpXG5leHBvcnQgKiBmcm9tICcuLi9kaXNwbGF5L0NvbG9yU3BhY2VOb2RlLmpzJzsgLy8gLnRvQ29sb3JTcGFjZSgpXG5leHBvcnQgKiBmcm9tICcuLi9kaXNwbGF5L1RvbmVNYXBwaW5nTm9kZS5qcyc7IC8vIC50b1RvbmVNYXBwaW5nKClcbmV4cG9ydCAqIGZyb20gJy4uL2FjY2Vzc29ycy9CdWZmZXJBdHRyaWJ1dGVOb2RlLmpzJzsgLy8gLnRvQXR0cmlidXRlKClcbmV4cG9ydCAqIGZyb20gJy4uL2dwZ3B1L0NvbXB1dGVOb2RlLmpzJzsgLy8gLmNvbXB1dGUoKVxuZXhwb3J0ICogZnJvbSAnLi4vY29yZS9DYWNoZU5vZGUuanMnOyAvLyAuY2FjaGUoKVxuZXhwb3J0ICogZnJvbSAnLi4vY29yZS9CeXBhc3NOb2RlLmpzJzsgLy8gLmJ5cGFzcygpXG5leHBvcnQgKiBmcm9tICcuLi91dGlscy9SZW1hcE5vZGUuanMnOyAvLyAucmVtYXAoKSwgLnJlbWFwQ2xhbXAoKVxuZXhwb3J0ICogZnJvbSAnLi4vY29kZS9FeHByZXNzaW9uTm9kZS5qcyc7IC8vIGV4cHJlc3Npb24oKVxuZXhwb3J0ICogZnJvbSAnLi4vdXRpbHMvRGlzY2FyZC5qcyc7IC8vIERpc2NhcmQoKSwgUmV0dXJuKClcbmV4cG9ydCAqIGZyb20gJy4uL2Rpc3BsYXkvUmVuZGVyT3V0cHV0Tm9kZS5qcyc7IC8vIC5yZW5kZXJPdXRwdXQoKVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTm9kZUVsZW1lbnQoIG5hbWUvKiwgbm9kZUVsZW1lbnQqLyApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5UU0xCYXNlOiBBZGROb2RlRWxlbWVudCBoYXMgYmVlbiByZW1vdmVkIGluIGZhdm9yIG9mIHRyZWUtc2hha2luZy4gVHJ5aW5nIGFkZCcsIG5hbWUgKTtcblxufVxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IG5vZGVPYmplY3QsIHZhcnlpbmcgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIEF0dHJpYnV0ZU5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0F0dHJpYnV0ZU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggYXR0cmlidXRlTmFtZSwgbm9kZVR5cGUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoIG5vZGVUeXBlICk7XG5cblx0XHR0aGlzLmdsb2JhbCA9IHRydWU7XG5cblx0XHR0aGlzLl9hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcblxuXHR9XG5cblx0Z2V0SGFzaCggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZU5hbWUoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRsZXQgbm9kZVR5cGUgPSB0aGlzLm5vZGVUeXBlO1xuXG5cdFx0aWYgKCBub2RlVHlwZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlTmFtZSggYnVpbGRlciApO1xuXG5cdFx0XHRpZiAoIGJ1aWxkZXIuaGFzR2VvbWV0cnlBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKSApIHtcblxuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBidWlsZGVyLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSApO1xuXG5cdFx0XHRcdG5vZGVUeXBlID0gYnVpbGRlci5nZXRUeXBlRnJvbUF0dHJpYnV0ZSggYXR0cmlidXRlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bm9kZVR5cGUgPSAnZmxvYXQnO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbm9kZVR5cGU7XG5cblx0fVxuXG5cdHNldEF0dHJpYnV0ZU5hbWUoIGF0dHJpYnV0ZU5hbWUgKSB7XG5cblx0XHR0aGlzLl9hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRBdHRyaWJ1dGVOYW1lKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdHJldHVybiB0aGlzLl9hdHRyaWJ1dGVOYW1lO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZU5hbWUoIGJ1aWxkZXIgKTtcblx0XHRjb25zdCBub2RlVHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblx0XHRjb25zdCBnZW9tZXRyeUF0dHJpYnV0ZSA9IGJ1aWxkZXIuaGFzR2VvbWV0cnlBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKTtcblxuXHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGJ1aWxkZXIuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCBhdHRyaWJ1dGVOYW1lICk7XG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVUeXBlID0gYnVpbGRlci5nZXRUeXBlRnJvbUF0dHJpYnV0ZSggYXR0cmlidXRlICk7XG5cblx0XHRcdGNvbnN0IG5vZGVBdHRyaWJ1dGUgPSBidWlsZGVyLmdldEF0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSApO1xuXG5cdFx0XHRpZiAoIGJ1aWxkZXIuc2hhZGVyU3RhZ2UgPT09ICd2ZXJ0ZXgnICkge1xuXG5cdFx0XHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggbm9kZUF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGVUeXBlLCBub2RlVHlwZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IG5vZGVWYXJ5aW5nID0gdmFyeWluZyggdGhpcyApO1xuXG5cdFx0XHRcdHJldHVybiBub2RlVmFyeWluZy5idWlsZCggYnVpbGRlciwgbm9kZVR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCBgQXR0cmlidXRlTm9kZTogVmVydGV4IGF0dHJpYnV0ZSBcIiR7IGF0dHJpYnV0ZU5hbWUgfVwiIG5vdCBmb3VuZCBvbiBnZW9tZXRyeS5gICk7XG5cblx0XHRcdHJldHVybiBidWlsZGVyLmdlbmVyYXRlQ29uc3QoIG5vZGVUeXBlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcblxuXHRcdHN1cGVyLnNlcmlhbGl6ZSggZGF0YSApO1xuXG5cdFx0ZGF0YS5nbG9iYWwgPSB0aGlzLmdsb2JhbDtcblx0XHRkYXRhLl9hdHRyaWJ1dGVOYW1lID0gdGhpcy5fYXR0cmlidXRlTmFtZTtcblxuXHR9XG5cblx0ZGVzZXJpYWxpemUoIGRhdGEgKSB7XG5cblx0XHRzdXBlci5kZXNlcmlhbGl6ZSggZGF0YSApO1xuXG5cdFx0dGhpcy5nbG9iYWwgPSBkYXRhLmdsb2JhbDtcblx0XHR0aGlzLl9hdHRyaWJ1dGVOYW1lID0gZGF0YS5fYXR0cmlidXRlTmFtZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXR0cmlidXRlTm9kZTtcblxuZXhwb3J0IGNvbnN0IGF0dHJpYnV0ZSA9ICggbmFtZSwgbm9kZVR5cGUgKSA9PiBub2RlT2JqZWN0KCBuZXcgQXR0cmlidXRlTm9kZSggbmFtZSwgbm9kZVR5cGUgKSApO1xuIiwiaW1wb3J0IHsgYXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9BdHRyaWJ1dGVOb2RlLmpzJztcblxuZXhwb3J0IGNvbnN0IHV2ID0gKCBpbmRleCApID0+IGF0dHJpYnV0ZSggJ3V2JyArICggaW5kZXggPiAwID8gaW5kZXggOiAnJyApLCAndmVjMicgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIFRleHR1cmVTaXplTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnVGV4dHVyZVNpemVOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHRleHR1cmVOb2RlLCBsZXZlbE5vZGUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoICd1dmVjMicgKTtcblxuXHRcdHRoaXMuaXNUZXh0dXJlU2l6ZU5vZGUgPSB0cnVlO1xuXG5cdFx0dGhpcy50ZXh0dXJlTm9kZSA9IHRleHR1cmVOb2RlO1xuXHRcdHRoaXMubGV2ZWxOb2RlID0gbGV2ZWxOb2RlO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZVByb3BlcnR5ID0gdGhpcy50ZXh0dXJlTm9kZS5idWlsZCggYnVpbGRlciwgJ3Byb3BlcnR5JyApO1xuXHRcdGNvbnN0IGxldmVsID0gdGhpcy5sZXZlbE5vZGUgPT09IG51bGwgPyAnMCcgOiB0aGlzLmxldmVsTm9kZS5idWlsZCggYnVpbGRlciwgJ2ludCcgKTtcblxuXHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggYCR7IGJ1aWxkZXIuZ2V0TWV0aG9kKCAndGV4dHVyZURpbWVuc2lvbnMnICkgfSggJHsgdGV4dHVyZVByb3BlcnR5IH0sICR7IGxldmVsIH0gKWAsIHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSwgb3V0cHV0ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRleHR1cmVTaXplTm9kZTtcblxuZXhwb3J0IGNvbnN0IHRleHR1cmVTaXplID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFRleHR1cmVTaXplTm9kZSApO1xuIiwiaW1wb3J0IFVuaWZvcm1Ob2RlIGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIE1heE1pcExldmVsTm9kZSBleHRlbmRzIFVuaWZvcm1Ob2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ01heE1pcExldmVsTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCB0ZXh0dXJlTm9kZSApIHtcblxuXHRcdHN1cGVyKCAwICk7XG5cblx0XHR0aGlzLl90ZXh0dXJlTm9kZSA9IHRleHR1cmVOb2RlO1xuXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuRlJBTUU7XG5cblx0fVxuXG5cdGdldCB0ZXh0dXJlTm9kZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl90ZXh0dXJlTm9kZTtcblxuXHR9XG5cblx0Z2V0IHRleHR1cmUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fdGV4dHVyZU5vZGUudmFsdWU7XG5cblx0fVxuXG5cdHVwZGF0ZSgpIHtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG5cdFx0Y29uc3QgaW1hZ2VzID0gdGV4dHVyZS5pbWFnZXM7XG5cdFx0Y29uc3QgaW1hZ2UgPSAoIGltYWdlcyAmJiBpbWFnZXMubGVuZ3RoID4gMCApID8gKCAoIGltYWdlc1sgMCBdICYmIGltYWdlc1sgMCBdLmltYWdlICkgfHwgaW1hZ2VzWyAwIF0gKSA6IHRleHR1cmUuaW1hZ2U7XG5cblx0XHRpZiAoIGltYWdlICYmIGltYWdlLndpZHRoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW1hZ2U7XG5cblx0XHRcdHRoaXMudmFsdWUgPSBNYXRoLmxvZzIoIE1hdGgubWF4KCB3aWR0aCwgaGVpZ2h0ICkgKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWF4TWlwTGV2ZWxOb2RlO1xuXG5leHBvcnQgY29uc3QgbWF4TWlwTGV2ZWwgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF4TWlwTGV2ZWxOb2RlICk7XG4iLCJpbXBvcnQgVW5pZm9ybU5vZGUsIHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xuaW1wb3J0IHsgdXYgfSBmcm9tICcuL1VWLmpzJztcbmltcG9ydCB7IHRleHR1cmVTaXplIH0gZnJvbSAnLi9UZXh0dXJlU2l6ZU5vZGUuanMnO1xuaW1wb3J0IHsgY29sb3JTcGFjZVRvV29ya2luZyB9IGZyb20gJy4uL2Rpc3BsYXkvQ29sb3JTcGFjZU5vZGUuanMnO1xuaW1wb3J0IHsgZXhwcmVzc2lvbiB9IGZyb20gJy4uL2NvZGUvRXhwcmVzc2lvbk5vZGUuanMnO1xuaW1wb3J0IHsgbWF4TWlwTGV2ZWwgfSBmcm9tICcuLi91dGlscy9NYXhNaXBMZXZlbE5vZGUuanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5LCB2ZWMzLCBub2RlT2JqZWN0LCBpbnQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcblxuaW1wb3J0IHsgSW50VHlwZSwgVW5zaWduZWRJbnRUeXBlIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcblxuY2xhc3MgVGV4dHVyZU5vZGUgZXh0ZW5kcyBVbmlmb3JtTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdUZXh0dXJlTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCB2YWx1ZSwgdXZOb2RlID0gbnVsbCwgbGV2ZWxOb2RlID0gbnVsbCwgYmlhc05vZGUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoIHZhbHVlICk7XG5cblx0XHR0aGlzLmlzVGV4dHVyZU5vZGUgPSB0cnVlO1xuXG5cdFx0dGhpcy51dk5vZGUgPSB1dk5vZGU7XG5cdFx0dGhpcy5sZXZlbE5vZGUgPSBsZXZlbE5vZGU7XG5cdFx0dGhpcy5iaWFzTm9kZSA9IGJpYXNOb2RlO1xuXHRcdHRoaXMuY29tcGFyZU5vZGUgPSBudWxsO1xuXHRcdHRoaXMuZGVwdGhOb2RlID0gbnVsbDtcblx0XHR0aGlzLmdyYWROb2RlID0gbnVsbDtcblxuXHRcdHRoaXMuc2FtcGxlciA9IHRydWU7XG5cdFx0dGhpcy51cGRhdGVNYXRyaXggPSBmYWxzZTtcblx0XHR0aGlzLnVwZGF0ZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5OT05FO1xuXG5cdFx0dGhpcy5yZWZlcmVuY2VOb2RlID0gbnVsbDtcblxuXHRcdHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cdFx0dGhpcy5fbWF0cml4VW5pZm9ybSA9IG51bGw7XG5cblx0XHR0aGlzLnNldFVwZGF0ZU1hdHJpeCggdXZOb2RlID09PSBudWxsICk7XG5cblx0fVxuXG5cdHNldCB2YWx1ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMucmVmZXJlbmNlTm9kZSApIHtcblxuXHRcdFx0dGhpcy5yZWZlcmVuY2VOb2RlLnZhbHVlID0gdmFsdWU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRnZXQgdmFsdWUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yZWZlcmVuY2VOb2RlID8gdGhpcy5yZWZlcmVuY2VOb2RlLnZhbHVlIDogdGhpcy5fdmFsdWU7XG5cblx0fVxuXG5cdGdldFVuaWZvcm1IYXNoKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdHJldHVybiB0aGlzLnZhbHVlLnV1aWQ7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdGlmICggdGhpcy52YWx1ZS5pc0RlcHRoVGV4dHVyZSA9PT0gdHJ1ZSApIHJldHVybiAnZmxvYXQnO1xuXG5cdFx0aWYgKCB0aGlzLnZhbHVlLnR5cGUgPT09IFVuc2lnbmVkSW50VHlwZSApIHtcblxuXHRcdFx0cmV0dXJuICd1dmVjNCc7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLnZhbHVlLnR5cGUgPT09IEludFR5cGUgKSB7XG5cblx0XHRcdHJldHVybiAnaXZlYzQnO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuICd2ZWM0JztcblxuXHR9XG5cblx0Z2V0SW5wdXRUeXBlKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdHJldHVybiAndGV4dHVyZSc7XG5cblx0fVxuXG5cdGdldERlZmF1bHRVVigpIHtcblxuXHRcdHJldHVybiB1diggdGhpcy52YWx1ZS5jaGFubmVsICk7XG5cblx0fVxuXG5cdHVwZGF0ZVJlZmVyZW5jZSggLypzdGF0ZSovICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cblx0fVxuXG5cdGdldFRyYW5zZm9ybWVkVVYoIHV2Tm9kZSApIHtcblxuXHRcdGlmICggdGhpcy5fbWF0cml4VW5pZm9ybSA9PT0gbnVsbCApIHRoaXMuX21hdHJpeFVuaWZvcm0gPSB1bmlmb3JtKCB0aGlzLnZhbHVlLm1hdHJpeCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeFVuaWZvcm0ubXVsKCB2ZWMzKCB1dk5vZGUsIDEgKSApLnh5O1xuXG5cdH1cblxuXHRzZXRVcGRhdGVNYXRyaXgoIHZhbHVlICkge1xuXG5cdFx0dGhpcy51cGRhdGVNYXRyaXggPSB2YWx1ZTtcblx0XHR0aGlzLnVwZGF0ZVR5cGUgPSB2YWx1ZSA/IE5vZGVVcGRhdGVUeXBlLkZSQU1FIDogTm9kZVVwZGF0ZVR5cGUuTk9ORTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXR1cFVWKCBidWlsZGVyLCB1dk5vZGUgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlID0gdGhpcy52YWx1ZTtcblxuXHRcdGlmICggYnVpbGRlci5pc0ZsaXBZKCkgJiYgKCAoIHRleHR1cmUuaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCAmJiB0ZXh0dXJlLmZsaXBZID09PSB0cnVlICkgfHwgdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09IHRydWUgfHwgdGV4dHVyZS5pc0ZyYW1lYnVmZmVyVGV4dHVyZSA9PT0gdHJ1ZSB8fCB0ZXh0dXJlLmlzRGVwdGhUZXh0dXJlID09PSB0cnVlICkgKSB7XG5cblx0XHRcdGlmICggdGhpcy5zYW1wbGVyICkge1xuXG5cdFx0XHRcdHV2Tm9kZSA9IHV2Tm9kZS5mbGlwWSgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHV2Tm9kZSA9IHV2Tm9kZS5zZXRZKCBpbnQoIHRleHR1cmVTaXplKCB0aGlzLCB0aGlzLmxldmVsTm9kZSApLnkgKS5zdWIoIHV2Tm9kZS55ICkuc3ViKCAxICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHV2Tm9kZTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBwcm9wZXJ0aWVzID0gYnVpbGRlci5nZXROb2RlUHJvcGVydGllcyggdGhpcyApO1xuXHRcdHByb3BlcnRpZXMucmVmZXJlbmNlTm9kZSA9IHRoaXMucmVmZXJlbmNlTm9kZTtcblxuXHRcdC8vXG5cblx0XHRsZXQgdXZOb2RlID0gdGhpcy51dk5vZGU7XG5cblx0XHRpZiAoICggdXZOb2RlID09PSBudWxsIHx8IGJ1aWxkZXIuY29udGV4dC5mb3JjZVVWQ29udGV4dCA9PT0gdHJ1ZSApICYmIGJ1aWxkZXIuY29udGV4dC5nZXRVViApIHtcblxuXHRcdFx0dXZOb2RlID0gYnVpbGRlci5jb250ZXh0LmdldFVWKCB0aGlzICk7XG5cblx0XHR9XG5cblx0XHRpZiAoICEgdXZOb2RlICkgdXZOb2RlID0gdGhpcy5nZXREZWZhdWx0VVYoKTtcblxuXHRcdGlmICggdGhpcy51cGRhdGVNYXRyaXggPT09IHRydWUgKSB7XG5cblx0XHRcdHV2Tm9kZSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRVViggdXZOb2RlICk7XG5cblx0XHR9XG5cblx0XHR1dk5vZGUgPSB0aGlzLnNldHVwVVYoIGJ1aWxkZXIsIHV2Tm9kZSApO1xuXG5cdFx0Ly9cblxuXHRcdGxldCBsZXZlbE5vZGUgPSB0aGlzLmxldmVsTm9kZTtcblxuXHRcdGlmICggbGV2ZWxOb2RlID09PSBudWxsICYmIGJ1aWxkZXIuY29udGV4dC5nZXRUZXh0dXJlTGV2ZWwgKSB7XG5cblx0XHRcdGxldmVsTm9kZSA9IGJ1aWxkZXIuY29udGV4dC5nZXRUZXh0dXJlTGV2ZWwoIHRoaXMgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRwcm9wZXJ0aWVzLnV2Tm9kZSA9IHV2Tm9kZTtcblx0XHRwcm9wZXJ0aWVzLmxldmVsTm9kZSA9IGxldmVsTm9kZTtcblx0XHRwcm9wZXJ0aWVzLmJpYXNOb2RlID0gdGhpcy5iaWFzTm9kZTtcblx0XHRwcm9wZXJ0aWVzLmNvbXBhcmVOb2RlID0gdGhpcy5jb21wYXJlTm9kZTtcblx0XHRwcm9wZXJ0aWVzLmdyYWROb2RlID0gdGhpcy5ncmFkTm9kZTtcblx0XHRwcm9wZXJ0aWVzLmRlcHRoTm9kZSA9IHRoaXMuZGVwdGhOb2RlO1xuXG5cdH1cblxuXHRnZW5lcmF0ZVVWKCBidWlsZGVyLCB1dk5vZGUgKSB7XG5cblx0XHRyZXR1cm4gdXZOb2RlLmJ1aWxkKCBidWlsZGVyLCB0aGlzLnNhbXBsZXIgPT09IHRydWUgPyAndmVjMicgOiAnaXZlYzInICk7XG5cblx0fVxuXG5cdGdlbmVyYXRlU25pcHBldCggYnVpbGRlciwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGxldmVsU25pcHBldCwgYmlhc1NuaXBwZXQsIGRlcHRoU25pcHBldCwgY29tcGFyZVNuaXBwZXQsIGdyYWRTbmlwcGV0ICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IHRoaXMudmFsdWU7XG5cblx0XHRsZXQgc25pcHBldDtcblxuXHRcdGlmICggbGV2ZWxTbmlwcGV0ICkge1xuXG5cdFx0XHRzbmlwcGV0ID0gYnVpbGRlci5nZW5lcmF0ZVRleHR1cmVMZXZlbCggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGxldmVsU25pcHBldCwgZGVwdGhTbmlwcGV0ICk7XG5cblx0XHR9IGVsc2UgaWYgKCBiaWFzU25pcHBldCApIHtcblxuXHRcdFx0c25pcHBldCA9IGJ1aWxkZXIuZ2VuZXJhdGVUZXh0dXJlQmlhcyggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGJpYXNTbmlwcGV0LCBkZXB0aFNuaXBwZXQgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGdyYWRTbmlwcGV0ICkge1xuXG5cdFx0XHRzbmlwcGV0ID0gYnVpbGRlci5nZW5lcmF0ZVRleHR1cmVHcmFkKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgZ3JhZFNuaXBwZXQsIGRlcHRoU25pcHBldCApO1xuXG5cdFx0fSBlbHNlIGlmICggY29tcGFyZVNuaXBwZXQgKSB7XG5cblx0XHRcdHNuaXBwZXQgPSBidWlsZGVyLmdlbmVyYXRlVGV4dHVyZUNvbXBhcmUoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBjb21wYXJlU25pcHBldCwgZGVwdGhTbmlwcGV0ICk7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLnNhbXBsZXIgPT09IGZhbHNlICkge1xuXG5cdFx0XHRzbmlwcGV0ID0gYnVpbGRlci5nZW5lcmF0ZVRleHR1cmVMb2FkKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgZGVwdGhTbmlwcGV0ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzbmlwcGV0ID0gYnVpbGRlci5nZW5lcmF0ZVRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBkZXB0aFNuaXBwZXQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBzbmlwcGV0O1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xuXG5cdFx0Y29uc3QgcHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLnZhbHVlO1xuXG5cdFx0aWYgKCAhIHRleHR1cmUgfHwgdGV4dHVyZS5pc1RleHR1cmUgIT09IHRydWUgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RleHR1cmVOb2RlOiBOZWVkIGEgdGhyZWUuanMgdGV4dHVyZS4nICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydHkgPSBzdXBlci5nZW5lcmF0ZSggYnVpbGRlciwgJ3Byb3BlcnR5JyApO1xuXG5cdFx0aWYgKCBvdXRwdXQgPT09ICdzYW1wbGVyJyApIHtcblxuXHRcdFx0cmV0dXJuIHRleHR1cmVQcm9wZXJ0eSArICdfc2FtcGxlcic7XG5cblx0XHR9IGVsc2UgaWYgKCBidWlsZGVyLmlzUmVmZXJlbmNlKCBvdXRwdXQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRleHR1cmVQcm9wZXJ0eTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IG5vZGVEYXRhID0gYnVpbGRlci5nZXREYXRhRnJvbU5vZGUoIHRoaXMgKTtcblxuXHRcdFx0bGV0IHByb3BlcnR5TmFtZSA9IG5vZGVEYXRhLnByb3BlcnR5TmFtZTtcblxuXHRcdFx0aWYgKCBwcm9wZXJ0eU5hbWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zdCB7IHV2Tm9kZSwgbGV2ZWxOb2RlLCBiaWFzTm9kZSwgY29tcGFyZU5vZGUsIGRlcHRoTm9kZSwgZ3JhZE5vZGUgfSA9IHByb3BlcnRpZXM7XG5cblx0XHRcdFx0Y29uc3QgdXZTbmlwcGV0ID0gdGhpcy5nZW5lcmF0ZVVWKCBidWlsZGVyLCB1dk5vZGUgKTtcblx0XHRcdFx0Y29uc3QgbGV2ZWxTbmlwcGV0ID0gbGV2ZWxOb2RlID8gbGV2ZWxOb2RlLmJ1aWxkKCBidWlsZGVyLCAnZmxvYXQnICkgOiBudWxsO1xuXHRcdFx0XHRjb25zdCBiaWFzU25pcHBldCA9IGJpYXNOb2RlID8gYmlhc05vZGUuYnVpbGQoIGJ1aWxkZXIsICdmbG9hdCcgKSA6IG51bGw7XG5cdFx0XHRcdGNvbnN0IGRlcHRoU25pcHBldCA9IGRlcHRoTm9kZSA/IGRlcHRoTm9kZS5idWlsZCggYnVpbGRlciwgJ2ludCcgKSA6IG51bGw7XG5cdFx0XHRcdGNvbnN0IGNvbXBhcmVTbmlwcGV0ID0gY29tcGFyZU5vZGUgPyBjb21wYXJlTm9kZS5idWlsZCggYnVpbGRlciwgJ2Zsb2F0JyApIDogbnVsbDtcblx0XHRcdFx0Y29uc3QgZ3JhZFNuaXBwZXQgPSBncmFkTm9kZSA/IFsgZ3JhZE5vZGVbIDAgXS5idWlsZCggYnVpbGRlciwgJ3ZlYzInICksIGdyYWROb2RlWyAxIF0uYnVpbGQoIGJ1aWxkZXIsICd2ZWMyJyApIF0gOiBudWxsO1xuXG5cdFx0XHRcdGNvbnN0IG5vZGVWYXIgPSBidWlsZGVyLmdldFZhckZyb21Ob2RlKCB0aGlzICk7XG5cblx0XHRcdFx0cHJvcGVydHlOYW1lID0gYnVpbGRlci5nZXRQcm9wZXJ0eU5hbWUoIG5vZGVWYXIgKTtcblxuXHRcdFx0XHRjb25zdCBzbmlwcGV0ID0gdGhpcy5nZW5lcmF0ZVNuaXBwZXQoIGJ1aWxkZXIsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBsZXZlbFNuaXBwZXQsIGJpYXNTbmlwcGV0LCBkZXB0aFNuaXBwZXQsIGNvbXBhcmVTbmlwcGV0LCBncmFkU25pcHBldCApO1xuXG5cdFx0XHRcdGJ1aWxkZXIuYWRkTGluZUZsb3dDb2RlKCBgJHtwcm9wZXJ0eU5hbWV9ID0gJHtzbmlwcGV0fWAsIHRoaXMgKTtcblxuXHRcdFx0XHRub2RlRGF0YS5zbmlwcGV0ID0gc25pcHBldDtcblx0XHRcdFx0bm9kZURhdGEucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBzbmlwcGV0ID0gcHJvcGVydHlOYW1lO1xuXHRcdFx0Y29uc3Qgbm9kZVR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0XHRcdGlmICggYnVpbGRlci5uZWVkc1RvV29ya2luZ0NvbG9yU3BhY2UoIHRleHR1cmUgKSApIHtcblxuXHRcdFx0XHRzbmlwcGV0ID0gY29sb3JTcGFjZVRvV29ya2luZyggZXhwcmVzc2lvbiggc25pcHBldCwgbm9kZVR5cGUgKSwgdGV4dHVyZS5jb2xvclNwYWNlICkuc2V0dXAoIGJ1aWxkZXIgKS5idWlsZCggYnVpbGRlciwgbm9kZVR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIHNuaXBwZXQsIG5vZGVUeXBlLCBvdXRwdXQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2V0U2FtcGxlciggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnNhbXBsZXIgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRTYW1wbGVyKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2FtcGxlcjtcblxuXHR9XG5cblx0Ly8gQFRPRE86IE1vdmUgdG8gVFNMXG5cblx0dXYoIHV2Tm9kZSApIHtcblxuXHRcdGNvbnN0IHRleHR1cmVOb2RlID0gdGhpcy5jbG9uZSgpO1xuXHRcdHRleHR1cmVOb2RlLnV2Tm9kZSA9IG5vZGVPYmplY3QoIHV2Tm9kZSApO1xuXHRcdHRleHR1cmVOb2RlLnJlZmVyZW5jZU5vZGUgPSB0aGlzLmdldFNlbGYoKTtcblxuXHRcdHJldHVybiBub2RlT2JqZWN0KCB0ZXh0dXJlTm9kZSApO1xuXG5cdH1cblxuXHRibHVyKCBhbW91bnROb2RlICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZU5vZGUgPSB0aGlzLmNsb25lKCk7XG5cdFx0dGV4dHVyZU5vZGUuYmlhc05vZGUgPSBub2RlT2JqZWN0KCBhbW91bnROb2RlICkubXVsKCBtYXhNaXBMZXZlbCggdGV4dHVyZU5vZGUgKSApO1xuXHRcdHRleHR1cmVOb2RlLnJlZmVyZW5jZU5vZGUgPSB0aGlzLmdldFNlbGYoKTtcblxuXHRcdHJldHVybiBub2RlT2JqZWN0KCB0ZXh0dXJlTm9kZSApO1xuXG5cdH1cblxuXHRsZXZlbCggbGV2ZWxOb2RlICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZU5vZGUgPSB0aGlzLmNsb25lKCk7XG5cdFx0dGV4dHVyZU5vZGUubGV2ZWxOb2RlID0gbm9kZU9iamVjdCggbGV2ZWxOb2RlICk7XG5cdFx0dGV4dHVyZU5vZGUucmVmZXJlbmNlTm9kZSA9IHRoaXMuZ2V0U2VsZigpO1xuXG5cdFx0cmV0dXJuIG5vZGVPYmplY3QoIHRleHR1cmVOb2RlICk7XG5cblx0fVxuXG5cdHNpemUoIGxldmVsTm9kZSApIHtcblxuXHRcdHJldHVybiB0ZXh0dXJlU2l6ZSggdGhpcywgbGV2ZWxOb2RlICk7XG5cblx0fVxuXG5cdGJpYXMoIGJpYXNOb2RlICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZU5vZGUgPSB0aGlzLmNsb25lKCk7XG5cdFx0dGV4dHVyZU5vZGUuYmlhc05vZGUgPSBub2RlT2JqZWN0KCBiaWFzTm9kZSApO1xuXHRcdHRleHR1cmVOb2RlLnJlZmVyZW5jZU5vZGUgPSB0aGlzLmdldFNlbGYoKTtcblxuXHRcdHJldHVybiBub2RlT2JqZWN0KCB0ZXh0dXJlTm9kZSApO1xuXG5cdH1cblxuXHRjb21wYXJlKCBjb21wYXJlTm9kZSApIHtcblxuXHRcdGNvbnN0IHRleHR1cmVOb2RlID0gdGhpcy5jbG9uZSgpO1xuXHRcdHRleHR1cmVOb2RlLmNvbXBhcmVOb2RlID0gbm9kZU9iamVjdCggY29tcGFyZU5vZGUgKTtcblx0XHR0ZXh0dXJlTm9kZS5yZWZlcmVuY2VOb2RlID0gdGhpcy5nZXRTZWxmKCk7XG5cblx0XHRyZXR1cm4gbm9kZU9iamVjdCggdGV4dHVyZU5vZGUgKTtcblxuXHR9XG5cblx0Z3JhZCggZ3JhZE5vZGVYLCBncmFkTm9kZVkgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlTm9kZSA9IHRoaXMuY2xvbmUoKTtcblx0XHR0ZXh0dXJlTm9kZS5ncmFkTm9kZSA9IFsgbm9kZU9iamVjdCggZ3JhZE5vZGVYICksIG5vZGVPYmplY3QoIGdyYWROb2RlWSApIF07XG5cdFx0dGV4dHVyZU5vZGUucmVmZXJlbmNlTm9kZSA9IHRoaXMuZ2V0U2VsZigpO1xuXG5cdFx0cmV0dXJuIG5vZGVPYmplY3QoIHRleHR1cmVOb2RlICk7XG5cblx0fVxuXG5cdGRlcHRoKCBkZXB0aE5vZGUgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlTm9kZSA9IHRoaXMuY2xvbmUoKTtcblx0XHR0ZXh0dXJlTm9kZS5kZXB0aE5vZGUgPSBub2RlT2JqZWN0KCBkZXB0aE5vZGUgKTtcblx0XHR0ZXh0dXJlTm9kZS5yZWZlcmVuY2VOb2RlID0gdGhpcy5nZXRTZWxmKCk7XG5cblx0XHRyZXR1cm4gbm9kZU9iamVjdCggdGV4dHVyZU5vZGUgKTtcblxuXHR9XG5cblx0Ly8gLS1cblxuXHRzZXJpYWxpemUoIGRhdGEgKSB7XG5cblx0XHRzdXBlci5zZXJpYWxpemUoIGRhdGEgKTtcblxuXHRcdGRhdGEudmFsdWUgPSB0aGlzLnZhbHVlLnRvSlNPTiggZGF0YS5tZXRhICkudXVpZDtcblx0XHRkYXRhLnNhbXBsZXIgPSB0aGlzLnNhbXBsZXI7XG5cdFx0ZGF0YS51cGRhdGVNYXRyaXggPSB0aGlzLnVwZGF0ZU1hdHJpeDtcblx0XHRkYXRhLnVwZGF0ZVR5cGUgPSB0aGlzLnVwZGF0ZVR5cGU7XG5cblx0fVxuXG5cdGRlc2VyaWFsaXplKCBkYXRhICkge1xuXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcblxuXHRcdHRoaXMudmFsdWUgPSBkYXRhLm1ldGEudGV4dHVyZXNbIGRhdGEudmFsdWUgXTtcblx0XHR0aGlzLnNhbXBsZXIgPSBkYXRhLnNhbXBsZXI7XG5cdFx0dGhpcy51cGRhdGVNYXRyaXggPSBkYXRhLnVwZGF0ZU1hdHJpeDtcblx0XHR0aGlzLnVwZGF0ZVR5cGUgPSBkYXRhLnVwZGF0ZVR5cGU7XG5cblx0fVxuXG5cdHVwZGF0ZSgpIHtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLnZhbHVlO1xuXHRcdGNvbnN0IG1hdHJpeFVuaWZvcm0gPSB0aGlzLl9tYXRyaXhVbmlmb3JtO1xuXG5cdFx0aWYgKCBtYXRyaXhVbmlmb3JtICE9PSBudWxsICkgbWF0cml4VW5pZm9ybS52YWx1ZSA9IHRleHR1cmUubWF0cml4O1xuXG5cdFx0aWYgKCB0ZXh0dXJlLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdHRleHR1cmUudXBkYXRlTWF0cml4KCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0Y29uc3QgbmV3Tm9kZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnZhbHVlLCB0aGlzLnV2Tm9kZSwgdGhpcy5sZXZlbE5vZGUsIHRoaXMuYmlhc05vZGUgKTtcblx0XHRuZXdOb2RlLnNhbXBsZXIgPSB0aGlzLnNhbXBsZXI7XG5cblx0XHRyZXR1cm4gbmV3Tm9kZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dHVyZU5vZGU7XG5cbmV4cG9ydCBjb25zdCB0ZXh0dXJlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFRleHR1cmVOb2RlICk7XG5leHBvcnQgY29uc3QgdGV4dHVyZUxvYWQgPSAoIC4uLnBhcmFtcyApID0+IHRleHR1cmUoIC4uLnBhcmFtcyApLnNldFNhbXBsZXIoIGZhbHNlICk7XG5cbi8vZXhwb3J0IGNvbnN0IHRleHR1cmVMZXZlbCA9ICggdmFsdWUsIHV2LCBsZXZlbCApID0+IHRleHR1cmUoIHZhbHVlLCB1diApLmxldmVsKCBsZXZlbCApO1xuXG5leHBvcnQgY29uc3Qgc2FtcGxlciA9ICggYVRleHR1cmUgKSA9PiAoIGFUZXh0dXJlLmlzTm9kZSA9PT0gdHJ1ZSA/IGFUZXh0dXJlIDogdGV4dHVyZSggYVRleHR1cmUgKSApLmNvbnZlcnQoICdzYW1wbGVyJyApO1xuIiwiaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xuaW1wb3J0IHsgcmVuZGVyR3JvdXAgfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Hcm91cE5vZGUuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XG5cbmV4cG9ydCBjb25zdCBjYW1lcmFOZWFyID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCAnZmxvYXQnICkubGFiZWwoICdjYW1lcmFOZWFyJyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApLm9uUmVuZGVyVXBkYXRlKCAoIHsgY2FtZXJhIH0gKSA9PiBjYW1lcmEubmVhciApO1xuZXhwb3J0IGNvbnN0IGNhbWVyYUZhciA9IC8qQF9fUFVSRV9fKi8gdW5pZm9ybSggJ2Zsb2F0JyApLmxhYmVsKCAnY2FtZXJhRmFyJyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApLm9uUmVuZGVyVXBkYXRlKCAoIHsgY2FtZXJhIH0gKSA9PiBjYW1lcmEuZmFyICk7XG5leHBvcnQgY29uc3QgY2FtZXJhUHJvamVjdGlvbk1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gdW5pZm9ybSggJ21hdDQnICkubGFiZWwoICdjYW1lcmFQcm9qZWN0aW9uTWF0cml4JyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApLm9uUmVuZGVyVXBkYXRlKCAoIHsgY2FtZXJhIH0gKSA9PiBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuZXhwb3J0IGNvbnN0IGNhbWVyYVByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCAnbWF0NCcgKS5sYWJlbCggJ2NhbWVyYVByb2plY3Rpb25NYXRyaXhJbnZlcnNlJyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApLm9uUmVuZGVyVXBkYXRlKCAoIHsgY2FtZXJhIH0gKSA9PiBjYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2UgKTtcbmV4cG9ydCBjb25zdCBjYW1lcmFWaWV3TWF0cml4ID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCAnbWF0NCcgKS5sYWJlbCggJ2NhbWVyYVZpZXdNYXRyaXgnICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICkub25SZW5kZXJVcGRhdGUoICggeyBjYW1lcmEgfSApID0+IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcbmV4cG9ydCBjb25zdCBjYW1lcmFXb3JsZE1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gdW5pZm9ybSggJ21hdDQnICkubGFiZWwoICdjYW1lcmFXb3JsZE1hdHJpeCcgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCB7IGNhbWVyYSB9ICkgPT4gY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5leHBvcnQgY29uc3QgY2FtZXJhTm9ybWFsTWF0cml4ID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCAnbWF0MycgKS5sYWJlbCggJ2NhbWVyYU5vcm1hbE1hdHJpeCcgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCB7IGNhbWVyYSB9ICkgPT4gY2FtZXJhLm5vcm1hbE1hdHJpeCApO1xuZXhwb3J0IGNvbnN0IGNhbWVyYVBvc2l0aW9uID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCBuZXcgVmVjdG9yMygpICkubGFiZWwoICdjYW1lcmFQb3NpdGlvbicgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCB7IGNhbWVyYSB9LCBzZWxmICkgPT4gc2VsZi52YWx1ZS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApICk7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgVW5pZm9ybU5vZGUgZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xuXG5jbGFzcyBPYmplY3QzRE5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ09iamVjdDNETm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBzY29wZSwgb2JqZWN0M2QgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuc2NvcGUgPSBzY29wZTtcblx0XHR0aGlzLm9iamVjdDNkID0gb2JqZWN0M2Q7XG5cblx0XHR0aGlzLnVwZGF0ZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5PQkpFQ1Q7XG5cblx0XHR0aGlzLl91bmlmb3JtTm9kZSA9IG5ldyBVbmlmb3JtTm9kZSggbnVsbCApO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSgpIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcblxuXHRcdGlmICggc2NvcGUgPT09IE9iamVjdDNETm9kZS5XT1JMRF9NQVRSSVggKSB7XG5cblx0XHRcdHJldHVybiAnbWF0NCc7XG5cblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gT2JqZWN0M0ROb2RlLlBPU0lUSU9OIHx8IHNjb3BlID09PSBPYmplY3QzRE5vZGUuVklFV19QT1NJVElPTiB8fCBzY29wZSA9PT0gT2JqZWN0M0ROb2RlLkRJUkVDVElPTiB8fCBzY29wZSA9PT0gT2JqZWN0M0ROb2RlLlNDQUxFICkge1xuXG5cdFx0XHRyZXR1cm4gJ3ZlYzMnO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGUoIGZyYW1lICkge1xuXG5cdFx0Y29uc3Qgb2JqZWN0ID0gdGhpcy5vYmplY3QzZDtcblx0XHRjb25zdCB1bmlmb3JtTm9kZSA9IHRoaXMuX3VuaWZvcm1Ob2RlO1xuXHRcdGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcblxuXHRcdGlmICggc2NvcGUgPT09IE9iamVjdDNETm9kZS5XT1JMRF9NQVRSSVggKSB7XG5cblx0XHRcdHVuaWZvcm1Ob2RlLnZhbHVlID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE9iamVjdDNETm9kZS5QT1NJVElPTiApIHtcblxuXHRcdFx0dW5pZm9ybU5vZGUudmFsdWUgPSB1bmlmb3JtTm9kZS52YWx1ZSB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHR1bmlmb3JtTm9kZS52YWx1ZS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE9iamVjdDNETm9kZS5TQ0FMRSApIHtcblxuXHRcdFx0dW5pZm9ybU5vZGUudmFsdWUgPSB1bmlmb3JtTm9kZS52YWx1ZSB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHR1bmlmb3JtTm9kZS52YWx1ZS5zZXRGcm9tTWF0cml4U2NhbGUoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE9iamVjdDNETm9kZS5ESVJFQ1RJT04gKSB7XG5cblx0XHRcdHVuaWZvcm1Ob2RlLnZhbHVlID0gdW5pZm9ybU5vZGUudmFsdWUgfHwgbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0b2JqZWN0LmdldFdvcmxkRGlyZWN0aW9uKCB1bmlmb3JtTm9kZS52YWx1ZSApO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE9iamVjdDNETm9kZS5WSUVXX1BPU0lUSU9OICkge1xuXG5cdFx0XHRjb25zdCBjYW1lcmEgPSBmcmFtZS5jYW1lcmE7XG5cblx0XHRcdHVuaWZvcm1Ob2RlLnZhbHVlID0gdW5pZm9ybU5vZGUudmFsdWUgfHwgbmV3IFZlY3RvcjMoKTtcblx0XHRcdHVuaWZvcm1Ob2RlLnZhbHVlLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdHVuaWZvcm1Ob2RlLnZhbHVlLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcblxuXHRcdGlmICggc2NvcGUgPT09IE9iamVjdDNETm9kZS5XT1JMRF9NQVRSSVggKSB7XG5cblx0XHRcdHRoaXMuX3VuaWZvcm1Ob2RlLm5vZGVUeXBlID0gJ21hdDQnO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE9iamVjdDNETm9kZS5QT1NJVElPTiB8fCBzY29wZSA9PT0gT2JqZWN0M0ROb2RlLlZJRVdfUE9TSVRJT04gfHwgc2NvcGUgPT09IE9iamVjdDNETm9kZS5ESVJFQ1RJT04gfHwgc2NvcGUgPT09IE9iamVjdDNETm9kZS5TQ0FMRSApIHtcblxuXHRcdFx0dGhpcy5fdW5pZm9ybU5vZGUubm9kZVR5cGUgPSAndmVjMyc7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fdW5pZm9ybU5vZGUuYnVpbGQoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0c2VyaWFsaXplKCBkYXRhICkge1xuXG5cdFx0c3VwZXIuc2VyaWFsaXplKCBkYXRhICk7XG5cblx0XHRkYXRhLnNjb3BlID0gdGhpcy5zY29wZTtcblxuXHR9XG5cblx0ZGVzZXJpYWxpemUoIGRhdGEgKSB7XG5cblx0XHRzdXBlci5kZXNlcmlhbGl6ZSggZGF0YSApO1xuXG5cdFx0dGhpcy5zY29wZSA9IGRhdGEuc2NvcGU7XG5cblx0fVxuXG59XG5cbk9iamVjdDNETm9kZS5XT1JMRF9NQVRSSVggPSAnd29ybGRNYXRyaXgnO1xuT2JqZWN0M0ROb2RlLlBPU0lUSU9OID0gJ3Bvc2l0aW9uJztcbk9iamVjdDNETm9kZS5TQ0FMRSA9ICdzY2FsZSc7XG5PYmplY3QzRE5vZGUuVklFV19QT1NJVElPTiA9ICd2aWV3UG9zaXRpb24nO1xuT2JqZWN0M0ROb2RlLkRJUkVDVElPTiA9ICdkaXJlY3Rpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBPYmplY3QzRE5vZGU7XG5cbmV4cG9ydCBjb25zdCBvYmplY3REaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT2JqZWN0M0ROb2RlLCBPYmplY3QzRE5vZGUuRElSRUNUSU9OICk7XG5leHBvcnQgY29uc3Qgb2JqZWN0V29ybGRNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT2JqZWN0M0ROb2RlLCBPYmplY3QzRE5vZGUuV09STERfTUFUUklYICk7XG5leHBvcnQgY29uc3Qgb2JqZWN0UG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT2JqZWN0M0ROb2RlLCBPYmplY3QzRE5vZGUuUE9TSVRJT04gKTtcbmV4cG9ydCBjb25zdCBvYmplY3RTY2FsZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPYmplY3QzRE5vZGUsIE9iamVjdDNETm9kZS5TQ0FMRSApO1xuZXhwb3J0IGNvbnN0IG9iamVjdFZpZXdQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPYmplY3QzRE5vZGUsIE9iamVjdDNETm9kZS5WSUVXX1BPU0lUSU9OICk7XG4iLCJpbXBvcnQgT2JqZWN0M0ROb2RlIGZyb20gJy4vT2JqZWN0M0ROb2RlLmpzJztcbmltcG9ydCB7IEZuLCBub2RlSW1tdXRhYmxlIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xuXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRyaXg0LmpzJztcbmltcG9ydCB7IGNhbWVyYVZpZXdNYXRyaXggfSBmcm9tICcuL0NhbWVyYS5qcyc7XG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRyaXgzLmpzJztcblxuY2xhc3MgTW9kZWxOb2RlIGV4dGVuZHMgT2JqZWN0M0ROb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ01vZGVsTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBzY29wZSApIHtcblxuXHRcdHN1cGVyKCBzY29wZSApO1xuXG5cdH1cblxuXHR1cGRhdGUoIGZyYW1lICkge1xuXG5cdFx0dGhpcy5vYmplY3QzZCA9IGZyYW1lLm9iamVjdDtcblxuXHRcdHN1cGVyLnVwZGF0ZSggZnJhbWUgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTW9kZWxOb2RlO1xuXG5leHBvcnQgY29uc3QgbW9kZWxEaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1vZGVsTm9kZSwgTW9kZWxOb2RlLkRJUkVDVElPTiApO1xuZXhwb3J0IGNvbnN0IG1vZGVsV29ybGRNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1vZGVsTm9kZSwgTW9kZWxOb2RlLldPUkxEX01BVFJJWCApO1xuZXhwb3J0IGNvbnN0IG1vZGVsUG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1vZGVsTm9kZSwgTW9kZWxOb2RlLlBPU0lUSU9OICk7XG5leHBvcnQgY29uc3QgbW9kZWxTY2FsZSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTW9kZWxOb2RlLCBNb2RlbE5vZGUuU0NBTEUgKTtcbmV4cG9ydCBjb25zdCBtb2RlbFZpZXdQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTW9kZWxOb2RlLCBNb2RlbE5vZGUuVklFV19QT1NJVElPTiApO1xuZXhwb3J0IGNvbnN0IG1vZGVsTm9ybWFsTWF0cml4ID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCBuZXcgTWF0cml4MygpICkub25PYmplY3RVcGRhdGUoICggeyBvYmplY3QgfSwgc2VsZiApID0+IHNlbGYudmFsdWUuZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubWF0cml4V29ybGQgKSApO1xuZXhwb3J0IGNvbnN0IG1vZGVsV29ybGRNYXRyaXhJbnZlcnNlID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCBuZXcgTWF0cml4NCgpICkub25PYmplY3RVcGRhdGUoICggeyBvYmplY3QgfSwgc2VsZiApID0+IHNlbGYudmFsdWUuY29weSggb2JqZWN0Lm1hdHJpeFdvcmxkICkuaW52ZXJ0KCkgKTtcbmV4cG9ydCBjb25zdCBtb2RlbFZpZXdNYXRyaXggPSAvKkBfX1BVUkVfXyovIGNhbWVyYVZpZXdNYXRyaXgubXVsKCBtb2RlbFdvcmxkTWF0cml4ICkudG9WYXIoICdtb2RlbFZpZXdNYXRyaXgnICk7XG5cbmV4cG9ydCBjb25zdCBoaWdoUHJlY2lzaW9uTW9kZWxWaWV3TWF0cml4ID0gLypAX19QVVJFX18qLyAoIEZuKCAoIGJ1aWxkZXIgKSA9PiB7XG5cblx0YnVpbGRlci5jb250ZXh0LmlzSGlnaFByZWNpc2lvbk1vZGVsVmlld01hdHJpeCA9IHRydWU7XG5cblx0cmV0dXJuIHVuaWZvcm0oICdtYXQ0JyApLm9uT2JqZWN0VXBkYXRlKCAoIHsgb2JqZWN0LCBjYW1lcmEgfSApID0+IHtcblxuXHRcdHJldHVybiBvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdH0gKTtcblxufSApLm9uY2UoKSApKCkudG9WYXIoICdoaWdoUHJlY2lzaW9uTW9kZWxWaWV3TWF0cml4JyApO1xuXG5leHBvcnQgY29uc3QgaGlnaFByZWNpc2lvbk1vZGVsTm9ybWFsVmlld01hdHJpeCA9IC8qQF9fUFVSRV9fKi8gKCBGbiggKCBidWlsZGVyICkgPT4ge1xuXG5cdGNvbnN0IGlzSGlnaFByZWNpc2lvbk1vZGVsVmlld01hdHJpeCA9IGJ1aWxkZXIuY29udGV4dC5pc0hpZ2hQcmVjaXNpb25Nb2RlbFZpZXdNYXRyaXg7XG5cblx0cmV0dXJuIHVuaWZvcm0oICdtYXQzJyApLm9uT2JqZWN0VXBkYXRlKCAoIHsgb2JqZWN0LCBjYW1lcmEgfSApID0+IHtcblxuXHRcdGlmICggaXNIaWdoUHJlY2lzaW9uTW9kZWxWaWV3TWF0cml4ICE9PSB0cnVlICkge1xuXG5cdFx0XHRvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iamVjdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XG5cblx0fSApO1xuXG59ICkub25jZSgpICkoKS50b1ZhciggJ2hpZ2hQcmVjaXNpb25Nb2RlbE5vcm1hbE1hdHJpeCcgKTtcbiIsImltcG9ydCB7IGF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQXR0cmlidXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBtb2RlbFdvcmxkTWF0cml4LCBtb2RlbFZpZXdNYXRyaXggfSBmcm9tICcuL01vZGVsTm9kZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBwb3NpdGlvbkdlb21ldHJ5ID0gLypAX19QVVJFX18qLyBhdHRyaWJ1dGUoICdwb3NpdGlvbicsICd2ZWMzJyApO1xuZXhwb3J0IGNvbnN0IHBvc2l0aW9uTG9jYWwgPSAvKkBfX1BVUkVfXyovIHBvc2l0aW9uR2VvbWV0cnkudmFyeWluZyggJ3Bvc2l0aW9uTG9jYWwnICk7XG5leHBvcnQgY29uc3QgcG9zaXRpb25QcmV2aW91cyA9IC8qQF9fUFVSRV9fKi8gcG9zaXRpb25HZW9tZXRyeS52YXJ5aW5nKCAncG9zaXRpb25QcmV2aW91cycgKTtcbmV4cG9ydCBjb25zdCBwb3NpdGlvbldvcmxkID0gLypAX19QVVJFX18qLyBtb2RlbFdvcmxkTWF0cml4Lm11bCggcG9zaXRpb25Mb2NhbCApLnh5ei52YXJ5aW5nKCAndl9wb3NpdGlvbldvcmxkJyApO1xuZXhwb3J0IGNvbnN0IHBvc2l0aW9uV29ybGREaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovIHBvc2l0aW9uTG9jYWwudHJhbnNmb3JtRGlyZWN0aW9uKCBtb2RlbFdvcmxkTWF0cml4ICkudmFyeWluZyggJ3ZfcG9zaXRpb25Xb3JsZERpcmVjdGlvbicgKS5ub3JtYWxpemUoKS50b1ZhciggJ3Bvc2l0aW9uV29ybGREaXJlY3Rpb24nICk7XG5leHBvcnQgY29uc3QgcG9zaXRpb25WaWV3ID0gLypAX19QVVJFX18qLyBtb2RlbFZpZXdNYXRyaXgubXVsKCBwb3NpdGlvbkxvY2FsICkueHl6LnZhcnlpbmcoICd2X3Bvc2l0aW9uVmlldycgKTtcbmV4cG9ydCBjb25zdCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovIHBvc2l0aW9uVmlldy5uZWdhdGUoKS52YXJ5aW5nKCAndl9wb3NpdGlvblZpZXdEaXJlY3Rpb24nICkubm9ybWFsaXplKCkudG9WYXIoICdwb3NpdGlvblZpZXdEaXJlY3Rpb24nICk7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xuaW1wb3J0IHsgbm9kZUltbXV0YWJsZSwgZmxvYXQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmltcG9ydCB7IEJhY2tTaWRlLCBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuXG5jbGFzcyBGcm9udEZhY2luZ05vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0Zyb250RmFjaW5nTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoICdib29sJyApO1xuXG5cdFx0dGhpcy5pc0Zyb250RmFjaW5nTm9kZSA9IHRydWU7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgeyByZW5kZXJlciwgbWF0ZXJpYWwgfSA9IGJ1aWxkZXI7XG5cblx0XHRpZiAoIHJlbmRlcmVyLmNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gJ2ZhbHNlJztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJ1aWxkZXIuZ2V0RnJvbnRGYWNpbmcoKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRnJvbnRGYWNpbmdOb2RlO1xuXG5leHBvcnQgY29uc3QgZnJvbnRGYWNpbmcgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIEZyb250RmFjaW5nTm9kZSApO1xuZXhwb3J0IGNvbnN0IGZhY2VEaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovIGZsb2F0KCBmcm9udEZhY2luZyApLm11bCggMi4wICkuc3ViKCAxLjAgKTtcbiIsImltcG9ydCB7IGF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQXR0cmlidXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBjYW1lcmFWaWV3TWF0cml4IH0gZnJvbSAnLi9DYW1lcmEuanMnO1xuaW1wb3J0IHsgbW9kZWxOb3JtYWxNYXRyaXgsIG1vZGVsV29ybGRNYXRyaXggfSBmcm9tICcuL01vZGVsTm9kZS5qcyc7XG5pbXBvcnQgeyBtYXQzLCB2ZWMzIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgcG9zaXRpb25WaWV3IH0gZnJvbSAnLi9Qb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBGbiwgdmFyeWluZyB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IGZhY2VEaXJlY3Rpb24gfSBmcm9tICcuLi9kaXNwbGF5L0Zyb250RmFjaW5nTm9kZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBub3JtYWxHZW9tZXRyeSA9IC8qQF9fUFVSRV9fKi8gYXR0cmlidXRlKCAnbm9ybWFsJywgJ3ZlYzMnICk7XG5cbmV4cG9ydCBjb25zdCBub3JtYWxMb2NhbCA9IC8qQF9fUFVSRV9fKi8gKCBGbiggKCBidWlsZGVyICkgPT4ge1xuXG5cdGlmICggYnVpbGRlci5nZW9tZXRyeS5oYXNBdHRyaWJ1dGUoICdub3JtYWwnICkgPT09IGZhbHNlICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVFNMLk5vcm1hbE5vZGU6IFZlcnRleCBhdHRyaWJ1dGUgXCJub3JtYWxcIiBub3QgZm91bmQgb24gZ2VvbWV0cnkuJyApO1xuXG5cdFx0cmV0dXJuIHZlYzMoIDAsIDEsIDAgKTtcblxuXHR9XG5cblx0cmV0dXJuIG5vcm1hbEdlb21ldHJ5O1xuXG59LCAndmVjMycgKS5vbmNlKCkgKSgpLnRvVmFyKCAnbm9ybWFsTG9jYWwnICk7XG5cbmV4cG9ydCBjb25zdCBub3JtYWxGbGF0ID0gLypAX19QVVJFX18qLyBwb3NpdGlvblZpZXcuZEZkeCgpLmNyb3NzKCBwb3NpdGlvblZpZXcuZEZkeSgpICkubm9ybWFsaXplKCkudG9WYXIoICdub3JtYWxGbGF0JyApO1xuXG5leHBvcnQgY29uc3Qgbm9ybWFsVmlldyA9IC8qQF9fUFVSRV9fKi8gKCBGbiggKCBidWlsZGVyICkgPT4ge1xuXG5cdGxldCBub2RlO1xuXG5cdGlmICggYnVpbGRlci5tYXRlcmlhbC5mbGF0U2hhZGluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdG5vZGUgPSBub3JtYWxGbGF0O1xuXG5cdH0gZWxzZSB7XG5cblx0XHRub2RlID0gdmFyeWluZyggdHJhbnNmb3JtTm9ybWFsVG9WaWV3KCBub3JtYWxMb2NhbCApLCAndl9ub3JtYWxWaWV3JyApLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRyZXR1cm4gbm9kZTtcblxufSwgJ3ZlYzMnICkub25jZSgpICkoKS50b1ZhciggJ25vcm1hbFZpZXcnICk7XG5cbmV4cG9ydCBjb25zdCBub3JtYWxXb3JsZCA9IC8qQF9fUFVSRV9fKi8gdmFyeWluZyggbm9ybWFsVmlldy50cmFuc2Zvcm1EaXJlY3Rpb24oIGNhbWVyYVZpZXdNYXRyaXggKSwgJ3Zfbm9ybWFsV29ybGQnICkubm9ybWFsaXplKCkudG9WYXIoICdub3JtYWxXb3JsZCcgKTtcblxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybWVkTm9ybWFsVmlldyA9IC8qQF9fUFVSRV9fKi8gKCBGbiggKCBidWlsZGVyICkgPT4ge1xuXG5cdHJldHVybiBidWlsZGVyLmNvbnRleHQuc2V0dXBOb3JtYWwoKTtcblxufSwgJ3ZlYzMnICkub25jZSgpICkoKS5tdWwoIGZhY2VEaXJlY3Rpb24gKS50b1ZhciggJ3RyYW5zZm9ybWVkTm9ybWFsVmlldycgKTtcblxuXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtZWROb3JtYWxXb3JsZCA9IC8qQF9fUFVSRV9fKi8gdHJhbnNmb3JtZWROb3JtYWxWaWV3LnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhVmlld01hdHJpeCApLnRvVmFyKCAndHJhbnNmb3JtZWROb3JtYWxXb3JsZCcgKTtcblxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybWVkQ2xlYXJjb2F0Tm9ybWFsVmlldyA9IC8qQF9fUFVSRV9fKi8gKCBGbiggKCBidWlsZGVyICkgPT4ge1xuXG5cdHJldHVybiBidWlsZGVyLmNvbnRleHQuc2V0dXBDbGVhcmNvYXROb3JtYWwoKTtcblxufSwgJ3ZlYzMnICkub25jZSgpICkoKS5tdWwoIGZhY2VEaXJlY3Rpb24gKS50b1ZhciggJ3RyYW5zZm9ybWVkQ2xlYXJjb2F0Tm9ybWFsVmlldycgKTtcblxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybU5vcm1hbCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBub3JtYWwsIG1hdHJpeCA9IG1vZGVsV29ybGRNYXRyaXggXSApID0+IHtcblxuXHRjb25zdCBtID0gbWF0MyggbWF0cml4ICk7XG5cblx0Y29uc3QgdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWwuZGl2KCB2ZWMzKCBtWyAwIF0uZG90KCBtWyAwIF0gKSwgbVsgMSBdLmRvdCggbVsgMSBdICksIG1bIDIgXS5kb3QoIG1bIDIgXSApICkgKTtcblxuXHRyZXR1cm4gbS5tdWwoIHRyYW5zZm9ybWVkTm9ybWFsICkueHl6O1xuXG59ICk7XG5cbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1Ob3JtYWxUb1ZpZXcgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgbm9ybWFsIF0sIGJ1aWxkZXIgKSA9PiB7XG5cblx0Y29uc3QgbW9kZWxOb3JtYWxWaWV3TWF0cml4ID0gYnVpbGRlci5yZW5kZXJlci5ub2Rlcy5tb2RlbE5vcm1hbFZpZXdNYXRyaXg7XG5cblx0aWYgKCBtb2RlbE5vcm1hbFZpZXdNYXRyaXggIT09IG51bGwgKSB7XG5cblx0XHRyZXR1cm4gbW9kZWxOb3JtYWxWaWV3TWF0cml4LnRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsICk7XG5cblx0fVxuXG5cdC8vXG5cblx0Y29uc3QgdHJhbnNmb3JtZWROb3JtYWwgPSBtb2RlbE5vcm1hbE1hdHJpeC5tdWwoIG5vcm1hbCApO1xuXG5cdHJldHVybiBjYW1lcmFWaWV3TWF0cml4LnRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwgKTtcblxufSApO1xuIiwiaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xuXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxSZWZyYWN0aW9uUmF0aW8gPSAvKkBfX1BVUkVfXyovIHVuaWZvcm0oIDAgKS5vblJlZmVyZW5jZSggKCB7IG1hdGVyaWFsIH0gKSA9PiBtYXRlcmlhbCApLm9uUmVuZGVyVXBkYXRlKCAoIHsgbWF0ZXJpYWwgfSApID0+IG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbyApO1xuIiwiaW1wb3J0IHsgY2FtZXJhVmlld01hdHJpeCB9IGZyb20gJy4vQ2FtZXJhLmpzJztcbmltcG9ydCB7IHRyYW5zZm9ybWVkTm9ybWFsVmlldyB9IGZyb20gJy4vTm9ybWFsLmpzJztcbmltcG9ydCB7IHBvc2l0aW9uVmlld0RpcmVjdGlvbiB9IGZyb20gJy4vUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgbWF0ZXJpYWxSZWZyYWN0aW9uUmF0aW8gfSBmcm9tICcuL01hdGVyaWFsUHJvcGVydGllcy5qcyc7XG5cbmV4cG9ydCBjb25zdCByZWZsZWN0VmlldyA9IC8qQF9fUFVSRV9fKi8gcG9zaXRpb25WaWV3RGlyZWN0aW9uLm5lZ2F0ZSgpLnJlZmxlY3QoIHRyYW5zZm9ybWVkTm9ybWFsVmlldyApO1xuZXhwb3J0IGNvbnN0IHJlZnJhY3RWaWV3ID0gLypAX19QVVJFX18qLyBwb3NpdGlvblZpZXdEaXJlY3Rpb24ubmVnYXRlKCkucmVmcmFjdCggdHJhbnNmb3JtZWROb3JtYWxWaWV3LCBtYXRlcmlhbFJlZnJhY3Rpb25SYXRpbyApO1xuXG5leHBvcnQgY29uc3QgcmVmbGVjdFZlY3RvciA9IC8qQF9fUFVSRV9fKi8gcmVmbGVjdFZpZXcudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmFWaWV3TWF0cml4ICkudG9WYXIoICdyZWZsZWN0VmVjdG9yJyApO1xuZXhwb3J0IGNvbnN0IHJlZnJhY3RWZWN0b3IgPSAvKkBfX1BVUkVfXyovIHJlZnJhY3RWaWV3LnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhVmlld01hdHJpeCApLnRvVmFyKCAncmVmbGVjdFZlY3RvcicgKTtcbiIsImltcG9ydCBUZXh0dXJlTm9kZSBmcm9tICcuL1RleHR1cmVOb2RlLmpzJztcbmltcG9ydCB7IHJlZmxlY3RWZWN0b3IsIHJlZnJhY3RWZWN0b3IgfSBmcm9tICcuL1JlZmxlY3RWZWN0b3IuanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5LCB2ZWMzIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5pbXBvcnQgeyBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsIEN1YmVSZWZyYWN0aW9uTWFwcGluZywgV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbmNsYXNzIEN1YmVUZXh0dXJlTm9kZSBleHRlbmRzIFRleHR1cmVOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0N1YmVUZXh0dXJlTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCB2YWx1ZSwgdXZOb2RlID0gbnVsbCwgbGV2ZWxOb2RlID0gbnVsbCwgYmlhc05vZGUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoIHZhbHVlLCB1dk5vZGUsIGxldmVsTm9kZSwgYmlhc05vZGUgKTtcblxuXHRcdHRoaXMuaXNDdWJlVGV4dHVyZU5vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRnZXRJbnB1dFR5cGUoIC8qYnVpbGRlciovICkge1xuXG5cdFx0cmV0dXJuICdjdWJlVGV4dHVyZSc7XG5cblx0fVxuXG5cdGdldERlZmF1bHRVVigpIHtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLnZhbHVlO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLm1hcHBpbmcgPT09IEN1YmVSZWZsZWN0aW9uTWFwcGluZyApIHtcblxuXHRcdFx0cmV0dXJuIHJlZmxlY3RWZWN0b3I7XG5cblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLm1hcHBpbmcgPT09IEN1YmVSZWZyYWN0aW9uTWFwcGluZyApIHtcblxuXHRcdFx0cmV0dXJuIHJlZnJhY3RWZWN0b3I7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQ3ViZVRleHR1cmVOb2RlOiBNYXBwaW5nIFwiJXNcIiBub3Qgc3VwcG9ydGVkLicsIHRleHR1cmUubWFwcGluZyApO1xuXG5cdFx0XHRyZXR1cm4gdmVjMyggMCwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXRVcGRhdGVNYXRyaXgoIC8qdXBkYXRlTWF0cml4Ki8gKSB7IH0gLy8gSWdub3JlIC51cGRhdGVNYXRyaXggZm9yIEN1YmVUZXh0dXJlTm9kZVxuXG5cdHNldHVwVVYoIGJ1aWxkZXIsIHV2Tm9kZSApIHtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLnZhbHVlO1xuXG5cdFx0aWYgKCBidWlsZGVyLnJlbmRlcmVyLmNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gfHwgISB0ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSApIHtcblxuXHRcdFx0cmV0dXJuIHZlYzMoIHV2Tm9kZS54Lm5lZ2F0ZSgpLCB1dk5vZGUueXogKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiB1dk5vZGU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdlbmVyYXRlVVYoIGJ1aWxkZXIsIGN1YmVVViApIHtcblxuXHRcdHJldHVybiBjdWJlVVYuYnVpbGQoIGJ1aWxkZXIsICd2ZWMzJyApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDdWJlVGV4dHVyZU5vZGU7XG5cbmV4cG9ydCBjb25zdCBjdWJlVGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBDdWJlVGV4dHVyZU5vZGUgKTtcbiIsImltcG9ydCBVbmlmb3JtTm9kZSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcbmltcG9ydCB7IG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIEJ1ZmZlck5vZGUgZXh0ZW5kcyBVbmlmb3JtTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdCdWZmZXJOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHZhbHVlLCBidWZmZXJUeXBlLCBidWZmZXJDb3VudCA9IDAgKSB7XG5cblx0XHRzdXBlciggdmFsdWUsIGJ1ZmZlclR5cGUgKTtcblxuXHRcdHRoaXMuaXNCdWZmZXJOb2RlID0gdHJ1ZTtcblxuXHRcdHRoaXMuYnVmZmVyVHlwZSA9IGJ1ZmZlclR5cGU7XG5cdFx0dGhpcy5idWZmZXJDb3VudCA9IGJ1ZmZlckNvdW50O1xuXG5cdH1cblxuXHRnZXRFbGVtZW50VHlwZSggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0fVxuXG5cdGdldElucHV0VHlwZSggLypidWlsZGVyKi8gKSB7XG5cblx0XHRyZXR1cm4gJ2J1ZmZlcic7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1ZmZlck5vZGU7XG5cbmV4cG9ydCBjb25zdCBidWZmZXIgPSAoIHZhbHVlLCB0eXBlLCBjb3VudCApID0+IG5vZGVPYmplY3QoIG5ldyBCdWZmZXJOb2RlKCB2YWx1ZSwgdHlwZSwgY291bnQgKSApO1xuIiwiaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2V0VmFsdWVUeXBlIH0gZnJvbSAnLi4vY29yZS9Ob2RlVXRpbHMuanMnO1xuaW1wb3J0IEFycmF5RWxlbWVudE5vZGUgZnJvbSAnLi4vdXRpbHMvQXJyYXlFbGVtZW50Tm9kZS5qcyc7XG5pbXBvcnQgQnVmZmVyTm9kZSBmcm9tICcuL0J1ZmZlck5vZGUuanMnO1xuXG5jbGFzcyBVbmlmb3JtQXJyYXlFbGVtZW50Tm9kZSBleHRlbmRzIEFycmF5RWxlbWVudE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnVW5pZm9ybUFycmF5RWxlbWVudE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggYXJyYXlCdWZmZXIsIGluZGV4Tm9kZSApIHtcblxuXHRcdHN1cGVyKCBhcnJheUJ1ZmZlciwgaW5kZXhOb2RlICk7XG5cblx0XHR0aGlzLmlzQXJyYXlCdWZmZXJFbGVtZW50Tm9kZSA9IHRydWU7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3Qgc25pcHBldCA9IHN1cGVyLmdlbmVyYXRlKCBidWlsZGVyICk7XG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoKTtcblxuXHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggc25pcHBldCwgJ3ZlYzQnLCB0eXBlICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFVuaWZvcm1BcnJheU5vZGUgZXh0ZW5kcyBCdWZmZXJOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1VuaWZvcm1BcnJheU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIGVsZW1lbnRUeXBlID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCBudWxsLCAndmVjNCcgKTtcblxuXHRcdHRoaXMuYXJyYXkgPSB2YWx1ZTtcblx0XHR0aGlzLmVsZW1lbnRUeXBlID0gZWxlbWVudFR5cGU7XG5cblx0XHR0aGlzLl9lbGVtZW50VHlwZSA9IG51bGw7XG5cdFx0dGhpcy5fZWxlbWVudExlbmd0aCA9IDA7XG5cblx0XHR0aGlzLnVwZGF0ZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5SRU5ERVI7XG5cblx0XHR0aGlzLmlzQXJyYXlCdWZmZXJOb2RlID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0RWxlbWVudFR5cGUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50VHlwZSB8fCB0aGlzLl9lbGVtZW50VHlwZTtcblxuXHR9XG5cblx0Z2V0RWxlbWVudExlbmd0aCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9lbGVtZW50TGVuZ3RoO1xuXG5cdH1cblxuXHR1cGRhdGUoIC8qZnJhbWUqLyApIHtcblxuXHRcdGNvbnN0IHsgYXJyYXksIHZhbHVlIH0gPSB0aGlzO1xuXG5cdFx0Y29uc3QgZWxlbWVudExlbmd0aCA9IHRoaXMuZ2V0RWxlbWVudExlbmd0aCgpO1xuXHRcdGNvbnN0IGVsZW1lbnRUeXBlID0gdGhpcy5nZXRFbGVtZW50VHlwZSgpO1xuXG5cdFx0aWYgKCBlbGVtZW50TGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICogNDtcblxuXHRcdFx0XHR2YWx1ZVsgaW5kZXggXSA9IGFycmF5WyBpIF07XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIGVsZW1lbnRUeXBlID09PSAnY29sb3InICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICogNDtcblx0XHRcdFx0Y29uc3QgdmVjdG9yID0gYXJyYXlbIGkgXTtcblxuXHRcdFx0XHR2YWx1ZVsgaW5kZXggXSA9IHZlY3Rvci5yO1xuXHRcdFx0XHR2YWx1ZVsgaW5kZXggKyAxIF0gPSB2ZWN0b3IuZztcblx0XHRcdFx0dmFsdWVbIGluZGV4ICsgMiBdID0gdmVjdG9yLmIgfHwgMDtcblx0XHRcdFx0Ly92YWx1ZVsgaW5kZXggKyAzIF0gPSB2ZWN0b3IuYSB8fCAwO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICogNDtcblx0XHRcdFx0Y29uc3QgdmVjdG9yID0gYXJyYXlbIGkgXTtcblxuXHRcdFx0XHR2YWx1ZVsgaW5kZXggXSA9IHZlY3Rvci54O1xuXHRcdFx0XHR2YWx1ZVsgaW5kZXggKyAxIF0gPSB2ZWN0b3IueTtcblx0XHRcdFx0dmFsdWVbIGluZGV4ICsgMiBdID0gdmVjdG9yLnogfHwgMDtcblx0XHRcdFx0dmFsdWVbIGluZGV4ICsgMyBdID0gdmVjdG9yLncgfHwgMDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMuYXJyYXkubGVuZ3RoO1xuXG5cdFx0dGhpcy5fZWxlbWVudFR5cGUgPSB0aGlzLmVsZW1lbnRUeXBlID09PSBudWxsID8gZ2V0VmFsdWVUeXBlKCB0aGlzLmFycmF5WyAwIF0gKSA6IHRoaXMuZWxlbWVudFR5cGU7XG5cdFx0dGhpcy5fZWxlbWVudExlbmd0aCA9IGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggdGhpcy5fZWxlbWVudFR5cGUgKTtcblxuXHRcdGxldCBhcnJheVR5cGUgPSBGbG9hdDMyQXJyYXk7XG5cblx0XHRpZiAoIHRoaXMuX2VsZW1lbnRUeXBlLmNoYXJBdCggMCApID09PSAnaScgKSBhcnJheVR5cGUgPSBJbnQzMkFycmF5O1xuXHRcdGVsc2UgaWYgKCB0aGlzLl9lbGVtZW50VHlwZS5jaGFyQXQoIDAgKSA9PT0gJ3UnICkgYXJyYXlUeXBlID0gVWludDMyQXJyYXk7XG5cblx0XHR0aGlzLnZhbHVlID0gbmV3IGFycmF5VHlwZSggbGVuZ3RoICogNCApO1xuXHRcdHRoaXMuYnVmZmVyQ291bnQgPSBsZW5ndGg7XG5cdFx0dGhpcy5idWZmZXJUeXBlID0gYnVpbGRlci5jaGFuZ2VDb21wb25lbnRUeXBlKCAndmVjNCcsIGJ1aWxkZXIuZ2V0Q29tcG9uZW50VHlwZSggdGhpcy5fZWxlbWVudFR5cGUgKSApO1xuXG5cdFx0cmV0dXJuIHN1cGVyLnNldHVwKCBidWlsZGVyICk7XG5cblx0fVxuXG5cdGVsZW1lbnQoIGluZGV4Tm9kZSApIHtcblxuXHRcdHJldHVybiBub2RlT2JqZWN0KCBuZXcgVW5pZm9ybUFycmF5RWxlbWVudE5vZGUoIHRoaXMsIG5vZGVPYmplY3QoIGluZGV4Tm9kZSApICkgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVW5pZm9ybUFycmF5Tm9kZTtcblxuZXhwb3J0IGNvbnN0IHVuaWZvcm1BcnJheSA9ICggdmFsdWVzLCBub2RlVHlwZSApID0+IG5vZGVPYmplY3QoIG5ldyBVbmlmb3JtQXJyYXlOb2RlKCB2YWx1ZXMsIG5vZGVUeXBlICkgKTtcblxuLy9cblxuZXhwb3J0IGNvbnN0IHVuaWZvcm1zID0gKCB2YWx1ZXMsIG5vZGVUeXBlICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE2OFxuXG5cdGNvbnNvbGUud2FybiggJ1RTTC5Vbmlmb3JtQXJyYXlOb2RlOiB1bmlmb3JtcygpIGhhcyBiZWVuIHJlbmFtZWQgdG8gdW5pZm9ybUFycmF5KCkuJyApO1xuXHRyZXR1cm4gbm9kZU9iamVjdCggbmV3IFVuaWZvcm1BcnJheU5vZGUoIHZhbHVlcywgbm9kZVR5cGUgKSApO1xuXG59O1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xuaW1wb3J0IHsgdGV4dHVyZSB9IGZyb20gJy4vVGV4dHVyZU5vZGUuanMnO1xuaW1wb3J0IHsgY3ViZVRleHR1cmUgfSBmcm9tICcuL0N1YmVUZXh0dXJlTm9kZS5qcyc7XG5pbXBvcnQgeyBidWZmZXIgfSBmcm9tICcuL0J1ZmZlck5vZGUuanMnO1xuaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IHVuaWZvcm1BcnJheSB9IGZyb20gJy4vVW5pZm9ybUFycmF5Tm9kZS5qcyc7XG5pbXBvcnQgQXJyYXlFbGVtZW50Tm9kZSBmcm9tICcuLi91dGlscy9BcnJheUVsZW1lbnROb2RlLmpzJztcblxuY2xhc3MgUmVmZXJlbmNlRWxlbWVudE5vZGUgZXh0ZW5kcyBBcnJheUVsZW1lbnROb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1JlZmVyZW5jZUVsZW1lbnROb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHJlZmVyZW5jZU5vZGUsIGluZGV4Tm9kZSApIHtcblxuXHRcdHN1cGVyKCByZWZlcmVuY2VOb2RlLCBpbmRleE5vZGUgKTtcblxuXHRcdHRoaXMucmVmZXJlbmNlTm9kZSA9IHJlZmVyZW5jZU5vZGU7XG5cblx0XHR0aGlzLmlzUmVmZXJlbmNlRWxlbWVudE5vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnJlZmVyZW5jZU5vZGUudW5pZm9ybVR5cGU7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3Qgc25pcHBldCA9IHN1cGVyLmdlbmVyYXRlKCBidWlsZGVyICk7XG5cdFx0Y29uc3QgYXJyYXlUeXBlID0gdGhpcy5yZWZlcmVuY2VOb2RlLmdldE5vZGVUeXBlKCk7XG5cdFx0Y29uc3QgZWxlbWVudFR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCk7XG5cblx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIHNuaXBwZXQsIGFycmF5VHlwZSwgZWxlbWVudFR5cGUgKTtcblxuXHR9XG5cbn1cblxuLy8gVE9ETzogRXh0ZW5kcyB0aGlzIGZyb20gUmVmZXJlbmNlQmFzZU5vZGVcbmNsYXNzIFJlZmVyZW5jZU5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1JlZmVyZW5jZU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggcHJvcGVydHksIHVuaWZvcm1UeXBlLCBvYmplY3QgPSBudWxsLCBjb3VudCA9IG51bGwgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXHRcdHRoaXMudW5pZm9ybVR5cGUgPSB1bmlmb3JtVHlwZTtcblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0XHR0aGlzLmNvdW50ID0gY291bnQ7XG5cblx0XHR0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0eS5zcGxpdCggJy4nICk7XG5cdFx0dGhpcy5yZWZlcmVuY2UgPSBvYmplY3Q7XG5cdFx0dGhpcy5ub2RlID0gbnVsbDtcblx0XHR0aGlzLmdyb3VwID0gbnVsbDtcblx0XHR0aGlzLm5hbWUgPSBudWxsO1xuXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuT0JKRUNUO1xuXG5cdH1cblxuXHRlbGVtZW50KCBpbmRleE5vZGUgKSB7XG5cblx0XHRyZXR1cm4gbm9kZU9iamVjdCggbmV3IFJlZmVyZW5jZUVsZW1lbnROb2RlKCB0aGlzLCBub2RlT2JqZWN0KCBpbmRleE5vZGUgKSApICk7XG5cblx0fVxuXG5cdHNldEdyb3VwKCBncm91cCApIHtcblxuXHRcdHRoaXMuZ3JvdXAgPSBncm91cDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsYWJlbCggbmFtZSApIHtcblxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0Tm9kZVR5cGUoIHVuaWZvcm1UeXBlICkge1xuXG5cdFx0bGV0IG5vZGUgPSBudWxsO1xuXG5cdFx0aWYgKCB0aGlzLmNvdW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRub2RlID0gYnVmZmVyKCBudWxsLCB1bmlmb3JtVHlwZSwgdGhpcy5jb3VudCApO1xuXG5cdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdGhpcy5nZXRWYWx1ZUZyb21SZWZlcmVuY2UoKSApICkge1xuXG5cdFx0XHRub2RlID0gdW5pZm9ybUFycmF5KCBudWxsLCB1bmlmb3JtVHlwZSApO1xuXG5cdFx0fSBlbHNlIGlmICggdW5pZm9ybVR5cGUgPT09ICd0ZXh0dXJlJyApIHtcblxuXHRcdFx0bm9kZSA9IHRleHR1cmUoIG51bGwgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHVuaWZvcm1UeXBlID09PSAnY3ViZVRleHR1cmUnICkge1xuXG5cdFx0XHRub2RlID0gY3ViZVRleHR1cmUoIG51bGwgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG5vZGUgPSB1bmlmb3JtKCBudWxsLCB1bmlmb3JtVHlwZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmdyb3VwICE9PSBudWxsICkge1xuXG5cdFx0XHRub2RlLnNldEdyb3VwKCB0aGlzLmdyb3VwICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gbnVsbCApIG5vZGUubGFiZWwoIHRoaXMubmFtZSApO1xuXG5cdFx0dGhpcy5ub2RlID0gbm9kZS5nZXRTZWxmKCk7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vZGUgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMudXBkYXRlUmVmZXJlbmNlKCBidWlsZGVyICk7XG5cdFx0XHR0aGlzLnVwZGF0ZVZhbHVlKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0fVxuXG5cdGdldFZhbHVlRnJvbVJlZmVyZW5jZSggb2JqZWN0ID0gdGhpcy5yZWZlcmVuY2UgKSB7XG5cblx0XHRjb25zdCB7IHByb3BlcnRpZXMgfSA9IHRoaXM7XG5cblx0XHRsZXQgdmFsdWUgPSBvYmplY3RbIHByb3BlcnRpZXNbIDAgXSBdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhbHVlID0gdmFsdWVbIHByb3BlcnRpZXNbIGkgXSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXG5cdH1cblxuXHR1cGRhdGVSZWZlcmVuY2UoIHN0YXRlICkge1xuXG5cdFx0dGhpcy5yZWZlcmVuY2UgPSB0aGlzLm9iamVjdCAhPT0gbnVsbCA/IHRoaXMub2JqZWN0IDogc3RhdGUub2JqZWN0O1xuXG5cdFx0cmV0dXJuIHRoaXMucmVmZXJlbmNlO1xuXG5cdH1cblxuXHRzZXR1cCgpIHtcblxuXHRcdHRoaXMudXBkYXRlVmFsdWUoKTtcblxuXHRcdHJldHVybiB0aGlzLm5vZGU7XG5cblx0fVxuXG5cdHVwZGF0ZSggLypmcmFtZSovICkge1xuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSgpO1xuXG5cdH1cblxuXHR1cGRhdGVWYWx1ZSgpIHtcblxuXHRcdGlmICggdGhpcy5ub2RlID09PSBudWxsICkgdGhpcy5zZXROb2RlVHlwZSggdGhpcy51bmlmb3JtVHlwZSApO1xuXG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlRnJvbVJlZmVyZW5jZSgpO1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXG5cdFx0XHR0aGlzLm5vZGUuYXJyYXkgPSB2YWx1ZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMubm9kZS52YWx1ZSA9IHZhbHVlO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSZWZlcmVuY2VOb2RlO1xuXG5leHBvcnQgY29uc3QgcmVmZXJlbmNlID0gKCBuYW1lLCB0eXBlLCBvYmplY3QgKSA9PiBub2RlT2JqZWN0KCBuZXcgUmVmZXJlbmNlTm9kZSggbmFtZSwgdHlwZSwgb2JqZWN0ICkgKTtcbmV4cG9ydCBjb25zdCByZWZlcmVuY2VCdWZmZXIgPSAoIG5hbWUsIHR5cGUsIGNvdW50LCBvYmplY3QgKSA9PiBub2RlT2JqZWN0KCBuZXcgUmVmZXJlbmNlTm9kZSggbmFtZSwgdHlwZSwgb2JqZWN0LCBjb3VudCApICk7XG4iLCJpbXBvcnQgUmVmZXJlbmNlTm9kZSBmcm9tICcuL1JlZmVyZW5jZU5vZGUuanMnO1xuLy9pbXBvcnQgeyByZW5kZXJHcm91cCB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybUdyb3VwTm9kZS5qcyc7XG4vL2ltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY2xhc3MgTWF0ZXJpYWxSZWZlcmVuY2VOb2RlIGV4dGVuZHMgUmVmZXJlbmNlTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdNYXRlcmlhbFJlZmVyZW5jZU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggcHJvcGVydHksIGlucHV0VHlwZSwgbWF0ZXJpYWwgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoIHByb3BlcnR5LCBpbnB1dFR5cGUsIG1hdGVyaWFsICk7XG5cblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cblx0XHQvL3RoaXMudXBkYXRlVHlwZSA9IE5vZGVVcGRhdGVUeXBlLlJFTkRFUjtcblxuXHRcdHRoaXMuaXNNYXRlcmlhbFJlZmVyZW5jZU5vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHQvKnNldE5vZGVUeXBlKCBub2RlICkge1xuXG5cdFx0c3VwZXIuc2V0Tm9kZVR5cGUoIG5vZGUgKTtcblxuXHRcdHRoaXMubm9kZS5ncm91cE5vZGUgPSByZW5kZXJHcm91cDtcblxuXHR9Ki9cblxuXHR1cGRhdGVSZWZlcmVuY2UoIHN0YXRlICkge1xuXG5cdFx0dGhpcy5yZWZlcmVuY2UgPSB0aGlzLm1hdGVyaWFsICE9PSBudWxsID8gdGhpcy5tYXRlcmlhbCA6IHN0YXRlLm1hdGVyaWFsO1xuXG5cdFx0cmV0dXJuIHRoaXMucmVmZXJlbmNlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXRlcmlhbFJlZmVyZW5jZU5vZGU7XG5cbmV4cG9ydCBjb25zdCBtYXRlcmlhbFJlZmVyZW5jZSA9ICggbmFtZSwgdHlwZSwgbWF0ZXJpYWwgKSA9PiBub2RlT2JqZWN0KCBuZXcgTWF0ZXJpYWxSZWZlcmVuY2VOb2RlKCBuYW1lLCB0eXBlLCBtYXRlcmlhbCApICk7XG4iLCJpbXBvcnQgeyBhdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0F0dHJpYnV0ZU5vZGUuanMnO1xuaW1wb3J0IHsgY2FtZXJhVmlld01hdHJpeCB9IGZyb20gJy4vQ2FtZXJhLmpzJztcbmltcG9ydCB7IG1vZGVsVmlld01hdHJpeCB9IGZyb20gJy4vTW9kZWxOb2RlLmpzJztcbmltcG9ydCB7IEZuLCB2ZWM0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5leHBvcnQgY29uc3QgdGFuZ2VudEdlb21ldHJ5ID0gLypAX19QVVJFX18qLyBGbiggKCBidWlsZGVyICkgPT4ge1xuXG5cdGlmICggYnVpbGRlci5nZW9tZXRyeS5oYXNBdHRyaWJ1dGUoICd0YW5nZW50JyApID09PSBmYWxzZSApIHtcblxuXHRcdGJ1aWxkZXIuZ2VvbWV0cnkuY29tcHV0ZVRhbmdlbnRzKCk7XG5cblx0fVxuXG5cdHJldHVybiBhdHRyaWJ1dGUoICd0YW5nZW50JywgJ3ZlYzQnICk7XG5cbn0gKSgpO1xuXG5leHBvcnQgY29uc3QgdGFuZ2VudExvY2FsID0gLypAX19QVVJFX18qLyB0YW5nZW50R2VvbWV0cnkueHl6LnRvVmFyKCAndGFuZ2VudExvY2FsJyApO1xuZXhwb3J0IGNvbnN0IHRhbmdlbnRWaWV3ID0gLypAX19QVVJFX18qLyBtb2RlbFZpZXdNYXRyaXgubXVsKCB2ZWM0KCB0YW5nZW50TG9jYWwsIDAgKSApLnh5ei52YXJ5aW5nKCAndl90YW5nZW50VmlldycgKS5ub3JtYWxpemUoKS50b1ZhciggJ3RhbmdlbnRWaWV3JyApO1xuZXhwb3J0IGNvbnN0IHRhbmdlbnRXb3JsZCA9IC8qQF9fUFVSRV9fKi8gdGFuZ2VudFZpZXcudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmFWaWV3TWF0cml4ICkudmFyeWluZyggJ3ZfdGFuZ2VudFdvcmxkJyApLm5vcm1hbGl6ZSgpLnRvVmFyKCAndGFuZ2VudFdvcmxkJyApO1xuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybWVkVGFuZ2VudFZpZXcgPSAvKkBfX1BVUkVfXyovIHRhbmdlbnRWaWV3LnRvVmFyKCAndHJhbnNmb3JtZWRUYW5nZW50VmlldycgKTtcbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1lZFRhbmdlbnRXb3JsZCA9IC8qQF9fUFVSRV9fKi8gdHJhbnNmb3JtZWRUYW5nZW50Vmlldy50cmFuc2Zvcm1EaXJlY3Rpb24oIGNhbWVyYVZpZXdNYXRyaXggKS5ub3JtYWxpemUoKS50b1ZhciggJ3RyYW5zZm9ybWVkVGFuZ2VudFdvcmxkJyApO1xuIiwiaW1wb3J0IHsgdmFyeWluZyB9IGZyb20gJy4uL2NvcmUvVmFyeWluZ05vZGUuanMnO1xuaW1wb3J0IHsgY2FtZXJhVmlld01hdHJpeCB9IGZyb20gJy4vQ2FtZXJhLmpzJztcbmltcG9ydCB7IG5vcm1hbEdlb21ldHJ5LCBub3JtYWxMb2NhbCwgbm9ybWFsVmlldywgbm9ybWFsV29ybGQsIHRyYW5zZm9ybWVkTm9ybWFsVmlldyB9IGZyb20gJy4vTm9ybWFsLmpzJztcbmltcG9ydCB7IHRhbmdlbnRHZW9tZXRyeSwgdGFuZ2VudExvY2FsLCB0YW5nZW50VmlldywgdGFuZ2VudFdvcmxkLCB0cmFuc2Zvcm1lZFRhbmdlbnRWaWV3IH0gZnJvbSAnLi9UYW5nZW50LmpzJztcblxuY29uc3QgZ2V0Qml0YW5nZW50ID0gKCBjcm9zc05vcm1hbFRhbmdlbnQgKSA9PiBjcm9zc05vcm1hbFRhbmdlbnQubXVsKCB0YW5nZW50R2VvbWV0cnkudyApLnh5ejtcblxuZXhwb3J0IGNvbnN0IGJpdGFuZ2VudEdlb21ldHJ5ID0gLypAX19QVVJFX18qLyB2YXJ5aW5nKCBnZXRCaXRhbmdlbnQoIG5vcm1hbEdlb21ldHJ5LmNyb3NzKCB0YW5nZW50R2VvbWV0cnkgKSApLCAndl9iaXRhbmdlbnRHZW9tZXRyeScgKS5ub3JtYWxpemUoKS50b1ZhciggJ2JpdGFuZ2VudEdlb21ldHJ5JyApO1xuZXhwb3J0IGNvbnN0IGJpdGFuZ2VudExvY2FsID0gLypAX19QVVJFX18qLyB2YXJ5aW5nKCBnZXRCaXRhbmdlbnQoIG5vcm1hbExvY2FsLmNyb3NzKCB0YW5nZW50TG9jYWwgKSApLCAndl9iaXRhbmdlbnRMb2NhbCcgKS5ub3JtYWxpemUoKS50b1ZhciggJ2JpdGFuZ2VudExvY2FsJyApO1xuZXhwb3J0IGNvbnN0IGJpdGFuZ2VudFZpZXcgPSAvKkBfX1BVUkVfXyovIHZhcnlpbmcoIGdldEJpdGFuZ2VudCggbm9ybWFsVmlldy5jcm9zcyggdGFuZ2VudFZpZXcgKSApLCAndl9iaXRhbmdlbnRWaWV3JyApLm5vcm1hbGl6ZSgpLnRvVmFyKCAnYml0YW5nZW50VmlldycgKTtcbmV4cG9ydCBjb25zdCBiaXRhbmdlbnRXb3JsZCA9IC8qQF9fUFVSRV9fKi8gdmFyeWluZyggZ2V0Qml0YW5nZW50KCBub3JtYWxXb3JsZC5jcm9zcyggdGFuZ2VudFdvcmxkICkgKSwgJ3ZfYml0YW5nZW50V29ybGQnICkubm9ybWFsaXplKCkudG9WYXIoICdiaXRhbmdlbnRXb3JsZCcgKTtcbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1lZEJpdGFuZ2VudFZpZXcgPSAvKkBfX1BVUkVfXyovIGdldEJpdGFuZ2VudCggdHJhbnNmb3JtZWROb3JtYWxWaWV3LmNyb3NzKCB0cmFuc2Zvcm1lZFRhbmdlbnRWaWV3ICkgKS5ub3JtYWxpemUoKS50b1ZhciggJ3RyYW5zZm9ybWVkQml0YW5nZW50VmlldycgKTtcbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1lZEJpdGFuZ2VudFdvcmxkID0gLypAX19QVVJFX18qLyB0cmFuc2Zvcm1lZEJpdGFuZ2VudFZpZXcudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmFWaWV3TWF0cml4ICkubm9ybWFsaXplKCkudG9WYXIoICd0cmFuc2Zvcm1lZEJpdGFuZ2VudFdvcmxkJyApO1xuIiwiaW1wb3J0IHsgYml0YW5nZW50VmlldyB9IGZyb20gJy4vQml0YW5nZW50LmpzJztcbmltcG9ydCB7IG5vcm1hbFZpZXcsIHRyYW5zZm9ybWVkTm9ybWFsVmlldyB9IGZyb20gJy4vTm9ybWFsLmpzJztcbmltcG9ydCB7IHRhbmdlbnRWaWV3IH0gZnJvbSAnLi9UYW5nZW50LmpzJztcbmltcG9ydCB7IG1hdDMgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyBtaXggfSBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJztcbmltcG9ydCB7IGFuaXNvdHJvcHksIGFuaXNvdHJvcHlCLCByb3VnaG5lc3MgfSBmcm9tICcuLi9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XG5pbXBvcnQgeyBwb3NpdGlvblZpZXdEaXJlY3Rpb24gfSBmcm9tICcuL1Bvc2l0aW9uLmpzJztcblxuZXhwb3J0IGNvbnN0IFRCTlZpZXdNYXRyaXggPSAvKkBfX1BVUkVfXyovIG1hdDMoIHRhbmdlbnRWaWV3LCBiaXRhbmdlbnRWaWV3LCBub3JtYWxWaWV3ICk7XG5cbmV4cG9ydCBjb25zdCBwYXJhbGxheERpcmVjdGlvbiA9IC8qQF9fUFVSRV9fKi8gcG9zaXRpb25WaWV3RGlyZWN0aW9uLm11bCggVEJOVmlld01hdHJpeCApLyoubm9ybWFsaXplKCkqLztcbmV4cG9ydCBjb25zdCBwYXJhbGxheFVWID0gKCB1diwgc2NhbGUgKSA9PiB1di5zdWIoIHBhcmFsbGF4RGlyZWN0aW9uLm11bCggc2NhbGUgKSApO1xuXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtZWRCZW50Tm9ybWFsVmlldyA9IC8qQF9fUFVSRV9fKi8gKCAoKSA9PiB7XG5cblx0Ly8gaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2ZpbGFtZW50L0ZpbGFtZW50Lm1kLmh0bWwjbGlnaHRpbmcvaW1hZ2ViYXNlZGxpZ2h0cy9hbmlzb3Ryb3B5XG5cblx0bGV0IGJlbnROb3JtYWwgPSBhbmlzb3Ryb3B5Qi5jcm9zcyggcG9zaXRpb25WaWV3RGlyZWN0aW9uICk7XG5cdGJlbnROb3JtYWwgPSBiZW50Tm9ybWFsLmNyb3NzKCBhbmlzb3Ryb3B5QiApLm5vcm1hbGl6ZSgpO1xuXHRiZW50Tm9ybWFsID0gbWl4KCBiZW50Tm9ybWFsLCB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcsIGFuaXNvdHJvcHkubXVsKCByb3VnaG5lc3Mub25lTWludXMoKSApLm9uZU1pbnVzKCkucG93MigpLnBvdzIoKSApLm5vcm1hbGl6ZSgpO1xuXG5cdHJldHVybiBiZW50Tm9ybWFsO1xuXG5cbn0gKSgpO1xuIiwiaW1wb3J0IFRlbXBOb2RlIGZyb20gJy4uL2NvcmUvVGVtcE5vZGUuanMnO1xuaW1wb3J0IHsgYWRkIH0gZnJvbSAnLi4vbWF0aC9PcGVyYXRvck5vZGUuanMnO1xuXG5pbXBvcnQgeyBub3JtYWxWaWV3LCB0cmFuc2Zvcm1Ob3JtYWxUb1ZpZXcgfSBmcm9tICcuLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcbmltcG9ydCB7IHBvc2l0aW9uVmlldyB9IGZyb20gJy4uL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBUQk5WaWV3TWF0cml4IH0gZnJvbSAnLi4vYWNjZXNzb3JzL0FjY2Vzc29yc1V0aWxzLmpzJztcbmltcG9ydCB7IHV2IH0gZnJvbSAnLi4vYWNjZXNzb3JzL1VWLmpzJztcbmltcG9ydCB7IGZhY2VEaXJlY3Rpb24gfSBmcm9tICcuL0Zyb250RmFjaW5nTm9kZS5qcyc7XG5pbXBvcnQgeyBGbiwgbm9kZVByb3h5LCB2ZWMzIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5pbXBvcnQgeyBUYW5nZW50U3BhY2VOb3JtYWxNYXAsIE9iamVjdFNwYWNlTm9ybWFsTWFwIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcblxuLy8gTm9ybWFsIE1hcHBpbmcgV2l0aG91dCBQcmVjb21wdXRlZCBUYW5nZW50c1xuLy8gaHR0cDovL3d3dy50aGV0ZW50aHBsYW5ldC5kZS9hcmNoaXZlcy8xMTgwXG5cbmNvbnN0IHBlcnR1cmJOb3JtYWwyQXJiID0gLypAX19QVVJFX18qLyBGbiggKCBpbnB1dHMgKSA9PiB7XG5cblx0Y29uc3QgeyBleWVfcG9zLCBzdXJmX25vcm0sIG1hcE4sIHV2IH0gPSBpbnB1dHM7XG5cblx0Y29uc3QgcTAgPSBleWVfcG9zLmRGZHgoKTtcblx0Y29uc3QgcTEgPSBleWVfcG9zLmRGZHkoKTtcblx0Y29uc3Qgc3QwID0gdXYuZEZkeCgpO1xuXHRjb25zdCBzdDEgPSB1di5kRmR5KCk7XG5cblx0Y29uc3QgTiA9IHN1cmZfbm9ybTsgLy8gbm9ybWFsaXplZFxuXG5cdGNvbnN0IHExcGVycCA9IHExLmNyb3NzKCBOICk7XG5cdGNvbnN0IHEwcGVycCA9IE4uY3Jvc3MoIHEwICk7XG5cblx0Y29uc3QgVCA9IHExcGVycC5tdWwoIHN0MC54ICkuYWRkKCBxMHBlcnAubXVsKCBzdDEueCApICk7XG5cdGNvbnN0IEIgPSBxMXBlcnAubXVsKCBzdDAueSApLmFkZCggcTBwZXJwLm11bCggc3QxLnkgKSApO1xuXG5cdGNvbnN0IGRldCA9IFQuZG90KCBUICkubWF4KCBCLmRvdCggQiApICk7XG5cdGNvbnN0IHNjYWxlID0gZmFjZURpcmVjdGlvbi5tdWwoIGRldC5pbnZlcnNlU3FydCgpICk7XG5cblx0cmV0dXJuIGFkZCggVC5tdWwoIG1hcE4ueCwgc2NhbGUgKSwgQi5tdWwoIG1hcE4ueSwgc2NhbGUgKSwgTi5tdWwoIG1hcE4ueiApICkubm9ybWFsaXplKCk7XG5cbn0gKTtcblxuY2xhc3MgTm9ybWFsTWFwTm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ05vcm1hbE1hcE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3Rvciggbm9kZSwgc2NhbGVOb2RlID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCAndmVjMycgKTtcblxuXHRcdHRoaXMubm9kZSA9IG5vZGU7XG5cdFx0dGhpcy5zY2FsZU5vZGUgPSBzY2FsZU5vZGU7XG5cblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgeyBub3JtYWxNYXBUeXBlLCBzY2FsZU5vZGUgfSA9IHRoaXM7XG5cblx0XHRsZXQgbm9ybWFsTWFwID0gdGhpcy5ub2RlLm11bCggMi4wICkuc3ViKCAxLjAgKTtcblxuXHRcdGlmICggc2NhbGVOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRub3JtYWxNYXAgPSB2ZWMzKCBub3JtYWxNYXAueHkubXVsKCBzY2FsZU5vZGUgKSwgbm9ybWFsTWFwLnogKTtcblxuXHRcdH1cblxuXHRcdGxldCBvdXRwdXROb2RlID0gbnVsbDtcblxuXHRcdGlmICggbm9ybWFsTWFwVHlwZSA9PT0gT2JqZWN0U3BhY2VOb3JtYWxNYXAgKSB7XG5cblx0XHRcdG91dHB1dE5vZGUgPSB0cmFuc2Zvcm1Ob3JtYWxUb1ZpZXcoIG5vcm1hbE1hcCApO1xuXG5cdFx0fSBlbHNlIGlmICggbm9ybWFsTWFwVHlwZSA9PT0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwICkge1xuXG5cdFx0XHRjb25zdCB0YW5nZW50ID0gYnVpbGRlci5oYXNHZW9tZXRyeUF0dHJpYnV0ZSggJ3RhbmdlbnQnICk7XG5cblx0XHRcdGlmICggdGFuZ2VudCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRvdXRwdXROb2RlID0gVEJOVmlld01hdHJpeC5tdWwoIG5vcm1hbE1hcCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG91dHB1dE5vZGUgPSBwZXJ0dXJiTm9ybWFsMkFyYigge1xuXHRcdFx0XHRcdGV5ZV9wb3M6IHBvc2l0aW9uVmlldyxcblx0XHRcdFx0XHRzdXJmX25vcm06IG5vcm1hbFZpZXcsXG5cdFx0XHRcdFx0bWFwTjogbm9ybWFsTWFwLFxuXHRcdFx0XHRcdHV2OiB1digpXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dE5vZGU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vcm1hbE1hcE5vZGU7XG5cbmV4cG9ydCBjb25zdCBub3JtYWxNYXAgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTm9ybWFsTWFwTm9kZSApO1xuIiwiaW1wb3J0IFRlbXBOb2RlIGZyb20gJy4uL2NvcmUvVGVtcE5vZGUuanMnO1xuaW1wb3J0IHsgdXYgfSBmcm9tICcuLi9hY2Nlc3NvcnMvVVYuanMnO1xuaW1wb3J0IHsgbm9ybWFsVmlldyB9IGZyb20gJy4uL2FjY2Vzc29ycy9Ob3JtYWwuanMnO1xuaW1wb3J0IHsgcG9zaXRpb25WaWV3IH0gZnJvbSAnLi4vYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IGZhY2VEaXJlY3Rpb24gfSBmcm9tICcuL0Zyb250RmFjaW5nTm9kZS5qcyc7XG5pbXBvcnQgeyBGbiwgbm9kZVByb3h5LCBmbG9hdCwgdmVjMiB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuLy8gQnVtcCBNYXBwaW5nIFVucGFyYW1ldHJpemVkIFN1cmZhY2VzIG9uIHRoZSBHUFUgYnkgTW9ydGVuIFMuIE1pa2tlbHNlblxuLy8gaHR0cHM6Ly9tbWlray5naXRodWIuaW8vcGFwZXJzM2QvbW1fc2ZncmFkX2J1bXAucGRmXG5cbmNvbnN0IGRIZHh5X2Z3ZCA9IEZuKCAoIHsgdGV4dHVyZU5vZGUsIGJ1bXBTY2FsZSB9ICkgPT4ge1xuXG5cdC8vIEl0J3MgdXNlZCB0byBwcmVzZXJ2ZSB0aGUgc2FtZSBUZXh0dXJlTm9kZSBpbnN0YW5jZVxuXHRjb25zdCBzYW1wbGVUZXh0dXJlID0gKCBjYWxsYmFjayApID0+IHRleHR1cmVOb2RlLmNhY2hlKCkuY29udGV4dCggeyBnZXRVVjogKCB0ZXhOb2RlICkgPT4gY2FsbGJhY2soIHRleE5vZGUudXZOb2RlIHx8IHV2KCkgKSwgZm9yY2VVVkNvbnRleHQ6IHRydWUgfSApO1xuXG5cdGNvbnN0IEhsbCA9IGZsb2F0KCBzYW1wbGVUZXh0dXJlKCAoIHV2Tm9kZSApID0+IHV2Tm9kZSApICk7XG5cblx0cmV0dXJuIHZlYzIoXG5cdFx0ZmxvYXQoIHNhbXBsZVRleHR1cmUoICggdXZOb2RlICkgPT4gdXZOb2RlLmFkZCggdXZOb2RlLmRGZHgoKSApICkgKS5zdWIoIEhsbCApLFxuXHRcdGZsb2F0KCBzYW1wbGVUZXh0dXJlKCAoIHV2Tm9kZSApID0+IHV2Tm9kZS5hZGQoIHV2Tm9kZS5kRmR5KCkgKSApICkuc3ViKCBIbGwgKVxuXHQpLm11bCggYnVtcFNjYWxlICk7XG5cbn0gKTtcblxuLy8gRXZhbHVhdGUgdGhlIGRlcml2YXRpdmUgb2YgdGhlIGhlaWdodCB3LnIudC4gc2NyZWVuLXNwYWNlIHVzaW5nIGZvcndhcmQgZGlmZmVyZW5jaW5nIChsaXN0aW5nIDIpXG5cbmNvbnN0IHBlcnR1cmJOb3JtYWxBcmIgPSBGbiggKCBpbnB1dHMgKSA9PiB7XG5cblx0Y29uc3QgeyBzdXJmX3Bvcywgc3VyZl9ub3JtLCBkSGR4eSB9ID0gaW5wdXRzO1xuXG5cdC8vIG5vcm1hbGl6ZSBpcyBkb25lIHRvIGVuc3VyZSB0aGF0IHRoZSBidW1wIG1hcCBsb29rcyB0aGUgc2FtZSByZWdhcmRsZXNzIG9mIHRoZSB0ZXh0dXJlJ3Mgc2NhbGVcblx0Y29uc3QgdlNpZ21hWCA9IHN1cmZfcG9zLmRGZHgoKS5ub3JtYWxpemUoKTtcblx0Y29uc3QgdlNpZ21hWSA9IHN1cmZfcG9zLmRGZHkoKS5ub3JtYWxpemUoKTtcblx0Y29uc3Qgdk4gPSBzdXJmX25vcm07IC8vIG5vcm1hbGl6ZWRcblxuXHRjb25zdCBSMSA9IHZTaWdtYVkuY3Jvc3MoIHZOICk7XG5cdGNvbnN0IFIyID0gdk4uY3Jvc3MoIHZTaWdtYVggKTtcblxuXHRjb25zdCBmRGV0ID0gdlNpZ21hWC5kb3QoIFIxICkubXVsKCBmYWNlRGlyZWN0aW9uICk7XG5cblx0Y29uc3QgdkdyYWQgPSBmRGV0LnNpZ24oKS5tdWwoIGRIZHh5LngubXVsKCBSMSApLmFkZCggZEhkeHkueS5tdWwoIFIyICkgKSApO1xuXG5cdHJldHVybiBmRGV0LmFicygpLm11bCggc3VyZl9ub3JtICkuc3ViKCB2R3JhZCApLm5vcm1hbGl6ZSgpO1xuXG59ICk7XG5cbmNsYXNzIEJ1bXBNYXBOb2RlIGV4dGVuZHMgVGVtcE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnQnVtcE1hcE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggdGV4dHVyZU5vZGUsIHNjYWxlTm9kZSA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggJ3ZlYzMnICk7XG5cblx0XHR0aGlzLnRleHR1cmVOb2RlID0gdGV4dHVyZU5vZGU7XG5cdFx0dGhpcy5zY2FsZU5vZGUgPSBzY2FsZU5vZGU7XG5cblx0fVxuXG5cdHNldHVwKCkge1xuXG5cdFx0Y29uc3QgYnVtcFNjYWxlID0gdGhpcy5zY2FsZU5vZGUgIT09IG51bGwgPyB0aGlzLnNjYWxlTm9kZSA6IDE7XG5cdFx0Y29uc3QgZEhkeHkgPSBkSGR4eV9md2QoIHsgdGV4dHVyZU5vZGU6IHRoaXMudGV4dHVyZU5vZGUsIGJ1bXBTY2FsZSB9ICk7XG5cblx0XHRyZXR1cm4gcGVydHVyYk5vcm1hbEFyYigge1xuXHRcdFx0c3VyZl9wb3M6IHBvc2l0aW9uVmlldyxcblx0XHRcdHN1cmZfbm9ybTogbm9ybWFsVmlldyxcblx0XHRcdGRIZHh5XG5cdFx0fSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCdW1wTWFwTm9kZTtcblxuZXhwb3J0IGNvbnN0IGJ1bXBNYXAgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggQnVtcE1hcE5vZGUgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyByZWZlcmVuY2UgfSBmcm9tICcuL1JlZmVyZW5jZU5vZGUuanMnO1xuaW1wb3J0IHsgbWF0ZXJpYWxSZWZlcmVuY2UgfSBmcm9tICcuL01hdGVyaWFsUmVmZXJlbmNlTm9kZS5qcyc7XG5pbXBvcnQgeyBub3JtYWxWaWV3IH0gZnJvbSAnLi9Ob3JtYWwuanMnO1xuaW1wb3J0IHsgbm9kZUltbXV0YWJsZSwgZmxvYXQsIHZlYzIsIHZlYzMsIG1hdDIgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XG5pbXBvcnQgeyBub3JtYWxNYXAgfSBmcm9tICcuLi9kaXNwbGF5L05vcm1hbE1hcE5vZGUuanMnO1xuaW1wb3J0IHsgYnVtcE1hcCB9IGZyb20gJy4uL2Rpc3BsYXkvQnVtcE1hcE5vZGUuanMnO1xuXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcblxuY29uc3QgX3Byb3BlcnR5Q2FjaGUgPSBuZXcgTWFwKCk7XG5cbmNsYXNzIE1hdGVyaWFsTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnTWF0ZXJpYWxOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHNjb3BlICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuc2NvcGUgPSBzY29wZTtcblxuXHR9XG5cblx0Z2V0Q2FjaGUoIHByb3BlcnR5LCB0eXBlICkge1xuXG5cdFx0bGV0IG5vZGUgPSBfcHJvcGVydHlDYWNoZS5nZXQoIHByb3BlcnR5ICk7XG5cblx0XHRpZiAoIG5vZGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bm9kZSA9IG1hdGVyaWFsUmVmZXJlbmNlKCBwcm9wZXJ0eSwgdHlwZSApO1xuXG5cdFx0XHRfcHJvcGVydHlDYWNoZS5zZXQoIHByb3BlcnR5LCBub2RlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbm9kZTtcblxuXHR9XG5cblx0Z2V0RmxvYXQoIHByb3BlcnR5ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2FjaGUoIHByb3BlcnR5LCAnZmxvYXQnICk7XG5cblx0fVxuXG5cdGdldENvbG9yKCBwcm9wZXJ0eSApIHtcblxuXHRcdHJldHVybiB0aGlzLmdldENhY2hlKCBwcm9wZXJ0eSwgJ2NvbG9yJyApO1xuXG5cdH1cblxuXHRnZXRUZXh0dXJlKCBwcm9wZXJ0eSApIHtcblxuXHRcdHJldHVybiB0aGlzLmdldENhY2hlKCBwcm9wZXJ0eSA9PT0gJ21hcCcgPyAnbWFwJyA6IHByb3BlcnR5ICsgJ01hcCcsICd0ZXh0dXJlJyApO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IG1hdGVyaWFsID0gYnVpbGRlci5jb250ZXh0Lm1hdGVyaWFsO1xuXHRcdGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcblxuXHRcdGxldCBub2RlID0gbnVsbDtcblxuXHRcdGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5DT0xPUiApIHtcblxuXHRcdFx0Y29uc3QgY29sb3JOb2RlID0gbWF0ZXJpYWwuY29sb3IgIT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Q29sb3IoIHNjb3BlICkgOiB2ZWMzKCk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubWFwICYmIG1hdGVyaWFsLm1hcC5pc1RleHR1cmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0bm9kZSA9IGNvbG9yTm9kZS5tdWwoIHRoaXMuZ2V0VGV4dHVyZSggJ21hcCcgKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5vZGUgPSBjb2xvck5vZGU7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuT1BBQ0lUWSApIHtcblxuXHRcdFx0Y29uc3Qgb3BhY2l0eU5vZGUgPSB0aGlzLmdldEZsb2F0KCBzY29wZSApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmFscGhhTWFwICYmIG1hdGVyaWFsLmFscGhhTWFwLmlzVGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRub2RlID0gb3BhY2l0eU5vZGUubXVsKCB0aGlzLmdldFRleHR1cmUoICdhbHBoYScgKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5vZGUgPSBvcGFjaXR5Tm9kZTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5TUEVDVUxBUl9TVFJFTkdUSCApIHtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCAmJiBtYXRlcmlhbC5zcGVjdWxhck1hcC5pc1RleHR1cmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0bm9kZSA9IHRoaXMuZ2V0VGV4dHVyZSggJ3NwZWN1bGFyJyApLnI7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bm9kZSA9IGZsb2F0KCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuU1BFQ1VMQVJfSU5URU5TSVRZICkge1xuXG5cdFx0XHRjb25zdCBzcGVjdWxhckludGVuc2l0eSA9IHRoaXMuZ2V0RmxvYXQoIHNjb3BlICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XG5cblx0XHRcdFx0bm9kZSA9IHNwZWN1bGFySW50ZW5zaXR5Lm11bCggdGhpcy5nZXRUZXh0dXJlKCBzY29wZSApLmEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub2RlID0gc3BlY3VsYXJJbnRlbnNpdHk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuU1BFQ1VMQVJfQ09MT1IgKSB7XG5cblx0XHRcdGNvbnN0IHNwZWN1bGFyQ29sb3JOb2RlID0gdGhpcy5nZXRDb2xvciggc2NvcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwICYmIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JNYXAuaXNUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdG5vZGUgPSBzcGVjdWxhckNvbG9yTm9kZS5tdWwoIHRoaXMuZ2V0VGV4dHVyZSggc2NvcGUgKS5yZ2IgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub2RlID0gc3BlY3VsYXJDb2xvck5vZGU7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuUk9VR0hORVNTICkgeyAvLyBUT0RPOiBjbGVhbnVwIHNpbWlsYXIgYnJhbmNoZXNcblxuXHRcdFx0Y29uc3Qgcm91Z2huZXNzTm9kZSA9IHRoaXMuZ2V0RmxvYXQoIHNjb3BlICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwucm91Z2huZXNzTWFwICYmIG1hdGVyaWFsLnJvdWdobmVzc01hcC5pc1RleHR1cmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0bm9kZSA9IHJvdWdobmVzc05vZGUubXVsKCB0aGlzLmdldFRleHR1cmUoIHNjb3BlICkuZyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5vZGUgPSByb3VnaG5lc3NOb2RlO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gTWF0ZXJpYWxOb2RlLk1FVEFMTkVTUyApIHtcblxuXHRcdFx0Y29uc3QgbWV0YWxuZXNzTm9kZSA9IHRoaXMuZ2V0RmxvYXQoIHNjb3BlICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubWV0YWxuZXNzTWFwICYmIG1hdGVyaWFsLm1ldGFsbmVzc01hcC5pc1RleHR1cmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0bm9kZSA9IG1ldGFsbmVzc05vZGUubXVsKCB0aGlzLmdldFRleHR1cmUoIHNjb3BlICkuYiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5vZGUgPSBtZXRhbG5lc3NOb2RlO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gTWF0ZXJpYWxOb2RlLkVNSVNTSVZFICkge1xuXG5cdFx0XHRjb25zdCBlbWlzc2l2ZUludGVuc2l0eU5vZGUgPSB0aGlzLmdldEZsb2F0KCAnZW1pc3NpdmVJbnRlbnNpdHknICk7XG5cdFx0XHRjb25zdCBlbWlzc2l2ZU5vZGUgPSB0aGlzLmdldENvbG9yKCBzY29wZSApLm11bCggZW1pc3NpdmVJbnRlbnNpdHlOb2RlICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgJiYgbWF0ZXJpYWwuZW1pc3NpdmVNYXAuaXNUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdG5vZGUgPSBlbWlzc2l2ZU5vZGUubXVsKCB0aGlzLmdldFRleHR1cmUoIHNjb3BlICkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub2RlID0gZW1pc3NpdmVOb2RlO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gTWF0ZXJpYWxOb2RlLk5PUk1BTCApIHtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cblx0XHRcdFx0bm9kZSA9IG5vcm1hbE1hcCggdGhpcy5nZXRUZXh0dXJlKCAnbm9ybWFsJyApLCB0aGlzLmdldENhY2hlKCAnbm9ybWFsU2NhbGUnLCAndmVjMicgKSApO1xuXHRcdFx0XHRub2RlLm5vcm1hbE1hcFR5cGUgPSBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG5cdFx0XHRcdG5vZGUgPSBidW1wTWFwKCB0aGlzLmdldFRleHR1cmUoICdidW1wJyApLnIsIHRoaXMuZ2V0RmxvYXQoICdidW1wU2NhbGUnICkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub2RlID0gbm9ybWFsVmlldztcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5DTEVBUkNPQVQgKSB7XG5cblx0XHRcdGNvbnN0IGNsZWFyY29hdE5vZGUgPSB0aGlzLmdldEZsb2F0KCBzY29wZSApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmNsZWFyY29hdE1hcCAmJiBtYXRlcmlhbC5jbGVhcmNvYXRNYXAuaXNUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdG5vZGUgPSBjbGVhcmNvYXROb2RlLm11bCggdGhpcy5nZXRUZXh0dXJlKCBzY29wZSApLnIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub2RlID0gY2xlYXJjb2F0Tm9kZTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5DTEVBUkNPQVRfUk9VR0hORVNTICkge1xuXG5cdFx0XHRjb25zdCBjbGVhcmNvYXRSb3VnaG5lc3NOb2RlID0gdGhpcy5nZXRGbG9hdCggc2NvcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgJiYgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwLmlzVGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRub2RlID0gY2xlYXJjb2F0Um91Z2huZXNzTm9kZS5tdWwoIHRoaXMuZ2V0VGV4dHVyZSggc2NvcGUgKS5yICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bm9kZSA9IGNsZWFyY29hdFJvdWdobmVzc05vZGU7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuQ0xFQVJDT0FUX05PUk1BTCApIHtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXAgKSB7XG5cblx0XHRcdFx0bm9kZSA9IG5vcm1hbE1hcCggdGhpcy5nZXRUZXh0dXJlKCBzY29wZSApLCB0aGlzLmdldENhY2hlKCBzY29wZSArICdTY2FsZScsICd2ZWMyJyApICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bm9kZSA9IG5vcm1hbFZpZXc7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuU0hFRU4gKSB7XG5cblx0XHRcdGNvbnN0IHNoZWVuTm9kZSA9IHRoaXMuZ2V0Q29sb3IoICdzaGVlbkNvbG9yJyApLm11bCggdGhpcy5nZXRGbG9hdCggJ3NoZWVuJyApICk7IC8vIE1vdmUgdGhpcyBtdWwoKSB0byBDUFVcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zaGVlbkNvbG9yTWFwICYmIG1hdGVyaWFsLnNoZWVuQ29sb3JNYXAuaXNUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdG5vZGUgPSBzaGVlbk5vZGUubXVsKCB0aGlzLmdldFRleHR1cmUoICdzaGVlbkNvbG9yJyApLnJnYiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5vZGUgPSBzaGVlbk5vZGU7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuU0hFRU5fUk9VR0hORVNTICkge1xuXG5cdFx0XHRjb25zdCBzaGVlblJvdWdobmVzc05vZGUgPSB0aGlzLmdldEZsb2F0KCBzY29wZSApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwICYmIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwLmlzVGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRub2RlID0gc2hlZW5Sb3VnaG5lc3NOb2RlLm11bCggdGhpcy5nZXRUZXh0dXJlKCBzY29wZSApLmEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub2RlID0gc2hlZW5Sb3VnaG5lc3NOb2RlO1xuXG5cdFx0XHR9XG5cblx0XHRcdG5vZGUgPSBub2RlLmNsYW1wKCAwLjA3LCAxLjAgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuQU5JU09UUk9QWSApIHtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5hbmlzb3Ryb3B5TWFwICYmIG1hdGVyaWFsLmFuaXNvdHJvcHlNYXAuaXNUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGNvbnN0IGFuaXNvdHJvcHlQb2xhciA9IHRoaXMuZ2V0VGV4dHVyZSggc2NvcGUgKTtcblx0XHRcdFx0Y29uc3QgYW5pc290cm9weU1hdCA9IG1hdDIoIG1hdGVyaWFsQW5pc290cm9weVZlY3Rvci54LCBtYXRlcmlhbEFuaXNvdHJvcHlWZWN0b3IueSwgbWF0ZXJpYWxBbmlzb3Ryb3B5VmVjdG9yLnkubmVnYXRlKCksIG1hdGVyaWFsQW5pc290cm9weVZlY3Rvci54ICk7XG5cblx0XHRcdFx0bm9kZSA9IGFuaXNvdHJvcHlNYXQubXVsKCBhbmlzb3Ryb3B5UG9sYXIucmcubXVsKCAyLjAgKS5zdWIoIHZlYzIoIDEuMCApICkubm9ybWFsaXplKCkubXVsKCBhbmlzb3Ryb3B5UG9sYXIuYiApICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bm9kZSA9IG1hdGVyaWFsQW5pc290cm9weVZlY3RvcjtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5JUklERVNDRU5DRV9USElDS05FU1MgKSB7XG5cblx0XHRcdGNvbnN0IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bSA9IHJlZmVyZW5jZSggJzEnLCAnZmxvYXQnLCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgKSB7XG5cblx0XHRcdFx0Y29uc3QgaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtID0gcmVmZXJlbmNlKCAnMCcsICdmbG9hdCcsIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgKTtcblxuXHRcdFx0XHRub2RlID0gaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtLnN1YiggaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtICkubXVsKCB0aGlzLmdldFRleHR1cmUoIHNjb3BlICkuZyApLmFkZCggaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bm9kZSA9IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5UUkFOU01JU1NJT04gKSB7XG5cblx0XHRcdGNvbnN0IHRyYW5zbWlzc2lvbk5vZGUgPSB0aGlzLmdldEZsb2F0KCBzY29wZSApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCApIHtcblxuXHRcdFx0XHRub2RlID0gdHJhbnNtaXNzaW9uTm9kZS5tdWwoIHRoaXMuZ2V0VGV4dHVyZSggc2NvcGUgKS5yICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bm9kZSA9IHRyYW5zbWlzc2lvbk5vZGU7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuVEhJQ0tORVNTICkge1xuXG5cdFx0XHRjb25zdCB0aGlja25lc3NOb2RlID0gdGhpcy5nZXRGbG9hdCggc2NvcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC50aGlja25lc3NNYXAgKSB7XG5cblx0XHRcdFx0bm9kZSA9IHRoaWNrbmVzc05vZGUubXVsKCB0aGlzLmdldFRleHR1cmUoIHNjb3BlICkuZyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5vZGUgPSB0aGlja25lc3NOb2RlO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gTWF0ZXJpYWxOb2RlLklPUiApIHtcblxuXHRcdFx0bm9kZSA9IHRoaXMuZ2V0RmxvYXQoIHNjb3BlICk7XG5cblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gTWF0ZXJpYWxOb2RlLkxJR0hUX01BUCApIHtcblxuXHRcdFx0bm9kZSA9IHRoaXMuZ2V0VGV4dHVyZSggc2NvcGUgKS5yZ2IubXVsKCB0aGlzLmdldEZsb2F0KCAnbGlnaHRNYXBJbnRlbnNpdHknICkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuQU9fTUFQICkge1xuXG5cdFx0XHRub2RlID0gdGhpcy5nZXRUZXh0dXJlKCBzY29wZSApLnIuc3ViKCAxLjAgKS5tdWwoIHRoaXMuZ2V0RmxvYXQoICdhb01hcEludGVuc2l0eScgKSApLmFkZCggMS4wICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBvdXRwdXRUeXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXG5cdFx0XHRub2RlID0gdGhpcy5nZXRDYWNoZSggc2NvcGUsIG91dHB1dFR5cGUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlO1xuXG5cdH1cblxufVxuXG5NYXRlcmlhbE5vZGUuQUxQSEFfVEVTVCA9ICdhbHBoYVRlc3QnO1xuTWF0ZXJpYWxOb2RlLkNPTE9SID0gJ2NvbG9yJztcbk1hdGVyaWFsTm9kZS5PUEFDSVRZID0gJ29wYWNpdHknO1xuTWF0ZXJpYWxOb2RlLlNISU5JTkVTUyA9ICdzaGluaW5lc3MnO1xuTWF0ZXJpYWxOb2RlLlNQRUNVTEFSID0gJ3NwZWN1bGFyJztcbk1hdGVyaWFsTm9kZS5TUEVDVUxBUl9TVFJFTkdUSCA9ICdzcGVjdWxhclN0cmVuZ3RoJztcbk1hdGVyaWFsTm9kZS5TUEVDVUxBUl9JTlRFTlNJVFkgPSAnc3BlY3VsYXJJbnRlbnNpdHknO1xuTWF0ZXJpYWxOb2RlLlNQRUNVTEFSX0NPTE9SID0gJ3NwZWN1bGFyQ29sb3InO1xuTWF0ZXJpYWxOb2RlLlJFRkxFQ1RJVklUWSA9ICdyZWZsZWN0aXZpdHknO1xuTWF0ZXJpYWxOb2RlLlJPVUdITkVTUyA9ICdyb3VnaG5lc3MnO1xuTWF0ZXJpYWxOb2RlLk1FVEFMTkVTUyA9ICdtZXRhbG5lc3MnO1xuTWF0ZXJpYWxOb2RlLk5PUk1BTCA9ICdub3JtYWwnO1xuTWF0ZXJpYWxOb2RlLkNMRUFSQ09BVCA9ICdjbGVhcmNvYXQnO1xuTWF0ZXJpYWxOb2RlLkNMRUFSQ09BVF9ST1VHSE5FU1MgPSAnY2xlYXJjb2F0Um91Z2huZXNzJztcbk1hdGVyaWFsTm9kZS5DTEVBUkNPQVRfTk9STUFMID0gJ2NsZWFyY29hdE5vcm1hbCc7XG5NYXRlcmlhbE5vZGUuRU1JU1NJVkUgPSAnZW1pc3NpdmUnO1xuTWF0ZXJpYWxOb2RlLlJPVEFUSU9OID0gJ3JvdGF0aW9uJztcbk1hdGVyaWFsTm9kZS5TSEVFTiA9ICdzaGVlbic7XG5NYXRlcmlhbE5vZGUuU0hFRU5fUk9VR0hORVNTID0gJ3NoZWVuUm91Z2huZXNzJztcbk1hdGVyaWFsTm9kZS5BTklTT1RST1BZID0gJ2FuaXNvdHJvcHknO1xuTWF0ZXJpYWxOb2RlLklSSURFU0NFTkNFID0gJ2lyaWRlc2NlbmNlJztcbk1hdGVyaWFsTm9kZS5JUklERVNDRU5DRV9JT1IgPSAnaXJpZGVzY2VuY2VJT1InO1xuTWF0ZXJpYWxOb2RlLklSSURFU0NFTkNFX1RISUNLTkVTUyA9ICdpcmlkZXNjZW5jZVRoaWNrbmVzcyc7XG5NYXRlcmlhbE5vZGUuSU9SID0gJ2lvcic7XG5NYXRlcmlhbE5vZGUuVFJBTlNNSVNTSU9OID0gJ3RyYW5zbWlzc2lvbic7XG5NYXRlcmlhbE5vZGUuVEhJQ0tORVNTID0gJ3RoaWNrbmVzcyc7XG5NYXRlcmlhbE5vZGUuQVRURU5VQVRJT05fRElTVEFOQ0UgPSAnYXR0ZW51YXRpb25EaXN0YW5jZSc7XG5NYXRlcmlhbE5vZGUuQVRURU5VQVRJT05fQ09MT1IgPSAnYXR0ZW51YXRpb25Db2xvcic7XG5NYXRlcmlhbE5vZGUuTElORV9TQ0FMRSA9ICdzY2FsZSc7XG5NYXRlcmlhbE5vZGUuTElORV9EQVNIX1NJWkUgPSAnZGFzaFNpemUnO1xuTWF0ZXJpYWxOb2RlLkxJTkVfR0FQX1NJWkUgPSAnZ2FwU2l6ZSc7XG5NYXRlcmlhbE5vZGUuTElORV9XSURUSCA9ICdsaW5ld2lkdGgnO1xuTWF0ZXJpYWxOb2RlLkxJTkVfREFTSF9PRkZTRVQgPSAnZGFzaE9mZnNldCc7XG5NYXRlcmlhbE5vZGUuUE9JTlRfV0lEVEggPSAncG9pbnRXaWR0aCc7XG5NYXRlcmlhbE5vZGUuRElTUEVSU0lPTiA9ICdkaXNwZXJzaW9uJztcbk1hdGVyaWFsTm9kZS5MSUdIVF9NQVAgPSAnbGlnaHQnO1xuTWF0ZXJpYWxOb2RlLkFPX01BUCA9ICdhbyc7XG5cbmV4cG9ydCBkZWZhdWx0IE1hdGVyaWFsTm9kZTtcblxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsQWxwaGFUZXN0ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5BTFBIQV9URVNUICk7XG5leHBvcnQgY29uc3QgbWF0ZXJpYWxDb2xvciA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuQ09MT1IgKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbFNoaW5pbmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuU0hJTklORVNTICk7XG5leHBvcnQgY29uc3QgbWF0ZXJpYWxFbWlzc2l2ZSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuRU1JU1NJVkUgKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbE9wYWNpdHkgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLk9QQUNJVFkgKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbFNwZWN1bGFyID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5TUEVDVUxBUiApO1xuXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxTcGVjdWxhckludGVuc2l0eSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuU1BFQ1VMQVJfSU5URU5TSVRZICk7XG5leHBvcnQgY29uc3QgbWF0ZXJpYWxTcGVjdWxhckNvbG9yID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5TUEVDVUxBUl9DT0xPUiApO1xuXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxTcGVjdWxhclN0cmVuZ3RoID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5TUEVDVUxBUl9TVFJFTkdUSCApO1xuZXhwb3J0IGNvbnN0IG1hdGVyaWFsUmVmbGVjdGl2aXR5ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5SRUZMRUNUSVZJVFkgKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbFJvdWdobmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuUk9VR0hORVNTICk7XG5leHBvcnQgY29uc3QgbWF0ZXJpYWxNZXRhbG5lc3MgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLk1FVEFMTkVTUyApO1xuZXhwb3J0IGNvbnN0IG1hdGVyaWFsTm9ybWFsID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5OT1JNQUwgKS5jb250ZXh0KCB7IGdldFVWOiBudWxsIH0gKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbENsZWFyY29hdCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuQ0xFQVJDT0FUICk7XG5leHBvcnQgY29uc3QgbWF0ZXJpYWxDbGVhcmNvYXRSb3VnaG5lc3MgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLkNMRUFSQ09BVF9ST1VHSE5FU1MgKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbENsZWFyY29hdE5vcm1hbCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuQ0xFQVJDT0FUX05PUk1BTCApLmNvbnRleHQoIHsgZ2V0VVY6IG51bGwgfSApO1xuZXhwb3J0IGNvbnN0IG1hdGVyaWFsUm90YXRpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLlJPVEFUSU9OICk7XG5leHBvcnQgY29uc3QgbWF0ZXJpYWxTaGVlbiA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuU0hFRU4gKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbFNoZWVuUm91Z2huZXNzID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5TSEVFTl9ST1VHSE5FU1MgKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbEFuaXNvdHJvcHkgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLkFOSVNPVFJPUFkgKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbElyaWRlc2NlbmNlID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5JUklERVNDRU5DRSApO1xuZXhwb3J0IGNvbnN0IG1hdGVyaWFsSXJpZGVzY2VuY2VJT1IgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLklSSURFU0NFTkNFX0lPUiApO1xuZXhwb3J0IGNvbnN0IG1hdGVyaWFsSXJpZGVzY2VuY2VUaGlja25lc3MgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLklSSURFU0NFTkNFX1RISUNLTkVTUyApO1xuZXhwb3J0IGNvbnN0IG1hdGVyaWFsVHJhbnNtaXNzaW9uID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5UUkFOU01JU1NJT04gKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbFRoaWNrbmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuVEhJQ0tORVNTICk7XG5leHBvcnQgY29uc3QgbWF0ZXJpYWxJT1IgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLklPUiApO1xuZXhwb3J0IGNvbnN0IG1hdGVyaWFsQXR0ZW51YXRpb25EaXN0YW5jZSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuQVRURU5VQVRJT05fRElTVEFOQ0UgKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbEF0dGVudWF0aW9uQ29sb3IgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLkFUVEVOVUFUSU9OX0NPTE9SICk7XG5leHBvcnQgY29uc3QgbWF0ZXJpYWxMaW5lU2NhbGUgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLkxJTkVfU0NBTEUgKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbExpbmVEYXNoU2l6ZSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuTElORV9EQVNIX1NJWkUgKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbExpbmVHYXBTaXplID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5MSU5FX0dBUF9TSVpFICk7XG5leHBvcnQgY29uc3QgbWF0ZXJpYWxMaW5lV2lkdGggPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLkxJTkVfV0lEVEggKTtcbmV4cG9ydCBjb25zdCBtYXRlcmlhbExpbmVEYXNoT2Zmc2V0ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5MSU5FX0RBU0hfT0ZGU0VUICk7XG5leHBvcnQgY29uc3QgbWF0ZXJpYWxQb2ludFdpZHRoID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5QT0lOVF9XSURUSCApO1xuZXhwb3J0IGNvbnN0IG1hdGVyaWFsRGlzcGVyc2lvbiA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuRElTUEVSU0lPTiApO1xuZXhwb3J0IGNvbnN0IG1hdGVyaWFsTGlnaHRNYXAgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLkxJR0hUX01BUCApO1xuZXhwb3J0IGNvbnN0IG1hdGVyaWFsQU9NYXAgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLkFPX01BUCApO1xuZXhwb3J0IGNvbnN0IG1hdGVyaWFsQW5pc290cm9weVZlY3RvciA9IC8qQF9fUFVSRV9fKi8gdW5pZm9ybSggbmV3IFZlY3RvcjIoKSApLm9uUmVmZXJlbmNlKCBmdW5jdGlvbiAoIGZyYW1lICkge1xuXG5cdHJldHVybiBmcmFtZS5tYXRlcmlhbDtcblxufSApLm9uUmVuZGVyVXBkYXRlKCBmdW5jdGlvbiAoIHsgbWF0ZXJpYWwgfSApIHtcblxuXHR0aGlzLnZhbHVlLnNldCggbWF0ZXJpYWwuYW5pc290cm9weSAqIE1hdGguY29zKCBtYXRlcmlhbC5hbmlzb3Ryb3B5Um90YXRpb24gKSwgbWF0ZXJpYWwuYW5pc290cm9weSAqIE1hdGguc2luKCBtYXRlcmlhbC5hbmlzb3Ryb3B5Um90YXRpb24gKSApO1xuXG59ICk7XG4iLCJpbXBvcnQgVGVtcE5vZGUgZnJvbSAnLi4vY29yZS9UZW1wTm9kZS5qcyc7XG5pbXBvcnQgeyBjYW1lcmFQcm9qZWN0aW9uTWF0cml4IH0gZnJvbSAnLi9DYW1lcmEuanMnO1xuaW1wb3J0IHsgcG9zaXRpb25Mb2NhbCB9IGZyb20gJy4vUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5LCB2YXJ5aW5nIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgbW9kZWxWaWV3TWF0cml4IH0gZnJvbSAnLi9Nb2RlbE5vZGUuanMnO1xuXG5jbGFzcyBNb2RlbFZpZXdQcm9qZWN0aW9uTm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ01vZGVsVmlld1Byb2plY3Rpb25Ob2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHBvc2l0aW9uTm9kZSA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggJ3ZlYzQnICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uTm9kZSA9IHBvc2l0aW9uTm9kZTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRpZiAoIGJ1aWxkZXIuc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgKSB7XG5cblx0XHRcdHJldHVybiB2YXJ5aW5nKCBidWlsZGVyLmNvbnRleHQubXZwICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb25Ob2RlIHx8IHBvc2l0aW9uTG9jYWw7XG5cdFx0Y29uc3Qgdmlld01hdHJpeCA9IGJ1aWxkZXIucmVuZGVyZXIubm9kZXMubW9kZWxWaWV3TWF0cml4IHx8IG1vZGVsVmlld01hdHJpeDtcblxuXHRcdHJldHVybiBjYW1lcmFQcm9qZWN0aW9uTWF0cml4Lm11bCggdmlld01hdHJpeCApLm11bCggcG9zaXRpb24gKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTW9kZWxWaWV3UHJvamVjdGlvbk5vZGU7XG5cbmV4cG9ydCBjb25zdCBtb2RlbFZpZXdQcm9qZWN0aW9uID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1vZGVsVmlld1Byb2plY3Rpb25Ob2RlICk7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuL05vZGUuanMnO1xuaW1wb3J0IHsgbm9kZUltbXV0YWJsZSwgdmFyeWluZyB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY2xhc3MgSW5kZXhOb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdJbmRleE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3Rvciggc2NvcGUgKSB7XG5cblx0XHRzdXBlciggJ3VpbnQnICk7XG5cblx0XHR0aGlzLnNjb3BlID0gc2NvcGU7XG5cblx0XHR0aGlzLmlzSW5zdGFuY2VJbmRleE5vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IG5vZGVUeXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXHRcdGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcblxuXHRcdGxldCBwcm9wZXJ0eU5hbWU7XG5cblx0XHRpZiAoIHNjb3BlID09PSBJbmRleE5vZGUuVkVSVEVYICkge1xuXG5cdFx0XHQvLyBUaGUgaW5kZXggb2YgYSB2ZXJ0ZXggd2l0aGluIGEgbWVzaC5cblx0XHRcdHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0VmVydGV4SW5kZXgoKTtcblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBJbmRleE5vZGUuSU5TVEFOQ0UgKSB7XG5cblx0XHRcdC8vIFRoZSBpbmRleCBvZiBlaXRoZXIgYSBtZXNoIGluc3RhbmNlIG9yIGFuIGludm9jYXRpb24gb2YgYSBjb21wdXRlIHNoYWRlci5cblx0XHRcdHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0SW5zdGFuY2VJbmRleCgpO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IEluZGV4Tm9kZS5EUkFXICkge1xuXG5cdFx0XHQvLyBUaGUgaW5kZXggb2YgYSBkcmF3IGNhbGwuXG5cdFx0XHRwcm9wZXJ0eU5hbWUgPSBidWlsZGVyLmdldERyYXdJbmRleCgpO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IEluZGV4Tm9kZS5JTlZPQ0FUSU9OX0xPQ0FMICkge1xuXG5cdFx0XHQvLyBUaGUgaW5kZXggb2YgYSBjb21wdXRlIGludm9jYXRpb24gd2l0aGluIHRoZSBzY29wZSBvZiBhIHdvcmtncm91cCBsb2FkLlxuXHRcdFx0cHJvcGVydHlOYW1lID0gYnVpbGRlci5nZXRJbnZvY2F0aW9uTG9jYWxJbmRleCgpO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IEluZGV4Tm9kZS5JTlZPQ0FUSU9OX1NVQkdST1VQICkge1xuXG5cdFx0XHQvLyBUaGUgaW5kZXggb2YgYSBjb21wdXRlIGludm9jYXRpb24gd2l0aGluIHRoZSBzY29wZSBvZiBhIHN1Ymdyb3VwLlxuXHRcdFx0cHJvcGVydHlOYW1lID0gYnVpbGRlci5nZXRJbnZvY2F0aW9uU3ViZ3JvdXBJbmRleCgpO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IEluZGV4Tm9kZS5TVUJHUk9VUCApIHtcblxuXHRcdFx0Ly8gVGhlIGluZGV4IG9mIHRoZSBzdWJncm91cCB0aGUgY3VycmVudCBjb21wdXRlIGludm9jYXRpb24gYmVsb25ncyB0by5cblx0XHRcdHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0U3ViZ3JvdXBJbmRleCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuSW5kZXhOb2RlOiBVbmtub3duIHNjb3BlOiAnICsgc2NvcGUgKTtcblxuXHRcdH1cblxuXHRcdGxldCBvdXRwdXQ7XG5cblx0XHRpZiAoIGJ1aWxkZXIuc2hhZGVyU3RhZ2UgPT09ICd2ZXJ0ZXgnIHx8IGJ1aWxkZXIuc2hhZGVyU3RhZ2UgPT09ICdjb21wdXRlJyApIHtcblxuXHRcdFx0b3V0cHV0ID0gcHJvcGVydHlOYW1lO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3Qgbm9kZVZhcnlpbmcgPSB2YXJ5aW5nKCB0aGlzICk7XG5cblx0XHRcdG91dHB1dCA9IG5vZGVWYXJ5aW5nLmJ1aWxkKCBidWlsZGVyLCBub2RlVHlwZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHR9XG5cbn1cblxuSW5kZXhOb2RlLlZFUlRFWCA9ICd2ZXJ0ZXgnO1xuSW5kZXhOb2RlLklOU1RBTkNFID0gJ2luc3RhbmNlJztcbkluZGV4Tm9kZS5TVUJHUk9VUCA9ICdzdWJncm91cCc7XG5JbmRleE5vZGUuSU5WT0NBVElPTl9MT0NBTCA9ICdpbnZvY2F0aW9uTG9jYWwnO1xuSW5kZXhOb2RlLklOVk9DQVRJT05fU1VCR1JPVVAgPSAnaW52b2NhdGlvblN1Ymdyb3VwJztcbkluZGV4Tm9kZS5EUkFXID0gJ2RyYXcnO1xuXG5leHBvcnQgZGVmYXVsdCBJbmRleE5vZGU7XG5cbmV4cG9ydCBjb25zdCB2ZXJ0ZXhJbmRleCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggSW5kZXhOb2RlLCBJbmRleE5vZGUuVkVSVEVYICk7XG5leHBvcnQgY29uc3QgaW5zdGFuY2VJbmRleCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggSW5kZXhOb2RlLCBJbmRleE5vZGUuSU5TVEFOQ0UgKTtcbmV4cG9ydCBjb25zdCBzdWJncm91cEluZGV4ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBJbmRleE5vZGUsIEluZGV4Tm9kZS5TVUJHUk9VUCApO1xuZXhwb3J0IGNvbnN0IGludm9jYXRpb25TdWJncm91cEluZGV4ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBJbmRleE5vZGUsIEluZGV4Tm9kZS5JTlZPQ0FUSU9OX1NVQkdST1VQICk7XG5leHBvcnQgY29uc3QgaW52b2NhdGlvbkxvY2FsSW5kZXggPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIEluZGV4Tm9kZSwgSW5kZXhOb2RlLklOVk9DQVRJT05fTE9DQUwgKTtcbmV4cG9ydCBjb25zdCBkcmF3SW5kZXggPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIEluZGV4Tm9kZSwgSW5kZXhOb2RlLkRSQVcgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyB2YXJ5aW5nUHJvcGVydHkgfSBmcm9tICcuLi9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XG5pbXBvcnQgeyBpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUsIGluc3RhbmNlZER5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL0J1ZmZlckF0dHJpYnV0ZU5vZGUuanMnO1xuaW1wb3J0IHsgbm9ybWFsTG9jYWwsIHRyYW5zZm9ybU5vcm1hbCB9IGZyb20gJy4vTm9ybWFsLmpzJztcbmltcG9ydCB7IHBvc2l0aW9uTG9jYWwgfSBmcm9tICcuL1Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IG5vZGVQcm94eSwgdmVjMywgbWF0NCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgYnVmZmVyIH0gZnJvbSAnLi4vYWNjZXNzb3JzL0J1ZmZlck5vZGUuanMnO1xuaW1wb3J0IHsgaW5zdGFuY2VJbmRleCB9IGZyb20gJy4uL2NvcmUvSW5kZXhOb2RlLmpzJztcblxuaW1wb3J0IHsgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgfSBmcm9tICcuLi8uLi9jb3JlL0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLmpzJztcbmltcG9ydCB7IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uLy4uL2NvcmUvSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IER5bmFtaWNEcmF3VXNhZ2UgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuXG5jbGFzcyBJbnN0YW5jZU5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0luc3RhbmNlTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBjb3VudCwgaW5zdGFuY2VNYXRyaXgsIGluc3RhbmNlQ29sb3IgKSB7XG5cblx0XHRzdXBlciggJ3ZvaWQnICk7XG5cblx0XHR0aGlzLmNvdW50ID0gY291bnQ7XG5cdFx0dGhpcy5pbnN0YW5jZU1hdHJpeCA9IGluc3RhbmNlTWF0cml4O1xuXHRcdHRoaXMuaW5zdGFuY2VDb2xvciA9IGluc3RhbmNlQ29sb3I7XG5cblx0XHR0aGlzLmluc3RhbmNlTWF0cml4Tm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLmluc3RhbmNlQ29sb3JOb2RlID0gbnVsbDtcblxuXHRcdHRoaXMudXBkYXRlVHlwZSA9IE5vZGVVcGRhdGVUeXBlLkZSQU1FO1xuXG5cdFx0dGhpcy5idWZmZXIgPSBudWxsO1xuXHRcdHRoaXMuYnVmZmVyQ29sb3IgPSBudWxsO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHsgY291bnQsIGluc3RhbmNlTWF0cml4LCBpbnN0YW5jZUNvbG9yIH0gPSB0aGlzO1xuXG5cdFx0bGV0IHsgaW5zdGFuY2VNYXRyaXhOb2RlLCBpbnN0YW5jZUNvbG9yTm9kZSB9ID0gdGhpcztcblxuXHRcdGlmICggaW5zdGFuY2VNYXRyaXhOb2RlID09PSBudWxsICkge1xuXG5cdFx0XHQvLyBCb3RoIFdlYkdQVSBhbmQgV2ViR0wgYmFja2VuZHMgaGF2ZSBVQk8gbWF4IGxpbWl0ZWQgdG8gNjRrYi4gTWF0cml4IGNvdW50IG51bWJlciBiaWdnZXIgdGhhbiAxMDAwICggMTYgKiA0ICogMTAwMCA9IDY0a2IgKSB3aWxsIGZhbGxiYWNrIHRvIGF0dHJpYnV0ZS5cblxuXHRcdFx0aWYgKCBjb3VudCA8PSAxMDAwICkge1xuXG5cdFx0XHRcdGluc3RhbmNlTWF0cml4Tm9kZSA9IGJ1ZmZlciggaW5zdGFuY2VNYXRyaXguYXJyYXksICdtYXQ0JywgTWF0aC5tYXgoIGNvdW50LCAxICkgKS5lbGVtZW50KCBpbnN0YW5jZUluZGV4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgYnVmZmVyID0gbmV3IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyKCBpbnN0YW5jZU1hdHJpeC5hcnJheSwgMTYsIDEgKTtcblxuXHRcdFx0XHR0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcblxuXHRcdFx0XHRjb25zdCBidWZmZXJGbiA9IGluc3RhbmNlTWF0cml4LnVzYWdlID09PSBEeW5hbWljRHJhd1VzYWdlID8gaW5zdGFuY2VkRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSA6IGluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTtcblxuXHRcdFx0XHRjb25zdCBpbnN0YW5jZUJ1ZmZlcnMgPSBbXG5cdFx0XHRcdFx0Ly8gRi5TaWduYXR1cmUgLT4gYnVmZmVyQXR0cmlidXRlKCBhcnJheSwgdHlwZSwgc3RyaWRlLCBvZmZzZXQgKVxuXHRcdFx0XHRcdGJ1ZmZlckZuKCBidWZmZXIsICd2ZWM0JywgMTYsIDAgKSxcblx0XHRcdFx0XHRidWZmZXJGbiggYnVmZmVyLCAndmVjNCcsIDE2LCA0ICksXG5cdFx0XHRcdFx0YnVmZmVyRm4oIGJ1ZmZlciwgJ3ZlYzQnLCAxNiwgOCApLFxuXHRcdFx0XHRcdGJ1ZmZlckZuKCBidWZmZXIsICd2ZWM0JywgMTYsIDEyIClcblx0XHRcdFx0XTtcblxuXHRcdFx0XHRpbnN0YW5jZU1hdHJpeE5vZGUgPSBtYXQ0KCAuLi5pbnN0YW5jZUJ1ZmZlcnMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmluc3RhbmNlTWF0cml4Tm9kZSA9IGluc3RhbmNlTWF0cml4Tm9kZTtcblxuXHRcdH1cblxuXHRcdGlmICggaW5zdGFuY2VDb2xvciAmJiBpbnN0YW5jZUNvbG9yTm9kZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgYnVmZmVyID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggaW5zdGFuY2VDb2xvci5hcnJheSwgMyApO1xuXG5cdFx0XHRjb25zdCBidWZmZXJGbiA9IGluc3RhbmNlQ29sb3IudXNhZ2UgPT09IER5bmFtaWNEcmF3VXNhZ2UgPyBpbnN0YW5jZWREeW5hbWljQnVmZmVyQXR0cmlidXRlIDogaW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlO1xuXG5cdFx0XHR0aGlzLmJ1ZmZlckNvbG9yID0gYnVmZmVyO1xuXG5cdFx0XHRpbnN0YW5jZUNvbG9yTm9kZSA9IHZlYzMoIGJ1ZmZlckZuKCBidWZmZXIsICd2ZWMzJywgMywgMCApICk7XG5cblx0XHRcdHRoaXMuaW5zdGFuY2VDb2xvck5vZGUgPSBpbnN0YW5jZUNvbG9yTm9kZTtcblxuXHRcdH1cblxuXHRcdC8vIFBPU0lUSU9OXG5cblx0XHRjb25zdCBpbnN0YW5jZVBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXhOb2RlLm11bCggcG9zaXRpb25Mb2NhbCApLnh5ejtcblx0XHRwb3NpdGlvbkxvY2FsLmFzc2lnbiggaW5zdGFuY2VQb3NpdGlvbiApO1xuXG5cdFx0Ly8gTk9STUFMXG5cblx0XHRpZiAoIGJ1aWxkZXIuaGFzR2VvbWV0cnlBdHRyaWJ1dGUoICdub3JtYWwnICkgKSB7XG5cblx0XHRcdGNvbnN0IGluc3RhbmNlTm9ybWFsID0gdHJhbnNmb3JtTm9ybWFsKCBub3JtYWxMb2NhbCwgaW5zdGFuY2VNYXRyaXhOb2RlICk7XG5cblx0XHRcdC8vIEFTU0lHTlNcblxuXHRcdFx0bm9ybWFsTG9jYWwuYXNzaWduKCBpbnN0YW5jZU5vcm1hbCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQ09MT1JcblxuXHRcdGlmICggdGhpcy5pbnN0YW5jZUNvbG9yTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dmFyeWluZ1Byb3BlcnR5KCAndmVjMycsICd2SW5zdGFuY2VDb2xvcicgKS5hc3NpZ24oIHRoaXMuaW5zdGFuY2VDb2xvck5vZGUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dXBkYXRlKCAvKmZyYW1lKi8gKSB7XG5cblx0XHRpZiAoIHRoaXMuaW5zdGFuY2VNYXRyaXgudXNhZ2UgIT09IER5bmFtaWNEcmF3VXNhZ2UgJiYgdGhpcy5idWZmZXIgIT0gbnVsbCAmJiB0aGlzLmluc3RhbmNlTWF0cml4LnZlcnNpb24gIT09IHRoaXMuYnVmZmVyLnZlcnNpb24gKSB7XG5cblx0XHRcdHRoaXMuYnVmZmVyLnZlcnNpb24gPSB0aGlzLmluc3RhbmNlTWF0cml4LnZlcnNpb247XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuaW5zdGFuY2VDb2xvciAmJiB0aGlzLmluc3RhbmNlQ29sb3IudXNhZ2UgIT09IER5bmFtaWNEcmF3VXNhZ2UgJiYgdGhpcy5idWZmZXJDb2xvciAhPSBudWxsICYmIHRoaXMuaW5zdGFuY2VDb2xvci52ZXJzaW9uICE9PSB0aGlzLmJ1ZmZlckNvbG9yLnZlcnNpb24gKSB7XG5cblx0XHRcdHRoaXMuYnVmZmVyQ29sb3IudmVyc2lvbiA9IHRoaXMuaW5zdGFuY2VDb2xvci52ZXJzaW9uO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnN0YW5jZU5vZGU7XG5cbmV4cG9ydCBjb25zdCBpbnN0YW5jZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBJbnN0YW5jZU5vZGUgKTtcbiIsImltcG9ydCBJbnN0YW5jZU5vZGUgZnJvbSAnLi9JbnN0YW5jZU5vZGUuanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5jbGFzcyBJbnN0YW5jZWRNZXNoTm9kZSBleHRlbmRzIEluc3RhbmNlTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdJbnN0YW5jZWRNZXNoTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBpbnN0YW5jZU1lc2ggKSB7XG5cblx0XHRjb25zdCB7IGNvdW50LCBpbnN0YW5jZU1hdHJpeCwgaW5zdGFuY2VDb2xvciB9ID0gaW5zdGFuY2VNZXNoO1xuXG5cdFx0c3VwZXIoIGNvdW50LCBpbnN0YW5jZU1hdHJpeCwgaW5zdGFuY2VDb2xvciApO1xuXG5cdFx0dGhpcy5pbnN0YW5jZU1lc2ggPSBpbnN0YW5jZU1lc2g7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEluc3RhbmNlZE1lc2hOb2RlO1xuXG5leHBvcnQgY29uc3QgaW5zdGFuY2VkTWVzaCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBJbnN0YW5jZWRNZXNoTm9kZSApO1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcbmltcG9ydCB7IG5vcm1hbExvY2FsIH0gZnJvbSAnLi9Ob3JtYWwuanMnO1xuaW1wb3J0IHsgcG9zaXRpb25Mb2NhbCB9IGZyb20gJy4vUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5LCB2ZWMzLCBtYXQzLCBtYXQ0LCBpbnQsIGl2ZWMyLCBmbG9hdCwgRm4gfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyB0ZXh0dXJlTG9hZCB9IGZyb20gJy4vVGV4dHVyZU5vZGUuanMnO1xuaW1wb3J0IHsgdGV4dHVyZVNpemUgfSBmcm9tICcuL1RleHR1cmVTaXplTm9kZS5qcyc7XG5pbXBvcnQgeyB0YW5nZW50TG9jYWwgfSBmcm9tICcuL1RhbmdlbnQuanMnO1xuaW1wb3J0IHsgaW5zdGFuY2VJbmRleCwgZHJhd0luZGV4IH0gZnJvbSAnLi4vY29yZS9JbmRleE5vZGUuanMnO1xuaW1wb3J0IHsgdmFyeWluZ1Byb3BlcnR5IH0gZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xuXG5jbGFzcyBCYXRjaE5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0JhdGNoTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBiYXRjaE1lc2ggKSB7XG5cblx0XHRzdXBlciggJ3ZvaWQnICk7XG5cblx0XHR0aGlzLmJhdGNoTWVzaCA9IGJhdGNoTWVzaDtcblxuXG5cdFx0dGhpcy5iYXRjaGluZ0lkTm9kZSA9IG51bGw7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Ly8gUE9TSVRJT05cblxuXHRcdGlmICggdGhpcy5iYXRjaGluZ0lkTm9kZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCBidWlsZGVyLmdldERyYXdJbmRleCgpID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuYmF0Y2hpbmdJZE5vZGUgPSBpbnN0YW5jZUluZGV4O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuYmF0Y2hpbmdJZE5vZGUgPSBkcmF3SW5kZXg7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGdldEluZGlyZWN0SW5kZXggPSBGbiggKCBbIGlkIF0gKSA9PiB7XG5cblx0XHRcdGNvbnN0IHNpemUgPSB0ZXh0dXJlU2l6ZSggdGV4dHVyZUxvYWQoIHRoaXMuYmF0Y2hNZXNoLl9pbmRpcmVjdFRleHR1cmUgKSwgMCApO1xuXHRcdFx0Y29uc3QgeCA9IGludCggaWQgKS5tb2RJbnQoIGludCggc2l6ZSApICk7XG5cdFx0XHRjb25zdCB5ID0gaW50KCBpZCApLmRpdiggaW50KCBzaXplICkgKTtcblx0XHRcdHJldHVybiB0ZXh0dXJlTG9hZCggdGhpcy5iYXRjaE1lc2guX2luZGlyZWN0VGV4dHVyZSwgaXZlYzIoIHgsIHkgKSApLng7XG5cblx0XHR9ICkuc2V0TGF5b3V0KCB7XG5cdFx0XHRuYW1lOiAnZ2V0SW5kaXJlY3RJbmRleCcsXG5cdFx0XHR0eXBlOiAndWludCcsXG5cdFx0XHRpbnB1dHM6IFtcblx0XHRcdFx0eyBuYW1lOiAnaWQnLCB0eXBlOiAnaW50JyB9XG5cdFx0XHRdXG5cdFx0fSApO1xuXG5cdFx0Y29uc3QgaW5kaXJlY3RJZCA9IGdldEluZGlyZWN0SW5kZXgoIGludCggdGhpcy5iYXRjaGluZ0lkTm9kZSApICk7XG5cblx0XHRjb25zdCBtYXRyaWNlc1RleHR1cmUgPSB0aGlzLmJhdGNoTWVzaC5fbWF0cmljZXNUZXh0dXJlO1xuXG5cdFx0Y29uc3Qgc2l6ZSA9IHRleHR1cmVTaXplKCB0ZXh0dXJlTG9hZCggbWF0cmljZXNUZXh0dXJlICksIDAgKTtcblx0XHRjb25zdCBqID0gZmxvYXQoIGluZGlyZWN0SWQgKS5tdWwoIDQgKS50b0ludCgpLnRvVmFyKCk7XG5cblx0XHRjb25zdCB4ID0gai5tb2RJbnQoIHNpemUgKTtcblx0XHRjb25zdCB5ID0gai5kaXYoIGludCggc2l6ZSApICk7XG5cdFx0Y29uc3QgYmF0Y2hpbmdNYXRyaXggPSBtYXQ0KFxuXHRcdFx0dGV4dHVyZUxvYWQoIG1hdHJpY2VzVGV4dHVyZSwgaXZlYzIoIHgsIHkgKSApLFxuXHRcdFx0dGV4dHVyZUxvYWQoIG1hdHJpY2VzVGV4dHVyZSwgaXZlYzIoIHguYWRkKCAxICksIHkgKSApLFxuXHRcdFx0dGV4dHVyZUxvYWQoIG1hdHJpY2VzVGV4dHVyZSwgaXZlYzIoIHguYWRkKCAyICksIHkgKSApLFxuXHRcdFx0dGV4dHVyZUxvYWQoIG1hdHJpY2VzVGV4dHVyZSwgaXZlYzIoIHguYWRkKCAzICksIHkgKSApXG5cdFx0KTtcblxuXG5cdFx0Y29uc3QgY29sb3JzVGV4dHVyZSA9IHRoaXMuYmF0Y2hNZXNoLl9jb2xvcnNUZXh0dXJlO1xuXG5cdFx0aWYgKCBjb2xvcnNUZXh0dXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBnZXRCYXRjaGluZ0NvbG9yID0gRm4oICggWyBpZCBdICkgPT4ge1xuXG5cdFx0XHRcdGNvbnN0IHNpemUgPSB0ZXh0dXJlU2l6ZSggdGV4dHVyZUxvYWQoIGNvbG9yc1RleHR1cmUgKSwgMCApLng7XG5cdFx0XHRcdGNvbnN0IGogPSBpZDtcblx0XHRcdFx0Y29uc3QgeCA9IGoubW9kSW50KCBzaXplICk7XG5cdFx0XHRcdGNvbnN0IHkgPSBqLmRpdiggc2l6ZSApO1xuXHRcdFx0XHRyZXR1cm4gdGV4dHVyZUxvYWQoIGNvbG9yc1RleHR1cmUsIGl2ZWMyKCB4LCB5ICkgKS5yZ2I7XG5cblx0XHRcdH0gKS5zZXRMYXlvdXQoIHtcblx0XHRcdFx0bmFtZTogJ2dldEJhdGNoaW5nQ29sb3InLFxuXHRcdFx0XHR0eXBlOiAndmVjMycsXG5cdFx0XHRcdGlucHV0czogW1xuXHRcdFx0XHRcdHsgbmFtZTogJ2lkJywgdHlwZTogJ2ludCcgfVxuXHRcdFx0XHRdXG5cdFx0XHR9ICk7XG5cblx0XHRcdGNvbnN0IGNvbG9yID0gZ2V0QmF0Y2hpbmdDb2xvciggaW5kaXJlY3RJZCApO1xuXG5cdFx0XHR2YXJ5aW5nUHJvcGVydHkoICd2ZWMzJywgJ3ZCYXRjaENvbG9yJyApLmFzc2lnbiggY29sb3IgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGJtID0gbWF0MyggYmF0Y2hpbmdNYXRyaXggKTtcblxuXHRcdHBvc2l0aW9uTG9jYWwuYXNzaWduKCBiYXRjaGluZ01hdHJpeC5tdWwoIHBvc2l0aW9uTG9jYWwgKSApO1xuXG5cdFx0Y29uc3QgdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxMb2NhbC5kaXYoIHZlYzMoIGJtWyAwIF0uZG90KCBibVsgMCBdICksIGJtWyAxIF0uZG90KCBibVsgMSBdICksIGJtWyAyIF0uZG90KCBibVsgMiBdICkgKSApO1xuXG5cdFx0Y29uc3QgYmF0Y2hpbmdOb3JtYWwgPSBibS5tdWwoIHRyYW5zZm9ybWVkTm9ybWFsICkueHl6O1xuXG5cdFx0bm9ybWFsTG9jYWwuYXNzaWduKCBiYXRjaGluZ05vcm1hbCApO1xuXG5cdFx0aWYgKCBidWlsZGVyLmhhc0dlb21ldHJ5QXR0cmlidXRlKCAndGFuZ2VudCcgKSApIHtcblxuXHRcdFx0dGFuZ2VudExvY2FsLm11bEFzc2lnbiggYm0gKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hOb2RlO1xuXG5leHBvcnQgY29uc3QgYmF0Y2ggPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggQmF0Y2hOb2RlICk7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgYXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9BdHRyaWJ1dGVOb2RlLmpzJztcbmltcG9ydCB7IHJlZmVyZW5jZSwgcmVmZXJlbmNlQnVmZmVyIH0gZnJvbSAnLi9SZWZlcmVuY2VOb2RlLmpzJztcbmltcG9ydCB7IGFkZCB9IGZyb20gJy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJztcbmltcG9ydCB7IG5vcm1hbExvY2FsIH0gZnJvbSAnLi9Ob3JtYWwuanMnO1xuaW1wb3J0IHsgcG9zaXRpb25Mb2NhbCwgcG9zaXRpb25QcmV2aW91cyB9IGZyb20gJy4vUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgdGFuZ2VudExvY2FsIH0gZnJvbSAnLi9UYW5nZW50LmpzJztcbmltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcbmltcG9ydCB7IGJ1ZmZlciB9IGZyb20gJy4vQnVmZmVyTm9kZS5qcyc7XG5cbmNvbnN0IF9mcmFtZUlkID0gbmV3IFdlYWtNYXAoKTtcblxuY2xhc3MgU2tpbm5pbmdOb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdTa2lubmluZ05vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3Rvciggc2tpbm5lZE1lc2gsIHVzZVJlZmVyZW5jZSA9IGZhbHNlICkge1xuXG5cdFx0c3VwZXIoICd2b2lkJyApO1xuXG5cdFx0dGhpcy5za2lubmVkTWVzaCA9IHNraW5uZWRNZXNoO1xuXHRcdHRoaXMudXNlUmVmZXJlbmNlID0gdXNlUmVmZXJlbmNlO1xuXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuT0JKRUNUO1xuXG5cdFx0Ly9cblxuXHRcdHRoaXMuc2tpbkluZGV4Tm9kZSA9IGF0dHJpYnV0ZSggJ3NraW5JbmRleCcsICd1dmVjNCcgKTtcblx0XHR0aGlzLnNraW5XZWlnaHROb2RlID0gYXR0cmlidXRlKCAnc2tpbldlaWdodCcsICd2ZWM0JyApO1xuXG5cdFx0bGV0IGJpbmRNYXRyaXhOb2RlLCBiaW5kTWF0cml4SW52ZXJzZU5vZGUsIGJvbmVNYXRyaWNlc05vZGU7XG5cblx0XHRpZiAoIHVzZVJlZmVyZW5jZSApIHtcblxuXHRcdFx0YmluZE1hdHJpeE5vZGUgPSByZWZlcmVuY2UoICdiaW5kTWF0cml4JywgJ21hdDQnICk7XG5cdFx0XHRiaW5kTWF0cml4SW52ZXJzZU5vZGUgPSByZWZlcmVuY2UoICdiaW5kTWF0cml4SW52ZXJzZScsICdtYXQ0JyApO1xuXHRcdFx0Ym9uZU1hdHJpY2VzTm9kZSA9IHJlZmVyZW5jZUJ1ZmZlciggJ3NrZWxldG9uLmJvbmVNYXRyaWNlcycsICdtYXQ0Jywgc2tpbm5lZE1lc2guc2tlbGV0b24uYm9uZXMubGVuZ3RoICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRiaW5kTWF0cml4Tm9kZSA9IHVuaWZvcm0oIHNraW5uZWRNZXNoLmJpbmRNYXRyaXgsICdtYXQ0JyApO1xuXHRcdFx0YmluZE1hdHJpeEludmVyc2VOb2RlID0gdW5pZm9ybSggc2tpbm5lZE1lc2guYmluZE1hdHJpeEludmVyc2UsICdtYXQ0JyApO1xuXHRcdFx0Ym9uZU1hdHJpY2VzTm9kZSA9IGJ1ZmZlciggc2tpbm5lZE1lc2guc2tlbGV0b24uYm9uZU1hdHJpY2VzLCAnbWF0NCcsIHNraW5uZWRNZXNoLnNrZWxldG9uLmJvbmVzLmxlbmd0aCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5iaW5kTWF0cml4Tm9kZSA9IGJpbmRNYXRyaXhOb2RlO1xuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2VOb2RlID0gYmluZE1hdHJpeEludmVyc2VOb2RlO1xuXHRcdHRoaXMuYm9uZU1hdHJpY2VzTm9kZSA9IGJvbmVNYXRyaWNlc05vZGU7XG5cdFx0dGhpcy5wcmV2aW91c0JvbmVNYXRyaWNlc05vZGUgPSBudWxsO1xuXG5cdH1cblxuXHRnZXRTa2lubmVkUG9zaXRpb24oIGJvbmVNYXRyaWNlcyA9IHRoaXMuYm9uZU1hdHJpY2VzTm9kZSwgcG9zaXRpb24gPSBwb3NpdGlvbkxvY2FsICkge1xuXG5cdFx0Y29uc3QgeyBza2luSW5kZXhOb2RlLCBza2luV2VpZ2h0Tm9kZSwgYmluZE1hdHJpeE5vZGUsIGJpbmRNYXRyaXhJbnZlcnNlTm9kZSB9ID0gdGhpcztcblxuXHRcdGNvbnN0IGJvbmVNYXRYID0gYm9uZU1hdHJpY2VzLmVsZW1lbnQoIHNraW5JbmRleE5vZGUueCApO1xuXHRcdGNvbnN0IGJvbmVNYXRZID0gYm9uZU1hdHJpY2VzLmVsZW1lbnQoIHNraW5JbmRleE5vZGUueSApO1xuXHRcdGNvbnN0IGJvbmVNYXRaID0gYm9uZU1hdHJpY2VzLmVsZW1lbnQoIHNraW5JbmRleE5vZGUueiApO1xuXHRcdGNvbnN0IGJvbmVNYXRXID0gYm9uZU1hdHJpY2VzLmVsZW1lbnQoIHNraW5JbmRleE5vZGUudyApO1xuXG5cdFx0Ly8gUE9TSVRJT05cblxuXHRcdGNvbnN0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4Tm9kZS5tdWwoIHBvc2l0aW9uICk7XG5cblx0XHRjb25zdCBza2lubmVkID0gYWRkKFxuXHRcdFx0Ym9uZU1hdFgubXVsKCBza2luV2VpZ2h0Tm9kZS54ICkubXVsKCBza2luVmVydGV4ICksXG5cdFx0XHRib25lTWF0WS5tdWwoIHNraW5XZWlnaHROb2RlLnkgKS5tdWwoIHNraW5WZXJ0ZXggKSxcblx0XHRcdGJvbmVNYXRaLm11bCggc2tpbldlaWdodE5vZGUueiApLm11bCggc2tpblZlcnRleCApLFxuXHRcdFx0Ym9uZU1hdFcubXVsKCBza2luV2VpZ2h0Tm9kZS53ICkubXVsKCBza2luVmVydGV4IClcblx0XHQpO1xuXG5cdFx0cmV0dXJuIGJpbmRNYXRyaXhJbnZlcnNlTm9kZS5tdWwoIHNraW5uZWQgKS54eXo7XG5cblx0fVxuXG5cdGdldFNraW5uZWROb3JtYWwoIGJvbmVNYXRyaWNlcyA9IHRoaXMuYm9uZU1hdHJpY2VzTm9kZSwgbm9ybWFsID0gbm9ybWFsTG9jYWwgKSB7XG5cblx0XHRjb25zdCB7IHNraW5JbmRleE5vZGUsIHNraW5XZWlnaHROb2RlLCBiaW5kTWF0cml4Tm9kZSwgYmluZE1hdHJpeEludmVyc2VOb2RlIH0gPSB0aGlzO1xuXG5cdFx0Y29uc3QgYm9uZU1hdFggPSBib25lTWF0cmljZXMuZWxlbWVudCggc2tpbkluZGV4Tm9kZS54ICk7XG5cdFx0Y29uc3QgYm9uZU1hdFkgPSBib25lTWF0cmljZXMuZWxlbWVudCggc2tpbkluZGV4Tm9kZS55ICk7XG5cdFx0Y29uc3QgYm9uZU1hdFogPSBib25lTWF0cmljZXMuZWxlbWVudCggc2tpbkluZGV4Tm9kZS56ICk7XG5cdFx0Y29uc3QgYm9uZU1hdFcgPSBib25lTWF0cmljZXMuZWxlbWVudCggc2tpbkluZGV4Tm9kZS53ICk7XG5cblx0XHQvLyBOT1JNQUxcblxuXHRcdGxldCBza2luTWF0cml4ID0gYWRkKFxuXHRcdFx0c2tpbldlaWdodE5vZGUueC5tdWwoIGJvbmVNYXRYICksXG5cdFx0XHRza2luV2VpZ2h0Tm9kZS55Lm11bCggYm9uZU1hdFkgKSxcblx0XHRcdHNraW5XZWlnaHROb2RlLnoubXVsKCBib25lTWF0WiApLFxuXHRcdFx0c2tpbldlaWdodE5vZGUudy5tdWwoIGJvbmVNYXRXIClcblx0XHQpO1xuXG5cdFx0c2tpbk1hdHJpeCA9IGJpbmRNYXRyaXhJbnZlcnNlTm9kZS5tdWwoIHNraW5NYXRyaXggKS5tdWwoIGJpbmRNYXRyaXhOb2RlICk7XG5cblx0XHRyZXR1cm4gc2tpbk1hdHJpeC50cmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCApLnh5ejtcblxuXHR9XG5cblx0Z2V0UHJldmlvdXNTa2lubmVkUG9zaXRpb24oIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBza2lubmVkTWVzaCA9IGJ1aWxkZXIub2JqZWN0O1xuXG5cdFx0aWYgKCB0aGlzLnByZXZpb3VzQm9uZU1hdHJpY2VzTm9kZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0c2tpbm5lZE1lc2guc2tlbGV0b24ucHJldmlvdXNCb25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBza2lubmVkTWVzaC5za2VsZXRvbi5ib25lTWF0cmljZXMgKTtcblxuXHRcdFx0dGhpcy5wcmV2aW91c0JvbmVNYXRyaWNlc05vZGUgPSByZWZlcmVuY2VCdWZmZXIoICdza2VsZXRvbi5wcmV2aW91c0JvbmVNYXRyaWNlcycsICdtYXQ0Jywgc2tpbm5lZE1lc2guc2tlbGV0b24uYm9uZXMubGVuZ3RoICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRTa2lubmVkUG9zaXRpb24oIHRoaXMucHJldmlvdXNCb25lTWF0cmljZXNOb2RlLCBwb3NpdGlvblByZXZpb3VzICk7XG5cblx0fVxuXG5cdG5lZWRzUHJldmlvdXNCb25lTWF0cmljZXMoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBtcnQgPSBidWlsZGVyLnJlbmRlcmVyLmdldE1SVCgpO1xuXG5cdFx0cmV0dXJuIG1ydCAmJiBtcnQuaGFzKCAndmVsb2NpdHknICk7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0aWYgKCB0aGlzLm5lZWRzUHJldmlvdXNCb25lTWF0cmljZXMoIGJ1aWxkZXIgKSApIHtcblxuXHRcdFx0cG9zaXRpb25QcmV2aW91cy5hc3NpZ24oIHRoaXMuZ2V0UHJldmlvdXNTa2lubmVkUG9zaXRpb24oIGJ1aWxkZXIgKSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2tpblBvc2l0aW9uID0gdGhpcy5nZXRTa2lubmVkUG9zaXRpb24oKTtcblxuXG5cdFx0cG9zaXRpb25Mb2NhbC5hc3NpZ24oIHNraW5Qb3NpdGlvbiApO1xuXG5cdFx0aWYgKCBidWlsZGVyLmhhc0dlb21ldHJ5QXR0cmlidXRlKCAnbm9ybWFsJyApICkge1xuXG5cdFx0XHRjb25zdCBza2luTm9ybWFsID0gdGhpcy5nZXRTa2lubmVkTm9ybWFsKCk7XG5cblx0XHRcdG5vcm1hbExvY2FsLmFzc2lnbiggc2tpbk5vcm1hbCApO1xuXG5cdFx0XHRpZiAoIGJ1aWxkZXIuaGFzR2VvbWV0cnlBdHRyaWJ1dGUoICd0YW5nZW50JyApICkge1xuXG5cdFx0XHRcdHRhbmdlbnRMb2NhbC5hc3NpZ24oIHNraW5Ob3JtYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xuXG5cdFx0aWYgKCBvdXRwdXQgIT09ICd2b2lkJyApIHtcblxuXHRcdFx0cmV0dXJuIHBvc2l0aW9uTG9jYWwuYnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGUoIGZyYW1lICkge1xuXG5cdFx0Y29uc3Qgb2JqZWN0ID0gdGhpcy51c2VSZWZlcmVuY2UgPyBmcmFtZS5vYmplY3QgOiB0aGlzLnNraW5uZWRNZXNoO1xuXHRcdGNvbnN0IHNrZWxldG9uID0gb2JqZWN0LnNrZWxldG9uO1xuXG5cdFx0aWYgKCBfZnJhbWVJZC5nZXQoIHNrZWxldG9uICkgPT09IGZyYW1lLmZyYW1lSWQgKSByZXR1cm47XG5cblx0XHRfZnJhbWVJZC5zZXQoIHNrZWxldG9uLCBmcmFtZS5mcmFtZUlkICk7XG5cblx0XHRpZiAoIHRoaXMucHJldmlvdXNCb25lTWF0cmljZXNOb2RlICE9PSBudWxsICkgc2tlbGV0b24ucHJldmlvdXNCb25lTWF0cmljZXMuc2V0KCBza2VsZXRvbi5ib25lTWF0cmljZXMgKTtcblxuXHRcdHNrZWxldG9uLnVwZGF0ZSgpO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTa2lubmluZ05vZGU7XG5cbmV4cG9ydCBjb25zdCBza2lubmluZyA9ICggc2tpbm5lZE1lc2ggKSA9PiBub2RlT2JqZWN0KCBuZXcgU2tpbm5pbmdOb2RlKCBza2lubmVkTWVzaCApICk7XG5leHBvcnQgY29uc3Qgc2tpbm5pbmdSZWZlcmVuY2UgPSAoIHNraW5uZWRNZXNoICkgPT4gbm9kZU9iamVjdCggbmV3IFNraW5uaW5nTm9kZSggc2tpbm5lZE1lc2gsIHRydWUgKSApO1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcbmltcG9ydCB7IGV4cHJlc3Npb24gfSBmcm9tICcuLi9jb2RlL0V4cHJlc3Npb25Ob2RlLmpzJztcbmltcG9ydCB7IG5vZGVPYmplY3QsIG5vZGVBcnJheSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY2xhc3MgTG9vcE5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0xvb3BOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtcyA9IFtdICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMucGFyYW1zID0gcGFyYW1zO1xuXG5cdH1cblxuXHRnZXRWYXJOYW1lKCBpbmRleCApIHtcblxuXHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCAnaScuY2hhckNvZGVBdCgpICsgaW5kZXggKTtcblxuXHR9XG5cblx0Z2V0UHJvcGVydGllcyggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHByb3BlcnRpZXMgPSBidWlsZGVyLmdldE5vZGVQcm9wZXJ0aWVzKCB0aGlzICk7XG5cblx0XHRpZiAoIHByb3BlcnRpZXMuc3RhY2tOb2RlICE9PSB1bmRlZmluZWQgKSByZXR1cm4gcHJvcGVydGllcztcblxuXHRcdC8vXG5cblx0XHRjb25zdCBpbnB1dHMgPSB7fTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMucGFyYW1zLmxlbmd0aCAtIDE7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwYXJhbSA9IHRoaXMucGFyYW1zWyBpIF07XG5cblx0XHRcdGNvbnN0IG5hbWUgPSAoIHBhcmFtLmlzTm9kZSAhPT0gdHJ1ZSAmJiBwYXJhbS5uYW1lICkgfHwgdGhpcy5nZXRWYXJOYW1lKCBpICk7XG5cdFx0XHRjb25zdCB0eXBlID0gKCBwYXJhbS5pc05vZGUgIT09IHRydWUgJiYgcGFyYW0udHlwZSApIHx8ICdpbnQnO1xuXG5cdFx0XHRpbnB1dHNbIG5hbWUgXSA9IGV4cHJlc3Npb24oIG5hbWUsIHR5cGUgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHN0YWNrID0gYnVpbGRlci5hZGRTdGFjaygpOyAvLyBUT0RPOiBjYWNoZSgpIGl0XG5cblx0XHRwcm9wZXJ0aWVzLnJldHVybnNOb2RlID0gdGhpcy5wYXJhbXNbIHRoaXMucGFyYW1zLmxlbmd0aCAtIDEgXSggaW5wdXRzLCBzdGFjaywgYnVpbGRlciApO1xuXHRcdHByb3BlcnRpZXMuc3RhY2tOb2RlID0gc3RhY2s7XG5cblx0XHRidWlsZGVyLnJlbW92ZVN0YWNrKCk7XG5cblx0XHRyZXR1cm4gcHJvcGVydGllcztcblxuXHR9XG5cblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCB7IHJldHVybnNOb2RlIH0gPSB0aGlzLmdldFByb3BlcnRpZXMoIGJ1aWxkZXIgKTtcblxuXHRcdHJldHVybiByZXR1cm5zTm9kZSA/IHJldHVybnNOb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgOiAndm9pZCc7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Ly8gc2V0dXAgcHJvcGVydGllc1xuXG5cdFx0dGhpcy5nZXRQcm9wZXJ0aWVzKCBidWlsZGVyICk7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgcHJvcGVydGllcyA9IHRoaXMuZ2V0UHJvcGVydGllcyggYnVpbGRlciApO1xuXG5cdFx0Y29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG5cdFx0Y29uc3Qgc3RhY2tOb2RlID0gcHJvcGVydGllcy5zdGFja05vZGU7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwYXJhbXMubGVuZ3RoIC0gMTsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBhcmFtID0gcGFyYW1zWyBpIF07XG5cblx0XHRcdGxldCBzdGFydCA9IG51bGwsIGVuZCA9IG51bGwsIG5hbWUgPSBudWxsLCB0eXBlID0gbnVsbCwgY29uZGl0aW9uID0gbnVsbCwgdXBkYXRlID0gbnVsbDtcblxuXHRcdFx0aWYgKCBwYXJhbS5pc05vZGUgKSB7XG5cblx0XHRcdFx0dHlwZSA9ICdpbnQnO1xuXHRcdFx0XHRuYW1lID0gdGhpcy5nZXRWYXJOYW1lKCBpICk7XG5cdFx0XHRcdHN0YXJ0ID0gJzAnO1xuXHRcdFx0XHRlbmQgPSBwYXJhbS5idWlsZCggYnVpbGRlciwgdHlwZSApO1xuXHRcdFx0XHRjb25kaXRpb24gPSAnPCc7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dHlwZSA9IHBhcmFtLnR5cGUgfHwgJ2ludCc7XG5cdFx0XHRcdG5hbWUgPSBwYXJhbS5uYW1lIHx8IHRoaXMuZ2V0VmFyTmFtZSggaSApO1xuXHRcdFx0XHRzdGFydCA9IHBhcmFtLnN0YXJ0O1xuXHRcdFx0XHRlbmQgPSBwYXJhbS5lbmQ7XG5cdFx0XHRcdGNvbmRpdGlvbiA9IHBhcmFtLmNvbmRpdGlvbjtcblx0XHRcdFx0dXBkYXRlID0gcGFyYW0udXBkYXRlO1xuXG5cdFx0XHRcdGlmICggdHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyApIHN0YXJ0ID0gYnVpbGRlci5nZW5lcmF0ZUNvbnN0KCB0eXBlLCBzdGFydCApO1xuXHRcdFx0XHRlbHNlIGlmICggc3RhcnQgJiYgc3RhcnQuaXNOb2RlICkgc3RhcnQgPSBzdGFydC5idWlsZCggYnVpbGRlciwgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZW9mIGVuZCA9PT0gJ251bWJlcicgKSBlbmQgPSBidWlsZGVyLmdlbmVyYXRlQ29uc3QoIHR5cGUsIGVuZCApO1xuXHRcdFx0XHRlbHNlIGlmICggZW5kICYmIGVuZC5pc05vZGUgKSBlbmQgPSBlbmQuYnVpbGQoIGJ1aWxkZXIsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRzdGFydCA9IHN0YXJ0ICsgJyAtIDEnO1xuXHRcdFx0XHRcdGVuZCA9ICcwJztcblx0XHRcdFx0XHRjb25kaXRpb24gPSAnPj0nO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVuZCAhPT0gdW5kZWZpbmVkICYmIHN0YXJ0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRzdGFydCA9ICcwJztcblx0XHRcdFx0XHRjb25kaXRpb24gPSAnPCc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY29uZGl0aW9uID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIE51bWJlciggc3RhcnQgKSA+IE51bWJlciggZW5kICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbmRpdGlvbiA9ICc+PSc7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25kaXRpb24gPSAnPCc7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGludGVybmFsUGFyYW0gPSB7IHN0YXJ0LCBlbmQsIGNvbmRpdGlvbiB9O1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRjb25zdCBzdGFydFNuaXBwZXQgPSBpbnRlcm5hbFBhcmFtLnN0YXJ0O1xuXHRcdFx0Y29uc3QgZW5kU25pcHBldCA9IGludGVybmFsUGFyYW0uZW5kO1xuXG5cdFx0XHRsZXQgZGVjbGFyYXRpb25TbmlwcGV0ID0gJyc7XG5cdFx0XHRsZXQgY29uZGl0aW9uYWxTbmlwcGV0ID0gJyc7XG5cdFx0XHRsZXQgdXBkYXRlU25pcHBldCA9ICcnO1xuXG5cdFx0XHRpZiAoICEgdXBkYXRlICkge1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gJ2ludCcgfHwgdHlwZSA9PT0gJ3VpbnQnICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb25kaXRpb24uaW5jbHVkZXMoICc8JyApICkgdXBkYXRlID0gJysrJztcblx0XHRcdFx0XHRlbHNlIHVwZGF0ZSA9ICctLSc7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggY29uZGl0aW9uLmluY2x1ZGVzKCAnPCcgKSApIHVwZGF0ZSA9ICcrPSAxLic7XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGUgPSAnLT0gMS4nO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRkZWNsYXJhdGlvblNuaXBwZXQgKz0gYnVpbGRlci5nZXRWYXIoIHR5cGUsIG5hbWUgKSArICcgPSAnICsgc3RhcnRTbmlwcGV0O1xuXG5cdFx0XHRjb25kaXRpb25hbFNuaXBwZXQgKz0gbmFtZSArICcgJyArIGNvbmRpdGlvbiArICcgJyArIGVuZFNuaXBwZXQ7XG5cdFx0XHR1cGRhdGVTbmlwcGV0ICs9IG5hbWUgKyAnICcgKyB1cGRhdGU7XG5cblx0XHRcdGNvbnN0IGZvclNuaXBwZXQgPSBgZm9yICggJHsgZGVjbGFyYXRpb25TbmlwcGV0IH07ICR7IGNvbmRpdGlvbmFsU25pcHBldCB9OyAkeyB1cGRhdGVTbmlwcGV0IH0gKWA7XG5cblx0XHRcdGJ1aWxkZXIuYWRkRmxvd0NvZGUoICggaSA9PT0gMCA/ICdcXG4nIDogJycgKSArIGJ1aWxkZXIudGFiICsgZm9yU25pcHBldCArICcge1xcblxcbicgKS5hZGRGbG93VGFiKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBzdGFja1NuaXBwZXQgPSBzdGFja05vZGUuYnVpbGQoIGJ1aWxkZXIsICd2b2lkJyApO1xuXG5cdFx0Y29uc3QgcmV0dXJuc1NuaXBwZXQgPSBwcm9wZXJ0aWVzLnJldHVybnNOb2RlID8gcHJvcGVydGllcy5yZXR1cm5zTm9kZS5idWlsZCggYnVpbGRlciApIDogJyc7XG5cblx0XHRidWlsZGVyLnJlbW92ZUZsb3dUYWIoKS5hZGRGbG93Q29kZSggJ1xcbicgKyBidWlsZGVyLnRhYiArIHN0YWNrU25pcHBldCApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5wYXJhbXMubGVuZ3RoIC0gMTsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGJ1aWxkZXIuYWRkRmxvd0NvZGUoICggaSA9PT0gMCA/ICcnIDogYnVpbGRlci50YWIgKSArICd9XFxuXFxuJyApLnJlbW92ZUZsb3dUYWIoKTtcblxuXHRcdH1cblxuXHRcdGJ1aWxkZXIuYWRkRmxvd1RhYigpO1xuXG5cdFx0cmV0dXJuIHJldHVybnNTbmlwcGV0O1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBMb29wTm9kZTtcblxuZXhwb3J0IGNvbnN0IExvb3AgPSAoIC4uLnBhcmFtcyApID0+IG5vZGVPYmplY3QoIG5ldyBMb29wTm9kZSggbm9kZUFycmF5KCBwYXJhbXMsICdpbnQnICkgKSApLmFwcGVuZCgpO1xuZXhwb3J0IGNvbnN0IENvbnRpbnVlID0gKCkgPT4gZXhwcmVzc2lvbiggJ2NvbnRpbnVlJyApLmFwcGVuZCgpO1xuZXhwb3J0IGNvbnN0IEJyZWFrID0gKCkgPT4gZXhwcmVzc2lvbiggJ2JyZWFrJyApLmFwcGVuZCgpO1xuXG4vL1xuXG5leHBvcnQgY29uc3QgbG9vcCA9ICggLi4ucGFyYW1zICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE2OFxuXG5cdGNvbnNvbGUud2FybiggJ1RTTC5Mb29wTm9kZTogbG9vcCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gTG9vcCgpLicgKTtcblx0cmV0dXJuIExvb3AoIC4uLnBhcmFtcyApO1xuXG59O1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZmxvYXQsIG5vZGVQcm94eSwgRm4gfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XG5pbXBvcnQgeyByZWZlcmVuY2UgfSBmcm9tICcuL1JlZmVyZW5jZU5vZGUuanMnO1xuaW1wb3J0IHsgcG9zaXRpb25Mb2NhbCB9IGZyb20gJy4vUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgbm9ybWFsTG9jYWwgfSBmcm9tICcuL05vcm1hbC5qcyc7XG5pbXBvcnQgeyB0ZXh0dXJlTG9hZCB9IGZyb20gJy4vVGV4dHVyZU5vZGUuanMnO1xuaW1wb3J0IHsgaW5zdGFuY2VJbmRleCwgdmVydGV4SW5kZXggfSBmcm9tICcuLi9jb3JlL0luZGV4Tm9kZS5qcyc7XG5pbXBvcnQgeyBpdmVjMiwgaW50IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgTG9vcCB9IGZyb20gJy4uL3V0aWxzL0xvb3BOb2RlLmpzJztcblxuaW1wb3J0IHsgRGF0YUFycmF5VGV4dHVyZSB9IGZyb20gJy4uLy4uL3RleHR1cmVzL0RhdGFBcnJheVRleHR1cmUuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3I0LmpzJztcbmltcG9ydCB7IEZsb2F0VHlwZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IF9tb3JwaFRleHR1cmVzID0gLypAX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgX21vcnBoVmVjNCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjQoKTtcblxuY29uc3QgZ2V0TW9ycGggPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgYnVmZmVyTWFwLCBpbmZsdWVuY2UsIHN0cmlkZSwgd2lkdGgsIGRlcHRoLCBvZmZzZXQgfSApID0+IHtcblxuXHRjb25zdCB0ZXhlbEluZGV4ID0gaW50KCB2ZXJ0ZXhJbmRleCApLm11bCggc3RyaWRlICkuYWRkKCBvZmZzZXQgKTtcblxuXHRjb25zdCB5ID0gdGV4ZWxJbmRleC5kaXYoIHdpZHRoICk7XG5cdGNvbnN0IHggPSB0ZXhlbEluZGV4LnN1YiggeS5tdWwoIHdpZHRoICkgKTtcblxuXHRjb25zdCBidWZmZXJBdHRyaWIgPSB0ZXh0dXJlTG9hZCggYnVmZmVyTWFwLCBpdmVjMiggeCwgeSApICkuZGVwdGgoIGRlcHRoICk7XG5cblx0cmV0dXJuIGJ1ZmZlckF0dHJpYi5tdWwoIGluZmx1ZW5jZSApO1xuXG59ICk7XG5cbmZ1bmN0aW9uIGdldEVudHJ5KCBnZW9tZXRyeSApIHtcblxuXHRjb25zdCBoYXNNb3JwaFBvc2l0aW9uID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB1bmRlZmluZWQ7XG5cdGNvbnN0IGhhc01vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZDtcblx0Y29uc3QgaGFzTW9ycGhDb2xvcnMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZDtcblxuXHQvLyBpbnN0ZWFkIG9mIHVzaW5nIGF0dHJpYnV0ZXMsIHRoZSBXZWJHTCAyIGNvZGUgcGF0aCBlbmNvZGVzIG1vcnBoIHRhcmdldHNcblx0Ly8gaW50byBhbiBhcnJheSBvZiBkYXRhIHRleHR1cmVzLiBFYWNoIGxheWVyIHJlcHJlc2VudHMgYSBzaW5nbGUgbW9ycGggdGFyZ2V0LlxuXG5cdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yO1xuXHRjb25zdCBtb3JwaFRhcmdldHNDb3VudCA9ICggbW9ycGhBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApID8gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoIDogMDtcblxuXHRsZXQgZW50cnkgPSBfbW9ycGhUZXh0dXJlcy5nZXQoIGdlb21ldHJ5ICk7XG5cblx0aWYgKCBlbnRyeSA9PT0gdW5kZWZpbmVkIHx8IGVudHJ5LmNvdW50ICE9PSBtb3JwaFRhcmdldHNDb3VudCApIHtcblxuXHRcdGlmICggZW50cnkgIT09IHVuZGVmaW5lZCApIGVudHJ5LnRleHR1cmUuZGlzcG9zZSgpO1xuXG5cdFx0Y29uc3QgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IFtdO1xuXHRcdGNvbnN0IG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgW107XG5cdFx0Y29uc3QgbW9ycGhDb2xvcnMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgfHwgW107XG5cblx0XHRsZXQgdmVydGV4RGF0YUNvdW50ID0gMDtcblxuXHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiA9PT0gdHJ1ZSApIHZlcnRleERhdGFDb3VudCA9IDE7XG5cdFx0aWYgKCBoYXNNb3JwaE5vcm1hbHMgPT09IHRydWUgKSB2ZXJ0ZXhEYXRhQ291bnQgPSAyO1xuXHRcdGlmICggaGFzTW9ycGhDb2xvcnMgPT09IHRydWUgKSB2ZXJ0ZXhEYXRhQ291bnQgPSAzO1xuXG5cdFx0bGV0IHdpZHRoID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCAqIHZlcnRleERhdGFDb3VudDtcblx0XHRsZXQgaGVpZ2h0ID0gMTtcblxuXHRcdGNvbnN0IG1heFRleHR1cmVTaXplID0gNDA5NjsgLy8gQFRPRE86IFVzZSAnY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplJ1xuXG5cdFx0aWYgKCB3aWR0aCA+IG1heFRleHR1cmVTaXplICkge1xuXG5cdFx0XHRoZWlnaHQgPSBNYXRoLmNlaWwoIHdpZHRoIC8gbWF4VGV4dHVyZVNpemUgKTtcblx0XHRcdHdpZHRoID0gbWF4VGV4dHVyZVNpemU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCB3aWR0aCAqIGhlaWdodCAqIDQgKiBtb3JwaFRhcmdldHNDb3VudCApO1xuXG5cdFx0Y29uc3QgYnVmZmVyVGV4dHVyZSA9IG5ldyBEYXRhQXJyYXlUZXh0dXJlKCBidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG1vcnBoVGFyZ2V0c0NvdW50ICk7XG5cdFx0YnVmZmVyVGV4dHVyZS50eXBlID0gRmxvYXRUeXBlO1xuXHRcdGJ1ZmZlclRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0Ly8gZmlsbCBidWZmZXJcblxuXHRcdGNvbnN0IHZlcnRleERhdGFTdHJpZGUgPSB2ZXJ0ZXhEYXRhQ291bnQgKiA0O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbW9ycGhUYXJnZXRzQ291bnQ7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XG5cdFx0XHRjb25zdCBtb3JwaE5vcm1hbCA9IG1vcnBoTm9ybWFsc1sgaSBdO1xuXHRcdFx0Y29uc3QgbW9ycGhDb2xvciA9IG1vcnBoQ29sb3JzWyBpIF07XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IHdpZHRoICogaGVpZ2h0ICogNCAqIGk7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IG1vcnBoVGFyZ2V0LmNvdW50OyBqICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHN0cmlkZSA9IGogKiB2ZXJ0ZXhEYXRhU3RyaWRlO1xuXG5cdFx0XHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdF9tb3JwaFZlYzQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhUYXJnZXQsIGogKTtcblxuXHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgMCBdID0gX21vcnBoVmVjNC54O1xuXHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgMSBdID0gX21vcnBoVmVjNC55O1xuXHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgMiBdID0gX21vcnBoVmVjNC56O1xuXHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgMyBdID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYXNNb3JwaE5vcm1hbHMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRfbW9ycGhWZWM0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoTm9ybWFsLCBqICk7XG5cblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDQgXSA9IF9tb3JwaFZlYzQueDtcblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDUgXSA9IF9tb3JwaFZlYzQueTtcblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDYgXSA9IF9tb3JwaFZlYzQuejtcblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDcgXSA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzTW9ycGhDb2xvcnMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRfbW9ycGhWZWM0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQ29sb3IsIGogKTtcblxuXHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgOCBdID0gX21vcnBoVmVjNC54O1xuXHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgOSBdID0gX21vcnBoVmVjNC55O1xuXHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgMTAgXSA9IF9tb3JwaFZlYzQuejtcblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDExIF0gPSAoIG1vcnBoQ29sb3IuaXRlbVNpemUgPT09IDQgKSA/IF9tb3JwaFZlYzQudyA6IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRlbnRyeSA9IHtcblx0XHRcdGNvdW50OiBtb3JwaFRhcmdldHNDb3VudCxcblx0XHRcdHRleHR1cmU6IGJ1ZmZlclRleHR1cmUsXG5cdFx0XHRzdHJpZGU6IHZlcnRleERhdGFDb3VudCxcblx0XHRcdHNpemU6IG5ldyBWZWN0b3IyKCB3aWR0aCwgaGVpZ2h0IClcblx0XHR9O1xuXG5cdFx0X21vcnBoVGV4dHVyZXMuc2V0KCBnZW9tZXRyeSwgZW50cnkgKTtcblxuXHRcdGZ1bmN0aW9uIGRpc3Bvc2VUZXh0dXJlKCkge1xuXG5cdFx0XHRidWZmZXJUZXh0dXJlLmRpc3Bvc2UoKTtcblxuXHRcdFx0X21vcnBoVGV4dHVyZXMuZGVsZXRlKCBnZW9tZXRyeSApO1xuXG5cdFx0XHRnZW9tZXRyeS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIGRpc3Bvc2VUZXh0dXJlICk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIGRpc3Bvc2VUZXh0dXJlICk7XG5cblx0fVxuXG5cdHJldHVybiBlbnRyeTtcblxufVxuXG5cbmNsYXNzIE1vcnBoTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnTW9ycGhOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIG1lc2ggKSB7XG5cblx0XHRzdXBlciggJ3ZvaWQnICk7XG5cblx0XHR0aGlzLm1lc2ggPSBtZXNoO1xuXHRcdHRoaXMubW9ycGhCYXNlSW5mbHVlbmNlID0gdW5pZm9ybSggMSApO1xuXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuT0JKRUNUO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHsgZ2VvbWV0cnkgfSA9IGJ1aWxkZXI7XG5cblx0XHRjb25zdCBoYXNNb3JwaFBvc2l0aW9uID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB1bmRlZmluZWQ7XG5cdFx0Y29uc3QgaGFzTW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkuaGFzQXR0cmlidXRlKCAnbm9ybWFsJyApICYmIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZDtcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yO1xuXHRcdGNvbnN0IG1vcnBoVGFyZ2V0c0NvdW50ID0gKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkgPyBtb3JwaEF0dHJpYnV0ZS5sZW5ndGggOiAwO1xuXG5cdFx0Ly8gbm9kZXNcblxuXHRcdGNvbnN0IHsgdGV4dHVyZTogYnVmZmVyTWFwLCBzdHJpZGUsIHNpemUgfSA9IGdldEVudHJ5KCBnZW9tZXRyeSApO1xuXG5cdFx0aWYgKCBoYXNNb3JwaFBvc2l0aW9uID09PSB0cnVlICkgcG9zaXRpb25Mb2NhbC5tdWxBc3NpZ24oIHRoaXMubW9ycGhCYXNlSW5mbHVlbmNlICk7XG5cdFx0aWYgKCBoYXNNb3JwaE5vcm1hbHMgPT09IHRydWUgKSBub3JtYWxMb2NhbC5tdWxBc3NpZ24oIHRoaXMubW9ycGhCYXNlSW5mbHVlbmNlICk7XG5cblx0XHRjb25zdCB3aWR0aCA9IGludCggc2l6ZS53aWR0aCApO1xuXG5cdFx0TG9vcCggbW9ycGhUYXJnZXRzQ291bnQsICggeyBpIH0gKSA9PiB7XG5cblx0XHRcdGNvbnN0IGluZmx1ZW5jZSA9IGZsb2F0KCAwICkudG9WYXIoKTtcblxuXHRcdFx0aWYgKCB0aGlzLm1lc2guY291bnQgPiAxICYmICggdGhpcy5tZXNoLm1vcnBoVGV4dHVyZSAhPT0gbnVsbCAmJiB0aGlzLm1lc2gubW9ycGhUZXh0dXJlICE9PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0XHRpbmZsdWVuY2UuYXNzaWduKCB0ZXh0dXJlTG9hZCggdGhpcy5tZXNoLm1vcnBoVGV4dHVyZSwgaXZlYzIoIGludCggaSApLmFkZCggMSApLCBpbnQoIGluc3RhbmNlSW5kZXggKSApICkuciApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGluZmx1ZW5jZS5hc3NpZ24oIHJlZmVyZW5jZSggJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcycsICdmbG9hdCcgKS5lbGVtZW50KCBpICkudG9WYXIoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRwb3NpdGlvbkxvY2FsLmFkZEFzc2lnbiggZ2V0TW9ycGgoIHtcblx0XHRcdFx0XHRidWZmZXJNYXAsXG5cdFx0XHRcdFx0aW5mbHVlbmNlLFxuXHRcdFx0XHRcdHN0cmlkZSxcblx0XHRcdFx0XHR3aWR0aCxcblx0XHRcdFx0XHRkZXB0aDogaSxcblx0XHRcdFx0XHRvZmZzZXQ6IGludCggMCApXG5cdFx0XHRcdH0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzTW9ycGhOb3JtYWxzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdG5vcm1hbExvY2FsLmFkZEFzc2lnbiggZ2V0TW9ycGgoIHtcblx0XHRcdFx0XHRidWZmZXJNYXAsXG5cdFx0XHRcdFx0aW5mbHVlbmNlLFxuXHRcdFx0XHRcdHN0cmlkZSxcblx0XHRcdFx0XHR3aWR0aCxcblx0XHRcdFx0XHRkZXB0aDogaSxcblx0XHRcdFx0XHRvZmZzZXQ6IGludCggMSApXG5cdFx0XHRcdH0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdHVwZGF0ZSgpIHtcblxuXHRcdGNvbnN0IG1vcnBoQmFzZUluZmx1ZW5jZSA9IHRoaXMubW9ycGhCYXNlSW5mbHVlbmNlO1xuXG5cdFx0aWYgKCB0aGlzLm1lc2guZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdG1vcnBoQmFzZUluZmx1ZW5jZS52YWx1ZSA9IDE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtb3JwaEJhc2VJbmZsdWVuY2UudmFsdWUgPSAxIC0gdGhpcy5tZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5yZWR1Y2UoICggYSwgYiApID0+IGEgKyBiLCAwICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vcnBoTm9kZTtcblxuZXhwb3J0IGNvbnN0IG1vcnBoUmVmZXJlbmNlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1vcnBoTm9kZSApO1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcblxuY2xhc3MgTGlnaHRpbmdOb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdMaWdodGluZ05vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCAndmVjMycgKTtcblxuXHRcdHRoaXMuaXNMaWdodGluZ05vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggLypidWlsZGVyKi8gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdBYnN0cmFjdCBmdW5jdGlvbi4nICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IExpZ2h0aW5nTm9kZTtcbiIsImltcG9ydCBMaWdodGluZ05vZGUgZnJvbSAnLi9MaWdodGluZ05vZGUuanMnO1xuXG5jbGFzcyBBT05vZGUgZXh0ZW5kcyBMaWdodGluZ05vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnQU9Ob2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGFvTm9kZSA9IG51bGwgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5hb05vZGUgPSBhb05vZGU7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0YnVpbGRlci5jb250ZXh0LmFtYmllbnRPY2NsdXNpb24ubXVsQXNzaWduKCB0aGlzLmFvTm9kZSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBT05vZGU7XG4iLCJpbXBvcnQgQ29udGV4dE5vZGUgZnJvbSAnLi4vY29yZS9Db250ZXh0Tm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlUHJveHksIGZsb2F0LCB2ZWMzIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5jbGFzcyBMaWdodGluZ0NvbnRleHROb2RlIGV4dGVuZHMgQ29udGV4dE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnTGlnaHRpbmdDb250ZXh0Tm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBub2RlLCBsaWdodGluZ01vZGVsID0gbnVsbCwgYmFja2Ryb3BOb2RlID0gbnVsbCwgYmFja2Ryb3BBbHBoYU5vZGUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoIG5vZGUgKTtcblxuXHRcdHRoaXMubGlnaHRpbmdNb2RlbCA9IGxpZ2h0aW5nTW9kZWw7XG5cdFx0dGhpcy5iYWNrZHJvcE5vZGUgPSBiYWNrZHJvcE5vZGU7XG5cdFx0dGhpcy5iYWNrZHJvcEFscGhhTm9kZSA9IGJhY2tkcm9wQWxwaGFOb2RlO1xuXG5cdFx0dGhpcy5fdmFsdWUgPSBudWxsO1xuXG5cdH1cblxuXHRnZXRDb250ZXh0KCkge1xuXG5cdFx0Y29uc3QgeyBiYWNrZHJvcE5vZGUsIGJhY2tkcm9wQWxwaGFOb2RlIH0gPSB0aGlzO1xuXG5cdFx0Y29uc3QgZGlyZWN0RGlmZnVzZSA9IHZlYzMoKS50b1ZhciggJ2RpcmVjdERpZmZ1c2UnICksXG5cdFx0XHRkaXJlY3RTcGVjdWxhciA9IHZlYzMoKS50b1ZhciggJ2RpcmVjdFNwZWN1bGFyJyApLFxuXHRcdFx0aW5kaXJlY3REaWZmdXNlID0gdmVjMygpLnRvVmFyKCAnaW5kaXJlY3REaWZmdXNlJyApLFxuXHRcdFx0aW5kaXJlY3RTcGVjdWxhciA9IHZlYzMoKS50b1ZhciggJ2luZGlyZWN0U3BlY3VsYXInICk7XG5cblx0XHRjb25zdCByZWZsZWN0ZWRMaWdodCA9IHtcblx0XHRcdGRpcmVjdERpZmZ1c2UsXG5cdFx0XHRkaXJlY3RTcGVjdWxhcixcblx0XHRcdGluZGlyZWN0RGlmZnVzZSxcblx0XHRcdGluZGlyZWN0U3BlY3VsYXJcblx0XHR9O1xuXG5cdFx0Y29uc3QgY29udGV4dCA9IHtcblx0XHRcdHJhZGlhbmNlOiB2ZWMzKCkudG9WYXIoICdyYWRpYW5jZScgKSxcblx0XHRcdGlycmFkaWFuY2U6IHZlYzMoKS50b1ZhciggJ2lycmFkaWFuY2UnICksXG5cdFx0XHRpYmxJcnJhZGlhbmNlOiB2ZWMzKCkudG9WYXIoICdpYmxJcnJhZGlhbmNlJyApLFxuXHRcdFx0YW1iaWVudE9jY2x1c2lvbjogZmxvYXQoIDEgKS50b1ZhciggJ2FtYmllbnRPY2NsdXNpb24nICksXG5cdFx0XHRyZWZsZWN0ZWRMaWdodCxcblx0XHRcdGJhY2tkcm9wOiBiYWNrZHJvcE5vZGUsXG5cdFx0XHRiYWNrZHJvcEFscGhhOiBiYWNrZHJvcEFscGhhTm9kZVxuXHRcdH07XG5cblx0XHRyZXR1cm4gY29udGV4dDtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHR0aGlzLnZhbHVlID0gdGhpcy5fdmFsdWUgfHwgKCB0aGlzLl92YWx1ZSA9IHRoaXMuZ2V0Q29udGV4dCgpICk7XG5cdFx0dGhpcy52YWx1ZS5saWdodGluZ01vZGVsID0gdGhpcy5saWdodGluZ01vZGVsIHx8IGJ1aWxkZXIuY29udGV4dC5saWdodGluZ01vZGVsO1xuXG5cdFx0cmV0dXJuIHN1cGVyLnNldHVwKCBidWlsZGVyICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IExpZ2h0aW5nQ29udGV4dE5vZGU7XG5cbmV4cG9ydCBjb25zdCBsaWdodGluZ0NvbnRleHQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTGlnaHRpbmdDb250ZXh0Tm9kZSApO1xuIiwiaW1wb3J0IExpZ2h0aW5nTm9kZSBmcm9tICcuL0xpZ2h0aW5nTm9kZS5qcyc7XG5cbmNsYXNzIElycmFkaWFuY2VOb2RlIGV4dGVuZHMgTGlnaHRpbmdOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0lycmFkaWFuY2VOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIG5vZGUgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRidWlsZGVyLmNvbnRleHQuaXJyYWRpYW5jZS5hZGRBc3NpZ24oIHRoaXMubm9kZSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJcnJhZGlhbmNlTm9kZTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcbmltcG9ydCB7IEZuLCBub2RlSW1tdXRhYmxlLCB2ZWMyIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xuXG5sZXQgc2NyZWVuU2l6ZVZlYywgdmlld3BvcnRWZWM7XG5cbmNsYXNzIFNjcmVlbk5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1NjcmVlbk5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3Rvciggc2NvcGUgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5zY29wZSA9IHNjb3BlO1xuXG5cdFx0dGhpcy5pc1ZpZXdwb3J0Tm9kZSA9IHRydWU7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCkge1xuXG5cdFx0aWYgKCB0aGlzLnNjb3BlID09PSBTY3JlZW5Ob2RlLlZJRVdQT1JUICkgcmV0dXJuICd2ZWM0Jztcblx0XHRlbHNlIHJldHVybiAndmVjMic7XG5cblx0fVxuXG5cdGdldFVwZGF0ZVR5cGUoKSB7XG5cblx0XHRsZXQgdXBkYXRlVHlwZSA9IE5vZGVVcGRhdGVUeXBlLk5PTkU7XG5cblx0XHRpZiAoIHRoaXMuc2NvcGUgPT09IFNjcmVlbk5vZGUuU0laRSB8fCB0aGlzLnNjb3BlID09PSBTY3JlZW5Ob2RlLlZJRVdQT1JUICkge1xuXG5cdFx0XHR1cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuUkVOREVSO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gdXBkYXRlVHlwZTtcblxuXHRcdHJldHVybiB1cGRhdGVUeXBlO1xuXG5cdH1cblxuXHR1cGRhdGUoIHsgcmVuZGVyZXIgfSApIHtcblxuXHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXG5cdFx0aWYgKCB0aGlzLnNjb3BlID09PSBTY3JlZW5Ob2RlLlZJRVdQT1JUICkge1xuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR2aWV3cG9ydFZlYy5jb3B5KCByZW5kZXJUYXJnZXQudmlld3BvcnQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZW5kZXJlci5nZXRWaWV3cG9ydCggdmlld3BvcnRWZWMgKTtcblxuXHRcdFx0XHR2aWV3cG9ydFZlYy5tdWx0aXBseVNjYWxhciggcmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHNjcmVlblNpemVWZWMud2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XG5cdFx0XHRcdHNjcmVlblNpemVWZWMuaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZW5kZXJlci5nZXREcmF3aW5nQnVmZmVyU2l6ZSggc2NyZWVuU2l6ZVZlYyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldHVwKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcblxuXHRcdGxldCBvdXRwdXQgPSBudWxsO1xuXG5cdFx0aWYgKCBzY29wZSA9PT0gU2NyZWVuTm9kZS5TSVpFICkge1xuXG5cdFx0XHRvdXRwdXQgPSB1bmlmb3JtKCBzY3JlZW5TaXplVmVjIHx8ICggc2NyZWVuU2l6ZVZlYyA9IG5ldyBWZWN0b3IyKCkgKSApO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IFNjcmVlbk5vZGUuVklFV1BPUlQgKSB7XG5cblx0XHRcdG91dHB1dCA9IHVuaWZvcm0oIHZpZXdwb3J0VmVjIHx8ICggdmlld3BvcnRWZWMgPSBuZXcgVmVjdG9yNCgpICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG91dHB1dCA9IHZlYzIoIHNjcmVlbkNvb3JkaW5hdGUuZGl2KCBzY3JlZW5TaXplICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xuXG5cdFx0aWYgKCB0aGlzLnNjb3BlID09PSBTY3JlZW5Ob2RlLkNPT1JESU5BVEUgKSB7XG5cblx0XHRcdGxldCBjb29yZCA9IGJ1aWxkZXIuZ2V0RnJhZ0Nvb3JkKCk7XG5cblx0XHRcdGlmICggYnVpbGRlci5pc0ZsaXBZKCkgKSB7XG5cblx0XHRcdFx0Ly8gZm9sbG93IHdlYmdwdSBzdGFuZGFyZHNcblxuXHRcdFx0XHRjb25zdCBzaXplID0gYnVpbGRlci5nZXROb2RlUHJvcGVydGllcyggc2NyZWVuU2l6ZSApLm91dHB1dE5vZGUuYnVpbGQoIGJ1aWxkZXIgKTtcblxuXHRcdFx0XHRjb29yZCA9IGAkeyBidWlsZGVyLmdldFR5cGUoICd2ZWMyJyApIH0oICR7IGNvb3JkIH0ueCwgJHsgc2l6ZSB9LnkgLSAkeyBjb29yZCB9LnkgKWA7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvb3JkO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1cGVyLmdlbmVyYXRlKCBidWlsZGVyICk7XG5cblx0fVxuXG59XG5cblNjcmVlbk5vZGUuQ09PUkRJTkFURSA9ICdjb29yZGluYXRlJztcblNjcmVlbk5vZGUuVklFV1BPUlQgPSAndmlld3BvcnQnO1xuU2NyZWVuTm9kZS5TSVpFID0gJ3NpemUnO1xuU2NyZWVuTm9kZS5VViA9ICd1dic7XG5cbmV4cG9ydCBkZWZhdWx0IFNjcmVlbk5vZGU7XG5cbi8vIFNjcmVlblxuXG5leHBvcnQgY29uc3Qgc2NyZWVuVVYgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFNjcmVlbk5vZGUsIFNjcmVlbk5vZGUuVVYgKTtcbmV4cG9ydCBjb25zdCBzY3JlZW5TaXplID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBTY3JlZW5Ob2RlLCBTY3JlZW5Ob2RlLlNJWkUgKTtcbmV4cG9ydCBjb25zdCBzY3JlZW5Db29yZGluYXRlID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBTY3JlZW5Ob2RlLCBTY3JlZW5Ob2RlLkNPT1JESU5BVEUgKTtcblxuLy8gVmlld3BvcnRcblxuZXhwb3J0IGNvbnN0IHZpZXdwb3J0ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBTY3JlZW5Ob2RlLCBTY3JlZW5Ob2RlLlZJRVdQT1JUICk7XG5leHBvcnQgY29uc3Qgdmlld3BvcnRTaXplID0gdmlld3BvcnQuenc7XG5leHBvcnQgY29uc3Qgdmlld3BvcnRDb29yZGluYXRlID0gLypAX19QVVJFX18qLyBzY3JlZW5Db29yZGluYXRlLnN1Yiggdmlld3BvcnQueHkgKTtcbmV4cG9ydCBjb25zdCB2aWV3cG9ydFVWID0gLypAX19QVVJFX18qLyB2aWV3cG9ydENvb3JkaW5hdGUuZGl2KCB2aWV3cG9ydFNpemUgKTtcblxuLy8gRGVwcmVjYXRlZFxuXG5leHBvcnQgY29uc3Qgdmlld3BvcnRSZXNvbHV0aW9uID0gLypAX19QVVJFX18qLyAoIEZuKCAoKSA9PiB7IC8vIEBkZXByZWNhdGVkLCByMTY5XG5cblx0Y29uc29sZS53YXJuKCAnVFNMLlZpZXdwb3J0Tm9kZTogXCJ2aWV3cG9ydFJlc29sdXRpb25cIiBpcyBkZXByZWNhdGVkLiBVc2UgXCJzY3JlZW5TaXplXCIgaW5zdGVhZC4nICk7XG5cblx0cmV0dXJuIHNjcmVlblNpemU7XG5cbn0sICd2ZWMyJyApLm9uY2UoKSApKCk7XG5cbmV4cG9ydCBjb25zdCB2aWV3cG9ydFRvcExlZnQgPSAvKkBfX1BVUkVfXyovICggRm4oICgpID0+IHsgLy8gQGRlcHJlY2F0ZWQsIHIxNjhcblxuXHRjb25zb2xlLndhcm4oICdUU0wuVmlld3BvcnROb2RlOiBcInZpZXdwb3J0VG9wTGVmdFwiIGlzIGRlcHJlY2F0ZWQuIFVzZSBcInNjcmVlblVWXCIgaW5zdGVhZC4nICk7XG5cblx0cmV0dXJuIHNjcmVlblVWO1xuXG59LCAndmVjMicgKS5vbmNlKCkgKSgpO1xuXG5leHBvcnQgY29uc3Qgdmlld3BvcnRCb3R0b21MZWZ0ID0gLypAX19QVVJFX18qLyAoIEZuKCAoKSA9PiB7IC8vIEBkZXByZWNhdGVkLCByMTY4XG5cblx0Y29uc29sZS53YXJuKCAnVFNMLlZpZXdwb3J0Tm9kZTogXCJ2aWV3cG9ydEJvdHRvbUxlZnRcIiBpcyBkZXByZWNhdGVkLiBVc2UgXCJzY3JlZW5VVi5mbGlwWSgpXCIgaW5zdGVhZC4nICk7XG5cblx0cmV0dXJuIHNjcmVlblVWLmZsaXBZKCk7XG5cbn0sICd2ZWMyJyApLm9uY2UoKSApKCk7XG4iLCJpbXBvcnQgVGV4dHVyZU5vZGUgZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgc2NyZWVuVVYgfSBmcm9tICcuL1NjcmVlbk5vZGUuanMnO1xuXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IEZyYW1lYnVmZmVyVGV4dHVyZSB9IGZyb20gJy4uLy4uL3RleHR1cmVzL0ZyYW1lYnVmZmVyVGV4dHVyZS5qcyc7XG5pbXBvcnQgeyBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuXG5jb25zdCBfc2l6ZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcblxuY2xhc3MgVmlld3BvcnRUZXh0dXJlTm9kZSBleHRlbmRzIFRleHR1cmVOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1ZpZXdwb3J0VGV4dHVyZU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggdXZOb2RlID0gc2NyZWVuVVYsIGxldmVsTm9kZSA9IG51bGwsIGZyYW1lYnVmZmVyVGV4dHVyZSA9IG51bGwgKSB7XG5cblx0XHRpZiAoIGZyYW1lYnVmZmVyVGV4dHVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0ZnJhbWVidWZmZXJUZXh0dXJlID0gbmV3IEZyYW1lYnVmZmVyVGV4dHVyZSgpO1xuXHRcdFx0ZnJhbWVidWZmZXJUZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhck1pcG1hcExpbmVhckZpbHRlcjtcblxuXHRcdH1cblxuXHRcdHN1cGVyKCBmcmFtZWJ1ZmZlclRleHR1cmUsIHV2Tm9kZSwgbGV2ZWxOb2RlICk7XG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5pc091dHB1dFRleHR1cmVOb2RlID0gdHJ1ZTtcblxuXHRcdHRoaXMudXBkYXRlQmVmb3JlVHlwZSA9IE5vZGVVcGRhdGVUeXBlLkZSQU1FO1xuXG5cdH1cblxuXHR1cGRhdGVCZWZvcmUoIGZyYW1lICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSBmcmFtZS5yZW5kZXJlcjtcblx0XHRyZW5kZXJlci5nZXREcmF3aW5nQnVmZmVyU2l6ZSggX3NpemUgKTtcblxuXHRcdC8vXG5cblx0XHRjb25zdCBmcmFtZWJ1ZmZlclRleHR1cmUgPSB0aGlzLnZhbHVlO1xuXG5cdFx0aWYgKCBmcmFtZWJ1ZmZlclRleHR1cmUuaW1hZ2Uud2lkdGggIT09IF9zaXplLndpZHRoIHx8IGZyYW1lYnVmZmVyVGV4dHVyZS5pbWFnZS5oZWlnaHQgIT09IF9zaXplLmhlaWdodCApIHtcblxuXHRcdFx0ZnJhbWVidWZmZXJUZXh0dXJlLmltYWdlLndpZHRoID0gX3NpemUud2lkdGg7XG5cdFx0XHRmcmFtZWJ1ZmZlclRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gX3NpemUuaGVpZ2h0O1xuXHRcdFx0ZnJhbWVidWZmZXJUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRjb25zdCBjdXJyZW50R2VuZXJhdGVNaXBtYXBzID0gZnJhbWVidWZmZXJUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcblx0XHRmcmFtZWJ1ZmZlclRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gdGhpcy5nZW5lcmF0ZU1pcG1hcHM7XG5cblx0XHRyZW5kZXJlci5jb3B5RnJhbWVidWZmZXJUb1RleHR1cmUoIGZyYW1lYnVmZmVyVGV4dHVyZSApO1xuXG5cdFx0ZnJhbWVidWZmZXJUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGN1cnJlbnRHZW5lcmF0ZU1pcG1hcHM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0Y29uc3Qgdmlld3BvcnRUZXh0dXJlTm9kZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnV2Tm9kZSwgdGhpcy5sZXZlbE5vZGUsIHRoaXMudmFsdWUgKTtcblx0XHR2aWV3cG9ydFRleHR1cmVOb2RlLmdlbmVyYXRlTWlwbWFwcyA9IHRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0cmV0dXJuIHZpZXdwb3J0VGV4dHVyZU5vZGU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdwb3J0VGV4dHVyZU5vZGU7XG5cbmV4cG9ydCBjb25zdCB2aWV3cG9ydFRleHR1cmUgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggVmlld3BvcnRUZXh0dXJlTm9kZSApO1xuZXhwb3J0IGNvbnN0IHZpZXdwb3J0TWlwVGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBWaWV3cG9ydFRleHR1cmVOb2RlLCBudWxsLCBudWxsLCB7IGdlbmVyYXRlTWlwbWFwczogdHJ1ZSB9ICk7XG4iLCJpbXBvcnQgVmlld3BvcnRUZXh0dXJlTm9kZSBmcm9tICcuL1ZpZXdwb3J0VGV4dHVyZU5vZGUuanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgc2NyZWVuVVYgfSBmcm9tICcuL1NjcmVlbk5vZGUuanMnO1xuXG5pbXBvcnQgeyBEZXB0aFRleHR1cmUgfSBmcm9tICcuLi8uLi90ZXh0dXJlcy9EZXB0aFRleHR1cmUuanMnO1xuXG5sZXQgc2hhcmVkRGVwdGhidWZmZXIgPSBudWxsO1xuXG5jbGFzcyBWaWV3cG9ydERlcHRoVGV4dHVyZU5vZGUgZXh0ZW5kcyBWaWV3cG9ydFRleHR1cmVOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1ZpZXdwb3J0RGVwdGhUZXh0dXJlTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCB1dk5vZGUgPSBzY3JlZW5VViwgbGV2ZWxOb2RlID0gbnVsbCApIHtcblxuXHRcdGlmICggc2hhcmVkRGVwdGhidWZmZXIgPT09IG51bGwgKSB7XG5cblx0XHRcdHNoYXJlZERlcHRoYnVmZmVyID0gbmV3IERlcHRoVGV4dHVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0c3VwZXIoIHV2Tm9kZSwgbGV2ZWxOb2RlLCBzaGFyZWREZXB0aGJ1ZmZlciApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3cG9ydERlcHRoVGV4dHVyZU5vZGU7XG5cbmV4cG9ydCBjb25zdCB2aWV3cG9ydERlcHRoVGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBWaWV3cG9ydERlcHRoVGV4dHVyZU5vZGUgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBmbG9hdCwgbG9nLCBsb2cyLCBub2RlSW1tdXRhYmxlLCBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyBjYW1lcmFOZWFyLCBjYW1lcmFGYXIgfSBmcm9tICcuLi9hY2Nlc3NvcnMvQ2FtZXJhLmpzJztcbmltcG9ydCB7IHBvc2l0aW9uVmlldyB9IGZyb20gJy4uL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyB2aWV3cG9ydERlcHRoVGV4dHVyZSB9IGZyb20gJy4vVmlld3BvcnREZXB0aFRleHR1cmVOb2RlLmpzJztcblxuY2xhc3MgVmlld3BvcnREZXB0aE5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1ZpZXdwb3J0RGVwdGhOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHNjb3BlLCB2YWx1ZU5vZGUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoICdmbG9hdCcgKTtcblxuXHRcdHRoaXMuc2NvcGUgPSBzY29wZTtcblx0XHR0aGlzLnZhbHVlTm9kZSA9IHZhbHVlTm9kZTtcblxuXHRcdHRoaXMuaXNWaWV3cG9ydERlcHRoTm9kZSA9IHRydWU7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgeyBzY29wZSB9ID0gdGhpcztcblxuXHRcdGlmICggc2NvcGUgPT09IFZpZXdwb3J0RGVwdGhOb2RlLkRFUFRIX0JBU0UgKSB7XG5cblx0XHRcdHJldHVybiBidWlsZGVyLmdldEZyYWdEZXB0aCgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1cGVyLmdlbmVyYXRlKCBidWlsZGVyICk7XG5cblx0fVxuXG5cdHNldHVwKCB7IGNhbWVyYSB9ICkge1xuXG5cdFx0Y29uc3QgeyBzY29wZSB9ID0gdGhpcztcblx0XHRjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWVOb2RlO1xuXG5cdFx0bGV0IG5vZGUgPSBudWxsO1xuXG5cdFx0aWYgKCBzY29wZSA9PT0gVmlld3BvcnREZXB0aE5vZGUuREVQVEhfQkFTRSApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gbnVsbCApIHtcblxuIFx0XHRcdFx0bm9kZSA9IGRlcHRoQmFzZSgpLmFzc2lnbiggdmFsdWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IFZpZXdwb3J0RGVwdGhOb2RlLkRFUFRIICkge1xuXG5cdFx0XHRpZiAoIGNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRcdG5vZGUgPSB2aWV3WlRvUGVyc3BlY3RpdmVEZXB0aCggcG9zaXRpb25WaWV3LnosIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5vZGUgPSB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoIHBvc2l0aW9uVmlldy56LCBjYW1lcmFOZWFyLCBjYW1lcmFGYXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IFZpZXdwb3J0RGVwdGhOb2RlLkxJTkVBUl9ERVBUSCApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRpZiAoIGNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgdmlld1ogPSBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WiggdmFsdWUsIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xuXG5cdFx0XHRcdFx0bm9kZSA9IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCggdmlld1osIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRub2RlID0gdmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5vZGUgPSB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoIHBvc2l0aW9uVmlldy56LCBjYW1lcmFOZWFyLCBjYW1lcmFGYXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vZGU7XG5cblx0fVxuXG59XG5cblZpZXdwb3J0RGVwdGhOb2RlLkRFUFRIX0JBU0UgPSAnZGVwdGhCYXNlJztcblZpZXdwb3J0RGVwdGhOb2RlLkRFUFRIID0gJ2RlcHRoJztcblZpZXdwb3J0RGVwdGhOb2RlLkxJTkVBUl9ERVBUSCA9ICdsaW5lYXJEZXB0aCc7XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdwb3J0RGVwdGhOb2RlO1xuXG4vLyBOT1RFOiB2aWV3WiwgdGhlIHotY29vcmRpbmF0ZSBpbiBjYW1lcmEgc3BhY2UsIGlzIG5lZ2F0aXZlIGZvciBwb2ludHMgaW4gZnJvbnQgb2YgdGhlIGNhbWVyYVxuXG4vLyAtbmVhciBtYXBzIHRvIDA7IC1mYXIgbWFwcyB0byAxXG5leHBvcnQgY29uc3Qgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoID0gKCB2aWV3WiwgbmVhciwgZmFyICkgPT4gdmlld1ouYWRkKCBuZWFyICkuZGl2KCBuZWFyLnN1YiggZmFyICkgKTtcblxuLy8gbWFwcyBvcnRob2dyYXBoaWMgZGVwdGggaW4gWyAwLCAxIF0gdG8gdmlld1pcbmV4cG9ydCBjb25zdCBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ogPSAoIGRlcHRoLCBuZWFyLCBmYXIgKSA9PiBuZWFyLnN1YiggZmFyICkubXVsKCBkZXB0aCApLnN1YiggbmVhciApO1xuXG4vLyBOT1RFOiBodHRwczovL3R3aXR0ZXIuY29tL2dvbm5hdmlzL3N0YXR1cy8xMzc3MTgzNzg2OTQ5OTU5NjgyXG5cbi8vIC1uZWFyIG1hcHMgdG8gMDsgLWZhciBtYXBzIHRvIDFcbmV4cG9ydCBjb25zdCB2aWV3WlRvUGVyc3BlY3RpdmVEZXB0aCA9ICggdmlld1osIG5lYXIsIGZhciApID0+IG5lYXIuYWRkKCB2aWV3WiApLm11bCggZmFyICkuZGl2KCBmYXIuc3ViKCBuZWFyICkubXVsKCB2aWV3WiApICk7XG5cbi8vIG1hcHMgcGVyc3BlY3RpdmUgZGVwdGggaW4gWyAwLCAxIF0gdG8gdmlld1pcbmV4cG9ydCBjb25zdCBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WiA9ICggZGVwdGgsIG5lYXIsIGZhciApID0+IG5lYXIubXVsKCBmYXIgKS5kaXYoIGZhci5zdWIoIG5lYXIgKS5tdWwoIGRlcHRoICkuc3ViKCBmYXIgKSApO1xuXG4vLyAtbmVhciBtYXBzIHRvIDA7IC1mYXIgbWFwcyB0byAxXG5leHBvcnQgY29uc3Qgdmlld1pUb0xvZ2FyaXRobWljRGVwdGggPSAoIHZpZXdaLCBuZWFyLCBmYXIgKSA9PiB7XG5cblx0Ly8gTk9URTogdmlld1ogbXVzdCBiZSBuZWdhdGl2ZS0tc2VlIGV4cGxhbmF0aW9uIGF0IHRoZSBlbmQgb2YgdGhpcyBjb21tZW50IGJsb2NrLlxuXHQvLyBUaGUgZmluYWwgbG9nYXJpdGhtaWMgZGVwdGggZm9ybXVsYSB1c2VkIGhlcmUgaXMgYWRhcHRlZCBmcm9tIG9uZSBkZXNjcmliZWQgaW4gYW5cblx0Ly8gYXJ0aWNsZSBieSBUaGF0Y2hlciBVbHJpY2ggKHNlZSBodHRwOi8vdHVscmljaC5jb20vZ2Vla3N0dWZmL2xvZ19kZXB0aF9idWZmZXIudHh0KSxcblx0Ly8gd2hpY2ggd2FzIGFuIGltcHJvdmVtZW50IHVwb24gYW4gZWFybGllciBmb3JtdWxhIG9uZSBkZXNjcmliZWQgaW4gYW5cblx0Ly8gT3V0ZXJyYSBhcnRpY2xlIChodHRwczovL291dGVycmEuYmxvZ3Nwb3QuY29tLzIwMDkvMDgvbG9nYXJpdGhtaWMtei1idWZmZXIuaHRtbCkuXG5cdC8vIFVscmljaCdzIGZvcm11bGEgaXMgdGhlIGZvbGxvd2luZzpcblx0Ly8gICAgIHogPSBLICogbG9nKCB3IC8gY2FtZXJhTmVhciApIC8gbG9nKCBjYW1lcmFGYXIgLyBjYW1lcmFOZWFyIClcblx0Ly8gICAgIHdoZXJlIEsgPSAyXmsgLSAxLCBhbmQgayBpcyB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGRlcHRoIGJ1ZmZlci5cblx0Ly8gVGhlIE91dGVycmEgdmFyaWFudCBpZ25vcmVkIHRoZSBjYW1lcmEgbmVhciBwbGFuZSAoaXQgYXNzdW1lZCBpdCB3YXMgMCkgYW5kIGluc3RlYWRcblx0Ly8gb3B0ZWQgZm9yIGEgXCJDLWNvbnN0YW50XCIgZm9yIHJlc29sdXRpb24gYWRqdXN0bWVudCBvZiBvYmplY3RzIG5lYXIgdGhlIGNhbWVyYS5cblx0Ly8gT3V0ZXJyYSBzdGF0ZXM6IFwiTm90aWNlIHRoYXQgdGhlICdDJyB2YXJpYW50IGRvZXNu4oCZdCB1c2UgYSBuZWFyIHBsYW5lIGRpc3RhbmNlLCBpdCBoYXMgaXRcblx0Ly8gc2V0IGF0IDBcIiAocXVvdGUgZnJvbSBodHRwczovL291dGVycmEuYmxvZ3Nwb3QuY29tLzIwMTIvMTEvbWF4aW1pemluZy1kZXB0aC1idWZmZXItcmFuZ2UtYW5kLmh0bWwpLlxuXHQvLyBVbHJpY2gncyB2YXJpYW50IGhhcyB0aGUgYmVuZWZpdCBvZiBjb25zdGFudCByZWxhdGl2ZSBwcmVjaXNpb24gb3ZlciB0aGUgd2hvbGUgbmVhci1mYXIgcmFuZ2UuXG5cdC8vIEl0IHdhcyBkZWJhdGVkIGhlcmUgd2hldGhlciBPdXRlcnJhJ3MgXCJDLWNvbnN0YW50XCIgb3IgVWxyaWNoJ3MgXCJuZWFyIHBsYW5lXCIgdmFyaWFudCBzaG91bGRcblx0Ly8gYmUgdXNlZCwgYW5kIHVsdGltYXRlbHkgVWxyaWNoJ3MgXCJuZWFyIHBsYW5lXCIgdmVyc2lvbiB3YXMgY2hvc2VuLlxuXHQvLyBPdXRlcnJhIGV2ZW50dWFsbHkgbWFkZSBhbm90aGVyIGltcHJvdmVtZW50IHRvIHRoZWlyIG9yaWdpbmFsIFwiQy1jb25zdGFudFwiIHZhcmlhbnQsXG5cdC8vIGJ1dCBpdCBzdGlsbCBkb2VzIG5vdCBpbmNvcnBvcmF0ZSB0aGUgY2FtZXJhIG5lYXIgcGxhbmUgKGZvciB0aGlzIHZlcnNpb24sXG5cdC8vIHNlZSBodHRwczovL291dGVycmEuYmxvZ3Nwb3QuY29tLzIwMTMvMDcvbG9nYXJpdGhtaWMtZGVwdGgtYnVmZmVyLW9wdGltaXphdGlvbnMuaHRtbCkuXG5cdC8vIEhlcmUgd2UgbWFrZSA0IGNoYW5nZXMgdG8gVWxyaWNoJ3MgZm9ybXVsYTpcblx0Ly8gMS4gQ2xhbXAgdGhlIGNhbWVyYSBuZWFyIHBsYW5lIHNvIHdlIGRvbid0IGRpdmlkZSBieSAwLlxuXHQvLyAyLiBVc2UgbG9nMiBpbnN0ZWFkIG9mIGxvZyB0byBhdm9pZCBhbiBleHRyYSBtdWx0aXBseSAoc2hhZGVycyBpbXBsZW1lbnQgbG9nIHVzaW5nIGxvZzIpLlxuXHQvLyAzLiBBc3N1bWUgSyBpcyAxIChLID0gbWF4aW11bSB2YWx1ZSBpbiBkZXB0aCBidWZmZXI7IHNlZSBVbHJpY2gncyBmb3JtdWxhIGFib3ZlKS5cblx0Ly8gNC4gVG8gbWFpbnRhaW4gY29uc2lzdGVuY3kgd2l0aCB0aGUgZnVuY3Rpb25zIFwidmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoXCIgYW5kIFwidmlld1pUb1BlcnNwZWN0aXZlRGVwdGhcIixcblx0Ly8gICAgd2UgbW9kaWZ5IHRoZSBmb3JtdWxhIGhlcmUgdG8gdXNlICd2aWV3WicgaW5zdGVhZCBvZiAndycuIFRoZSBvdGhlciBmdW5jdGlvbnMgZXhwZWN0IGEgbmVnYXRpdmUgdmlld1osXG5cdC8vICAgIHNvIHdlIGRvIHRoZSBzYW1lIGhlcmUsIGhlbmNlIHRoZSAndmlld1oubmVnYXRlKCknIGNhbGwuXG5cdC8vIEZvciB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkZXB0aCBjdXJ2ZSwgc2VlIGh0dHBzOi8vd3d3LmRlc21vcy5jb20vY2FsY3VsYXRvci91eXFrMHZleDF1XG5cdG5lYXIgPSBuZWFyLm1heCggMWUtNiApLnRvVmFyKCk7XG5cdGNvbnN0IG51bWVyYXRvciA9IGxvZzIoIHZpZXdaLm5lZ2F0ZSgpLmRpdiggbmVhciApICk7XG5cdGNvbnN0IGRlbm9taW5hdG9yID0gbG9nMiggZmFyLmRpdiggbmVhciApICk7XG5cdHJldHVybiBudW1lcmF0b3IuZGl2KCBkZW5vbWluYXRvciApO1xuXG59O1xuXG4vLyBtYXBzIGxvZ2FyaXRobWljIGRlcHRoIGluIFsgMCwgMSBdIHRvIHZpZXdaXG5leHBvcnQgY29uc3QgbG9nYXJpdGhtaWNEZXB0aFRvVmlld1ogPSAoIGRlcHRoLCBuZWFyLCBmYXIgKSA9PiB7XG5cblx0Ly8gTk9URTogd2UgYWRkIGEgJ25lZ2F0ZSgpJyBjYWxsIHRvIHRoZSByZXR1cm4gdmFsdWUgaGVyZSB0byBtYWludGFpbiBjb25zaXN0ZW5jeSB3aXRoXG5cdC8vIHRoZSBmdW5jdGlvbnMgXCJvcnRob2dyYXBoaWNEZXB0aFRvVmlld1pcIiBhbmQgXCJwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WlwiICh0aGV5IHJldHVyblxuXHQvLyBhIG5lZ2F0aXZlIHZpZXdaKS5cblx0Y29uc3QgZXhwb25lbnQgPSBkZXB0aC5tdWwoIGxvZyggZmFyLmRpdiggbmVhciApICkgKTtcblx0cmV0dXJuIGZsb2F0KCBNYXRoLkUgKS5wb3coIGV4cG9uZW50ICkubXVsKCBuZWFyICkubmVnYXRlKCk7XG5cbn07XG5cbmNvbnN0IGRlcHRoQmFzZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBWaWV3cG9ydERlcHRoTm9kZSwgVmlld3BvcnREZXB0aE5vZGUuREVQVEhfQkFTRSApO1xuXG5leHBvcnQgY29uc3QgZGVwdGggPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFZpZXdwb3J0RGVwdGhOb2RlLCBWaWV3cG9ydERlcHRoTm9kZS5ERVBUSCApO1xuZXhwb3J0IGNvbnN0IGxpbmVhckRlcHRoID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFZpZXdwb3J0RGVwdGhOb2RlLCBWaWV3cG9ydERlcHRoTm9kZS5MSU5FQVJfREVQVEggKTtcbmV4cG9ydCBjb25zdCB2aWV3cG9ydExpbmVhckRlcHRoID0gLypAX19QVVJFX18qLyBsaW5lYXJEZXB0aCggdmlld3BvcnREZXB0aFRleHR1cmUoKSApO1xuXG5kZXB0aC5hc3NpZ24gPSAoIHZhbHVlICkgPT4gZGVwdGhCYXNlKCB2YWx1ZSApO1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY2xhc3MgQnVpbHRpbk5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSApIHtcblxuXHRcdHN1cGVyKCAnZmxvYXQnICk7XG5cblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXG5cdFx0dGhpcy5pc0J1aWx0aW5Ob2RlID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2VuZXJhdGUoIC8qIGJ1aWxkZXIgKi8gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5uYW1lO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCdWlsdGluTm9kZTtcblxuZXhwb3J0IGNvbnN0IGJ1aWx0aW4gPSBub2RlUHJveHkoIEJ1aWx0aW5Ob2RlICk7XG4iLCJcbmltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlT2JqZWN0LCBGbiwgYm9vbCwgZmxvYXQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyBwb3NpdGlvblZpZXcgfSBmcm9tICcuL1Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IGRpZmZ1c2VDb2xvciB9IGZyb20gJy4uL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcbmltcG9ydCB7IExvb3AgfSBmcm9tICcuLi91dGlscy9Mb29wTm9kZS5qcyc7XG5pbXBvcnQgeyBzbW9vdGhzdGVwIH0gZnJvbSAnLi4vbWF0aC9NYXRoTm9kZS5qcyc7XG5pbXBvcnQgeyB1bmlmb3JtQXJyYXkgfSBmcm9tICcuL1VuaWZvcm1BcnJheU5vZGUuanMnO1xuaW1wb3J0IHsgYnVpbHRpbiB9IGZyb20gJy4vQnVpbHRpbk5vZGUuanMnO1xuXG5jbGFzcyBDbGlwcGluZ05vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0NsaXBwaW5nTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBzY29wZSA9IENsaXBwaW5nTm9kZS5ERUZBVUxUICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuc2NvcGUgPSBzY29wZTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRzdXBlci5zZXR1cCggYnVpbGRlciApO1xuXG5cdFx0Y29uc3QgY2xpcHBpbmdDb250ZXh0ID0gYnVpbGRlci5jbGlwcGluZ0NvbnRleHQ7XG5cdFx0Y29uc3QgeyBpbnRlcnNlY3Rpb25QbGFuZXMsIHVuaW9uUGxhbmVzIH0gPSBjbGlwcGluZ0NvbnRleHQ7XG5cblx0XHR0aGlzLmhhcmR3YXJlQ2xpcHBpbmcgPSBidWlsZGVyLm1hdGVyaWFsLmhhcmR3YXJlQ2xpcHBpbmc7XG5cblx0XHRpZiAoIHRoaXMuc2NvcGUgPT09IENsaXBwaW5nTm9kZS5BTFBIQV9UT19DT1ZFUkFHRSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0dXBBbHBoYVRvQ292ZXJhZ2UoIGludGVyc2VjdGlvblBsYW5lcywgdW5pb25QbGFuZXMgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuc2NvcGUgPT09IENsaXBwaW5nTm9kZS5IQVJEV0FSRSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0dXBIYXJkd2FyZUNsaXBwaW5nKCB1bmlvblBsYW5lcywgYnVpbGRlciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0dXBEZWZhdWx0KCBpbnRlcnNlY3Rpb25QbGFuZXMsIHVuaW9uUGxhbmVzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldHVwQWxwaGFUb0NvdmVyYWdlKCBpbnRlcnNlY3Rpb25QbGFuZXMsIHVuaW9uUGxhbmVzICkge1xuXG5cdFx0cmV0dXJuIEZuKCAoKSA9PiB7XG5cblx0XHRcdGNvbnN0IGRpc3RhbmNlVG9QbGFuZSA9IGZsb2F0KCkudG9WYXIoICdkaXN0YW5jZVRvUGxhbmUnICk7XG5cdFx0XHRjb25zdCBkaXN0YW5jZUdyYWRpZW50ID0gZmxvYXQoKS50b1ZhciggJ2Rpc3RhbmNlVG9HcmFkaWVudCcgKTtcblxuXHRcdFx0Y29uc3QgY2xpcE9wYWNpdHkgPSBmbG9hdCggMSApLnRvVmFyKCAnY2xpcE9wYWNpdHknICk7XG5cblx0XHRcdGNvbnN0IG51bVVuaW9uUGxhbmVzID0gdW5pb25QbGFuZXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoICEgdGhpcy5oYXJkd2FyZUNsaXBwaW5nICYmIG51bVVuaW9uUGxhbmVzID4gMCApIHtcblxuXHRcdFx0XHRjb25zdCBjbGlwcGluZ1BsYW5lcyA9IHVuaWZvcm1BcnJheSggdW5pb25QbGFuZXMgKTtcblxuXHRcdFx0XHRMb29wKCBudW1VbmlvblBsYW5lcywgKCB7IGkgfSApID0+IHtcblxuXHRcdFx0XHRcdGNvbnN0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXMuZWxlbWVudCggaSApO1xuXG5cdFx0XHRcdFx0ZGlzdGFuY2VUb1BsYW5lLmFzc2lnbiggcG9zaXRpb25WaWV3LmRvdCggcGxhbmUueHl6ICkubmVnYXRlKCkuYWRkKCBwbGFuZS53ICkgKTtcblx0XHRcdFx0XHRkaXN0YW5jZUdyYWRpZW50LmFzc2lnbiggZGlzdGFuY2VUb1BsYW5lLmZ3aWR0aCgpLmRpdiggMi4wICkgKTtcblxuXHRcdFx0XHRcdGNsaXBPcGFjaXR5Lm11bEFzc2lnbiggc21vb3Roc3RlcCggZGlzdGFuY2VHcmFkaWVudC5uZWdhdGUoKSwgZGlzdGFuY2VHcmFkaWVudCwgZGlzdGFuY2VUb1BsYW5lICkgKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbnVtSW50ZXJzZWN0aW9uUGxhbmVzID0gaW50ZXJzZWN0aW9uUGxhbmVzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBudW1JbnRlcnNlY3Rpb25QbGFuZXMgPiAwICkge1xuXG5cdFx0XHRcdGNvbnN0IGNsaXBwaW5nUGxhbmVzID0gdW5pZm9ybUFycmF5KCBpbnRlcnNlY3Rpb25QbGFuZXMgKTtcblx0XHRcdFx0Y29uc3QgaW50ZXJzZWN0aW9uQ2xpcE9wYWNpdHkgPSBmbG9hdCggMSApLnRvVmFyKCAnaW50ZXJzZWN0aW9uQ2xpcE9wYWNpdHknICk7XG5cblx0XHRcdFx0TG9vcCggbnVtSW50ZXJzZWN0aW9uUGxhbmVzLCAoIHsgaSB9ICkgPT4ge1xuXG5cdFx0XHRcdFx0Y29uc3QgcGxhbmUgPSBjbGlwcGluZ1BsYW5lcy5lbGVtZW50KCBpICk7XG5cblx0XHRcdFx0XHRkaXN0YW5jZVRvUGxhbmUuYXNzaWduKCBwb3NpdGlvblZpZXcuZG90KCBwbGFuZS54eXogKS5uZWdhdGUoKS5hZGQoIHBsYW5lLncgKSApO1xuXHRcdFx0XHRcdGRpc3RhbmNlR3JhZGllbnQuYXNzaWduKCBkaXN0YW5jZVRvUGxhbmUuZndpZHRoKCkuZGl2KCAyLjAgKSApO1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uQ2xpcE9wYWNpdHkubXVsQXNzaWduKCBzbW9vdGhzdGVwKCBkaXN0YW5jZUdyYWRpZW50Lm5lZ2F0ZSgpLCBkaXN0YW5jZUdyYWRpZW50LCBkaXN0YW5jZVRvUGxhbmUgKS5vbmVNaW51cygpICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdGNsaXBPcGFjaXR5Lm11bEFzc2lnbiggaW50ZXJzZWN0aW9uQ2xpcE9wYWNpdHkub25lTWludXMoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRpZmZ1c2VDb2xvci5hLm11bEFzc2lnbiggY2xpcE9wYWNpdHkgKTtcblxuXHRcdFx0ZGlmZnVzZUNvbG9yLmEuZXF1YWwoIDAuMCApLmRpc2NhcmQoKTtcblxuXHRcdH0gKSgpO1xuXG5cdH1cblxuXHRzZXR1cERlZmF1bHQoIGludGVyc2VjdGlvblBsYW5lcywgdW5pb25QbGFuZXMgKSB7XG5cblx0XHRyZXR1cm4gRm4oICgpID0+IHtcblxuXHRcdFx0Y29uc3QgbnVtVW5pb25QbGFuZXMgPSB1bmlvblBsYW5lcy5sZW5ndGg7XG5cblx0XHRcdGlmICggISB0aGlzLmhhcmR3YXJlQ2xpcHBpbmcgJiYgbnVtVW5pb25QbGFuZXMgPiAwICkge1xuXG5cdFx0XHRcdGNvbnN0IGNsaXBwaW5nUGxhbmVzID0gdW5pZm9ybUFycmF5KCB1bmlvblBsYW5lcyApO1xuXG5cdFx0XHRcdExvb3AoIG51bVVuaW9uUGxhbmVzLCAoIHsgaSB9ICkgPT4ge1xuXG5cdFx0XHRcdFx0Y29uc3QgcGxhbmUgPSBjbGlwcGluZ1BsYW5lcy5lbGVtZW50KCBpICk7XG5cdFx0XHRcdFx0cG9zaXRpb25WaWV3LmRvdCggcGxhbmUueHl6ICkuZ3JlYXRlclRoYW4oIHBsYW5lLncgKS5kaXNjYXJkKCk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG51bUludGVyc2VjdGlvblBsYW5lcyA9IGludGVyc2VjdGlvblBsYW5lcy5sZW5ndGg7XG5cblx0XHRcdGlmICggbnVtSW50ZXJzZWN0aW9uUGxhbmVzID4gMCApIHtcblxuXHRcdFx0XHRjb25zdCBjbGlwcGluZ1BsYW5lcyA9IHVuaWZvcm1BcnJheSggaW50ZXJzZWN0aW9uUGxhbmVzICk7XG5cdFx0XHRcdGNvbnN0IGNsaXBwZWQgPSBib29sKCB0cnVlICkudG9WYXIoICdjbGlwcGVkJyApO1xuXG5cdFx0XHRcdExvb3AoIG51bUludGVyc2VjdGlvblBsYW5lcywgKCB7IGkgfSApID0+IHtcblxuXHRcdFx0XHRcdGNvbnN0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXMuZWxlbWVudCggaSApO1xuXHRcdFx0XHRcdGNsaXBwZWQuYXNzaWduKCBwb3NpdGlvblZpZXcuZG90KCBwbGFuZS54eXogKS5ncmVhdGVyVGhhbiggcGxhbmUudyApLmFuZCggY2xpcHBlZCApICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdGNsaXBwZWQuZGlzY2FyZCgpO1xuXG5cdFx0XHR9XG5cblx0XHR9ICkoKTtcblxuXHR9XG5cblx0c2V0dXBIYXJkd2FyZUNsaXBwaW5nKCB1bmlvblBsYW5lcywgYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IG51bVVuaW9uUGxhbmVzID0gdW5pb25QbGFuZXMubGVuZ3RoO1xuXG5cdFx0YnVpbGRlci5lbmFibGVIYXJkd2FyZUNsaXBwaW5nKCBudW1VbmlvblBsYW5lcyApO1xuXG5cdFx0cmV0dXJuIEZuKCAoKSA9PiB7XG5cblx0XHRcdGNvbnN0IGNsaXBwaW5nUGxhbmVzID0gdW5pZm9ybUFycmF5KCB1bmlvblBsYW5lcyApO1xuXHRcdFx0Y29uc3QgaHdfY2xpcF9kaXN0YW5jZXMgPSBidWlsdGluKCBidWlsZGVyLmdldENsaXBEaXN0YW5jZSgpICk7XG5cblx0XHRcdExvb3AoIG51bVVuaW9uUGxhbmVzLCAoIHsgaSB9ICkgPT4ge1xuXG5cdFx0XHRcdGNvbnN0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXMuZWxlbWVudCggaSApO1xuXG5cdFx0XHRcdGNvbnN0IGRpc3RhbmNlID0gcG9zaXRpb25WaWV3LmRvdCggcGxhbmUueHl6ICkuc3ViKCBwbGFuZS53ICkubmVnYXRlKCk7XG5cdFx0XHRcdGh3X2NsaXBfZGlzdGFuY2VzLmVsZW1lbnQoIGkgKS5hc3NpZ24oIGRpc3RhbmNlICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKSgpO1xuXG5cdH1cblxufVxuXG5DbGlwcGluZ05vZGUuQUxQSEFfVE9fQ09WRVJBR0UgPSAnYWxwaGFUb0NvdmVyYWdlJztcbkNsaXBwaW5nTm9kZS5ERUZBVUxUID0gJ2RlZmF1bHQnO1xuQ2xpcHBpbmdOb2RlLkhBUkRXQVJFID0gJ2hhcmR3YXJlJztcblxuZXhwb3J0IGRlZmF1bHQgQ2xpcHBpbmdOb2RlO1xuXG5leHBvcnQgY29uc3QgY2xpcHBpbmcgPSAoKSA9PiBub2RlT2JqZWN0KCBuZXcgQ2xpcHBpbmdOb2RlKCkgKTtcbmV4cG9ydCBjb25zdCBjbGlwcGluZ0FscGhhID0gKCkgPT4gbm9kZU9iamVjdCggbmV3IENsaXBwaW5nTm9kZSggQ2xpcHBpbmdOb2RlLkFMUEhBX1RPX0NPVkVSQUdFICkgKTtcbmV4cG9ydCBjb25zdCBoYXJkd2FyZUNsaXBwaW5nID0gKCkgPT4gbm9kZU9iamVjdCggbmV3IENsaXBwaW5nTm9kZSggQ2xpcHBpbmdOb2RlLkhBUkRXQVJFICkgKTtcbiIsImltcG9ydCB7IGFicywgYWRkLCBjZWlsLCBjbGFtcCwgZEZkeCwgZEZkeSwgZXhwMiwgZmxvYXQsIGZsb29yLCBGbiwgZnJhY3QsIGxlbmd0aCwgbG9nMiwgbWF4LCBtaW4sIG11bCwgc2luLCBzdWIsIHZlYzIsIHZlYzMgfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XG5cbi8qKlxuICogU2VlOiBodHRwczovL2Nhc3VhbC1lZmZlY3RzLmNvbS9yZXNlYXJjaC9XeW1hbjIwMTdIYXNoZWQvaW5kZXguaHRtbFxuICovXG5cbmNvbnN0IEFMUEhBX0hBU0hfU0NBTEUgPSAwLjA1OyAvLyBEZXJpdmVkIGZyb20gdHJpYWxzIG9ubHksIGFuZCBtYXkgYmUgY2hhbmdlZC5cblxuY29uc3QgaGFzaDJEID0gLypAX19QVVJFX18qLyBGbiggKCBbIHZhbHVlIF0gKSA9PiB7XG5cblx0cmV0dXJuIGZyYWN0KCBtdWwoIDEuMGU0LCBzaW4oIG11bCggMTcuMCwgdmFsdWUueCApLmFkZCggbXVsKCAwLjEsIHZhbHVlLnkgKSApICkgKS5tdWwoIGFkZCggMC4xLCBhYnMoIHNpbiggbXVsKCAxMy4wLCB2YWx1ZS55ICkuYWRkKCB2YWx1ZS54ICkgKSApICkgKSApO1xuXG59ICk7XG5cbmNvbnN0IGhhc2gzRCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB2YWx1ZSBdICkgPT4ge1xuXG5cdHJldHVybiBoYXNoMkQoIHZlYzIoIGhhc2gyRCggdmFsdWUueHkgKSwgdmFsdWUueiApICk7XG5cbn0gKTtcblxuY29uc3QgZ2V0QWxwaGFIYXNoVGhyZXNob2xkID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBvc2l0aW9uIF0gKSA9PiB7XG5cblx0Ly8gRmluZCB0aGUgZGlzY3JldGl6ZWQgZGVyaXZhdGl2ZXMgb2Ygb3VyIGNvb3JkaW5hdGVzXG5cdGNvbnN0IG1heERlcml2ID0gbWF4KFxuXHRcdGxlbmd0aCggZEZkeCggcG9zaXRpb24ueHl6ICkgKSxcblx0XHRsZW5ndGgoIGRGZHkoIHBvc2l0aW9uLnh5eiApIClcblx0KTtcblxuXHRjb25zdCBwaXhTY2FsZSA9IGZsb2F0KCAxICkuZGl2KCBmbG9hdCggQUxQSEFfSEFTSF9TQ0FMRSApLm11bCggbWF4RGVyaXYgKSApLnRvVmFyKCAncGl4U2NhbGUnICk7XG5cblx0Ly8gRmluZCB0d28gbmVhcmVzdCBsb2ctZGlzY3JldGl6ZWQgbm9pc2Ugc2NhbGVzXG5cdGNvbnN0IHBpeFNjYWxlcyA9IHZlYzIoXG5cdFx0ZXhwMiggZmxvb3IoIGxvZzIoIHBpeFNjYWxlICkgKSApLFxuXHRcdGV4cDIoIGNlaWwoIGxvZzIoIHBpeFNjYWxlICkgKSApXG5cdCk7XG5cblx0Ly8gQ29tcHV0ZSBhbHBoYSB0aHJlc2hvbGRzIGF0IG91ciB0d28gbm9pc2Ugc2NhbGVzXG5cdGNvbnN0IGFscGhhID0gdmVjMihcblx0XHRoYXNoM0QoIGZsb29yKCBwaXhTY2FsZXMueC5tdWwoIHBvc2l0aW9uLnh5eiApICkgKSxcblx0XHRoYXNoM0QoIGZsb29yKCBwaXhTY2FsZXMueS5tdWwoIHBvc2l0aW9uLnh5eiApICkgKSxcblx0KTtcblxuXHQvLyBGYWN0b3IgdG8gaW50ZXJwb2xhdGUgbGVycCB3aXRoXG5cdGNvbnN0IGxlcnBGYWN0b3IgPSBmcmFjdCggbG9nMiggcGl4U2NhbGUgKSApO1xuXG5cdC8vIEludGVycG9sYXRlIGFscGhhIHRocmVzaG9sZCBmcm9tIG5vaXNlIGF0IHR3byBzY2FsZXNcblx0Y29uc3QgeCA9IGFkZCggbXVsKCBsZXJwRmFjdG9yLm9uZU1pbnVzKCksIGFscGhhLnggKSwgbXVsKCBsZXJwRmFjdG9yLCBhbHBoYS55ICkgKTtcblxuXHQvLyBQYXNzIGludG8gQ0RGIHRvIGNvbXB1dGUgdW5pZm9ybWx5IGRpc3RyaWIgdGhyZXNob2xkXG5cdGNvbnN0IGEgPSBtaW4oIGxlcnBGYWN0b3IsIGxlcnBGYWN0b3Iub25lTWludXMoKSApO1xuXHRjb25zdCBjYXNlcyA9IHZlYzMoXG5cdFx0eC5tdWwoIHggKS5kaXYoIG11bCggMi4wLCBhICkubXVsKCBzdWIoIDEuMCwgYSApICkgKSxcblx0XHR4LnN1YiggbXVsKCAwLjUsIGEgKSApLmRpdiggc3ViKCAxLjAsIGEgKSApLFxuXHRcdHN1YiggMS4wLCBzdWIoIDEuMCwgeCApLm11bCggc3ViKCAxLjAsIHggKSApLmRpdiggbXVsKCAyLjAsIGEgKS5tdWwoIHN1YiggMS4wLCBhICkgKSApICkgKTtcblxuXHQvLyBGaW5kIG91ciBmaW5hbCwgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkIGFscGhhIHRocmVzaG9sZCAozrHPhClcblx0Y29uc3QgdGhyZXNob2xkID0geC5sZXNzVGhhbiggYS5vbmVNaW51cygpICkuc2VsZWN0KCB4Lmxlc3NUaGFuKCBhICkuc2VsZWN0KCBjYXNlcy54LCBjYXNlcy55ICksIGNhc2VzLnogKTtcblxuXHQvLyBBdm9pZHMgzrHPhCA9PSAwLiBDb3VsZCBhbHNvIGRvIM6xz4QgPTEtzrHPhFxuXHRyZXR1cm4gY2xhbXAoIHRocmVzaG9sZCwgMS4wZS02LCAxLjAgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnZ2V0QWxwaGFIYXNoVGhyZXNob2xkJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncG9zaXRpb24nLCB0eXBlOiAndmVjMycgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldEFscGhhSGFzaFRocmVzaG9sZDtcbiIsImltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi4vTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgTm9ybWFsQmxlbmRpbmcgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuXG5pbXBvcnQgeyBnZXROb2RlQ2hpbGRyZW4sIGdldENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vbm9kZXMvY29yZS9Ob2RlVXRpbHMuanMnO1xuaW1wb3J0IHsgYXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vbm9kZXMvY29yZS9BdHRyaWJ1dGVOb2RlLmpzJztcbmltcG9ydCB7IG91dHB1dCwgZGlmZnVzZUNvbG9yLCBlbWlzc2l2ZSwgdmFyeWluZ1Byb3BlcnR5IH0gZnJvbSAnLi4vLi4vbm9kZXMvY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xuaW1wb3J0IHsgbWF0ZXJpYWxBbHBoYVRlc3QsIG1hdGVyaWFsQ29sb3IsIG1hdGVyaWFsT3BhY2l0eSwgbWF0ZXJpYWxFbWlzc2l2ZSwgbWF0ZXJpYWxOb3JtYWwsIG1hdGVyaWFsTGlnaHRNYXAsIG1hdGVyaWFsQU9NYXAgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTWF0ZXJpYWxOb2RlLmpzJztcbmltcG9ydCB7IG1vZGVsVmlld1Byb2plY3Rpb24gfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTW9kZWxWaWV3UHJvamVjdGlvbk5vZGUuanMnO1xuaW1wb3J0IHsgbm9ybWFsTG9jYWwgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcbmltcG9ydCB7IGluc3RhbmNlZE1lc2ggfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvSW5zdGFuY2VkTWVzaE5vZGUuanMnO1xuaW1wb3J0IHsgYmF0Y2ggfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvQmF0Y2hOb2RlLmpzJztcbmltcG9ydCB7IG1hdGVyaWFsUmVmZXJlbmNlIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL01hdGVyaWFsUmVmZXJlbmNlTm9kZS5qcyc7XG5pbXBvcnQgeyBwb3NpdGlvbkxvY2FsLCBwb3NpdGlvblZpZXcgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgc2tpbm5pbmdSZWZlcmVuY2UgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvU2tpbm5pbmdOb2RlLmpzJztcbmltcG9ydCB7IG1vcnBoUmVmZXJlbmNlIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL01vcnBoTm9kZS5qcyc7XG5pbXBvcnQgeyBtaXggfSBmcm9tICcuLi8uLi9ub2Rlcy9tYXRoL01hdGhOb2RlLmpzJztcbmltcG9ydCB7IGZsb2F0LCB2ZWMzLCB2ZWM0IH0gZnJvbSAnLi4vLi4vbm9kZXMvdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IEFPTm9kZSBmcm9tICcuLi8uLi9ub2Rlcy9saWdodGluZy9BT05vZGUuanMnO1xuaW1wb3J0IHsgbGlnaHRpbmdDb250ZXh0IH0gZnJvbSAnLi4vLi4vbm9kZXMvbGlnaHRpbmcvTGlnaHRpbmdDb250ZXh0Tm9kZS5qcyc7XG5pbXBvcnQgSXJyYWRpYW5jZU5vZGUgZnJvbSAnLi4vLi4vbm9kZXMvbGlnaHRpbmcvSXJyYWRpYW5jZU5vZGUuanMnO1xuaW1wb3J0IHsgZGVwdGgsIHZpZXdaVG9Mb2dhcml0aG1pY0RlcHRoLCB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGggfSBmcm9tICcuLi8uLi9ub2Rlcy9kaXNwbGF5L1ZpZXdwb3J0RGVwdGhOb2RlLmpzJztcbmltcG9ydCB7IGNhbWVyYUZhciwgY2FtZXJhTmVhciB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9DYW1lcmEuanMnO1xuaW1wb3J0IHsgY2xpcHBpbmcsIGNsaXBwaW5nQWxwaGEsIGhhcmR3YXJlQ2xpcHBpbmcgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvQ2xpcHBpbmdOb2RlLmpzJztcbmltcG9ydCBOb2RlTWF0ZXJpYWxPYnNlcnZlciBmcm9tICcuL21hbmFnZXIvTm9kZU1hdGVyaWFsT2JzZXJ2ZXIuanMnO1xuaW1wb3J0IGdldEFscGhhSGFzaFRocmVzaG9sZCBmcm9tICcuLi8uLi9ub2Rlcy9mdW5jdGlvbnMvbWF0ZXJpYWwvZ2V0QWxwaGFIYXNoVGhyZXNob2xkLmpzJztcblxuY2xhc3MgTm9kZU1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnTm9kZU1hdGVyaWFsJztcblxuXHR9XG5cblx0Z2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50eXBlO1xuXG5cdH1cblxuXHRzZXQgdHlwZSggX3ZhbHVlICkgeyAvKiAqLyB9XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc05vZGVNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLmZvcmNlU2luZ2xlUGFzcyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7XG5cdFx0dGhpcy5oYXJkd2FyZUNsaXBwaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLmxpZ2h0c05vZGUgPSBudWxsO1xuXHRcdHRoaXMuZW52Tm9kZSA9IG51bGw7XG5cdFx0dGhpcy5hb05vZGUgPSBudWxsO1xuXG5cdFx0dGhpcy5jb2xvck5vZGUgPSBudWxsO1xuXHRcdHRoaXMubm9ybWFsTm9kZSA9IG51bGw7XG5cdFx0dGhpcy5vcGFjaXR5Tm9kZSA9IG51bGw7XG5cdFx0dGhpcy5iYWNrZHJvcE5vZGUgPSBudWxsO1xuXHRcdHRoaXMuYmFja2Ryb3BBbHBoYU5vZGUgPSBudWxsO1xuXHRcdHRoaXMuYWxwaGFUZXN0Tm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLnBvc2l0aW9uTm9kZSA9IG51bGw7XG5cdFx0dGhpcy5nZW9tZXRyeU5vZGUgPSBudWxsO1xuXG5cdFx0dGhpcy5kZXB0aE5vZGUgPSBudWxsO1xuXHRcdHRoaXMuc2hhZG93UG9zaXRpb25Ob2RlID0gbnVsbDtcblx0XHR0aGlzLnJlY2VpdmVkU2hhZG93Tm9kZSA9IG51bGw7XG5cdFx0dGhpcy5jYXN0U2hhZG93Tm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLm91dHB1dE5vZGUgPSBudWxsO1xuXHRcdHRoaXMubXJ0Tm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLmZyYWdtZW50Tm9kZSA9IG51bGw7XG5cdFx0dGhpcy52ZXJ0ZXhOb2RlID0gbnVsbDtcblxuXHR9XG5cblx0Y3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHlwZSArIGdldENhY2hlS2V5KCB0aGlzICk7XG5cblx0fVxuXG5cdGJ1aWxkKCBidWlsZGVyICkge1xuXG5cdFx0dGhpcy5zZXR1cCggYnVpbGRlciApO1xuXG5cdH1cblxuXHRzZXR1cE9ic2VydmVyKCBidWlsZGVyICkge1xuXG5cdFx0cmV0dXJuIG5ldyBOb2RlTWF0ZXJpYWxPYnNlcnZlciggYnVpbGRlciApO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdGJ1aWxkZXIuY29udGV4dC5zZXR1cE5vcm1hbCA9ICgpID0+IHRoaXMuc2V0dXBOb3JtYWwoIGJ1aWxkZXIgKTtcblxuXHRcdGNvbnN0IHJlbmRlcmVyID0gYnVpbGRlci5yZW5kZXJlcjtcblx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblxuXHRcdC8vIDwgVkVSVEVYIFNUQUdFID5cblxuXHRcdGJ1aWxkZXIuYWRkU3RhY2soKTtcblxuXHRcdGJ1aWxkZXIuc3RhY2sub3V0cHV0Tm9kZSA9IHRoaXMudmVydGV4Tm9kZSB8fCB0aGlzLnNldHVwUG9zaXRpb24oIGJ1aWxkZXIgKTtcblxuXHRcdGlmICggdGhpcy5nZW9tZXRyeU5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdGJ1aWxkZXIuc3RhY2sub3V0cHV0Tm9kZSA9IGJ1aWxkZXIuc3RhY2sub3V0cHV0Tm9kZS5ieXBhc3MoIHRoaXMuZ2VvbWV0cnlOb2RlICk7XG5cblx0XHR9XG5cblx0XHRidWlsZGVyLmFkZEZsb3coICd2ZXJ0ZXgnLCBidWlsZGVyLnJlbW92ZVN0YWNrKCkgKTtcblxuXHRcdC8vIDwgRlJBR01FTlQgU1RBR0UgPlxuXG5cdFx0YnVpbGRlci5hZGRTdGFjaygpO1xuXG5cdFx0bGV0IHJlc3VsdE5vZGU7XG5cblx0XHRjb25zdCBjbGlwcGluZ05vZGUgPSB0aGlzLnNldHVwQ2xpcHBpbmcoIGJ1aWxkZXIgKTtcblxuXHRcdGlmICggdGhpcy5kZXB0aFdyaXRlID09PSB0cnVlICkge1xuXG5cdFx0XHQvLyBvbmx5IHdyaXRlIGRlcHRoIGlmIGRlcHRoIGJ1ZmZlciBpcyBjb25maWd1cmVkXG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID09PSB0cnVlICkgdGhpcy5zZXR1cERlcHRoKCBidWlsZGVyICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCByZW5kZXJlci5kZXB0aCA9PT0gdHJ1ZSApIHRoaXMuc2V0dXBEZXB0aCggYnVpbGRlciApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuZnJhZ21lbnROb2RlID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLnNldHVwRGlmZnVzZUNvbG9yKCBidWlsZGVyICk7XG5cdFx0XHR0aGlzLnNldHVwVmFyaWFudHMoIGJ1aWxkZXIgKTtcblxuXHRcdFx0Y29uc3Qgb3V0Z29pbmdMaWdodE5vZGUgPSB0aGlzLnNldHVwTGlnaHRpbmcoIGJ1aWxkZXIgKTtcblxuXHRcdFx0aWYgKCBjbGlwcGluZ05vZGUgIT09IG51bGwgKSBidWlsZGVyLnN0YWNrLmFkZCggY2xpcHBpbmdOb2RlICk7XG5cblx0XHRcdC8vIGZvcmNlIHVuc2lnbmVkIGZsb2F0cyAtIHVzZWZ1bCBmb3IgUmVuZGVyVGFyZ2V0c1xuXG5cdFx0XHRjb25zdCBiYXNpY091dHB1dCA9IHZlYzQoIG91dGdvaW5nTGlnaHROb2RlLCBkaWZmdXNlQ29sb3IuYSApLm1heCggMCApO1xuXG5cdFx0XHRyZXN1bHROb2RlID0gdGhpcy5zZXR1cE91dHB1dCggYnVpbGRlciwgYmFzaWNPdXRwdXQgKTtcblxuXHRcdFx0Ly8gT1VUUFVUIE5PREVcblxuXHRcdFx0b3V0cHV0LmFzc2lnbiggcmVzdWx0Tm9kZSApO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRpZiAoIHRoaXMub3V0cHV0Tm9kZSAhPT0gbnVsbCApIHJlc3VsdE5vZGUgPSB0aGlzLm91dHB1dE5vZGU7XG5cblx0XHRcdC8vIE1SVFxuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zdCBtcnQgPSByZW5kZXJlci5nZXRNUlQoKTtcblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxNUlQgPSB0aGlzLm1ydE5vZGU7XG5cblx0XHRcdFx0aWYgKCBtcnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRyZXN1bHROb2RlID0gbXJ0O1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbE1SVCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0cmVzdWx0Tm9kZSA9IG1ydC5tZXJnZSggbWF0ZXJpYWxNUlQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbE1SVCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHJlc3VsdE5vZGUgPSBtYXRlcmlhbE1SVDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGxldCBmcmFnbWVudE5vZGUgPSB0aGlzLmZyYWdtZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBmcmFnbWVudE5vZGUuaXNPdXRwdXRTdHJ1Y3ROb2RlICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdGZyYWdtZW50Tm9kZSA9IHZlYzQoIGZyYWdtZW50Tm9kZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJlc3VsdE5vZGUgPSB0aGlzLnNldHVwT3V0cHV0KCBidWlsZGVyLCBmcmFnbWVudE5vZGUgKTtcblxuXHRcdH1cblxuXHRcdGJ1aWxkZXIuc3RhY2sub3V0cHV0Tm9kZSA9IHJlc3VsdE5vZGU7XG5cblx0XHRidWlsZGVyLmFkZEZsb3coICdmcmFnbWVudCcsIGJ1aWxkZXIucmVtb3ZlU3RhY2soKSApO1xuXG5cdFx0Ly8gPCBNT05JVE9SID5cblxuXHRcdGJ1aWxkZXIubW9uaXRvciA9IHRoaXMuc2V0dXBPYnNlcnZlciggYnVpbGRlciApO1xuXG5cdH1cblxuXHRzZXR1cENsaXBwaW5nKCBidWlsZGVyICkge1xuXG5cdFx0aWYgKCBidWlsZGVyLmNsaXBwaW5nQ29udGV4dCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xuXG5cdFx0Y29uc3QgeyB1bmlvblBsYW5lcywgaW50ZXJzZWN0aW9uUGxhbmVzIH0gPSBidWlsZGVyLmNsaXBwaW5nQ29udGV4dDtcblxuXHRcdGxldCByZXN1bHQgPSBudWxsO1xuXG5cdFx0aWYgKCB1bmlvblBsYW5lcy5sZW5ndGggPiAwIHx8IGludGVyc2VjdGlvblBsYW5lcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRjb25zdCBzYW1wbGVzID0gYnVpbGRlci5yZW5kZXJlci5zYW1wbGVzO1xuXG5cdFx0XHRpZiAoIHRoaXMuYWxwaGFUb0NvdmVyYWdlICYmIHNhbXBsZXMgPiAxICkge1xuXG5cdFx0XHRcdC8vIHRvIGJlIGFkZGVkIHRvIGZsb3cgd2hlbiB0aGUgY29sb3IvYWxwaGEgdmFsdWUgaGFzIGJlZW4gZGV0ZXJtaW5lZFxuXHRcdFx0XHRyZXN1bHQgPSBjbGlwcGluZ0FscGhhKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YnVpbGRlci5zdGFjay5hZGQoIGNsaXBwaW5nKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0c2V0dXBIYXJkd2FyZUNsaXBwaW5nKCBidWlsZGVyICkge1xuXG5cdFx0dGhpcy5oYXJkd2FyZUNsaXBwaW5nID0gZmFsc2U7XG5cblx0XHRpZiAoIGJ1aWxkZXIuY2xpcHBpbmdDb250ZXh0ID09PSBudWxsICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgY2FuZGlkYXRlQ291bnQgPSBidWlsZGVyLmNsaXBwaW5nQ29udGV4dC51bmlvblBsYW5lcy5sZW5ndGg7XG5cblx0XHQvLyA4IHBsYW5lcyBzdXBwb3J0ZWQgYnkgV2ViR0wgQU5HTEVfY2xpcF9jdWxsX2Rpc3RhbmNlIGFuZCBXZWJHUFUgY2xpcC1kaXN0YW5jZXNcblxuXHRcdGlmICggY2FuZGlkYXRlQ291bnQgPiAwICYmIGNhbmRpZGF0ZUNvdW50IDw9IDggJiYgYnVpbGRlci5pc0F2YWlsYWJsZSggJ2NsaXBEaXN0YW5jZScgKSApIHtcblxuXHRcdFx0YnVpbGRlci5zdGFjay5hZGQoIGhhcmR3YXJlQ2xpcHBpbmcoKSApO1xuXG5cdFx0XHR0aGlzLmhhcmR3YXJlQ2xpcHBpbmcgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuO1xuXG5cdH1cblxuXHRzZXR1cERlcHRoKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgeyByZW5kZXJlciwgY2FtZXJhIH0gPSBidWlsZGVyO1xuXG5cdFx0Ly8gRGVwdGhcblxuXHRcdGxldCBkZXB0aE5vZGUgPSB0aGlzLmRlcHRoTm9kZTtcblxuXHRcdGlmICggZGVwdGhOb2RlID09PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBtcnQgPSByZW5kZXJlci5nZXRNUlQoKTtcblxuXHRcdFx0aWYgKCBtcnQgJiYgbXJ0LmhhcyggJ2RlcHRoJyApICkge1xuXG5cdFx0XHRcdGRlcHRoTm9kZSA9IG1ydC5nZXQoICdkZXB0aCcgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggcmVuZGVyZXIubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRpZiAoIGNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRcdFx0ZGVwdGhOb2RlID0gdmlld1pUb0xvZ2FyaXRobWljRGVwdGgoIHBvc2l0aW9uVmlldy56LCBjYW1lcmFOZWFyLCBjYW1lcmFGYXIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZGVwdGhOb2RlID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKCBwb3NpdGlvblZpZXcueiwgY2FtZXJhTmVhciwgY2FtZXJhRmFyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGRlcHRoTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0ZGVwdGguYXNzaWduKCBkZXB0aE5vZGUgKS5hcHBlbmQoKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2V0dXBQb3NpdGlvbiggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHsgb2JqZWN0IH0gPSBidWlsZGVyO1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0YnVpbGRlci5hZGRTdGFjaygpO1xuXG5cdFx0Ly8gVmVydGV4XG5cblx0XHRpZiAoIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciApIHtcblxuXHRcdFx0bW9ycGhSZWZlcmVuY2UoIG9iamVjdCApLmFwcGVuZCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0c2tpbm5pbmdSZWZlcmVuY2UoIG9iamVjdCApLmFwcGVuZCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmRpc3BsYWNlbWVudE1hcCApIHtcblxuXHRcdFx0Y29uc3QgZGlzcGxhY2VtZW50TWFwID0gbWF0ZXJpYWxSZWZlcmVuY2UoICdkaXNwbGFjZW1lbnRNYXAnLCAndGV4dHVyZScgKTtcblx0XHRcdGNvbnN0IGRpc3BsYWNlbWVudFNjYWxlID0gbWF0ZXJpYWxSZWZlcmVuY2UoICdkaXNwbGFjZW1lbnRTY2FsZScsICdmbG9hdCcgKTtcblx0XHRcdGNvbnN0IGRpc3BsYWNlbWVudEJpYXMgPSBtYXRlcmlhbFJlZmVyZW5jZSggJ2Rpc3BsYWNlbWVudEJpYXMnLCAnZmxvYXQnICk7XG5cblx0XHRcdHBvc2l0aW9uTG9jYWwuYWRkQXNzaWduKCBub3JtYWxMb2NhbC5ub3JtYWxpemUoKS5tdWwoICggZGlzcGxhY2VtZW50TWFwLngubXVsKCBkaXNwbGFjZW1lbnRTY2FsZSApLmFkZCggZGlzcGxhY2VtZW50QmlhcyApICkgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaXNCYXRjaGVkTWVzaCApIHtcblxuXHRcdFx0YmF0Y2goIG9iamVjdCApLmFwcGVuZCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAoIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggJiYgb2JqZWN0Lmluc3RhbmNlTWF0cml4ICYmIG9iamVjdC5pbnN0YW5jZU1hdHJpeC5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9PT0gdHJ1ZSApICkge1xuXG5cdFx0XHRpbnN0YW5jZWRNZXNoKCBvYmplY3QgKS5hcHBlbmQoKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5wb3NpdGlvbk5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdHBvc2l0aW9uTG9jYWwuYXNzaWduKCB0aGlzLnBvc2l0aW9uTm9kZSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXR1cEhhcmR3YXJlQ2xpcHBpbmcoIGJ1aWxkZXIgKTtcblxuXHRcdGNvbnN0IG12cCA9IG1vZGVsVmlld1Byb2plY3Rpb24oKTtcblxuXHRcdGJ1aWxkZXIuY29udGV4dC52ZXJ0ZXggPSBidWlsZGVyLnJlbW92ZVN0YWNrKCk7XG5cdFx0YnVpbGRlci5jb250ZXh0Lm12cCA9IG12cDtcblxuXHRcdHJldHVybiBtdnA7XG5cblx0fVxuXG5cdHNldHVwRGlmZnVzZUNvbG9yKCB7IG9iamVjdCwgZ2VvbWV0cnkgfSApIHtcblxuXHRcdGxldCBjb2xvck5vZGUgPSB0aGlzLmNvbG9yTm9kZSA/IHZlYzQoIHRoaXMuY29sb3JOb2RlICkgOiBtYXRlcmlhbENvbG9yO1xuXG5cdFx0Ly8gVkVSVEVYIENPTE9SU1xuXG5cdFx0aWYgKCB0aGlzLnZlcnRleENvbG9ycyA9PT0gdHJ1ZSAmJiBnZW9tZXRyeS5oYXNBdHRyaWJ1dGUoICdjb2xvcicgKSApIHtcblxuXHRcdFx0Y29sb3JOb2RlID0gdmVjNCggY29sb3JOb2RlLnh5ei5tdWwoIGF0dHJpYnV0ZSggJ2NvbG9yJywgJ3ZlYzMnICkgKSwgY29sb3JOb2RlLmEgKTtcblxuXHRcdH1cblxuXHRcdC8vIEluc3RhbmNlZCBjb2xvcnNcblxuXHRcdGlmICggb2JqZWN0Lmluc3RhbmNlQ29sb3IgKSB7XG5cblx0XHRcdGNvbnN0IGluc3RhbmNlQ29sb3IgPSB2YXJ5aW5nUHJvcGVydHkoICd2ZWMzJywgJ3ZJbnN0YW5jZUNvbG9yJyApO1xuXG5cdFx0XHRjb2xvck5vZGUgPSBpbnN0YW5jZUNvbG9yLm11bCggY29sb3JOb2RlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdC5pc0JhdGNoZWRNZXNoICYmIG9iamVjdC5fY29sb3JzVGV4dHVyZSApIHtcblxuXHRcdFx0Y29uc3QgYmF0Y2hDb2xvciA9IHZhcnlpbmdQcm9wZXJ0eSggJ3ZlYzMnLCAndkJhdGNoQ29sb3InICk7XG5cblx0XHRcdGNvbG9yTm9kZSA9IGJhdGNoQ29sb3IubXVsKCBjb2xvck5vZGUgKTtcblxuXHRcdH1cblxuXG5cdFx0Ly8gQ09MT1JcblxuXHRcdGRpZmZ1c2VDb2xvci5hc3NpZ24oIGNvbG9yTm9kZSApO1xuXG5cdFx0Ly8gT1BBQ0lUWVxuXG5cdFx0Y29uc3Qgb3BhY2l0eU5vZGUgPSB0aGlzLm9wYWNpdHlOb2RlID8gZmxvYXQoIHRoaXMub3BhY2l0eU5vZGUgKSA6IG1hdGVyaWFsT3BhY2l0eTtcblx0XHRkaWZmdXNlQ29sb3IuYS5hc3NpZ24oIGRpZmZ1c2VDb2xvci5hLm11bCggb3BhY2l0eU5vZGUgKSApO1xuXG5cdFx0Ly8gQUxQSEEgVEVTVFxuXG5cdFx0aWYgKCB0aGlzLmFscGhhVGVzdE5vZGUgIT09IG51bGwgfHwgdGhpcy5hbHBoYVRlc3QgPiAwICkge1xuXG5cdFx0XHRjb25zdCBhbHBoYVRlc3ROb2RlID0gdGhpcy5hbHBoYVRlc3ROb2RlICE9PSBudWxsID8gZmxvYXQoIHRoaXMuYWxwaGFUZXN0Tm9kZSApIDogbWF0ZXJpYWxBbHBoYVRlc3Q7XG5cblx0XHRcdGRpZmZ1c2VDb2xvci5hLmxlc3NUaGFuRXF1YWwoIGFscGhhVGVzdE5vZGUgKS5kaXNjYXJkKCk7XG5cblx0XHR9XG5cblx0XHQvLyBBTFBIQSBIQVNIXG5cblx0XHRpZiAoIHRoaXMuYWxwaGFIYXNoID09PSB0cnVlICkge1xuXG5cdFx0XHRkaWZmdXNlQ29sb3IuYS5sZXNzVGhhbiggZ2V0QWxwaGFIYXNoVGhyZXNob2xkKCBwb3NpdGlvbkxvY2FsICkgKS5kaXNjYXJkKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMudHJhbnNwYXJlbnQgPT09IGZhbHNlICYmIHRoaXMuYmxlbmRpbmcgPT09IE5vcm1hbEJsZW5kaW5nICYmIHRoaXMuYWxwaGFUb0NvdmVyYWdlID09PSBmYWxzZSApIHtcblxuXHRcdFx0ZGlmZnVzZUNvbG9yLmEuYXNzaWduKCAxLjAgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2V0dXBWYXJpYW50cyggLypidWlsZGVyKi8gKSB7XG5cblx0XHQvLyBJbnRlcmZhY2UgZnVuY3Rpb24uXG5cblx0fVxuXG5cdHNldHVwT3V0Z29pbmdMaWdodCgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMubGlnaHRzID09PSB0cnVlICkgPyB2ZWMzKCAwICkgOiBkaWZmdXNlQ29sb3IucmdiO1xuXG5cdH1cblxuXHRzZXR1cE5vcm1hbCgpIHtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbE5vZGUgPyB2ZWMzKCB0aGlzLm5vcm1hbE5vZGUgKSA6IG1hdGVyaWFsTm9ybWFsO1xuXG5cdH1cblxuXHRzZXR1cEVudmlyb25tZW50KCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdGxldCBub2RlID0gbnVsbDtcblxuXHRcdGlmICggdGhpcy5lbnZOb2RlICkge1xuXG5cdFx0XHRub2RlID0gdGhpcy5lbnZOb2RlO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5lbnZNYXAgKSB7XG5cblx0XHRcdG5vZGUgPSB0aGlzLmVudk1hcC5pc0N1YmVUZXh0dXJlID8gbWF0ZXJpYWxSZWZlcmVuY2UoICdlbnZNYXAnLCAnY3ViZVRleHR1cmUnICkgOiBtYXRlcmlhbFJlZmVyZW5jZSggJ2Vudk1hcCcsICd0ZXh0dXJlJyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vZGU7XG5cblx0fVxuXG5cdHNldHVwTGlnaHRNYXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRsZXQgbm9kZSA9IG51bGw7XG5cblx0XHRpZiAoIGJ1aWxkZXIubWF0ZXJpYWwubGlnaHRNYXAgKSB7XG5cblx0XHRcdG5vZGUgPSBuZXcgSXJyYWRpYW5jZU5vZGUoIG1hdGVyaWFsTGlnaHRNYXAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlO1xuXG5cdH1cblxuXHRzZXR1cExpZ2h0cyggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IG1hdGVyaWFsTGlnaHRzTm9kZSA9IFtdO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGVudk5vZGUgPSB0aGlzLnNldHVwRW52aXJvbm1lbnQoIGJ1aWxkZXIgKTtcblxuXHRcdGlmICggZW52Tm9kZSAmJiBlbnZOb2RlLmlzTGlnaHRpbmdOb2RlICkge1xuXG5cdFx0XHRtYXRlcmlhbExpZ2h0c05vZGUucHVzaCggZW52Tm9kZSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbGlnaHRNYXBOb2RlID0gdGhpcy5zZXR1cExpZ2h0TWFwKCBidWlsZGVyICk7XG5cblx0XHRpZiAoIGxpZ2h0TWFwTm9kZSAmJiBsaWdodE1hcE5vZGUuaXNMaWdodGluZ05vZGUgKSB7XG5cblx0XHRcdG1hdGVyaWFsTGlnaHRzTm9kZS5wdXNoKCBsaWdodE1hcE5vZGUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hb05vZGUgIT09IG51bGwgfHwgYnVpbGRlci5tYXRlcmlhbC5hb01hcCApIHtcblxuXHRcdFx0Y29uc3QgYW9Ob2RlID0gdGhpcy5hb05vZGUgIT09IG51bGwgPyB0aGlzLmFvTm9kZSA6IG1hdGVyaWFsQU9NYXA7XG5cblx0XHRcdG1hdGVyaWFsTGlnaHRzTm9kZS5wdXNoKCBuZXcgQU9Ob2RlKCBhb05vZGUgKSApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGxpZ2h0c04gPSB0aGlzLmxpZ2h0c05vZGUgfHwgYnVpbGRlci5saWdodHNOb2RlO1xuXG5cdFx0aWYgKCBtYXRlcmlhbExpZ2h0c05vZGUubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0bGlnaHRzTiA9IGJ1aWxkZXIucmVuZGVyZXIubGlnaHRpbmcuY3JlYXRlTm9kZSggWyAuLi5saWdodHNOLmdldExpZ2h0cygpLCAuLi5tYXRlcmlhbExpZ2h0c05vZGUgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxpZ2h0c047XG5cblx0fVxuXG5cdHNldHVwTGlnaHRpbmdNb2RlbCggLypidWlsZGVyKi8gKSB7XG5cblx0XHQvLyBJbnRlcmZhY2UgZnVuY3Rpb24uXG5cblx0fVxuXG5cdHNldHVwTGlnaHRpbmcoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCB7IG1hdGVyaWFsIH0gPSBidWlsZGVyO1xuXHRcdGNvbnN0IHsgYmFja2Ryb3BOb2RlLCBiYWNrZHJvcEFscGhhTm9kZSwgZW1pc3NpdmVOb2RlIH0gPSB0aGlzO1xuXG5cdFx0Ly8gT1VUR09JTkcgTElHSFRcblxuXHRcdGNvbnN0IGxpZ2h0cyA9IHRoaXMubGlnaHRzID09PSB0cnVlIHx8IHRoaXMubGlnaHRzTm9kZSAhPT0gbnVsbDtcblxuXHRcdGNvbnN0IGxpZ2h0c05vZGUgPSBsaWdodHMgPyB0aGlzLnNldHVwTGlnaHRzKCBidWlsZGVyICkgOiBudWxsO1xuXG5cdFx0bGV0IG91dGdvaW5nTGlnaHROb2RlID0gdGhpcy5zZXR1cE91dGdvaW5nTGlnaHQoIGJ1aWxkZXIgKTtcblxuXHRcdGlmICggbGlnaHRzTm9kZSAmJiBsaWdodHNOb2RlLmdldFNjb3BlKCkuaGFzTGlnaHRzICkge1xuXG5cdFx0XHRjb25zdCBsaWdodGluZ01vZGVsID0gdGhpcy5zZXR1cExpZ2h0aW5nTW9kZWwoIGJ1aWxkZXIgKTtcblxuXHRcdFx0b3V0Z29pbmdMaWdodE5vZGUgPSBsaWdodGluZ0NvbnRleHQoIGxpZ2h0c05vZGUsIGxpZ2h0aW5nTW9kZWwsIGJhY2tkcm9wTm9kZSwgYmFja2Ryb3BBbHBoYU5vZGUgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGJhY2tkcm9wTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0b3V0Z29pbmdMaWdodE5vZGUgPSB2ZWMzKCBiYWNrZHJvcEFscGhhTm9kZSAhPT0gbnVsbCA/IG1peCggb3V0Z29pbmdMaWdodE5vZGUsIGJhY2tkcm9wTm9kZSwgYmFja2Ryb3BBbHBoYU5vZGUgKSA6IGJhY2tkcm9wTm9kZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gRU1JU1NJVkVcblxuXHRcdGlmICggKCBlbWlzc2l2ZU5vZGUgJiYgZW1pc3NpdmVOb2RlLmlzTm9kZSA9PT0gdHJ1ZSApIHx8ICggbWF0ZXJpYWwuZW1pc3NpdmUgJiYgbWF0ZXJpYWwuZW1pc3NpdmUuaXNDb2xvciA9PT0gdHJ1ZSApICkge1xuXG5cdFx0XHRlbWlzc2l2ZS5hc3NpZ24oIHZlYzMoIGVtaXNzaXZlTm9kZSA/IGVtaXNzaXZlTm9kZSA6IG1hdGVyaWFsRW1pc3NpdmUgKSApO1xuXG5cdFx0XHRvdXRnb2luZ0xpZ2h0Tm9kZSA9IG91dGdvaW5nTGlnaHROb2RlLmFkZCggZW1pc3NpdmUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvdXRnb2luZ0xpZ2h0Tm9kZTtcblxuXHR9XG5cblx0c2V0dXBPdXRwdXQoIGJ1aWxkZXIsIG91dHB1dE5vZGUgKSB7XG5cblx0XHQvLyBGT0dcblxuXHRcdGlmICggdGhpcy5mb2cgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IGZvZ05vZGUgPSBidWlsZGVyLmZvZ05vZGU7XG5cblx0XHRcdGlmICggZm9nTm9kZSApIG91dHB1dE5vZGUgPSB2ZWM0KCBmb2dOb2RlLm1peCggb3V0cHV0Tm9kZS5yZ2IsIGZvZ05vZGUuY29sb3JOb2RlICksIG91dHB1dE5vZGUuYSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dE5vZGU7XG5cblx0fVxuXG5cdHNldERlZmF1bHRWYWx1ZXMoIG1hdGVyaWFsICkge1xuXG5cdFx0Ly8gVGhpcyBhcHByb2FjaCBpcyB0byByZXVzZSB0aGUgbmF0aXZlIHJlZnJlc2hVbmlmb3Jtcypcblx0XHQvLyBhbmQgdHVybiBhdmFpbGFibGUgdGhlIHVzZSBvZiBmZWF0dXJlcyBsaWtlIHRyYW5zbWlzc2lvbiBhbmQgZW52aXJvbm1lbnQgaW4gY29yZVxuXG5cdFx0Zm9yICggY29uc3QgcHJvcGVydHkgaW4gbWF0ZXJpYWwgKSB7XG5cblx0XHRcdGNvbnN0IHZhbHVlID0gbWF0ZXJpYWxbIHByb3BlcnR5IF07XG5cblx0XHRcdGlmICggdGhpc1sgcHJvcGVydHkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXNbIHByb3BlcnR5IF0gPSB2YWx1ZTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICYmIHZhbHVlLmNsb25lICkgdGhpc1sgcHJvcGVydHkgXSA9IHZhbHVlLmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoIG1hdGVyaWFsLmNvbnN0cnVjdG9yLnByb3RvdHlwZSApO1xuXG5cdFx0Zm9yICggY29uc3Qga2V5IGluIGRlc2NyaXB0b3JzICkge1xuXG5cdFx0XHRpZiAoIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLCBrZXkgKSA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHQgICAgIGRlc2NyaXB0b3JzWyBrZXkgXS5nZXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLCBrZXksIGRlc2NyaXB0b3JzWyBrZXkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHRvSlNPTiggbWV0YSApIHtcblxuXHRcdGNvbnN0IGlzUm9vdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xuXG5cdFx0aWYgKCBpc1Jvb3QgKSB7XG5cblx0XHRcdG1ldGEgPSB7XG5cdFx0XHRcdHRleHR1cmVzOiB7fSxcblx0XHRcdFx0aW1hZ2VzOiB7fSxcblx0XHRcdFx0bm9kZXM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZGF0YSA9IE1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXHRcdGNvbnN0IG5vZGVDaGlsZHJlbiA9IGdldE5vZGVDaGlsZHJlbiggdGhpcyApO1xuXG5cdFx0ZGF0YS5pbnB1dE5vZGVzID0ge307XG5cblx0XHRmb3IgKCBjb25zdCB7IHByb3BlcnR5LCBjaGlsZE5vZGUgfSBvZiBub2RlQ2hpbGRyZW4gKSB7XG5cblx0XHRcdGRhdGEuaW5wdXROb2Rlc1sgcHJvcGVydHkgXSA9IGNoaWxkTm9kZS50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogQ29waWVkIGZyb20gT2JqZWN0M0QudG9KU09OXG5cblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcblxuXHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBjYWNoZSApIHtcblxuXHRcdFx0XHRjb25zdCBkYXRhID0gY2FjaGVbIGtleSBdO1xuXHRcdFx0XHRkZWxldGUgZGF0YS5tZXRhZGF0YTtcblx0XHRcdFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpc1Jvb3QgKSB7XG5cblx0XHRcdGNvbnN0IHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuXHRcdFx0Y29uc3QgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblx0XHRcdGNvbnN0IG5vZGVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5ub2RlcyApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBkYXRhLnRleHR1cmVzID0gdGV4dHVyZXM7XG5cdFx0XHRpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgZGF0YS5pbWFnZXMgPSBpbWFnZXM7XG5cdFx0XHRpZiAoIG5vZGVzLmxlbmd0aCA+IDAgKSBkYXRhLm5vZGVzID0gbm9kZXM7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0dGhpcy5saWdodHNOb2RlID0gc291cmNlLmxpZ2h0c05vZGU7XG5cdFx0dGhpcy5lbnZOb2RlID0gc291cmNlLmVudk5vZGU7XG5cblx0XHR0aGlzLmNvbG9yTm9kZSA9IHNvdXJjZS5jb2xvck5vZGU7XG5cdFx0dGhpcy5ub3JtYWxOb2RlID0gc291cmNlLm5vcm1hbE5vZGU7XG5cdFx0dGhpcy5vcGFjaXR5Tm9kZSA9IHNvdXJjZS5vcGFjaXR5Tm9kZTtcblx0XHR0aGlzLmJhY2tkcm9wTm9kZSA9IHNvdXJjZS5iYWNrZHJvcE5vZGU7XG5cdFx0dGhpcy5iYWNrZHJvcEFscGhhTm9kZSA9IHNvdXJjZS5iYWNrZHJvcEFscGhhTm9kZTtcblx0XHR0aGlzLmFscGhhVGVzdE5vZGUgPSBzb3VyY2UuYWxwaGFUZXN0Tm9kZTtcblxuXHRcdHRoaXMucG9zaXRpb25Ob2RlID0gc291cmNlLnBvc2l0aW9uTm9kZTtcblx0XHR0aGlzLmdlb21ldHJ5Tm9kZSA9IHNvdXJjZS5nZW9tZXRyeU5vZGU7XG5cblx0XHR0aGlzLmRlcHRoTm9kZSA9IHNvdXJjZS5kZXB0aE5vZGU7XG5cdFx0dGhpcy5zaGFkb3dQb3NpdGlvbk5vZGUgPSBzb3VyY2Uuc2hhZG93UG9zaXRpb25Ob2RlO1xuXHRcdHRoaXMucmVjZWl2ZWRTaGFkb3dOb2RlID0gc291cmNlLnJlY2VpdmVkU2hhZG93Tm9kZTtcblx0XHR0aGlzLmNhc3RTaGFkb3dOb2RlID0gc291cmNlLmNhc3RTaGFkb3dOb2RlO1xuXG5cdFx0dGhpcy5vdXRwdXROb2RlID0gc291cmNlLm91dHB1dE5vZGU7XG5cdFx0dGhpcy5tcnROb2RlID0gc291cmNlLm1ydE5vZGU7XG5cblx0XHR0aGlzLmZyYWdtZW50Tm9kZSA9IHNvdXJjZS5mcmFnbWVudE5vZGU7XG5cdFx0dGhpcy52ZXJ0ZXhOb2RlID0gc291cmNlLnZlcnRleE5vZGU7XG5cblx0XHRyZXR1cm4gc3VwZXIuY29weSggc291cmNlICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVNYXRlcmlhbDtcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi9Ob2RlTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgYXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vbm9kZXMvY29yZS9BdHRyaWJ1dGVOb2RlLmpzJztcbmltcG9ydCB7IGNhbWVyYVByb2plY3Rpb25NYXRyaXggfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvQ2FtZXJhLmpzJztcbmltcG9ydCB7IG1hdGVyaWFsQ29sb3IsIG1hdGVyaWFsT3BhY2l0eSwgbWF0ZXJpYWxQb2ludFdpZHRoIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL01hdGVyaWFsTm9kZS5qcyc7IC8vIG9yIHNob3VsZCB0aGlzIGJlIGEgcHJvcGVydHksIGluc3RlYWQ/XG5pbXBvcnQgeyBtb2RlbFZpZXdNYXRyaXggfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTW9kZWxOb2RlLmpzJztcbmltcG9ydCB7IHBvc2l0aW9uR2VvbWV0cnkgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgc21vb3Roc3RlcCwgbGVuZ3RoU3EgfSBmcm9tICcuLi8uLi9ub2Rlcy9tYXRoL01hdGhOb2RlLmpzJztcbmltcG9ydCB7IEZuLCB2ZWM0LCBmbG9hdCB9IGZyb20gJy4uLy4uL25vZGVzL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IHV2IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL1VWLmpzJztcbmltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSAnLi4vLi4vbm9kZXMvZGlzcGxheS9TY3JlZW5Ob2RlLmpzJztcblxuaW1wb3J0IHsgUG9pbnRzTWF0ZXJpYWwgfSBmcm9tICcuLi9Qb2ludHNNYXRlcmlhbC5qcyc7XG5cbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgUG9pbnRzTWF0ZXJpYWwoKTtcblxuY2xhc3MgSW5zdGFuY2VkUG9pbnRzTm9kZU1hdGVyaWFsIGV4dGVuZHMgTm9kZU1hdGVyaWFsIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0luc3RhbmNlZFBvaW50c05vZGVNYXRlcmlhbCc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbXMgPSB7fSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG5cdFx0dGhpcy51c2VBbHBoYVRvQ292ZXJhZ2UgPSB0cnVlO1xuXG5cdFx0dGhpcy51c2VDb2xvciA9IHBhcmFtcy52ZXJ0ZXhDb2xvcnM7XG5cblx0XHR0aGlzLnBvaW50V2lkdGggPSAxO1xuXG5cdFx0dGhpcy5wb2ludENvbG9yTm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLnBvaW50V2lkdGhOb2RlID0gbnVsbDtcblxuXHRcdHRoaXMuc2V0RGVmYXVsdFZhbHVlcyggX2RlZmF1bHRWYWx1ZXMgKTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbXMgKTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHR0aGlzLnNldHVwU2hhZGVycyggYnVpbGRlciApO1xuXG5cdFx0c3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0c2V0dXBTaGFkZXJzKCB7IHJlbmRlcmVyIH0gKSB7XG5cblx0XHRjb25zdCB1c2VBbHBoYVRvQ292ZXJhZ2UgPSB0aGlzLmFscGhhVG9Db3ZlcmFnZTtcblx0XHRjb25zdCB1c2VDb2xvciA9IHRoaXMudXNlQ29sb3I7XG5cblx0XHR0aGlzLnZlcnRleE5vZGUgPSBGbiggKCkgPT4ge1xuXG5cdFx0XHRjb25zdCBpbnN0YW5jZVBvc2l0aW9uID0gYXR0cmlidXRlKCAnaW5zdGFuY2VQb3NpdGlvbicgKS54eXo7XG5cblx0XHRcdC8vIGNhbWVyYSBzcGFjZVxuXHRcdFx0Y29uc3QgbXZQb3MgPSB2ZWM0KCBtb2RlbFZpZXdNYXRyaXgubXVsKCB2ZWM0KCBpbnN0YW5jZVBvc2l0aW9uLCAxLjAgKSApICk7XG5cblx0XHRcdGNvbnN0IGFzcGVjdCA9IHZpZXdwb3J0LnouZGl2KCB2aWV3cG9ydC53ICk7XG5cblx0XHRcdC8vIGNsaXAgc3BhY2Vcblx0XHRcdGNvbnN0IGNsaXBQb3MgPSBjYW1lcmFQcm9qZWN0aW9uTWF0cml4Lm11bCggbXZQb3MgKTtcblxuXHRcdFx0Ly8gb2Zmc2V0IGluIG5kYyBzcGFjZVxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gcG9zaXRpb25HZW9tZXRyeS54eS50b1ZhcigpO1xuXG5cdFx0XHRvZmZzZXQubXVsQXNzaWduKCB0aGlzLnBvaW50V2lkdGhOb2RlID8gdGhpcy5wb2ludFdpZHRoTm9kZSA6IG1hdGVyaWFsUG9pbnRXaWR0aCApO1xuXG5cdFx0XHRvZmZzZXQuYXNzaWduKCBvZmZzZXQuZGl2KCB2aWV3cG9ydC56ICkgKTtcblx0XHRcdG9mZnNldC55LmFzc2lnbiggb2Zmc2V0LnkubXVsKCBhc3BlY3QgKSApO1xuXG5cdFx0XHQvLyBiYWNrIHRvIGNsaXAgc3BhY2Vcblx0XHRcdG9mZnNldC5hc3NpZ24oIG9mZnNldC5tdWwoIGNsaXBQb3MudyApICk7XG5cblx0XHRcdC8vY2xpcFBvcy54eSArPSBvZmZzZXQ7XG5cdFx0XHRjbGlwUG9zLmFkZEFzc2lnbiggdmVjNCggb2Zmc2V0LCAwLCAwICkgKTtcblxuXHRcdFx0cmV0dXJuIGNsaXBQb3M7XG5cblx0XHR9ICkoKTtcblxuXHRcdHRoaXMuZnJhZ21lbnROb2RlID0gRm4oICgpID0+IHtcblxuXHRcdFx0Y29uc3QgYWxwaGEgPSBmbG9hdCggMSApLnRvVmFyKCk7XG5cblx0XHRcdGNvbnN0IGxlbjIgPSBsZW5ndGhTcSggdXYoKS5tdWwoIDIgKS5zdWIoIDEgKSApO1xuXG5cdFx0XHRpZiAoIHVzZUFscGhhVG9Db3ZlcmFnZSAmJiByZW5kZXJlci5zYW1wbGVzID4gMSApIHtcblxuXHRcdFx0XHRjb25zdCBkbGVuID0gZmxvYXQoIGxlbjIuZndpZHRoKCkgKS50b1ZhcigpO1xuXG5cdFx0XHRcdGFscGhhLmFzc2lnbiggc21vb3Roc3RlcCggZGxlbi5vbmVNaW51cygpLCBkbGVuLmFkZCggMSApLCBsZW4yICkub25lTWludXMoKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGxlbjIuZ3JlYXRlclRoYW4oIDEuMCApLmRpc2NhcmQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgcG9pbnRDb2xvck5vZGU7XG5cblx0XHRcdGlmICggdGhpcy5wb2ludENvbG9yTm9kZSApIHtcblxuXHRcdFx0XHRwb2ludENvbG9yTm9kZSA9IHRoaXMucG9pbnRDb2xvck5vZGU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCB1c2VDb2xvciApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGluc3RhbmNlQ29sb3IgPSBhdHRyaWJ1dGUoICdpbnN0YW5jZUNvbG9yJyApO1xuXG5cdFx0XHRcdFx0cG9pbnRDb2xvck5vZGUgPSBpbnN0YW5jZUNvbG9yLm11bCggbWF0ZXJpYWxDb2xvciApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwb2ludENvbG9yTm9kZSA9IG1hdGVyaWFsQ29sb3I7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGFscGhhLm11bEFzc2lnbiggbWF0ZXJpYWxPcGFjaXR5ICk7XG5cblx0XHRcdHJldHVybiB2ZWM0KCBwb2ludENvbG9yTm9kZSwgYWxwaGEgKTtcblxuXHRcdH0gKSgpO1xuXG5cdH1cblxuXHRnZXQgYWxwaGFUb0NvdmVyYWdlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudXNlQWxwaGFUb0NvdmVyYWdlO1xuXG5cdH1cblxuXHRzZXQgYWxwaGFUb0NvdmVyYWdlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy51c2VBbHBoYVRvQ292ZXJhZ2UgIT09IHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLnVzZUFscGhhVG9Db3ZlcmFnZSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEluc3RhbmNlZFBvaW50c05vZGVNYXRlcmlhbDtcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi9Ob2RlTWF0ZXJpYWwuanMnO1xuXG5pbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL0xpbmVCYXNpY01hdGVyaWFsLmpzJztcblxuY29uc3QgX2RlZmF1bHRWYWx1ZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpO1xuXG5jbGFzcyBMaW5lQmFzaWNOb2RlTWF0ZXJpYWwgZXh0ZW5kcyBOb2RlTWF0ZXJpYWwge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnTGluZUJhc2ljTm9kZU1hdGVyaWFsJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0xpbmVCYXNpY05vZGVNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zZXREZWZhdWx0VmFsdWVzKCBfZGVmYXVsdFZhbHVlcyApO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGluZUJhc2ljTm9kZU1hdGVyaWFsO1xuIiwiaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuL05vZGVNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBhdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL0F0dHJpYnV0ZU5vZGUuanMnO1xuaW1wb3J0IHsgbWF0ZXJpYWxMaW5lRGFzaE9mZnNldCwgbWF0ZXJpYWxMaW5lRGFzaFNpemUsIG1hdGVyaWFsTGluZUdhcFNpemUsIG1hdGVyaWFsTGluZVNjYWxlIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL01hdGVyaWFsTm9kZS5qcyc7XG5pbXBvcnQgeyBkYXNoU2l6ZSwgZ2FwU2l6ZSB9IGZyb20gJy4uLy4uL25vZGVzL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcbmltcG9ydCB7IHZhcnlpbmcsIGZsb2F0IH0gZnJvbSAnLi4vLi4vbm9kZXMvdHNsL1RTTEJhc2UuanMnO1xuXG5pbXBvcnQgeyBMaW5lRGFzaGVkTWF0ZXJpYWwgfSBmcm9tICcuLi9MaW5lRGFzaGVkTWF0ZXJpYWwuanMnO1xuXG5jb25zdCBfZGVmYXVsdFZhbHVlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IExpbmVEYXNoZWRNYXRlcmlhbCgpO1xuXG5jbGFzcyBMaW5lRGFzaGVkTm9kZU1hdGVyaWFsIGV4dGVuZHMgTm9kZU1hdGVyaWFsIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0xpbmVEYXNoZWROb2RlTWF0ZXJpYWwnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTGluZURhc2hlZE5vZGVNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zZXREZWZhdWx0VmFsdWVzKCBfZGVmYXVsdFZhbHVlcyApO1xuXG5cdFx0dGhpcy5kYXNoT2Zmc2V0ID0gMDtcblxuXHRcdHRoaXMub2Zmc2V0Tm9kZSA9IG51bGw7XG5cdFx0dGhpcy5kYXNoU2NhbGVOb2RlID0gbnVsbDtcblx0XHR0aGlzLmRhc2hTaXplTm9kZSA9IG51bGw7XG5cdFx0dGhpcy5nYXBTaXplTm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRzZXR1cFZhcmlhbnRzKCkge1xuXG5cdFx0Y29uc3Qgb2Zmc2V0Tm9kZSA9IHRoaXMub2Zmc2V0Tm9kZSA/IGZsb2F0KCB0aGlzLm9mZnNldE5vZGVOb2RlICkgOiBtYXRlcmlhbExpbmVEYXNoT2Zmc2V0O1xuXHRcdGNvbnN0IGRhc2hTY2FsZU5vZGUgPSB0aGlzLmRhc2hTY2FsZU5vZGUgPyBmbG9hdCggdGhpcy5kYXNoU2NhbGVOb2RlICkgOiBtYXRlcmlhbExpbmVTY2FsZTtcblx0XHRjb25zdCBkYXNoU2l6ZU5vZGUgPSB0aGlzLmRhc2hTaXplTm9kZSA/IGZsb2F0KCB0aGlzLmRhc2hTaXplTm9kZSApIDogbWF0ZXJpYWxMaW5lRGFzaFNpemU7XG5cdFx0Y29uc3QgZ2FwU2l6ZU5vZGUgPSB0aGlzLmRhc2hTaXplTm9kZSA/IGZsb2F0KCB0aGlzLmRhc2hHYXBOb2RlICkgOiBtYXRlcmlhbExpbmVHYXBTaXplO1xuXG5cdFx0ZGFzaFNpemUuYXNzaWduKCBkYXNoU2l6ZU5vZGUgKTtcblx0XHRnYXBTaXplLmFzc2lnbiggZ2FwU2l6ZU5vZGUgKTtcblxuXHRcdGNvbnN0IHZMaW5lRGlzdGFuY2UgPSB2YXJ5aW5nKCBhdHRyaWJ1dGUoICdsaW5lRGlzdGFuY2UnICkubXVsKCBkYXNoU2NhbGVOb2RlICkgKTtcblx0XHRjb25zdCB2TGluZURpc3RhbmNlT2Zmc2V0ID0gb2Zmc2V0Tm9kZSA/IHZMaW5lRGlzdGFuY2UuYWRkKCBvZmZzZXROb2RlICkgOiB2TGluZURpc3RhbmNlO1xuXG5cdFx0dkxpbmVEaXN0YW5jZU9mZnNldC5tb2QoIGRhc2hTaXplLmFkZCggZ2FwU2l6ZSApICkuZ3JlYXRlclRoYW4oIGRhc2hTaXplICkuZGlzY2FyZCgpO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5lRGFzaGVkTm9kZU1hdGVyaWFsO1xuIiwiaW1wb3J0IFZpZXdwb3J0VGV4dHVyZU5vZGUgZnJvbSAnLi9WaWV3cG9ydFRleHR1cmVOb2RlLmpzJztcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IHNjcmVlblVWIH0gZnJvbSAnLi9TY3JlZW5Ob2RlLmpzJztcblxuaW1wb3J0IHsgRnJhbWVidWZmZXJUZXh0dXJlIH0gZnJvbSAnLi4vLi4vdGV4dHVyZXMvRnJhbWVidWZmZXJUZXh0dXJlLmpzJztcblxubGV0IF9zaGFyZWRGcmFtZWJ1ZmZlciA9IG51bGw7XG5cbmNsYXNzIFZpZXdwb3J0U2hhcmVkVGV4dHVyZU5vZGUgZXh0ZW5kcyBWaWV3cG9ydFRleHR1cmVOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1ZpZXdwb3J0U2hhcmVkVGV4dHVyZU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggdXZOb2RlID0gc2NyZWVuVVYsIGxldmVsTm9kZSA9IG51bGwgKSB7XG5cblx0XHRpZiAoIF9zaGFyZWRGcmFtZWJ1ZmZlciA9PT0gbnVsbCApIHtcblxuXHRcdFx0X3NoYXJlZEZyYW1lYnVmZmVyID0gbmV3IEZyYW1lYnVmZmVyVGV4dHVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0c3VwZXIoIHV2Tm9kZSwgbGV2ZWxOb2RlLCBfc2hhcmVkRnJhbWVidWZmZXIgKTtcblxuXHR9XG5cblx0dXBkYXRlUmVmZXJlbmNlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdwb3J0U2hhcmVkVGV4dHVyZU5vZGU7XG5cbmV4cG9ydCBjb25zdCB2aWV3cG9ydFNoYXJlZFRleHR1cmUgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggVmlld3BvcnRTaGFyZWRUZXh0dXJlTm9kZSApO1xuIiwiaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuL05vZGVNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyB2YXJ5aW5nUHJvcGVydHkgfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XG5pbXBvcnQgeyBhdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL0F0dHJpYnV0ZU5vZGUuanMnO1xuaW1wb3J0IHsgY2FtZXJhUHJvamVjdGlvbk1hdHJpeCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9DYW1lcmEuanMnO1xuaW1wb3J0IHsgbWF0ZXJpYWxDb2xvciwgbWF0ZXJpYWxMaW5lU2NhbGUsIG1hdGVyaWFsTGluZURhc2hTaXplLCBtYXRlcmlhbExpbmVHYXBTaXplLCBtYXRlcmlhbExpbmVEYXNoT2Zmc2V0LCBtYXRlcmlhbExpbmVXaWR0aCwgbWF0ZXJpYWxPcGFjaXR5IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL01hdGVyaWFsTm9kZS5qcyc7XG5pbXBvcnQgeyBtb2RlbFZpZXdNYXRyaXggfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTW9kZWxOb2RlLmpzJztcbmltcG9ydCB7IHBvc2l0aW9uR2VvbWV0cnkgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgbWl4LCBzbW9vdGhzdGVwIH0gZnJvbSAnLi4vLi4vbm9kZXMvbWF0aC9NYXRoTm9kZS5qcyc7XG5pbXBvcnQgeyBGbiwgZmxvYXQsIHZlYzIsIHZlYzMsIHZlYzQsIElmIH0gZnJvbSAnLi4vLi4vbm9kZXMvdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgdXYgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvVVYuanMnO1xuaW1wb3J0IHsgdmlld3BvcnQgfSBmcm9tICcuLi8uLi9ub2Rlcy9kaXNwbGF5L1NjcmVlbk5vZGUuanMnO1xuaW1wb3J0IHsgZGFzaFNpemUsIGdhcFNpemUgfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XG5pbXBvcnQgeyB2aWV3cG9ydFNoYXJlZFRleHR1cmUgfSBmcm9tICcuLi8uLi9ub2Rlcy9kaXNwbGF5L1ZpZXdwb3J0U2hhcmVkVGV4dHVyZU5vZGUuanMnO1xuXG5pbXBvcnQgeyBMaW5lRGFzaGVkTWF0ZXJpYWwgfSBmcm9tICcuLi9MaW5lRGFzaGVkTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgTm9CbGVuZGluZyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgTGluZURhc2hlZE1hdGVyaWFsKCk7XG5cbmNsYXNzIExpbmUyTm9kZU1hdGVyaWFsIGV4dGVuZHMgTm9kZU1hdGVyaWFsIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0xpbmUyTm9kZU1hdGVyaWFsJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtcyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7XG5cblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XG5cblx0XHR0aGlzLnVzZUFscGhhVG9Db3ZlcmFnZSA9IHRydWU7XG5cdFx0dGhpcy51c2VDb2xvciA9IHBhcmFtcy52ZXJ0ZXhDb2xvcnM7XG5cdFx0dGhpcy51c2VEYXNoID0gcGFyYW1zLmRhc2hlZDtcblx0XHR0aGlzLnVzZVdvcmxkVW5pdHMgPSBmYWxzZTtcblxuXHRcdHRoaXMuZGFzaE9mZnNldCA9IDA7XG5cdFx0dGhpcy5saW5lV2lkdGggPSAxO1xuXG5cdFx0dGhpcy5saW5lQ29sb3JOb2RlID0gbnVsbDtcblxuXHRcdHRoaXMub2Zmc2V0Tm9kZSA9IG51bGw7XG5cdFx0dGhpcy5kYXNoU2NhbGVOb2RlID0gbnVsbDtcblx0XHR0aGlzLmRhc2hTaXplTm9kZSA9IG51bGw7XG5cdFx0dGhpcy5nYXBTaXplTm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLmJsZW5kaW5nID0gTm9CbGVuZGluZztcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbXMgKTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHR0aGlzLnNldHVwU2hhZGVycyggYnVpbGRlciApO1xuXG5cdFx0c3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0c2V0dXBTaGFkZXJzKCB7IHJlbmRlcmVyIH0gKSB7XG5cblx0XHRjb25zdCB1c2VBbHBoYVRvQ292ZXJhZ2UgPSB0aGlzLmFscGhhVG9Db3ZlcmFnZTtcblx0XHRjb25zdCB1c2VDb2xvciA9IHRoaXMudXNlQ29sb3I7XG5cdFx0Y29uc3QgdXNlRGFzaCA9IHRoaXMuZGFzaGVkO1xuXHRcdGNvbnN0IHVzZVdvcmxkVW5pdHMgPSB0aGlzLndvcmxkVW5pdHM7XG5cblx0XHRjb25zdCB0cmltU2VnbWVudCA9IEZuKCAoIHsgc3RhcnQsIGVuZCB9ICkgPT4ge1xuXG5cdFx0XHRjb25zdCBhID0gY2FtZXJhUHJvamVjdGlvbk1hdHJpeC5lbGVtZW50KCAyICkuZWxlbWVudCggMiApOyAvLyAzbmQgZW50cnkgaW4gM3RoIGNvbHVtblxuXHRcdFx0Y29uc3QgYiA9IGNhbWVyYVByb2plY3Rpb25NYXRyaXguZWxlbWVudCggMyApLmVsZW1lbnQoIDIgKTsgLy8gM25kIGVudHJ5IGluIDR0aCBjb2x1bW5cblx0XHRcdGNvbnN0IG5lYXJFc3RpbWF0ZSA9IGIubXVsKCAtIDAuNSApLmRpdiggYSApO1xuXG5cdFx0XHRjb25zdCBhbHBoYSA9IG5lYXJFc3RpbWF0ZS5zdWIoIHN0YXJ0LnogKS5kaXYoIGVuZC56LnN1Yiggc3RhcnQueiApICk7XG5cblx0XHRcdHJldHVybiB2ZWM0KCBtaXgoIHN0YXJ0Lnh5eiwgZW5kLnh5eiwgYWxwaGEgKSwgZW5kLncgKTtcblxuXHRcdH0gKS5zZXRMYXlvdXQoIHtcblx0XHRcdG5hbWU6ICd0cmltU2VnbWVudCcsXG5cdFx0XHR0eXBlOiAndmVjNCcsXG5cdFx0XHRpbnB1dHM6IFtcblx0XHRcdFx0eyBuYW1lOiAnc3RhcnQnLCB0eXBlOiAndmVjNCcgfSxcblx0XHRcdFx0eyBuYW1lOiAnZW5kJywgdHlwZTogJ3ZlYzQnIH1cblx0XHRcdF1cblx0XHR9ICk7XG5cblx0XHR0aGlzLnZlcnRleE5vZGUgPSBGbiggKCkgPT4ge1xuXG5cdFx0XHRjb25zdCBpbnN0YW5jZVN0YXJ0ID0gYXR0cmlidXRlKCAnaW5zdGFuY2VTdGFydCcgKTtcblx0XHRcdGNvbnN0IGluc3RhbmNlRW5kID0gYXR0cmlidXRlKCAnaW5zdGFuY2VFbmQnICk7XG5cblx0XHRcdC8vIGNhbWVyYSBzcGFjZVxuXG5cdFx0XHRjb25zdCBzdGFydCA9IHZlYzQoIG1vZGVsVmlld01hdHJpeC5tdWwoIHZlYzQoIGluc3RhbmNlU3RhcnQsIDEuMCApICkgKS50b1ZhciggJ3N0YXJ0JyApO1xuXHRcdFx0Y29uc3QgZW5kID0gdmVjNCggbW9kZWxWaWV3TWF0cml4Lm11bCggdmVjNCggaW5zdGFuY2VFbmQsIDEuMCApICkgKS50b1ZhciggJ2VuZCcgKTtcblxuXHRcdFx0aWYgKCB1c2VEYXNoICkge1xuXG5cdFx0XHRcdGNvbnN0IGRhc2hTY2FsZU5vZGUgPSB0aGlzLmRhc2hTY2FsZU5vZGUgPyBmbG9hdCggdGhpcy5kYXNoU2NhbGVOb2RlICkgOiBtYXRlcmlhbExpbmVTY2FsZTtcblx0XHRcdFx0Y29uc3Qgb2Zmc2V0Tm9kZSA9IHRoaXMub2Zmc2V0Tm9kZSA/IGZsb2F0KCB0aGlzLm9mZnNldE5vZGVOb2RlICkgOiBtYXRlcmlhbExpbmVEYXNoT2Zmc2V0O1xuXG5cdFx0XHRcdGNvbnN0IGluc3RhbmNlRGlzdGFuY2VTdGFydCA9IGF0dHJpYnV0ZSggJ2luc3RhbmNlRGlzdGFuY2VTdGFydCcgKTtcblx0XHRcdFx0Y29uc3QgaW5zdGFuY2VEaXN0YW5jZUVuZCA9IGF0dHJpYnV0ZSggJ2luc3RhbmNlRGlzdGFuY2VFbmQnICk7XG5cblx0XHRcdFx0bGV0IGxpbmVEaXN0YW5jZSA9IHBvc2l0aW9uR2VvbWV0cnkueS5sZXNzVGhhbiggMC41ICkuc2VsZWN0KCBkYXNoU2NhbGVOb2RlLm11bCggaW5zdGFuY2VEaXN0YW5jZVN0YXJ0ICksIGRhc2hTY2FsZU5vZGUubXVsKCBpbnN0YW5jZURpc3RhbmNlRW5kICkgKTtcblx0XHRcdFx0bGluZURpc3RhbmNlID0gbGluZURpc3RhbmNlLmFkZCggb2Zmc2V0Tm9kZSApO1xuXG5cdFx0XHRcdHZhcnlpbmdQcm9wZXJ0eSggJ2Zsb2F0JywgJ2xpbmVEaXN0YW5jZScgKS5hc3NpZ24oIGxpbmVEaXN0YW5jZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXNlV29ybGRVbml0cyApIHtcblxuXHRcdFx0XHR2YXJ5aW5nUHJvcGVydHkoICd2ZWMzJywgJ3dvcmxkU3RhcnQnICkuYXNzaWduKCBzdGFydC54eXogKTtcblx0XHRcdFx0dmFyeWluZ1Byb3BlcnR5KCAndmVjMycsICd3b3JsZEVuZCcgKS5hc3NpZ24oIGVuZC54eXogKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBhc3BlY3QgPSB2aWV3cG9ydC56LmRpdiggdmlld3BvcnQudyApO1xuXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIHBlcnNwZWN0aXZlIHByb2plY3Rpb24sIGFuZCBzZWdtZW50cyB0aGF0IHRlcm1pbmF0ZSBlaXRoZXIgaW4sIG9yIGJlaGluZCwgdGhlIGNhbWVyYSBwbGFuZVxuXHRcdFx0Ly8gY2xlYXJseSB0aGUgZ3B1IGZpcm13YXJlIGhhcyBhIHdheSBvZiBhZGRyZXNzaW5nIHRoaXMgaXNzdWUgd2hlbiBwcm9qZWN0aW5nIGludG8gbmRjIHNwYWNlXG5cdFx0XHQvLyBidXQgd2UgbmVlZCB0byBwZXJmb3JtIG5kYy1zcGFjZSBjYWxjdWxhdGlvbnMgaW4gdGhlIHNoYWRlciwgc28gd2UgbXVzdCBhZGRyZXNzIHRoaXMgaXNzdWUgZGlyZWN0bHlcblx0XHRcdC8vIHBlcmhhcHMgdGhlcmUgaXMgYSBtb3JlIGVsZWdhbnQgc29sdXRpb24gLS0gV2VzdExhbmdsZXlcblxuXHRcdFx0Y29uc3QgcGVyc3BlY3RpdmUgPSBjYW1lcmFQcm9qZWN0aW9uTWF0cml4LmVsZW1lbnQoIDIgKS5lbGVtZW50KCAzICkuZXF1YWwoIC0gMS4wICk7IC8vIDR0aCBlbnRyeSBpbiB0aGUgM3JkIGNvbHVtblxuXG5cdFx0XHRJZiggcGVyc3BlY3RpdmUsICgpID0+IHtcblxuXHRcdFx0XHRJZiggc3RhcnQuei5sZXNzVGhhbiggMC4wICkuYW5kKCBlbmQuei5ncmVhdGVyVGhhbiggMC4wICkgKSwgKCkgPT4ge1xuXG5cdFx0XHRcdFx0ZW5kLmFzc2lnbiggdHJpbVNlZ21lbnQoIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9ICkgKTtcblxuXHRcdFx0XHR9ICkuRWxzZUlmKCBlbmQuei5sZXNzVGhhbiggMC4wICkuYW5kKCBzdGFydC56LmdyZWF0ZXJUaGFuRXF1YWwoIDAuMCApICksICgpID0+IHtcblxuXHRcdFx0XHRcdHN0YXJ0LmFzc2lnbiggdHJpbVNlZ21lbnQoIHsgc3RhcnQ6IGVuZCwgZW5kOiBzdGFydCB9ICkgKTtcblxuXHRcdFx0IFx0fSApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIGNsaXAgc3BhY2Vcblx0XHRcdGNvbnN0IGNsaXBTdGFydCA9IGNhbWVyYVByb2plY3Rpb25NYXRyaXgubXVsKCBzdGFydCApO1xuXHRcdFx0Y29uc3QgY2xpcEVuZCA9IGNhbWVyYVByb2plY3Rpb25NYXRyaXgubXVsKCBlbmQgKTtcblxuXHRcdFx0Ly8gbmRjIHNwYWNlXG5cdFx0XHRjb25zdCBuZGNTdGFydCA9IGNsaXBTdGFydC54eXouZGl2KCBjbGlwU3RhcnQudyApO1xuXHRcdFx0Y29uc3QgbmRjRW5kID0gY2xpcEVuZC54eXouZGl2KCBjbGlwRW5kLncgKTtcblxuXHRcdFx0Ly8gZGlyZWN0aW9uXG5cdFx0XHRjb25zdCBkaXIgPSBuZGNFbmQueHkuc3ViKCBuZGNTdGFydC54eSApLnRvVmFyKCk7XG5cblx0XHRcdC8vIGFjY291bnQgZm9yIGNsaXAtc3BhY2UgYXNwZWN0IHJhdGlvXG5cdFx0XHRkaXIueC5hc3NpZ24oIGRpci54Lm11bCggYXNwZWN0ICkgKTtcblx0XHRcdGRpci5hc3NpZ24oIGRpci5ub3JtYWxpemUoKSApO1xuXG5cdFx0XHRjb25zdCBjbGlwID0gdmVjNCgpLnRvVmFyKCk7XG5cblx0XHRcdGlmICggdXNlV29ybGRVbml0cyApIHtcblxuXHRcdFx0XHQvLyBnZXQgdGhlIG9mZnNldCBkaXJlY3Rpb24gYXMgcGVycGVuZGljdWxhciB0byB0aGUgdmlldyB2ZWN0b3JcblxuXHRcdFx0XHRjb25zdCB3b3JsZERpciA9IGVuZC54eXouc3ViKCBzdGFydC54eXogKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0Y29uc3QgdG1wRndkID0gbWl4KCBzdGFydC54eXosIGVuZC54eXosIDAuNSApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRjb25zdCB3b3JsZFVwID0gd29ybGREaXIuY3Jvc3MoIHRtcEZ3ZCApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRjb25zdCB3b3JsZEZ3ZCA9IHdvcmxkRGlyLmNyb3NzKCB3b3JsZFVwICk7XG5cblx0XHRcdFx0Y29uc3Qgd29ybGRQb3MgPSB2YXJ5aW5nUHJvcGVydHkoICd2ZWM0JywgJ3dvcmxkUG9zJyApO1xuXG5cdFx0XHRcdHdvcmxkUG9zLmFzc2lnbiggcG9zaXRpb25HZW9tZXRyeS55Lmxlc3NUaGFuKCAwLjUgKS5zZWxlY3QoIHN0YXJ0LCBlbmQgKSApO1xuXG5cdFx0XHRcdC8vIGhlaWdodCBvZmZzZXRcblx0XHRcdFx0Y29uc3QgaHcgPSBtYXRlcmlhbExpbmVXaWR0aC5tdWwoIDAuNSApO1xuXHRcdFx0XHR3b3JsZFBvcy5hZGRBc3NpZ24oIHZlYzQoIHBvc2l0aW9uR2VvbWV0cnkueC5sZXNzVGhhbiggMC4wICkuc2VsZWN0KCB3b3JsZFVwLm11bCggaHcgKSwgd29ybGRVcC5tdWwoIGh3ICkubmVnYXRlKCkgKSwgMCApICk7XG5cblx0XHRcdFx0Ly8gZG9uJ3QgZXh0ZW5kIHRoZSBsaW5lIGlmIHdlJ3JlIHJlbmRlcmluZyBkYXNoZXMgYmVjYXVzZSB3ZVxuXHRcdFx0XHQvLyB3b24ndCBiZSByZW5kZXJpbmcgdGhlIGVuZGNhcHNcblx0XHRcdFx0aWYgKCAhIHVzZURhc2ggKSB7XG5cblx0XHRcdFx0XHQvLyBjYXAgZXh0ZW5zaW9uXG5cdFx0XHRcdFx0d29ybGRQb3MuYWRkQXNzaWduKCB2ZWM0KCBwb3NpdGlvbkdlb21ldHJ5LnkubGVzc1RoYW4oIDAuNSApLnNlbGVjdCggd29ybGREaXIubXVsKCBodyApLm5lZ2F0ZSgpLCB3b3JsZERpci5tdWwoIGh3ICkgKSwgMCApICk7XG5cblx0XHRcdFx0XHQvLyBhZGQgd2lkdGggdG8gdGhlIGJveFxuXHRcdFx0XHRcdHdvcmxkUG9zLmFkZEFzc2lnbiggdmVjNCggd29ybGRGd2QubXVsKCBodyApLCAwICkgKTtcblxuXHRcdFx0XHRcdC8vIGVuZGNhcHNcblx0XHRcdFx0XHRJZiggcG9zaXRpb25HZW9tZXRyeS55LmdyZWF0ZXJUaGFuKCAxLjAgKS5vciggcG9zaXRpb25HZW9tZXRyeS55Lmxlc3NUaGFuKCAwLjAgKSApLCAoKSA9PiB7XG5cblx0XHRcdFx0XHRcdHdvcmxkUG9zLnN1YkFzc2lnbiggdmVjNCggd29ybGRGd2QubXVsKCAyLjAgKS5tdWwoIGh3ICksIDAgKSApO1xuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBwcm9qZWN0IHRoZSB3b3JsZHBvc1xuXHRcdFx0XHRjbGlwLmFzc2lnbiggY2FtZXJhUHJvamVjdGlvbk1hdHJpeC5tdWwoIHdvcmxkUG9zICkgKTtcblxuXHRcdFx0XHQvLyBzaGlmdCB0aGUgZGVwdGggb2YgdGhlIHByb2plY3RlZCBwb2ludHMgc28gdGhlIGxpbmVcblx0XHRcdFx0Ly8gc2VnbWVudHMgb3ZlcmxhcCBuZWF0bHlcblx0XHRcdFx0Y29uc3QgY2xpcFBvc2UgPSB2ZWMzKCkudG9WYXIoKTtcblxuXHRcdFx0XHRjbGlwUG9zZS5hc3NpZ24oIHBvc2l0aW9uR2VvbWV0cnkueS5sZXNzVGhhbiggMC41ICkuc2VsZWN0KCBuZGNTdGFydCwgbmRjRW5kICkgKTtcblx0XHRcdFx0Y2xpcC56LmFzc2lnbiggY2xpcFBvc2Uuei5tdWwoIGNsaXAudyApICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gdmVjMiggZGlyLnksIGRpci54Lm5lZ2F0ZSgpICkudG9WYXIoICdvZmZzZXQnICk7XG5cblx0XHRcdFx0Ly8gdW5kbyBhc3BlY3QgcmF0aW8gYWRqdXN0bWVudFxuXHRcdFx0XHRkaXIueC5hc3NpZ24oIGRpci54LmRpdiggYXNwZWN0ICkgKTtcblx0XHRcdFx0b2Zmc2V0LnguYXNzaWduKCBvZmZzZXQueC5kaXYoIGFzcGVjdCApICk7XG5cblx0XHRcdFx0Ly8gc2lnbiBmbGlwXG5cdFx0XHRcdG9mZnNldC5hc3NpZ24oIHBvc2l0aW9uR2VvbWV0cnkueC5sZXNzVGhhbiggMC4wICkuc2VsZWN0KCBvZmZzZXQubmVnYXRlKCksIG9mZnNldCApICk7XG5cblx0XHRcdFx0Ly8gZW5kY2Fwc1xuXHRcdFx0XHRJZiggcG9zaXRpb25HZW9tZXRyeS55Lmxlc3NUaGFuKCAwLjAgKSwgKCkgPT4ge1xuXG5cdFx0XHRcdFx0b2Zmc2V0LmFzc2lnbiggb2Zmc2V0LnN1YiggZGlyICkgKTtcblxuXHRcdFx0XHR9ICkuRWxzZUlmKCBwb3NpdGlvbkdlb21ldHJ5LnkuZ3JlYXRlclRoYW4oIDEuMCApLCAoKSA9PiB7XG5cblx0XHRcdFx0XHRvZmZzZXQuYXNzaWduKCBvZmZzZXQuYWRkKCBkaXIgKSApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBhZGp1c3QgZm9yIGxpbmV3aWR0aFxuXHRcdFx0XHRvZmZzZXQuYXNzaWduKCBvZmZzZXQubXVsKCBtYXRlcmlhbExpbmVXaWR0aCApICk7XG5cblx0XHRcdFx0Ly8gYWRqdXN0IGZvciBjbGlwLXNwYWNlIHRvIHNjcmVlbi1zcGFjZSBjb252ZXJzaW9uIC8vIG1heWJlIHJlc29sdXRpb24gc2hvdWxkIGJlIGJhc2VkIG9uIHZpZXdwb3J0IC4uLlxuXHRcdFx0XHRvZmZzZXQuYXNzaWduKCBvZmZzZXQuZGl2KCB2aWV3cG9ydC53ICkgKTtcblxuXHRcdFx0XHQvLyBzZWxlY3QgZW5kXG5cdFx0XHRcdGNsaXAuYXNzaWduKCBwb3NpdGlvbkdlb21ldHJ5LnkubGVzc1RoYW4oIDAuNSApLnNlbGVjdCggY2xpcFN0YXJ0LCBjbGlwRW5kICkgKTtcblxuXHRcdFx0XHQvLyBiYWNrIHRvIGNsaXAgc3BhY2Vcblx0XHRcdFx0b2Zmc2V0LmFzc2lnbiggb2Zmc2V0Lm11bCggY2xpcC53ICkgKTtcblxuXHRcdFx0XHRjbGlwLmFzc2lnbiggY2xpcC5hZGQoIHZlYzQoIG9mZnNldCwgMCwgMCApICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2xpcDtcblxuXHRcdH0gKSgpO1xuXG5cdFx0Y29uc3QgY2xvc2VzdExpbmVUb0xpbmUgPSBGbiggKCB7IHAxLCBwMiwgcDMsIHA0IH0gKSA9PiB7XG5cblx0XHRcdGNvbnN0IHAxMyA9IHAxLnN1YiggcDMgKTtcblx0XHRcdGNvbnN0IHA0MyA9IHA0LnN1YiggcDMgKTtcblxuXHRcdFx0Y29uc3QgcDIxID0gcDIuc3ViKCBwMSApO1xuXG5cdFx0XHRjb25zdCBkMTM0MyA9IHAxMy5kb3QoIHA0MyApO1xuXHRcdFx0Y29uc3QgZDQzMjEgPSBwNDMuZG90KCBwMjEgKTtcblx0XHRcdGNvbnN0IGQxMzIxID0gcDEzLmRvdCggcDIxICk7XG5cdFx0XHRjb25zdCBkNDM0MyA9IHA0My5kb3QoIHA0MyApO1xuXHRcdFx0Y29uc3QgZDIxMjEgPSBwMjEuZG90KCBwMjEgKTtcblxuXHRcdFx0Y29uc3QgZGVub20gPSBkMjEyMS5tdWwoIGQ0MzQzICkuc3ViKCBkNDMyMS5tdWwoIGQ0MzIxICkgKTtcblx0XHRcdGNvbnN0IG51bWVyID0gZDEzNDMubXVsKCBkNDMyMSApLnN1YiggZDEzMjEubXVsKCBkNDM0MyApICk7XG5cblx0XHRcdGNvbnN0IG11YSA9IG51bWVyLmRpdiggZGVub20gKS5jbGFtcCgpO1xuXHRcdFx0Y29uc3QgbXViID0gZDEzNDMuYWRkKCBkNDMyMS5tdWwoIG11YSApICkuZGl2KCBkNDM0MyApLmNsYW1wKCk7XG5cblx0XHRcdHJldHVybiB2ZWMyKCBtdWEsIG11YiApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5jb2xvck5vZGUgPSBGbiggKCkgPT4ge1xuXG5cdFx0XHRjb25zdCB2VXYgPSB1digpO1xuXG5cdFx0XHRpZiAoIHVzZURhc2ggKSB7XG5cblx0XHRcdFx0Y29uc3QgZGFzaFNpemVOb2RlID0gdGhpcy5kYXNoU2l6ZU5vZGUgPyBmbG9hdCggdGhpcy5kYXNoU2l6ZU5vZGUgKSA6IG1hdGVyaWFsTGluZURhc2hTaXplO1xuXHRcdFx0XHRjb25zdCBnYXBTaXplTm9kZSA9IHRoaXMuZGFzaFNpemVOb2RlID8gZmxvYXQoIHRoaXMuZGFzaEdhcE5vZGUgKSA6IG1hdGVyaWFsTGluZUdhcFNpemU7XG5cblx0XHRcdFx0ZGFzaFNpemUuYXNzaWduKCBkYXNoU2l6ZU5vZGUgKTtcblx0XHRcdFx0Z2FwU2l6ZS5hc3NpZ24oIGdhcFNpemVOb2RlICk7XG5cblx0XHRcdFx0Y29uc3QgdkxpbmVEaXN0YW5jZSA9IHZhcnlpbmdQcm9wZXJ0eSggJ2Zsb2F0JywgJ2xpbmVEaXN0YW5jZScgKTtcblxuXHRcdFx0XHR2VXYueS5sZXNzVGhhbiggLSAxLjAgKS5vciggdlV2LnkuZ3JlYXRlclRoYW4oIDEuMCApICkuZGlzY2FyZCgpOyAvLyBkaXNjYXJkIGVuZGNhcHNcblx0XHRcdFx0dkxpbmVEaXN0YW5jZS5tb2QoIGRhc2hTaXplLmFkZCggZ2FwU2l6ZSApICkuZ3JlYXRlclRoYW4oIGRhc2hTaXplICkuZGlzY2FyZCgpOyAvLyB0b2RvIC0gRklYXG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYWxwaGEgPSBmbG9hdCggMSApLnRvVmFyKCAnYWxwaGEnICk7XG5cblx0XHRcdGlmICggdXNlV29ybGRVbml0cyApIHtcblxuXHRcdFx0XHRjb25zdCB3b3JsZFN0YXJ0ID0gdmFyeWluZ1Byb3BlcnR5KCAndmVjMycsICd3b3JsZFN0YXJ0JyApO1xuXHRcdFx0XHRjb25zdCB3b3JsZEVuZCA9IHZhcnlpbmdQcm9wZXJ0eSggJ3ZlYzMnLCAnd29ybGRFbmQnICk7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgY2xvc2VzdCBwb2ludHMgb24gdGhlIHZpZXcgcmF5IGFuZCB0aGUgbGluZSBzZWdtZW50XG5cdFx0XHRcdGNvbnN0IHJheUVuZCA9IHZhcnlpbmdQcm9wZXJ0eSggJ3ZlYzQnLCAnd29ybGRQb3MnICkueHl6Lm5vcm1hbGl6ZSgpLm11bCggMWU1ICk7XG5cdFx0XHRcdGNvbnN0IGxpbmVEaXIgPSB3b3JsZEVuZC5zdWIoIHdvcmxkU3RhcnQgKTtcblx0XHRcdFx0Y29uc3QgcGFyYW1zID0gY2xvc2VzdExpbmVUb0xpbmUoIHsgcDE6IHdvcmxkU3RhcnQsIHAyOiB3b3JsZEVuZCwgcDM6IHZlYzMoIDAuMCwgMC4wLCAwLjAgKSwgcDQ6IHJheUVuZCB9ICk7XG5cblx0XHRcdFx0Y29uc3QgcDEgPSB3b3JsZFN0YXJ0LmFkZCggbGluZURpci5tdWwoIHBhcmFtcy54ICkgKTtcblx0XHRcdFx0Y29uc3QgcDIgPSByYXlFbmQubXVsKCBwYXJhbXMueSApO1xuXHRcdFx0XHRjb25zdCBkZWx0YSA9IHAxLnN1YiggcDIgKTtcblx0XHRcdFx0Y29uc3QgbGVuID0gZGVsdGEubGVuZ3RoKCk7XG5cdFx0XHRcdGNvbnN0IG5vcm0gPSBsZW4uZGl2KCBtYXRlcmlhbExpbmVXaWR0aCApO1xuXG5cdFx0XHRcdGlmICggISB1c2VEYXNoICkge1xuXG5cdFx0XHRcdFx0aWYgKCB1c2VBbHBoYVRvQ292ZXJhZ2UgJiYgcmVuZGVyZXIuc2FtcGxlcyA+IDEgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGRub3JtID0gbm9ybS5md2lkdGgoKTtcblx0XHRcdFx0XHRcdGFscGhhLmFzc2lnbiggc21vb3Roc3RlcCggZG5vcm0ubmVnYXRlKCkuYWRkKCAwLjUgKSwgZG5vcm0uYWRkKCAwLjUgKSwgbm9ybSApLm9uZU1pbnVzKCkgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdG5vcm0uZ3JlYXRlclRoYW4oIDAuNSApLmRpc2NhcmQoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gcm91bmQgZW5kY2Fwc1xuXG5cdFx0XHRcdGlmICggdXNlQWxwaGFUb0NvdmVyYWdlICYmIHJlbmRlcmVyLnNhbXBsZXMgPiAxICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYSA9IHZVdi54O1xuXHRcdFx0XHRcdGNvbnN0IGIgPSB2VXYueS5ncmVhdGVyVGhhbiggMC4wICkuc2VsZWN0KCB2VXYueS5zdWIoIDEuMCApLCB2VXYueS5hZGQoIDEuMCApICk7XG5cblx0XHRcdFx0XHRjb25zdCBsZW4yID0gYS5tdWwoIGEgKS5hZGQoIGIubXVsKCBiICkgKTtcblxuXHRcdFx0XHRcdGNvbnN0IGRsZW4gPSBmbG9hdCggbGVuMi5md2lkdGgoKSApLnRvVmFyKCAnZGxlbicgKTtcblxuXHRcdFx0XHRcdElmKCB2VXYueS5hYnMoKS5ncmVhdGVyVGhhbiggMS4wICksICgpID0+IHtcblxuXHRcdFx0XHRcdFx0YWxwaGEuYXNzaWduKCBzbW9vdGhzdGVwKCBkbGVuLm9uZU1pbnVzKCksIGRsZW4uYWRkKCAxICksIGxlbjIgKS5vbmVNaW51cygpICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdElmKCB2VXYueS5hYnMoKS5ncmVhdGVyVGhhbiggMS4wICksICgpID0+IHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYSA9IHZVdi54O1xuXHRcdFx0XHRcdFx0Y29uc3QgYiA9IHZVdi55LmdyZWF0ZXJUaGFuKCAwLjAgKS5zZWxlY3QoIHZVdi55LnN1YiggMS4wICksIHZVdi55LmFkZCggMS4wICkgKTtcblx0XHRcdFx0XHRcdGNvbnN0IGxlbjIgPSBhLm11bCggYSApLmFkZCggYi5tdWwoIGIgKSApO1xuXG5cdFx0XHRcdFx0XHRsZW4yLmdyZWF0ZXJUaGFuKCAxLjAgKS5kaXNjYXJkKCk7XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBsaW5lQ29sb3JOb2RlO1xuXG5cdFx0XHRpZiAoIHRoaXMubGluZUNvbG9yTm9kZSApIHtcblxuXHRcdFx0XHRsaW5lQ29sb3JOb2RlID0gdGhpcy5saW5lQ29sb3JOb2RlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggdXNlQ29sb3IgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBpbnN0YW5jZUNvbG9yU3RhcnQgPSBhdHRyaWJ1dGUoICdpbnN0YW5jZUNvbG9yU3RhcnQnICk7XG5cdFx0XHRcdFx0Y29uc3QgaW5zdGFuY2VDb2xvckVuZCA9IGF0dHJpYnV0ZSggJ2luc3RhbmNlQ29sb3JFbmQnICk7XG5cblx0XHRcdFx0XHRjb25zdCBpbnN0YW5jZUNvbG9yID0gcG9zaXRpb25HZW9tZXRyeS55Lmxlc3NUaGFuKCAwLjUgKS5zZWxlY3QoIGluc3RhbmNlQ29sb3JTdGFydCwgaW5zdGFuY2VDb2xvckVuZCApO1xuXG5cdFx0XHRcdFx0bGluZUNvbG9yTm9kZSA9IGluc3RhbmNlQ29sb3IubXVsKCBtYXRlcmlhbENvbG9yICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGxpbmVDb2xvck5vZGUgPSBtYXRlcmlhbENvbG9yO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmVjNCggbGluZUNvbG9yTm9kZSwgYWxwaGEgKTtcblxuXHRcdH0gKSgpO1xuXG5cdFx0aWYgKCB0aGlzLnRyYW5zcGFyZW50ICkge1xuXG5cdFx0XHRjb25zdCBvcGFjaXR5Tm9kZSA9IHRoaXMub3BhY2l0eU5vZGUgPyBmbG9hdCggdGhpcy5vcGFjaXR5Tm9kZSApIDogbWF0ZXJpYWxPcGFjaXR5O1xuXG5cdFx0XHR0aGlzLm91dHB1dE5vZGUgPSB2ZWM0KCB0aGlzLmNvbG9yTm9kZS5yZ2IubXVsKCBvcGFjaXR5Tm9kZSApLmFkZCggdmlld3BvcnRTaGFyZWRUZXh0dXJlKCkucmdiLm11bCggb3BhY2l0eU5vZGUub25lTWludXMoKSApICksIHRoaXMuY29sb3JOb2RlLmEgKTtcblxuXHRcdH1cblxuXHR9XG5cblxuXHRnZXQgd29ybGRVbml0cygpIHtcblxuXHRcdHJldHVybiB0aGlzLnVzZVdvcmxkVW5pdHM7XG5cblx0fVxuXG5cdHNldCB3b3JsZFVuaXRzKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy51c2VXb3JsZFVuaXRzICE9PSB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy51c2VXb3JsZFVuaXRzID0gdmFsdWU7XG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblxuXHRnZXQgZGFzaGVkKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudXNlRGFzaDtcblxuXHR9XG5cblx0c2V0IGRhc2hlZCggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMudXNlRGFzaCAhPT0gdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMudXNlRGFzaCA9IHZhbHVlO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fVxuXG5cblx0Z2V0IGFscGhhVG9Db3ZlcmFnZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnVzZUFscGhhVG9Db3ZlcmFnZTtcblxuXHR9XG5cblx0c2V0IGFscGhhVG9Db3ZlcmFnZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMudXNlQWxwaGFUb0NvdmVyYWdlICE9PSB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy51c2VBbHBoYVRvQ292ZXJhZ2UgPSB2YWx1ZTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5lMk5vZGVNYXRlcmlhbDtcbiIsImltcG9ydCB7IG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBkaXJlY3Rpb25Ub0NvbG9yID0gKCBub2RlICkgPT4gbm9kZU9iamVjdCggbm9kZSApLm11bCggMC41ICkuYWRkKCAwLjUgKTtcbmV4cG9ydCBjb25zdCBjb2xvclRvRGlyZWN0aW9uID0gKCBub2RlICkgPT4gbm9kZU9iamVjdCggbm9kZSApLm11bCggMi4wICkuc3ViKCAxICk7XG4iLCJpbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4vTm9kZU1hdGVyaWFsLmpzJztcbmltcG9ydCB7IGRpZmZ1c2VDb2xvciB9IGZyb20gJy4uLy4uL25vZGVzL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcbmltcG9ydCB7IGRpcmVjdGlvblRvQ29sb3IgfSBmcm9tICcuLi8uLi9ub2Rlcy91dGlscy9QYWNraW5nLmpzJztcbmltcG9ydCB7IG1hdGVyaWFsT3BhY2l0eSB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbE5vZGUuanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtZWROb3JtYWxWaWV3IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL05vcm1hbC5qcyc7XG5pbXBvcnQgeyBmbG9hdCwgdmVjNCB9IGZyb20gJy4uLy4uL25vZGVzL3RzbC9UU0xCYXNlLmpzJztcblxuaW1wb3J0IHsgTWVzaE5vcm1hbE1hdGVyaWFsIH0gZnJvbSAnLi4vTWVzaE5vcm1hbE1hdGVyaWFsLmpzJztcblxuY29uc3QgX2RlZmF1bHRWYWx1ZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBNZXNoTm9ybWFsTWF0ZXJpYWwoKTtcblxuY2xhc3MgTWVzaE5vcm1hbE5vZGVNYXRlcmlhbCBleHRlbmRzIE5vZGVNYXRlcmlhbCB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdNZXNoTm9ybWFsTm9kZU1hdGVyaWFsJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTtcblxuXHRcdHRoaXMuaXNNZXNoTm9ybWFsTm9kZU1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2V0RGVmYXVsdFZhbHVlcyggX2RlZmF1bHRWYWx1ZXMgKTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdHNldHVwRGlmZnVzZUNvbG9yKCkge1xuXG5cdFx0Y29uc3Qgb3BhY2l0eU5vZGUgPSB0aGlzLm9wYWNpdHlOb2RlID8gZmxvYXQoIHRoaXMub3BhY2l0eU5vZGUgKSA6IG1hdGVyaWFsT3BhY2l0eTtcblxuXHRcdGRpZmZ1c2VDb2xvci5hc3NpZ24oIHZlYzQoIGRpcmVjdGlvblRvQ29sb3IoIHRyYW5zZm9ybWVkTm9ybWFsVmlldyApLCBvcGFjaXR5Tm9kZSApICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lc2hOb3JtYWxOb2RlTWF0ZXJpYWw7XG4iLCJpbXBvcnQgVGVtcE5vZGUgZnJvbSAnLi4vY29yZS9UZW1wTm9kZS5qcyc7XG5pbXBvcnQgeyBwb3NpdGlvbldvcmxkRGlyZWN0aW9uIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IG5vZGVQcm94eSwgdmVjMiB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY2xhc3MgRXF1aXJlY3RVVk5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdFcXVpcmVjdFVWTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBkaXJOb2RlID0gcG9zaXRpb25Xb3JsZERpcmVjdGlvbiApIHtcblxuXHRcdHN1cGVyKCAndmVjMicgKTtcblxuXHRcdHRoaXMuZGlyTm9kZSA9IGRpck5vZGU7XG5cblx0fVxuXG5cdHNldHVwKCkge1xuXG5cdFx0Y29uc3QgZGlyID0gdGhpcy5kaXJOb2RlO1xuXG5cdFx0Y29uc3QgdSA9IGRpci56LmF0YW4yKCBkaXIueCApLm11bCggMSAvICggTWF0aC5QSSAqIDIgKSApLmFkZCggMC41ICk7XG5cdFx0Y29uc3QgdiA9IGRpci55LmNsYW1wKCAtIDEuMCwgMS4wICkuYXNpbigpLm11bCggMSAvIE1hdGguUEkgKS5hZGQoIDAuNSApO1xuXG5cdFx0cmV0dXJuIHZlYzIoIHUsIHYgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXF1aXJlY3RVVk5vZGU7XG5cbmV4cG9ydCBjb25zdCBlcXVpcmVjdFVWID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEVxdWlyZWN0VVZOb2RlICk7XG4iLCJpbXBvcnQgeyBlcXVpcmVjdFVWIH0gZnJvbSAnLi4vLi4vbm9kZXMvdXRpbHMvRXF1aXJlY3RVVk5vZGUuanMnO1xuaW1wb3J0IHsgdGV4dHVyZSBhcyBUU0xfVGV4dHVyZSB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9UZXh0dXJlTm9kZS5qcyc7XG5pbXBvcnQgeyBwb3NpdGlvbldvcmxkRGlyZWN0aW9uIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcbmltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi4vLi4vbWF0ZXJpYWxzL25vZGVzL05vZGVNYXRlcmlhbC5qcyc7XG5cbmltcG9ydCB7IFdlYkdMQ3ViZVJlbmRlclRhcmdldCB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9XZWJHTEN1YmVSZW5kZXJUYXJnZXQuanMnO1xuaW1wb3J0IHsgU2NlbmUgfSBmcm9tICcuLi8uLi9zY2VuZXMvU2NlbmUuanMnO1xuaW1wb3J0IHsgQ3ViZUNhbWVyYSB9IGZyb20gJy4uLy4uL2NhbWVyYXMvQ3ViZUNhbWVyYS5qcyc7XG5pbXBvcnQgeyBCb3hHZW9tZXRyeSB9IGZyb20gJy4uLy4uL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4uLy4uL29iamVjdHMvTWVzaC5qcyc7XG5pbXBvcnQgeyBCYWNrU2lkZSwgTm9CbGVuZGluZywgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuXG4vLyBAVE9ETzogQ29uc2lkZXIgcmVuYW1lIFdlYkdMQ3ViZVJlbmRlclRhcmdldCB0byBqdXN0IEN1YmVSZW5kZXJUYXJnZXRcblxuY2xhc3MgQ3ViZVJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMQ3ViZVJlbmRlclRhcmdldCB7XG5cblx0Y29uc3RydWN0b3IoIHNpemUgPSAxLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRzdXBlciggc2l6ZSwgb3B0aW9ucyApO1xuXG5cdFx0dGhpcy5pc0N1YmVSZW5kZXJUYXJnZXQgPSB0cnVlO1xuXG5cdH1cblxuXHRmcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZSggcmVuZGVyZXIsIHRleHR1cmUgKSB7XG5cblx0XHRjb25zdCBjdXJyZW50TWluRmlsdGVyID0gdGV4dHVyZS5taW5GaWx0ZXI7XG5cdFx0Y29uc3QgY3VycmVudEdlbmVyYXRlTWlwbWFwcyA9IHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xuXG5cdFx0dGhpcy50ZXh0dXJlLnR5cGUgPSB0ZXh0dXJlLnR5cGU7XG5cdFx0dGhpcy50ZXh0dXJlLmNvbG9yU3BhY2UgPSB0ZXh0dXJlLmNvbG9yU3BhY2U7XG5cblx0XHR0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IHRleHR1cmUubWluRmlsdGVyO1xuXHRcdHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSB0ZXh0dXJlLm1hZ0ZpbHRlcjtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJveEdlb21ldHJ5KCA1LCA1LCA1ICk7XG5cblx0XHRjb25zdCB1dk5vZGUgPSBlcXVpcmVjdFVWKCBwb3NpdGlvbldvcmxkRGlyZWN0aW9uICk7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBOb2RlTWF0ZXJpYWwoKTtcblx0XHRtYXRlcmlhbC5jb2xvck5vZGUgPSBUU0xfVGV4dHVyZSggdGV4dHVyZSwgdXZOb2RlLCAwICk7XG5cdFx0bWF0ZXJpYWwuc2lkZSA9IEJhY2tTaWRlO1xuXHRcdG1hdGVyaWFsLmJsZW5kaW5nID0gTm9CbGVuZGluZztcblxuXHRcdGNvbnN0IG1lc2ggPSBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRjb25zdCBzY2VuZSA9IG5ldyBTY2VuZSgpO1xuXHRcdHNjZW5lLmFkZCggbWVzaCApO1xuXG5cdFx0Ly8gQXZvaWQgYmx1cnJlZCBwb2xlc1xuXHRcdGlmICggdGV4dHVyZS5taW5GaWx0ZXIgPT09IExpbmVhck1pcG1hcExpbmVhckZpbHRlciApIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXG5cdFx0Y29uc3QgY2FtZXJhID0gbmV3IEN1YmVDYW1lcmEoIDEsIDEwLCB0aGlzICk7XG5cblx0XHRjb25zdCBjdXJyZW50TVJUID0gcmVuZGVyZXIuZ2V0TVJUKCk7XG5cdFx0cmVuZGVyZXIuc2V0TVJUKCBudWxsICk7XG5cblx0XHRjYW1lcmEudXBkYXRlKCByZW5kZXJlciwgc2NlbmUgKTtcblxuXHRcdHJlbmRlcmVyLnNldE1SVCggY3VycmVudE1SVCApO1xuXG5cdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBjdXJyZW50TWluRmlsdGVyO1xuXHRcdHRleHR1cmUuY3VycmVudEdlbmVyYXRlTWlwbWFwcyA9IGN1cnJlbnRHZW5lcmF0ZU1pcG1hcHM7XG5cblx0XHRtZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRtZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDdWJlUmVuZGVyVGFyZ2V0O1xuIiwiaW1wb3J0IFRlbXBOb2RlIGZyb20gJy4uL2NvcmUvVGVtcE5vZGUuanMnO1xuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyBDdWJlVGV4dHVyZSB9IGZyb20gJy4uLy4uL3RleHR1cmVzL0N1YmVUZXh0dXJlLmpzJztcbmltcG9ydCB7IGN1YmVUZXh0dXJlIH0gZnJvbSAnLi4vYWNjZXNzb3JzL0N1YmVUZXh0dXJlTm9kZS5qcyc7XG5pbXBvcnQgQ3ViZVJlbmRlclRhcmdldCBmcm9tICcuLi8uLi9yZW5kZXJlcnMvY29tbW9uL0N1YmVSZW5kZXJUYXJnZXQuanMnO1xuaW1wb3J0IHsgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLCBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IF9jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbmNsYXNzIEN1YmVNYXBOb2RlIGV4dGVuZHMgVGVtcE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnQ3ViZU1hcE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggZW52Tm9kZSApIHtcblxuXHRcdHN1cGVyKCAndmVjMycgKTtcblxuXHRcdHRoaXMuZW52Tm9kZSA9IGVudk5vZGU7XG5cblx0XHR0aGlzLl9jdWJlVGV4dHVyZSA9IG51bGw7XG5cdFx0dGhpcy5fY3ViZVRleHR1cmVOb2RlID0gY3ViZVRleHR1cmUoKTtcblxuXHRcdGNvbnN0IGRlZmF1bHRUZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7XG5cdFx0ZGVmYXVsdFRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcblxuXHRcdHRoaXMuX2RlZmF1bHRUZXh0dXJlID0gZGVmYXVsdFRleHR1cmU7XG5cblx0XHR0aGlzLnVwZGF0ZUJlZm9yZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5SRU5ERVI7XG5cblx0fVxuXG5cdHVwZGF0ZUJlZm9yZSggZnJhbWUgKSB7XG5cblx0XHRjb25zdCB7IHJlbmRlcmVyLCBtYXRlcmlhbCB9ID0gZnJhbWU7XG5cblx0XHRjb25zdCBlbnZOb2RlID0gdGhpcy5lbnZOb2RlO1xuXG5cdFx0aWYgKCBlbnZOb2RlLmlzVGV4dHVyZU5vZGUgfHwgZW52Tm9kZS5pc01hdGVyaWFsUmVmZXJlbmNlTm9kZSApIHtcblxuXHRcdFx0Y29uc3QgdGV4dHVyZSA9ICggZW52Tm9kZS5pc1RleHR1cmVOb2RlICkgPyBlbnZOb2RlLnZhbHVlIDogbWF0ZXJpYWxbIGVudk5vZGUucHJvcGVydHkgXTtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlICYmIHRleHR1cmUuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRcdGNvbnN0IG1hcHBpbmcgPSB0ZXh0dXJlLm1hcHBpbmc7XG5cblx0XHRcdFx0aWYgKCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyB8fCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyApIHtcblxuXHRcdFx0XHRcdC8vIGNoZWNrIGZvciBjb252ZXJ0ZWQgY3ViZW1hcCBtYXBcblxuXHRcdFx0XHRcdGlmICggX2NhY2hlLmhhcyggdGV4dHVyZSApICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBjdWJlTWFwID0gX2NhY2hlLmdldCggdGV4dHVyZSApO1xuXG5cdFx0XHRcdFx0XHRtYXBUZXh0dXJlTWFwcGluZyggY3ViZU1hcCwgdGV4dHVyZS5tYXBwaW5nICk7XG5cdFx0XHRcdFx0XHR0aGlzLl9jdWJlVGV4dHVyZSA9IGN1YmVNYXA7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBjcmVhdGUgY3ViZSBtYXAgZnJvbSBlcXVpcmVjdGFuZ3VsYXIgbWFwXG5cblx0XHRcdFx0XHRcdGNvbnN0IGltYWdlID0gdGV4dHVyZS5pbWFnZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBpc0VxdWlyZWN0YW5ndWxhck1hcFJlYWR5KCBpbWFnZSApICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IG5ldyBDdWJlUmVuZGVyVGFyZ2V0KCBpbWFnZS5oZWlnaHQgKTtcblx0XHRcdFx0XHRcdFx0cmVuZGVyVGFyZ2V0LmZyb21FcXVpcmVjdGFuZ3VsYXJUZXh0dXJlKCByZW5kZXJlciwgdGV4dHVyZSApO1xuXG5cdFx0XHRcdFx0XHRcdG1hcFRleHR1cmVNYXBwaW5nKCByZW5kZXJUYXJnZXQudGV4dHVyZSwgdGV4dHVyZS5tYXBwaW5nICk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2N1YmVUZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cblx0XHRcdFx0XHRcdFx0X2NhY2hlLnNldCggdGV4dHVyZSwgcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcblxuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmF1bHQgY3ViZSB0ZXh0dXJlIGFzIGZhbGxiYWNrIHdoZW4gZXF1aXJlY3Rhbmd1bGFyIHRleHR1cmUgaXMgbm90IHlldCBsb2FkZWRcblxuXHRcdFx0XHRcdFx0XHR0aGlzLl9jdWJlVGV4dHVyZSA9IHRoaXMuX2RlZmF1bHRUZXh0dXJlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvL1xuXG5cdFx0XHRcdFx0dGhpcy5fY3ViZVRleHR1cmVOb2RlLnZhbHVlID0gdGhpcy5fY3ViZVRleHR1cmU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGVudk5vZGUgYWxyZWFkeSByZWZlcnMgdG8gYSBjdWJlIG1hcFxuXG5cdFx0XHRcdFx0dGhpcy5fY3ViZVRleHR1cmVOb2RlID0gdGhpcy5lbnZOb2RlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdHRoaXMudXBkYXRlQmVmb3JlKCBidWlsZGVyICk7XG5cblx0XHRyZXR1cm4gdGhpcy5fY3ViZVRleHR1cmVOb2RlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDdWJlTWFwTm9kZTtcblxuZnVuY3Rpb24gaXNFcXVpcmVjdGFuZ3VsYXJNYXBSZWFkeSggaW1hZ2UgKSB7XG5cblx0aWYgKCBpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdHJldHVybiBpbWFnZS5oZWlnaHQgPiAwO1xuXG59XG5cbmZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdGNvbnN0IHRleHR1cmUgPSBldmVudC50YXJnZXQ7XG5cblx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuXHRjb25zdCByZW5kZXJUYXJnZXQgPSBfY2FjaGUuZ2V0KCB0ZXh0dXJlICk7XG5cblx0aWYgKCByZW5kZXJUYXJnZXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdF9jYWNoZS5kZWxldGUoIHRleHR1cmUgKTtcblxuXHRcdHJlbmRlclRhcmdldC5kaXNwb3NlKCk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIG1hcFRleHR1cmVNYXBwaW5nKCB0ZXh0dXJlLCBtYXBwaW5nICkge1xuXG5cdGlmICggbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgKSB7XG5cblx0XHR0ZXh0dXJlLm1hcHBpbmcgPSBDdWJlUmVmbGVjdGlvbk1hcHBpbmc7XG5cblx0fSBlbHNlIGlmICggbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgKSB7XG5cblx0XHR0ZXh0dXJlLm1hcHBpbmcgPSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBjb25zdCBjdWJlTWFwTm9kZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBDdWJlTWFwTm9kZSApO1xuIiwiaW1wb3J0IExpZ2h0aW5nTm9kZSBmcm9tICcuL0xpZ2h0aW5nTm9kZS5qcyc7XG5pbXBvcnQgeyBjdWJlTWFwTm9kZSB9IGZyb20gJy4uL3V0aWxzL0N1YmVNYXBOb2RlLmpzJztcblxuY2xhc3MgQmFzaWNFbnZpcm9ubWVudE5vZGUgZXh0ZW5kcyBMaWdodGluZ05vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnQmFzaWNFbnZpcm9ubWVudE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggZW52Tm9kZSA9IG51bGwgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5lbnZOb2RlID0gZW52Tm9kZTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHQvLyBlbnZpcm9ubWVudCBwcm9wZXJ0eSBpcyB1c2VkIGluIHRoZSBmaW5pc2goKSBtZXRob2Qgb2YgQmFzaWNMaWdodGluZ01vZGVsXG5cblx0XHRidWlsZGVyLmNvbnRleHQuZW52aXJvbm1lbnQgPSBjdWJlTWFwTm9kZSggdGhpcy5lbnZOb2RlICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2ljRW52aXJvbm1lbnROb2RlO1xuIiwiaW1wb3J0IExpZ2h0aW5nTm9kZSBmcm9tICcuL0xpZ2h0aW5nTm9kZS5qcyc7XG5pbXBvcnQgeyBmbG9hdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY2xhc3MgQmFzaWNMaWdodE1hcE5vZGUgZXh0ZW5kcyBMaWdodGluZ05vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnQmFzaWNMaWdodE1hcE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggbGlnaHRNYXBOb2RlID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmxpZ2h0TWFwTm9kZSA9IGxpZ2h0TWFwTm9kZTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHQvLyBpcnJhZGlhbmNlTGlnaHRNYXAgcHJvcGVydHkgaXMgdXNlZCBpbiB0aGUgaW5kaXJlY3REaWZmdXNlKCkgbWV0aG9kIG9mIEJhc2ljTGlnaHRpbmdNb2RlbFxuXG5cdFx0Y29uc3QgUkVDSVBST0NBTF9QSSA9IGZsb2F0KCAxIC8gTWF0aC5QSSApO1xuXG5cdFx0YnVpbGRlci5jb250ZXh0LmlycmFkaWFuY2VMaWdodE1hcCA9IHRoaXMubGlnaHRNYXBOb2RlLm11bCggUkVDSVBST0NBTF9QSSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNpY0xpZ2h0TWFwTm9kZTtcbiIsImNsYXNzIExpZ2h0aW5nTW9kZWwge1xuXG5cdHN0YXJ0KCAvKmlucHV0LCBzdGFjaywgYnVpbGRlciovICkgeyB9XG5cblx0ZmluaXNoKCAvKmlucHV0LCBzdGFjaywgYnVpbGRlciovICkgeyB9XG5cblx0ZGlyZWN0KCAvKmlucHV0LCBzdGFjaywgYnVpbGRlciovICkgeyB9XG5cblx0ZGlyZWN0UmVjdEFyZWEoIC8qaW5wdXQsIHN0YWNrLCBidWlsZGVyKi8gKSB7fVxuXG5cdGluZGlyZWN0KCAvKmlucHV0LCBzdGFjaywgYnVpbGRlciovICkgeyB9XG5cblx0YW1iaWVudE9jY2x1c2lvbiggLyppbnB1dCwgc3RhY2ssIGJ1aWxkZXIqLyApIHsgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IExpZ2h0aW5nTW9kZWw7XG4iLCJpbXBvcnQgTGlnaHRpbmdNb2RlbCBmcm9tICcuLi9jb3JlL0xpZ2h0aW5nTW9kZWwuanMnO1xuaW1wb3J0IHsgZGlmZnVzZUNvbG9yIH0gZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xuaW1wb3J0IHsgTXVsdGlwbHlPcGVyYXRpb24sIE1peE9wZXJhdGlvbiwgQWRkT3BlcmF0aW9uIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IG1hdGVyaWFsU3BlY3VsYXJTdHJlbmd0aCwgbWF0ZXJpYWxSZWZsZWN0aXZpdHkgfSBmcm9tICcuLi9hY2Nlc3NvcnMvTWF0ZXJpYWxOb2RlLmpzJztcbmltcG9ydCB7IG1peCB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xuaW1wb3J0IHsgdmVjNCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY2xhc3MgQmFzaWNMaWdodGluZ01vZGVsIGV4dGVuZHMgTGlnaHRpbmdNb2RlbCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdH1cblxuXHRpbmRpcmVjdCggY29udGV4dCwgc3RhY2ssIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBhbWJpZW50T2NjbHVzaW9uID0gY29udGV4dC5hbWJpZW50T2NjbHVzaW9uO1xuXHRcdGNvbnN0IHJlZmxlY3RlZExpZ2h0ID0gY29udGV4dC5yZWZsZWN0ZWRMaWdodDtcblx0XHRjb25zdCBpcnJhZGlhbmNlTGlnaHRNYXAgPSBidWlsZGVyLmNvbnRleHQuaXJyYWRpYW5jZUxpZ2h0TWFwO1xuXG5cdFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlLmFzc2lnbiggdmVjNCggMC4wICkgKTtcblxuXHRcdC8vIGFjY3VtdWxhdGlvbiAoYmFrZWQgaW5kaXJlY3QgbGlnaHRpbmcgb25seSlcblxuXHRcdGlmICggaXJyYWRpYW5jZUxpZ2h0TWFwICkge1xuXG5cdFx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UuYWRkQXNzaWduKCBpcnJhZGlhbmNlTGlnaHRNYXAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZS5hZGRBc3NpZ24oIHZlYzQoIDEuMCwgMS4wLCAxLjAsIDAuMCApICk7XG5cblx0XHR9XG5cblx0XHQvLyBtb2R1bGF0aW9uXG5cblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UubXVsQXNzaWduKCBhbWJpZW50T2NjbHVzaW9uICk7XG5cblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UubXVsQXNzaWduKCBkaWZmdXNlQ29sb3IucmdiICk7XG5cblx0fVxuXG5cdGZpbmlzaCggY29udGV4dCwgc3RhY2ssIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IGJ1aWxkZXIubWF0ZXJpYWw7XG5cdFx0Y29uc3Qgb3V0Z29pbmdMaWdodCA9IGNvbnRleHQub3V0Z29pbmdMaWdodDtcblx0XHRjb25zdCBlbnZOb2RlID0gYnVpbGRlci5jb250ZXh0LmVudmlyb25tZW50O1xuXG5cdFx0aWYgKCBlbnZOb2RlICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBtYXRlcmlhbC5jb21iaW5lICkge1xuXG5cdFx0XHRcdGNhc2UgTXVsdGlwbHlPcGVyYXRpb246XG5cdFx0XHRcdFx0b3V0Z29pbmdMaWdodC5yZ2IuYXNzaWduKCBtaXgoIG91dGdvaW5nTGlnaHQucmdiLCBvdXRnb2luZ0xpZ2h0LnJnYi5tdWwoIGVudk5vZGUucmdiICksIG1hdGVyaWFsU3BlY3VsYXJTdHJlbmd0aC5tdWwoIG1hdGVyaWFsUmVmbGVjdGl2aXR5ICkgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgTWl4T3BlcmF0aW9uOlxuXHRcdFx0XHRcdG91dGdvaW5nTGlnaHQucmdiLmFzc2lnbiggbWl4KCBvdXRnb2luZ0xpZ2h0LnJnYiwgZW52Tm9kZS5yZ2IsIG1hdGVyaWFsU3BlY3VsYXJTdHJlbmd0aC5tdWwoIG1hdGVyaWFsUmVmbGVjdGl2aXR5ICkgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgQWRkT3BlcmF0aW9uOlxuXHRcdFx0XHRcdG91dGdvaW5nTGlnaHQucmdiLmFkZEFzc2lnbiggZW52Tm9kZS5yZ2IubXVsKCBtYXRlcmlhbFNwZWN1bGFyU3RyZW5ndGgubXVsKCBtYXRlcmlhbFJlZmxlY3Rpdml0eSApICkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJhc2ljTGlnaHRpbmdNb2RlbDogVW5zdXBwb3J0ZWQgLmNvbWJpbmUgdmFsdWU6JywgbWF0ZXJpYWwuY29tYmluZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2ljTGlnaHRpbmdNb2RlbDtcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi9Ob2RlTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgbWF0ZXJpYWxMaWdodE1hcCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbE5vZGUuanMnO1xuaW1wb3J0IEJhc2ljRW52aXJvbm1lbnROb2RlIGZyb20gJy4uLy4uL25vZGVzL2xpZ2h0aW5nL0Jhc2ljRW52aXJvbm1lbnROb2RlLmpzJztcbmltcG9ydCBCYXNpY0xpZ2h0TWFwTm9kZSBmcm9tICcuLi8uLi9ub2Rlcy9saWdodGluZy9CYXNpY0xpZ2h0TWFwTm9kZS5qcyc7XG5pbXBvcnQgQmFzaWNMaWdodGluZ01vZGVsIGZyb20gJy4uLy4uL25vZGVzL2Z1bmN0aW9ucy9CYXNpY0xpZ2h0aW5nTW9kZWwuanMnO1xuaW1wb3J0IHsgbm9ybWFsVmlldyB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9Ob3JtYWwuanMnO1xuaW1wb3J0IHsgZGlmZnVzZUNvbG9yIH0gZnJvbSAnLi4vLi4vbm9kZXMvY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xuXG5pbXBvcnQgeyBNZXNoQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL01lc2hCYXNpY01hdGVyaWFsLmpzJztcblxuY29uc3QgX2RlZmF1bHRWYWx1ZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCgpO1xuXG5jbGFzcyBNZXNoQmFzaWNOb2RlTWF0ZXJpYWwgZXh0ZW5kcyBOb2RlTWF0ZXJpYWwge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnTWVzaEJhc2ljTm9kZU1hdGVyaWFsJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc01lc2hCYXNpY05vZGVNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLmxpZ2h0cyA9IHRydWU7XG5cblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRzZXR1cE5vcm1hbCgpIHtcblxuXHRcdHJldHVybiBub3JtYWxWaWV3OyAvLyBzZWUgIzI4ODM5XG5cblx0fVxuXG5cdHNldHVwRW52aXJvbm1lbnQoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBlbnZOb2RlID0gc3VwZXIuc2V0dXBFbnZpcm9ubWVudCggYnVpbGRlciApO1xuXG5cdFx0cmV0dXJuIGVudk5vZGUgPyBuZXcgQmFzaWNFbnZpcm9ubWVudE5vZGUoIGVudk5vZGUgKSA6IG51bGw7XG5cblx0fVxuXG5cdHNldHVwTGlnaHRNYXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRsZXQgbm9kZSA9IG51bGw7XG5cblx0XHRpZiAoIGJ1aWxkZXIubWF0ZXJpYWwubGlnaHRNYXAgKSB7XG5cblx0XHRcdG5vZGUgPSBuZXcgQmFzaWNMaWdodE1hcE5vZGUoIG1hdGVyaWFsTGlnaHRNYXAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlO1xuXG5cdH1cblxuXHRzZXR1cE91dGdvaW5nTGlnaHQoKSB7XG5cblx0XHRyZXR1cm4gZGlmZnVzZUNvbG9yLnJnYjtcblxuXHR9XG5cblx0c2V0dXBMaWdodGluZ01vZGVsKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBCYXNpY0xpZ2h0aW5nTW9kZWwoKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWVzaEJhc2ljTm9kZU1hdGVyaWFsO1xuIiwiaW1wb3J0IHsgRm4gfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNvbnN0IEZfU2NobGljayA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBmMCwgZjkwLCBkb3RWSCB9ICkgPT4ge1xuXG5cdC8vIE9yaWdpbmFsIGFwcHJveGltYXRpb24gYnkgQ2hyaXN0b3BoZSBTY2hsaWNrICc5NFxuXHQvLyBmbG9hdCBmcmVzbmVsID0gcG93KCAxLjAgLSBkb3RWSCwgNS4wICk7XG5cblx0Ly8gT3B0aW1pemVkIHZhcmlhbnQgKHByZXNlbnRlZCBieSBFcGljIGF0IFNJR0dSQVBIICcxMylcblx0Ly8gaHR0cHM6Ly9jZG4yLnVucmVhbGVuZ2luZS5jb20vUmVzb3VyY2VzL2ZpbGVzLzIwMTNTaWdncmFwaFByZXNlbnRhdGlvbnNOb3Rlcy0yNjkxNTczOC5wZGZcblx0Y29uc3QgZnJlc25lbCA9IGRvdFZILm11bCggLSA1LjU1NDczICkuc3ViKCA2Ljk4MzE2ICkubXVsKCBkb3RWSCApLmV4cDIoKTtcblxuXHRyZXR1cm4gZjAubXVsKCBmcmVzbmVsLm9uZU1pbnVzKCkgKS5hZGQoIGY5MC5tdWwoIGZyZXNuZWwgKSApO1xuXG59ICk7IC8vIHZhbGlkYXRlZFxuXG5leHBvcnQgZGVmYXVsdCBGX1NjaGxpY2s7XG4iLCJpbXBvcnQgeyBGbiB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY29uc3QgQlJERl9MYW1iZXJ0ID0gLypAX19QVVJFX18qLyBGbiggKCBpbnB1dHMgKSA9PiB7XG5cblx0cmV0dXJuIGlucHV0cy5kaWZmdXNlQ29sb3IubXVsKCAxIC8gTWF0aC5QSSApOyAvLyBwdW5jdHVhbCBsaWdodFxuXG59ICk7IC8vIHZhbGlkYXRlZFxuXG5leHBvcnQgZGVmYXVsdCBCUkRGX0xhbWJlcnQ7XG4iLCJpbXBvcnQgQmFzaWNMaWdodGluZ01vZGVsIGZyb20gJy4vQmFzaWNMaWdodGluZ01vZGVsLmpzJztcbmltcG9ydCBGX1NjaGxpY2sgZnJvbSAnLi9CU0RGL0ZfU2NobGljay5qcyc7XG5pbXBvcnQgQlJERl9MYW1iZXJ0IGZyb20gJy4vQlNERi9CUkRGX0xhbWJlcnQuanMnO1xuaW1wb3J0IHsgZGlmZnVzZUNvbG9yIH0gZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtZWROb3JtYWxWaWV3IH0gZnJvbSAnLi4vYWNjZXNzb3JzL05vcm1hbC5qcyc7XG5pbXBvcnQgeyBtYXRlcmlhbFNwZWN1bGFyU3RyZW5ndGggfSBmcm9tICcuLi9hY2Nlc3NvcnMvTWF0ZXJpYWxOb2RlLmpzJztcbmltcG9ydCB7IHNoaW5pbmVzcywgc3BlY3VsYXJDb2xvciB9IGZyb20gJy4uL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcbmltcG9ydCB7IHBvc2l0aW9uVmlld0RpcmVjdGlvbiB9IGZyb20gJy4uL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBGbiwgZmxvYXQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNvbnN0IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCA9ICgpID0+IGZsb2F0KCAwLjI1ICk7XG5cbmNvbnN0IERfQmxpbm5QaG9uZyA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBkb3ROSCB9ICkgPT4ge1xuXG5cdHJldHVybiBzaGluaW5lc3MubXVsKCBmbG9hdCggMC41ICkgKS5hZGQoIDEuMCApLm11bCggZmxvYXQoIDEgLyBNYXRoLlBJICkgKS5tdWwoIGRvdE5ILnBvdyggc2hpbmluZXNzICkgKTtcblxufSApO1xuXG5jb25zdCBCUkRGX0JsaW5uUGhvbmcgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgbGlnaHREaXJlY3Rpb24gfSApID0+IHtcblxuXHRjb25zdCBoYWxmRGlyID0gbGlnaHREaXJlY3Rpb24uYWRkKCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gKS5ub3JtYWxpemUoKTtcblxuXHRjb25zdCBkb3ROSCA9IHRyYW5zZm9ybWVkTm9ybWFsVmlldy5kb3QoIGhhbGZEaXIgKS5jbGFtcCgpO1xuXHRjb25zdCBkb3RWSCA9IHBvc2l0aW9uVmlld0RpcmVjdGlvbi5kb3QoIGhhbGZEaXIgKS5jbGFtcCgpO1xuXG5cdGNvbnN0IEYgPSBGX1NjaGxpY2soIHsgZjA6IHNwZWN1bGFyQ29sb3IsIGY5MDogMS4wLCBkb3RWSCB9ICk7XG5cdGNvbnN0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoKTtcblx0Y29uc3QgRCA9IERfQmxpbm5QaG9uZyggeyBkb3ROSCB9ICk7XG5cblx0cmV0dXJuIEYubXVsKCBHICkubXVsKCBEICk7XG5cbn0gKTtcblxuY2xhc3MgUGhvbmdMaWdodGluZ01vZGVsIGV4dGVuZHMgQmFzaWNMaWdodGluZ01vZGVsIHtcblxuXHRjb25zdHJ1Y3Rvciggc3BlY3VsYXIgPSB0cnVlICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuc3BlY3VsYXIgPSBzcGVjdWxhcjtcblxuXHR9XG5cblx0ZGlyZWN0KCB7IGxpZ2h0RGlyZWN0aW9uLCBsaWdodENvbG9yLCByZWZsZWN0ZWRMaWdodCB9ICkge1xuXG5cdFx0Y29uc3QgZG90TkwgPSB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcuZG90KCBsaWdodERpcmVjdGlvbiApLmNsYW1wKCk7XG5cdFx0Y29uc3QgaXJyYWRpYW5jZSA9IGRvdE5MLm11bCggbGlnaHRDb2xvciApO1xuXG5cdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZS5hZGRBc3NpZ24oIGlycmFkaWFuY2UubXVsKCBCUkRGX0xhbWJlcnQoIHsgZGlmZnVzZUNvbG9yOiBkaWZmdXNlQ29sb3IucmdiIH0gKSApICk7XG5cblx0XHRpZiAoIHRoaXMuc3BlY3VsYXIgPT09IHRydWUgKSB7XG5cblx0XHRcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyLmFkZEFzc2lnbiggaXJyYWRpYW5jZS5tdWwoIEJSREZfQmxpbm5QaG9uZyggeyBsaWdodERpcmVjdGlvbiB9ICkgKS5tdWwoIG1hdGVyaWFsU3BlY3VsYXJTdHJlbmd0aCApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGluZGlyZWN0KCB7IGFtYmllbnRPY2NsdXNpb24sIGlycmFkaWFuY2UsIHJlZmxlY3RlZExpZ2h0IH0gKSB7XG5cblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UuYWRkQXNzaWduKCBpcnJhZGlhbmNlLm11bCggQlJERl9MYW1iZXJ0KCB7IGRpZmZ1c2VDb2xvciB9ICkgKSApO1xuXG5cdFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlLm11bEFzc2lnbiggYW1iaWVudE9jY2x1c2lvbiApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQaG9uZ0xpZ2h0aW5nTW9kZWw7XG4iLCJpbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4vTm9kZU1hdGVyaWFsLmpzJztcbmltcG9ydCBCYXNpY0Vudmlyb25tZW50Tm9kZSBmcm9tICcuLi8uLi9ub2Rlcy9saWdodGluZy9CYXNpY0Vudmlyb25tZW50Tm9kZS5qcyc7XG5pbXBvcnQgUGhvbmdMaWdodGluZ01vZGVsIGZyb20gJy4uLy4uL25vZGVzL2Z1bmN0aW9ucy9QaG9uZ0xpZ2h0aW5nTW9kZWwuanMnO1xuXG5pbXBvcnQgeyBNZXNoTGFtYmVydE1hdGVyaWFsIH0gZnJvbSAnLi4vTWVzaExhbWJlcnRNYXRlcmlhbC5qcyc7XG5cbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgTWVzaExhbWJlcnRNYXRlcmlhbCgpO1xuXG5jbGFzcyBNZXNoTGFtYmVydE5vZGVNYXRlcmlhbCBleHRlbmRzIE5vZGVNYXRlcmlhbCB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdNZXNoTGFtYmVydE5vZGVNYXRlcmlhbCc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNNZXNoTGFtYmVydE5vZGVNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLmxpZ2h0cyA9IHRydWU7XG5cblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRzZXR1cEVudmlyb25tZW50KCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgZW52Tm9kZSA9IHN1cGVyLnNldHVwRW52aXJvbm1lbnQoIGJ1aWxkZXIgKTtcblxuXHRcdHJldHVybiBlbnZOb2RlID8gbmV3IEJhc2ljRW52aXJvbm1lbnROb2RlKCBlbnZOb2RlICkgOiBudWxsO1xuXG5cdH1cblxuXHRzZXR1cExpZ2h0aW5nTW9kZWwoIC8qYnVpbGRlciovICkge1xuXG5cdFx0cmV0dXJuIG5ldyBQaG9uZ0xpZ2h0aW5nTW9kZWwoIGZhbHNlICk7IC8vICggc3BlY3VsYXIgKSAtPiBmb3JjZSBsYW1iZXJ0XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lc2hMYW1iZXJ0Tm9kZU1hdGVyaWFsO1xuIiwiaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuL05vZGVNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBzaGluaW5lc3MsIHNwZWN1bGFyQ29sb3IgfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XG5pbXBvcnQgeyBtYXRlcmlhbFNoaW5pbmVzcywgbWF0ZXJpYWxTcGVjdWxhciB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbE5vZGUuanMnO1xuaW1wb3J0IHsgZmxvYXQgfSBmcm9tICcuLi8uLi9ub2Rlcy90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgQmFzaWNFbnZpcm9ubWVudE5vZGUgZnJvbSAnLi4vLi4vbm9kZXMvbGlnaHRpbmcvQmFzaWNFbnZpcm9ubWVudE5vZGUuanMnO1xuaW1wb3J0IFBob25nTGlnaHRpbmdNb2RlbCBmcm9tICcuLi8uLi9ub2Rlcy9mdW5jdGlvbnMvUGhvbmdMaWdodGluZ01vZGVsLmpzJztcblxuaW1wb3J0IHsgTWVzaFBob25nTWF0ZXJpYWwgfSBmcm9tICcuLi9NZXNoUGhvbmdNYXRlcmlhbC5qcyc7XG5cbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKTtcblxuY2xhc3MgTWVzaFBob25nTm9kZU1hdGVyaWFsIGV4dGVuZHMgTm9kZU1hdGVyaWFsIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ01lc2hQaG9uZ05vZGVNYXRlcmlhbCc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNNZXNoUGhvbmdOb2RlTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy5saWdodHMgPSB0cnVlO1xuXG5cdFx0dGhpcy5zaGluaW5lc3NOb2RlID0gbnVsbDtcblx0XHR0aGlzLnNwZWN1bGFyTm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRzZXR1cEVudmlyb25tZW50KCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgZW52Tm9kZSA9IHN1cGVyLnNldHVwRW52aXJvbm1lbnQoIGJ1aWxkZXIgKTtcblxuXHRcdHJldHVybiBlbnZOb2RlID8gbmV3IEJhc2ljRW52aXJvbm1lbnROb2RlKCBlbnZOb2RlICkgOiBudWxsO1xuXG5cdH1cblxuXHRzZXR1cExpZ2h0aW5nTW9kZWwoIC8qYnVpbGRlciovICkge1xuXG5cdFx0cmV0dXJuIG5ldyBQaG9uZ0xpZ2h0aW5nTW9kZWwoKTtcblxuXHR9XG5cblx0c2V0dXBWYXJpYW50cygpIHtcblxuXHRcdC8vIFNISU5JTkVTU1xuXG5cdFx0Y29uc3Qgc2hpbmluZXNzTm9kZSA9ICggdGhpcy5zaGluaW5lc3NOb2RlID8gZmxvYXQoIHRoaXMuc2hpbmluZXNzTm9kZSApIDogbWF0ZXJpYWxTaGluaW5lc3MgKS5tYXgoIDFlLTQgKTsgLy8gdG8gcHJldmVudCBwb3coIDAuMCwgMC4wIClcblxuXHRcdHNoaW5pbmVzcy5hc3NpZ24oIHNoaW5pbmVzc05vZGUgKTtcblxuXHRcdC8vIFNQRUNVTEFSIENPTE9SXG5cblx0XHRjb25zdCBzcGVjdWxhck5vZGUgPSB0aGlzLnNwZWN1bGFyTm9kZSB8fCBtYXRlcmlhbFNwZWN1bGFyO1xuXG5cdFx0c3BlY3VsYXJDb2xvci5hc3NpZ24oIHNwZWN1bGFyTm9kZSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLnNoaW5pbmVzc05vZGUgPSBzb3VyY2Uuc2hpbmluZXNzTm9kZTtcblx0XHR0aGlzLnNwZWN1bGFyTm9kZSA9IHNvdXJjZS5zcGVjdWxhck5vZGU7XG5cblx0XHRyZXR1cm4gc3VwZXIuY29weSggc291cmNlICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lc2hQaG9uZ05vZGVNYXRlcmlhbDtcbiIsImltcG9ydCB7IG5vcm1hbFZpZXcgfSBmcm9tICcuLi8uLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcbmltcG9ydCB7IGZsb2F0LCBGbiB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY29uc3QgZ2V0R2VvbWV0cnlSb3VnaG5lc3MgPSAvKkBfX1BVUkVfXyovIEZuKCAoIGJ1aWxkZXIgKSA9PiB7XG5cblx0aWYgKCBidWlsZGVyLmdlb21ldHJ5Lmhhc0F0dHJpYnV0ZSggJ25vcm1hbCcgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRyZXR1cm4gZmxvYXQoIDAgKTtcblxuXHR9XG5cblx0Y29uc3QgZHh5ID0gbm9ybWFsVmlldy5kRmR4KCkuYWJzKCkubWF4KCBub3JtYWxWaWV3LmRGZHkoKS5hYnMoKSApO1xuXHRjb25zdCBnZW9tZXRyeVJvdWdobmVzcyA9IGR4eS54Lm1heCggZHh5LnkgKS5tYXgoIGR4eS56ICk7XG5cblx0cmV0dXJuIGdlb21ldHJ5Um91Z2huZXNzO1xuXG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldEdlb21ldHJ5Um91Z2huZXNzO1xuIiwiaW1wb3J0IGdldEdlb21ldHJ5Um91Z2huZXNzIGZyb20gJy4vZ2V0R2VvbWV0cnlSb3VnaG5lc3MuanMnO1xuaW1wb3J0IHsgRm4gfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNvbnN0IGdldFJvdWdobmVzcyA9IC8qQF9fUFVSRV9fKi8gRm4oICggaW5wdXRzICkgPT4ge1xuXG5cdGNvbnN0IHsgcm91Z2huZXNzIH0gPSBpbnB1dHM7XG5cblx0Y29uc3QgZ2VvbWV0cnlSb3VnaG5lc3MgPSBnZXRHZW9tZXRyeVJvdWdobmVzcygpO1xuXG5cdGxldCByb3VnaG5lc3NGYWN0b3IgPSByb3VnaG5lc3MubWF4KCAwLjA1MjUgKTsgLy8gMC4wNTI1IGNvcnJlc3BvbmRzIHRvIHRoZSBiYXNlIG1pcCBvZiBhIDI1NiBjdWJlbWFwLlxuXHRyb3VnaG5lc3NGYWN0b3IgPSByb3VnaG5lc3NGYWN0b3IuYWRkKCBnZW9tZXRyeVJvdWdobmVzcyApO1xuXHRyb3VnaG5lc3NGYWN0b3IgPSByb3VnaG5lc3NGYWN0b3IubWluKCAxLjAgKTtcblxuXHRyZXR1cm4gcm91Z2huZXNzRmFjdG9yO1xuXG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJvdWdobmVzcztcbiIsImltcG9ydCB7IGRpdiB9IGZyb20gJy4uLy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJztcbmltcG9ydCB7IEVQU0lMT04gfSBmcm9tICcuLi8uLi9tYXRoL01hdGhOb2RlLmpzJztcbmltcG9ydCB7IEZuIH0gZnJvbSAnLi4vLi4vdHNsL1RTTEJhc2UuanMnO1xuXG4vLyBNb3ZpbmcgRnJvc3RiaXRlIHRvIFBoeXNpY2FsbHkgQmFzZWQgUmVuZGVyaW5nIDMuMCAtIHBhZ2UgMTIsIGxpc3RpbmcgMlxuLy8gaHR0cHM6Ly9zZWJsYWdhcmRlLmZpbGVzLndvcmRwcmVzcy5jb20vMjAxNS8wNy9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnJfdjMyLnBkZlxuY29uc3QgVl9HR1hfU21pdGhDb3JyZWxhdGVkID0gLypAX19QVVJFX18qLyBGbiggKCB7IGFscGhhLCBkb3ROTCwgZG90TlYgfSApID0+IHtcblxuXHRjb25zdCBhMiA9IGFscGhhLnBvdzIoKTtcblxuXHRjb25zdCBndiA9IGRvdE5MLm11bCggYTIuYWRkKCBhMi5vbmVNaW51cygpLm11bCggZG90TlYucG93MigpICkgKS5zcXJ0KCkgKTtcblx0Y29uc3QgZ2wgPSBkb3ROVi5tdWwoIGEyLmFkZCggYTIub25lTWludXMoKS5tdWwoIGRvdE5MLnBvdzIoKSApICkuc3FydCgpICk7XG5cblx0cmV0dXJuIGRpdiggMC41LCBndi5hZGQoIGdsICkubWF4KCBFUFNJTE9OICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnVl9HR1hfU21pdGhDb3JyZWxhdGVkJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAnZG90TkwnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAnZG90TlYnLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApOyAvLyB2YWxpZGF0ZWRcblxuZXhwb3J0IGRlZmF1bHQgVl9HR1hfU21pdGhDb3JyZWxhdGVkO1xuIiwiaW1wb3J0IHsgZGl2IH0gZnJvbSAnLi4vLi4vbWF0aC9PcGVyYXRvck5vZGUuanMnO1xuaW1wb3J0IHsgRm4sIHZlYzMgfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XG5cbi8vIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9maWxhbWVudC9GaWxhbWVudC5tZC5odG1sI21hdGVyaWFsc3lzdGVtL2FuaXNvdHJvcGljbW9kZWwvYW5pc290cm9waWNzcGVjdWxhcmJyZGZcblxuY29uc3QgVl9HR1hfU21pdGhDb3JyZWxhdGVkX0FuaXNvdHJvcGljID0gLypAX19QVVJFX18qLyBGbiggKCB7IGFscGhhVCwgYWxwaGFCLCBkb3RUViwgZG90QlYsIGRvdFRMLCBkb3RCTCwgZG90TlYsIGRvdE5MIH0gKSA9PiB7XG5cblx0Y29uc3QgZ3YgPSBkb3ROTC5tdWwoIHZlYzMoIGFscGhhVC5tdWwoIGRvdFRWICksIGFscGhhQi5tdWwoIGRvdEJWICksIGRvdE5WICkubGVuZ3RoKCkgKTtcblx0Y29uc3QgZ2wgPSBkb3ROVi5tdWwoIHZlYzMoIGFscGhhVC5tdWwoIGRvdFRMICksIGFscGhhQi5tdWwoIGRvdEJMICksIGRvdE5MICkubGVuZ3RoKCkgKTtcblx0Y29uc3QgdiA9IGRpdiggMC41LCBndi5hZGQoIGdsICkgKTtcblxuXHRyZXR1cm4gdi5zYXR1cmF0ZSgpO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdWX0dHWF9TbWl0aENvcnJlbGF0ZWRfQW5pc290cm9waWMnLFxuXHR0eXBlOiAnZmxvYXQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdhbHBoYVQnLCB0eXBlOiAnZmxvYXQnLCBxdWFsaWZpZXI6ICdpbicgfSxcblx0XHR7IG5hbWU6ICdhbHBoYUInLCB0eXBlOiAnZmxvYXQnLCBxdWFsaWZpZXI6ICdpbicgfSxcblx0XHR7IG5hbWU6ICdkb3RUVicsIHR5cGU6ICdmbG9hdCcsIHF1YWxpZmllcjogJ2luJyB9LFxuXHRcdHsgbmFtZTogJ2RvdEJWJywgdHlwZTogJ2Zsb2F0JywgcXVhbGlmaWVyOiAnaW4nIH0sXG5cdFx0eyBuYW1lOiAnZG90VEwnLCB0eXBlOiAnZmxvYXQnLCBxdWFsaWZpZXI6ICdpbicgfSxcblx0XHR7IG5hbWU6ICdkb3RCTCcsIHR5cGU6ICdmbG9hdCcsIHF1YWxpZmllcjogJ2luJyB9LFxuXHRcdHsgbmFtZTogJ2RvdE5WJywgdHlwZTogJ2Zsb2F0JywgcXVhbGlmaWVyOiAnaW4nIH0sXG5cdFx0eyBuYW1lOiAnZG90TkwnLCB0eXBlOiAnZmxvYXQnLCBxdWFsaWZpZXI6ICdpbicgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IFZfR0dYX1NtaXRoQ29ycmVsYXRlZF9Bbmlzb3Ryb3BpYztcbiIsImltcG9ydCB7IEZuIH0gZnJvbSAnLi4vLi4vdHNsL1RTTEJhc2UuanMnO1xuXG4vLyBNaWNyb2ZhY2V0IE1vZGVscyBmb3IgUmVmcmFjdGlvbiB0aHJvdWdoIFJvdWdoIFN1cmZhY2VzIC0gZXF1YXRpb24gKDMzKVxuLy8gaHR0cDovL2dyYXBoaWNyYW50cy5ibG9nc3BvdC5jb20vMjAxMy8wOC9zcGVjdWxhci1icmRmLXJlZmVyZW5jZS5odG1sXG4vLyBhbHBoYSBpcyBcInJvdWdobmVzcyBzcXVhcmVkXCIgaW4gRGlzbmV54oCZcyByZXBhcmFtZXRlcml6YXRpb25cbmNvbnN0IERfR0dYID0gLypAX19QVVJFX18qLyBGbiggKCB7IGFscGhhLCBkb3ROSCB9ICkgPT4ge1xuXG5cdGNvbnN0IGEyID0gYWxwaGEucG93MigpO1xuXG5cdGNvbnN0IGRlbm9tID0gZG90TkgucG93MigpLm11bCggYTIub25lTWludXMoKSApLm9uZU1pbnVzKCk7IC8vIGF2b2lkIGFscGhhID0gMCB3aXRoIGRvdE5IID0gMVxuXG5cdHJldHVybiBhMi5kaXYoIGRlbm9tLnBvdzIoKSApLm11bCggMSAvIE1hdGguUEkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnRF9HR1gnLFxuXHR0eXBlOiAnZmxvYXQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICdkb3ROSCcsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7IC8vIHZhbGlkYXRlZFxuXG5leHBvcnQgZGVmYXVsdCBEX0dHWDtcbiIsImltcG9ydCB7IEZuLCBmbG9hdCwgdmVjMyB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY29uc3QgUkVDSVBST0NBTF9QSSA9IC8qQF9fUFVSRV9fKi8gZmxvYXQoIDEgLyBNYXRoLlBJICk7XG5cbi8vIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9maWxhbWVudC9GaWxhbWVudC5tZC5odG1sI21hdGVyaWFsc3lzdGVtL2FuaXNvdHJvcGljbW9kZWwvYW5pc290cm9waWNzcGVjdWxhcmJyZGZcblxuY29uc3QgRF9HR1hfQW5pc290cm9waWMgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgYWxwaGFULCBhbHBoYUIsIGRvdE5ILCBkb3RUSCwgZG90QkggfSApID0+IHtcblxuXHRjb25zdCBhMiA9IGFscGhhVC5tdWwoIGFscGhhQiApO1xuXHRjb25zdCB2ID0gdmVjMyggYWxwaGFCLm11bCggZG90VEggKSwgYWxwaGFULm11bCggZG90QkggKSwgYTIubXVsKCBkb3ROSCApICk7XG5cdGNvbnN0IHYyID0gdi5kb3QoIHYgKTtcblx0Y29uc3QgdzIgPSBhMi5kaXYoIHYyICk7XG5cblx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkubXVsKCBhMi5tdWwoIHcyLnBvdzIoKSApICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ0RfR0dYX0FuaXNvdHJvcGljJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnYWxwaGFUJywgdHlwZTogJ2Zsb2F0JywgcXVhbGlmaWVyOiAnaW4nIH0sXG5cdFx0eyBuYW1lOiAnYWxwaGFCJywgdHlwZTogJ2Zsb2F0JywgcXVhbGlmaWVyOiAnaW4nIH0sXG5cdFx0eyBuYW1lOiAnZG90TkgnLCB0eXBlOiAnZmxvYXQnLCBxdWFsaWZpZXI6ICdpbicgfSxcblx0XHR7IG5hbWU6ICdkb3RUSCcsIHR5cGU6ICdmbG9hdCcsIHF1YWxpZmllcjogJ2luJyB9LFxuXHRcdHsgbmFtZTogJ2RvdEJIJywgdHlwZTogJ2Zsb2F0JywgcXVhbGlmaWVyOiAnaW4nIH1cblx0XVxufSApO1xuXG5leHBvcnQgZGVmYXVsdCBEX0dHWF9Bbmlzb3Ryb3BpYztcbiIsImltcG9ydCBGX1NjaGxpY2sgZnJvbSAnLi9GX1NjaGxpY2suanMnO1xuaW1wb3J0IFZfR0dYX1NtaXRoQ29ycmVsYXRlZCBmcm9tICcuL1ZfR0dYX1NtaXRoQ29ycmVsYXRlZC5qcyc7XG5pbXBvcnQgVl9HR1hfU21pdGhDb3JyZWxhdGVkX0FuaXNvdHJvcGljIGZyb20gJy4vVl9HR1hfU21pdGhDb3JyZWxhdGVkX0FuaXNvdHJvcGljLmpzJztcbmltcG9ydCBEX0dHWCBmcm9tICcuL0RfR0dYLmpzJztcbmltcG9ydCBEX0dHWF9Bbmlzb3Ryb3BpYyBmcm9tICcuL0RfR0dYX0FuaXNvdHJvcGljLmpzJztcbmltcG9ydCB7IHRyYW5zZm9ybWVkTm9ybWFsVmlldyB9IGZyb20gJy4uLy4uL2FjY2Vzc29ycy9Ob3JtYWwuanMnO1xuaW1wb3J0IHsgcG9zaXRpb25WaWV3RGlyZWN0aW9uIH0gZnJvbSAnLi4vLi4vYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IGlyaWRlc2NlbmNlLCBhbHBoYVQsIGFuaXNvdHJvcHlULCBhbmlzb3Ryb3B5QiB9IGZyb20gJy4uLy4uL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcbmltcG9ydCB7IEZuLCBkZWZpbmVkIH0gZnJvbSAnLi4vLi4vdHNsL1RTTEJhc2UuanMnO1xuXG4vLyBHR1ggRGlzdHJpYnV0aW9uLCBTY2hsaWNrIEZyZXNuZWwsIEdHWF9TbWl0aENvcnJlbGF0ZWQgVmlzaWJpbGl0eVxuY29uc3QgQlJERl9HR1ggPSAvKkBfX1BVUkVfXyovIEZuKCAoIGlucHV0cyApID0+IHtcblxuXHRjb25zdCB7IGxpZ2h0RGlyZWN0aW9uLCBmMCwgZjkwLCByb3VnaG5lc3MsIGYsIFVTRV9JUklERVNDRU5DRSwgVVNFX0FOSVNPVFJPUFkgfSA9IGlucHV0cztcblxuXHRjb25zdCBub3JtYWxWaWV3ID0gaW5wdXRzLm5vcm1hbFZpZXcgfHwgdHJhbnNmb3JtZWROb3JtYWxWaWV3O1xuXG5cdGNvbnN0IGFscGhhID0gcm91Z2huZXNzLnBvdzIoKTsgLy8gVUU0J3Mgcm91Z2huZXNzXG5cblx0Y29uc3QgaGFsZkRpciA9IGxpZ2h0RGlyZWN0aW9uLmFkZCggcG9zaXRpb25WaWV3RGlyZWN0aW9uICkubm9ybWFsaXplKCk7XG5cblx0Y29uc3QgZG90TkwgPSBub3JtYWxWaWV3LmRvdCggbGlnaHREaXJlY3Rpb24gKS5jbGFtcCgpO1xuXHRjb25zdCBkb3ROViA9IG5vcm1hbFZpZXcuZG90KCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gKS5jbGFtcCgpOyAvLyBAIFRPRE86IE1vdmUgdG8gY29yZSBkb3ROVlxuXHRjb25zdCBkb3ROSCA9IG5vcm1hbFZpZXcuZG90KCBoYWxmRGlyICkuY2xhbXAoKTtcblx0Y29uc3QgZG90VkggPSBwb3NpdGlvblZpZXdEaXJlY3Rpb24uZG90KCBoYWxmRGlyICkuY2xhbXAoKTtcblxuXHRsZXQgRiA9IEZfU2NobGljayggeyBmMCwgZjkwLCBkb3RWSCB9ICk7XG5cdGxldCBWLCBEO1xuXG5cdGlmICggZGVmaW5lZCggVVNFX0lSSURFU0NFTkNFICkgKSB7XG5cblx0XHRGID0gaXJpZGVzY2VuY2UubWl4KCBGLCBmICk7XG5cblx0fVxuXG5cdGlmICggZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKSApIHtcblxuXHRcdGNvbnN0IGRvdFRMID0gYW5pc290cm9weVQuZG90KCBsaWdodERpcmVjdGlvbiApO1xuXHRcdGNvbnN0IGRvdFRWID0gYW5pc290cm9weVQuZG90KCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gKTtcblx0XHRjb25zdCBkb3RUSCA9IGFuaXNvdHJvcHlULmRvdCggaGFsZkRpciApO1xuXHRcdGNvbnN0IGRvdEJMID0gYW5pc290cm9weUIuZG90KCBsaWdodERpcmVjdGlvbiApO1xuXHRcdGNvbnN0IGRvdEJWID0gYW5pc290cm9weUIuZG90KCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gKTtcblx0XHRjb25zdCBkb3RCSCA9IGFuaXNvdHJvcHlCLmRvdCggaGFsZkRpciApO1xuXG5cdFx0ViA9IFZfR0dYX1NtaXRoQ29ycmVsYXRlZF9Bbmlzb3Ryb3BpYyggeyBhbHBoYVQsIGFscGhhQjogYWxwaGEsIGRvdFRWLCBkb3RCViwgZG90VEwsIGRvdEJMLCBkb3ROViwgZG90TkwgfSApO1xuXHRcdEQgPSBEX0dHWF9Bbmlzb3Ryb3BpYyggeyBhbHBoYVQsIGFscGhhQjogYWxwaGEsIGRvdE5ILCBkb3RUSCwgZG90QkggfSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkKCB7IGFscGhhLCBkb3ROTCwgZG90TlYgfSApO1xuXHRcdEQgPSBEX0dHWCggeyBhbHBoYSwgZG90TkggfSApO1xuXG5cdH1cblxuXHRyZXR1cm4gRi5tdWwoIFYgKS5tdWwoIEQgKTtcblxufSApOyAvLyB2YWxpZGF0ZWRcblxuZXhwb3J0IGRlZmF1bHQgQlJERl9HR1g7XG4iLCJpbXBvcnQgeyBGbiwgdmVjMiwgdmVjNCB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcblxuLy8gQW5hbHl0aWNhbCBhcHByb3hpbWF0aW9uIG9mIHRoZSBERkcgTFVULCBvbmUgaGFsZiBvZiB0aGVcbi8vIHNwbGl0LXN1bSBhcHByb3hpbWF0aW9uIHVzZWQgaW4gaW5kaXJlY3Qgc3BlY3VsYXIgbGlnaHRpbmcuXG4vLyB2aWEgJ2Vudmlyb25tZW50QlJERicgZnJvbSBcIlBoeXNpY2FsbHkgQmFzZWQgU2hhZGluZyBvbiBNb2JpbGVcIlxuLy8gaHR0cHM6Ly93d3cudW5yZWFsZW5naW5lLmNvbS9ibG9nL3BoeXNpY2FsbHktYmFzZWQtc2hhZGluZy1vbi1tb2JpbGVcbmNvbnN0IERGR0FwcHJveCA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyByb3VnaG5lc3MsIGRvdE5WIH0gKSA9PiB7XG5cblx0Y29uc3QgYzAgPSB2ZWM0KCAtIDEsIC0gMC4wMjc1LCAtIDAuNTcyLCAwLjAyMiApO1xuXG5cdGNvbnN0IGMxID0gdmVjNCggMSwgMC4wNDI1LCAxLjA0LCAtIDAuMDQgKTtcblxuXHRjb25zdCByID0gcm91Z2huZXNzLm11bCggYzAgKS5hZGQoIGMxICk7XG5cblx0Y29uc3QgYTAwNCA9IHIueC5tdWwoIHIueCApLm1pbiggZG90TlYubXVsKCAtIDkuMjggKS5leHAyKCkgKS5tdWwoIHIueCApLmFkZCggci55ICk7XG5cblx0Y29uc3QgZmFiID0gdmVjMiggLSAxLjA0LCAxLjA0ICkubXVsKCBhMDA0ICkuYWRkKCByLnp3ICk7XG5cblx0cmV0dXJuIGZhYjtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnREZHQXBwcm94Jyxcblx0dHlwZTogJ3ZlYzInLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdyb3VnaG5lc3MnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAnZG90TlYnLCB0eXBlOiAndmVjMycgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IERGR0FwcHJveDtcbiIsImltcG9ydCBERkdBcHByb3ggZnJvbSAnLi9ERkdBcHByb3guanMnO1xuaW1wb3J0IHsgRm4gfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNvbnN0IEVudmlyb25tZW50QlJERiA9IC8qQF9fUFVSRV9fKi8gRm4oICggaW5wdXRzICkgPT4ge1xuXG5cdGNvbnN0IHsgZG90TlYsIHNwZWN1bGFyQ29sb3IsIHNwZWN1bGFyRjkwLCByb3VnaG5lc3MgfSA9IGlucHV0cztcblxuXHRjb25zdCBmYWIgPSBERkdBcHByb3goIHsgZG90TlYsIHJvdWdobmVzcyB9ICk7XG5cdHJldHVybiBzcGVjdWxhckNvbG9yLm11bCggZmFiLnggKS5hZGQoIHNwZWN1bGFyRjkwLm11bCggZmFiLnkgKSApO1xuXG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IEVudmlyb25tZW50QlJERjtcbiIsImltcG9ydCB7IEZuLCB2ZWMzIH0gZnJvbSAnLi4vLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5jb25zdCBTY2hsaWNrX3RvX0YwID0gLypAX19QVVJFX18qLyBGbiggKCB7IGYsIGY5MCwgZG90VkggfSApID0+IHtcblxuXHRjb25zdCB4ID0gZG90Vkgub25lTWludXMoKS5zYXR1cmF0ZSgpO1xuXHRjb25zdCB4MiA9IHgubXVsKCB4ICk7XG5cdGNvbnN0IHg1ID0geC5tdWwoIHgyLCB4MiApLmNsYW1wKCAwLCAuOTk5OSApO1xuXG5cdHJldHVybiBmLnN1YiggdmVjMyggZjkwICkubXVsKCB4NSApICkuZGl2KCB4NS5vbmVNaW51cygpICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ1NjaGxpY2tfdG9fRjAnLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ2YnLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICdmOTAnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAnZG90VkgnLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG5leHBvcnQgZGVmYXVsdCBTY2hsaWNrX3RvX0YwO1xuIiwiaW1wb3J0IHsgdHJhbnNmb3JtZWROb3JtYWxWaWV3IH0gZnJvbSAnLi4vLi4vYWNjZXNzb3JzL05vcm1hbC5qcyc7XG5pbXBvcnQgeyBwb3NpdGlvblZpZXdEaXJlY3Rpb24gfSBmcm9tICcuLi8uLi9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgc2hlZW4sIHNoZWVuUm91Z2huZXNzIH0gZnJvbSAnLi4vLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xuaW1wb3J0IHsgRm4sIGZsb2F0IH0gZnJvbSAnLi4vLi4vdHNsL1RTTEJhc2UuanMnO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2ZpbGFtZW50L2Jsb2IvbWFzdGVyL3NoYWRlcnMvc3JjL2JyZGYuZnNcbmNvbnN0IERfQ2hhcmxpZSA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyByb3VnaG5lc3MsIGRvdE5IIH0gKSA9PiB7XG5cblx0Y29uc3QgYWxwaGEgPSByb3VnaG5lc3MucG93MigpO1xuXG5cdC8vIEVzdGV2ZXogYW5kIEt1bGxhIDIwMTcsIFwiUHJvZHVjdGlvbiBGcmllbmRseSBNaWNyb2ZhY2V0IFNoZWVuIEJSREZcIlxuXHRjb25zdCBpbnZBbHBoYSA9IGZsb2F0KCAxLjAgKS5kaXYoIGFscGhhICk7XG5cdGNvbnN0IGNvczJoID0gZG90TkgucG93MigpO1xuXHRjb25zdCBzaW4yaCA9IGNvczJoLm9uZU1pbnVzKCkubWF4KCAwLjAwNzgxMjUgKTsgLy8gMl4oLTE0LzIpLCBzbyBzaW4yaF4yID4gMCBpbiBmcDE2XG5cblx0cmV0dXJuIGZsb2F0KCAyLjAgKS5hZGQoIGludkFscGhhICkubXVsKCBzaW4yaC5wb3coIGludkFscGhhLm11bCggMC41ICkgKSApLmRpdiggMi4wICogTWF0aC5QSSApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdEX0NoYXJsaWUnLFxuXHR0eXBlOiAnZmxvYXQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdyb3VnaG5lc3MnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAnZG90TkgnLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2ZpbGFtZW50L2Jsb2IvbWFzdGVyL3NoYWRlcnMvc3JjL2JyZGYuZnNcbmNvbnN0IFZfTmV1YmVsdCA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBkb3ROViwgZG90TkwgfSApID0+IHtcblxuXHQvLyBOZXViZWx0IGFuZCBQZXR0aW5lbyAyMDEzLCBcIkNyYWZ0aW5nIGEgTmV4dC1nZW4gTWF0ZXJpYWwgUGlwZWxpbmUgZm9yIFRoZSBPcmRlcjogMTg4NlwiXG5cdHJldHVybiBmbG9hdCggMS4wICkuZGl2KCBmbG9hdCggNC4wICkubXVsKCBkb3ROTC5hZGQoIGRvdE5WICkuc3ViKCBkb3ROTC5tdWwoIGRvdE5WICkgKSApICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ1ZfTmV1YmVsdCcsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ2RvdE5WJywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ2RvdE5MJywgdHlwZTogJ2Zsb2F0JyB9XG5cdF1cbn0gKTtcblxuY29uc3QgQlJERl9TaGVlbiA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBsaWdodERpcmVjdGlvbiB9ICkgPT4ge1xuXG5cdGNvbnN0IGhhbGZEaXIgPSBsaWdodERpcmVjdGlvbi5hZGQoIHBvc2l0aW9uVmlld0RpcmVjdGlvbiApLm5vcm1hbGl6ZSgpO1xuXG5cdGNvbnN0IGRvdE5MID0gdHJhbnNmb3JtZWROb3JtYWxWaWV3LmRvdCggbGlnaHREaXJlY3Rpb24gKS5jbGFtcCgpO1xuXHRjb25zdCBkb3ROViA9IHRyYW5zZm9ybWVkTm9ybWFsVmlldy5kb3QoIHBvc2l0aW9uVmlld0RpcmVjdGlvbiApLmNsYW1wKCk7XG5cdGNvbnN0IGRvdE5IID0gdHJhbnNmb3JtZWROb3JtYWxWaWV3LmRvdCggaGFsZkRpciApLmNsYW1wKCk7XG5cblx0Y29uc3QgRCA9IERfQ2hhcmxpZSggeyByb3VnaG5lc3M6IHNoZWVuUm91Z2huZXNzLCBkb3ROSCB9ICk7XG5cdGNvbnN0IFYgPSBWX05ldWJlbHQoIHsgZG90TlYsIGRvdE5MIH0gKTtcblxuXHRyZXR1cm4gc2hlZW4ubXVsKCBEICkubXVsKCBWICk7XG5cbn0gKTtcblxuZXhwb3J0IGRlZmF1bHQgQlJERl9TaGVlbjtcbiIsImltcG9ydCB7IEZuLCBJZiwgbWF0MywgdmVjMiwgdmVjMyB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IG1heCB9IGZyb20gJy4uLy4uL21hdGgvTWF0aE5vZGUuanMnO1xuXG4vLyBSZWN0IEFyZWEgTGlnaHRcblxuLy8gUmVhbC1UaW1lIFBvbHlnb25hbC1MaWdodCBTaGFkaW5nIHdpdGggTGluZWFybHkgVHJhbnNmb3JtZWQgQ29zaW5lc1xuLy8gYnkgRXJpYyBIZWl0eiwgSm9uYXRoYW4gRHVwdXksIFN0ZXBoZW4gSGlsbCBhbmQgRGF2aWQgTmV1YmVsdFxuLy8gY29kZTogaHR0cHM6Ly9naXRodWIuY29tL3NlbGZzaGFkb3cvbHRjX2NvZGUvXG5cbmNvbnN0IExUQ19VdiA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBOLCBWLCByb3VnaG5lc3MgfSApID0+IHtcblxuXHRjb25zdCBMVVRfU0laRSA9IDY0LjA7XG5cdGNvbnN0IExVVF9TQ0FMRSA9ICggTFVUX1NJWkUgLSAxLjAgKSAvIExVVF9TSVpFO1xuXHRjb25zdCBMVVRfQklBUyA9IDAuNSAvIExVVF9TSVpFO1xuXG5cdGNvbnN0IGRvdE5WID0gTi5kb3QoIFYgKS5zYXR1cmF0ZSgpO1xuXG5cdC8vIHRleHR1cmUgcGFyYW1ldGVyaXplZCBieSBzcXJ0KCBHR1ggYWxwaGEgKSBhbmQgc3FydCggMSAtIGNvcyggdGhldGEgKSApXG5cdGNvbnN0IHV2ID0gdmVjMiggcm91Z2huZXNzLCBkb3ROVi5vbmVNaW51cygpLnNxcnQoKSApO1xuXG5cdHV2LmFzc2lnbiggdXYubXVsKCBMVVRfU0NBTEUgKS5hZGQoIExVVF9CSUFTICkgKTtcblxuXHRyZXR1cm4gdXY7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ0xUQ19VdicsXG5cdHR5cGU6ICd2ZWMyJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnTicsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ1YnLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICdyb3VnaG5lc3MnLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG5jb25zdCBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgZiB9ICkgPT4ge1xuXG5cdC8vIFJlYWwtVGltZSBBcmVhIExpZ2h0aW5nOiBhIEpvdXJuZXkgZnJvbSBSZXNlYXJjaCB0byBQcm9kdWN0aW9uIChwLjEwMilcblx0Ly8gQW4gYXBwcm94aW1hdGlvbiBvZiB0aGUgZm9ybSBmYWN0b3Igb2YgYSBob3Jpem9uLWNsaXBwZWQgcmVjdGFuZ2xlLlxuXG5cdGNvbnN0IGwgPSBmLmxlbmd0aCgpO1xuXG5cdHJldHVybiBtYXgoIGwubXVsKCBsICkuYWRkKCBmLnogKS5kaXYoIGwuYWRkKCAxLjAgKSApLCAwICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ0xUQ19DbGlwcGVkU3BoZXJlRm9ybUZhY3RvcicsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ2YnLCB0eXBlOiAndmVjMycgfVxuXHRdXG59ICk7XG5cbmNvbnN0IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyB2MSwgdjIgfSApID0+IHtcblxuXHRjb25zdCB4ID0gdjEuZG90KCB2MiApO1xuXHRjb25zdCB5ID0geC5hYnMoKS50b1ZhcigpO1xuXG5cdC8vIHJhdGlvbmFsIHBvbHlub21pYWwgYXBwcm94aW1hdGlvbiB0byB0aGV0YSAvIHNpbiggdGhldGEgKSAvIDJQSVxuXHRjb25zdCBhID0geS5tdWwoIDAuMDE0NTIwNiApLmFkZCggMC40OTY1MTU1ICkubXVsKCB5ICkuYWRkKCAwLjg1NDM5ODUgKS50b1ZhcigpO1xuXHRjb25zdCBiID0geS5hZGQoIDQuMTYxNjcyNCApLm11bCggeSApLmFkZCggMy40MTc1OTQwICkudG9WYXIoKTtcblx0Y29uc3QgdiA9IGEuZGl2KCBiICk7XG5cblx0Y29uc3QgdGhldGFfc2ludGhldGEgPSB4LmdyZWF0ZXJUaGFuKCAwLjAgKS5zZWxlY3QoIHYsIG1heCggeC5tdWwoIHggKS5vbmVNaW51cygpLCAxZS03ICkuaW52ZXJzZVNxcnQoKS5tdWwoIDAuNSApLnN1YiggdiApICk7XG5cblx0cmV0dXJuIHYxLmNyb3NzKCB2MiApLm11bCggdGhldGFfc2ludGhldGEgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yJyxcblx0dHlwZTogJ3ZlYzMnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICd2MScsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ3YyJywgdHlwZTogJ3ZlYzMnIH1cblx0XVxufSApO1xuXG5jb25zdCBMVENfRXZhbHVhdGUgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgTiwgViwgUCwgbUludiwgcDAsIHAxLCBwMiwgcDMgfSApID0+IHtcblxuXHQvLyBiYWlsIGlmIHBvaW50IGlzIG9uIGJhY2sgc2lkZSBvZiBwbGFuZSBvZiBsaWdodFxuXHQvLyBhc3N1bWVzIGNjdyB3aW5kaW5nIG9yZGVyIG9mIGxpZ2h0IHZlcnRpY2VzXG5cdGNvbnN0IHYxID0gcDEuc3ViKCBwMCApLnRvVmFyKCk7XG5cdGNvbnN0IHYyID0gcDMuc3ViKCBwMCApLnRvVmFyKCk7XG5cblx0Y29uc3QgbGlnaHROb3JtYWwgPSB2MS5jcm9zcyggdjIgKTtcblx0Y29uc3QgcmVzdWx0ID0gdmVjMygpLnRvVmFyKCk7XG5cblx0SWYoIGxpZ2h0Tm9ybWFsLmRvdCggUC5zdWIoIHAwICkgKS5ncmVhdGVyVGhhbkVxdWFsKCAwLjAgKSwgKCkgPT4ge1xuXG5cdFx0Ly8gY29uc3RydWN0IG9ydGhvbm9ybWFsIGJhc2lzIGFyb3VuZCBOXG5cdFx0Y29uc3QgVDEgPSBWLnN1YiggTi5tdWwoIFYuZG90KCBOICkgKSApLm5vcm1hbGl6ZSgpO1xuXHRcdGNvbnN0IFQyID0gTi5jcm9zcyggVDEgKS5uZWdhdGUoKTsgLy8gbmVnYXRlZCBmcm9tIHBhcGVyOyBwb3NzaWJseSBkdWUgdG8gYSBkaWZmZXJlbnQgaGFuZGVkbmVzcyBvZiB3b3JsZCBjb29yZGluYXRlIHN5c3RlbVxuXG5cdFx0Ly8gY29tcHV0ZSB0cmFuc2Zvcm1cblx0XHRjb25zdCBtYXQgPSBtSW52Lm11bCggbWF0MyggVDEsIFQyLCBOICkudHJhbnNwb3NlKCkgKS50b1ZhcigpO1xuXG5cdFx0Ly8gdHJhbnNmb3JtIHJlY3Rcblx0XHQvLyAmIHByb2plY3QgcmVjdCBvbnRvIHNwaGVyZVxuXHRcdGNvbnN0IGNvb3JkczAgPSBtYXQubXVsKCBwMC5zdWIoIFAgKSApLm5vcm1hbGl6ZSgpLnRvVmFyKCk7XG5cdFx0Y29uc3QgY29vcmRzMSA9IG1hdC5tdWwoIHAxLnN1YiggUCApICkubm9ybWFsaXplKCkudG9WYXIoKTtcblx0XHRjb25zdCBjb29yZHMyID0gbWF0Lm11bCggcDIuc3ViKCBQICkgKS5ub3JtYWxpemUoKS50b1ZhcigpO1xuXHRcdGNvbnN0IGNvb3JkczMgPSBtYXQubXVsKCBwMy5zdWIoIFAgKSApLm5vcm1hbGl6ZSgpLnRvVmFyKCk7XG5cblx0XHQvLyBjYWxjdWxhdGUgdmVjdG9yIGZvcm0gZmFjdG9yXG5cdFx0Y29uc3QgdmVjdG9yRm9ybUZhY3RvciA9IHZlYzMoIDAgKS50b1ZhcigpO1xuXHRcdHZlY3RvckZvcm1GYWN0b3IuYWRkQXNzaWduKCBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIHsgdjE6IGNvb3JkczAsIHYyOiBjb29yZHMxIH0gKSApO1xuXHRcdHZlY3RvckZvcm1GYWN0b3IuYWRkQXNzaWduKCBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIHsgdjE6IGNvb3JkczEsIHYyOiBjb29yZHMyIH0gKSApO1xuXHRcdHZlY3RvckZvcm1GYWN0b3IuYWRkQXNzaWduKCBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIHsgdjE6IGNvb3JkczIsIHYyOiBjb29yZHMzIH0gKSApO1xuXHRcdHZlY3RvckZvcm1GYWN0b3IuYWRkQXNzaWduKCBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIHsgdjE6IGNvb3JkczMsIHYyOiBjb29yZHMwIH0gKSApO1xuXG5cdFx0Ly8gYWRqdXN0IGZvciBob3Jpem9uIGNsaXBwaW5nXG5cdFx0cmVzdWx0LmFzc2lnbiggdmVjMyggTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCB7IGY6IHZlY3RvckZvcm1GYWN0b3IgfSApICkgKTtcblxuXHR9ICk7XG5cblx0cmV0dXJuIHJlc3VsdDtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnTFRDX0V2YWx1YXRlJyxcblx0dHlwZTogJ3ZlYzMnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdOJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAnVicsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ1AnLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICdtSW52JywgdHlwZTogJ21hdDMnIH0sXG5cdFx0eyBuYW1lOiAncDAnLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICdwMScsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ3AyJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAncDMnLCB0eXBlOiAndmVjMycgfVxuXHRdXG59ICk7XG5cblxuZXhwb3J0IHsgTFRDX0V2YWx1YXRlLCBMVENfVXYgfTtcbiIsImltcG9ydCB7IGFkZCwgbXVsLCBkaXYgfSBmcm9tICcuLi9tYXRoL09wZXJhdG9yTm9kZS5qcyc7XG5pbXBvcnQgeyBmbG9vciwgY2VpbCwgZnJhY3QsIHBvdyB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xuaW1wb3J0IHsgRm4sIGZsb2F0LCB2ZWMyLCB2ZWM0LCBpbnQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbi8vIE1pcHBlZCBCaWN1YmljIFRleHR1cmUgRmlsdGVyaW5nIGJ5IE44XG4vLyBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvRGwyU0RXXG5cbmNvbnN0IGJDID0gMS4wIC8gNi4wO1xuXG5jb25zdCB3MCA9ICggYSApID0+IG11bCggYkMsIG11bCggYSwgbXVsKCBhLCBhLm5lZ2F0ZSgpLmFkZCggMy4wICkgKS5zdWIoIDMuMCApICkuYWRkKCAxLjAgKSApO1xuXG5jb25zdCB3MSA9ICggYSApID0+IG11bCggYkMsIG11bCggYSwgbXVsKCBhLCBtdWwoIDMuMCwgYSApLnN1YiggNi4wICkgKSApLmFkZCggNC4wICkgKTtcblxuY29uc3QgdzIgPSAoIGEgKSA9PiBtdWwoIGJDLCBtdWwoIGEsIG11bCggYSwgbXVsKCAtIDMuMCwgYSApLmFkZCggMy4wICkgKS5hZGQoIDMuMCApICkuYWRkKCAxLjAgKSApO1xuXG5jb25zdCB3MyA9ICggYSApID0+IG11bCggYkMsIHBvdyggYSwgMyApICk7XG5cbmNvbnN0IGcwID0gKCBhICkgPT4gdzAoIGEgKS5hZGQoIHcxKCBhICkgKTtcblxuY29uc3QgZzEgPSAoIGEgKSA9PiB3MiggYSApLmFkZCggdzMoIGEgKSApO1xuXG4vLyBoMCBhbmQgaDEgYXJlIHRoZSB0d28gb2Zmc2V0IGZ1bmN0aW9uc1xuY29uc3QgaDAgPSAoIGEgKSA9PiBhZGQoIC0gMS4wLCB3MSggYSApLmRpdiggdzAoIGEgKS5hZGQoIHcxKCBhICkgKSApICk7XG5cbmNvbnN0IGgxID0gKCBhICkgPT4gYWRkKCAxLjAsIHczKCBhICkuZGl2KCB3MiggYSApLmFkZCggdzMoIGEgKSApICkgKTtcblxuY29uc3QgYmljdWJpYyA9ICggdGV4dHVyZU5vZGUsIHRleGVsU2l6ZSwgbG9kICkgPT4ge1xuXG5cdGNvbnN0IHV2ID0gdGV4dHVyZU5vZGUudXZOb2RlO1xuXHRjb25zdCB1dlNjYWxlZCA9IG11bCggdXYsIHRleGVsU2l6ZS56dyApLmFkZCggMC41ICk7XG5cblx0Y29uc3QgaXV2ID0gZmxvb3IoIHV2U2NhbGVkICk7XG5cdGNvbnN0IGZ1diA9IGZyYWN0KCB1dlNjYWxlZCApO1xuXG5cdGNvbnN0IGcweCA9IGcwKCBmdXYueCApO1xuXHRjb25zdCBnMXggPSBnMSggZnV2LnggKTtcblx0Y29uc3QgaDB4ID0gaDAoIGZ1di54ICk7XG5cdGNvbnN0IGgxeCA9IGgxKCBmdXYueCApO1xuXHRjb25zdCBoMHkgPSBoMCggZnV2LnkgKTtcblx0Y29uc3QgaDF5ID0gaDEoIGZ1di55ICk7XG5cblx0Y29uc3QgcDAgPSB2ZWMyKCBpdXYueC5hZGQoIGgweCApLCBpdXYueS5hZGQoIGgweSApICkuc3ViKCAwLjUgKS5tdWwoIHRleGVsU2l6ZS54eSApO1xuXHRjb25zdCBwMSA9IHZlYzIoIGl1di54LmFkZCggaDF4ICksIGl1di55LmFkZCggaDB5ICkgKS5zdWIoIDAuNSApLm11bCggdGV4ZWxTaXplLnh5ICk7XG5cdGNvbnN0IHAyID0gdmVjMiggaXV2LnguYWRkKCBoMHggKSwgaXV2LnkuYWRkKCBoMXkgKSApLnN1YiggMC41ICkubXVsKCB0ZXhlbFNpemUueHkgKTtcblx0Y29uc3QgcDMgPSB2ZWMyKCBpdXYueC5hZGQoIGgxeCApLCBpdXYueS5hZGQoIGgxeSApICkuc3ViKCAwLjUgKS5tdWwoIHRleGVsU2l6ZS54eSApO1xuXG5cdGNvbnN0IGEgPSBnMCggZnV2LnkgKS5tdWwoIGFkZCggZzB4Lm11bCggdGV4dHVyZU5vZGUudXYoIHAwICkubGV2ZWwoIGxvZCApICksIGcxeC5tdWwoIHRleHR1cmVOb2RlLnV2KCBwMSApLmxldmVsKCBsb2QgKSApICkgKTtcblx0Y29uc3QgYiA9IGcxKCBmdXYueSApLm11bCggYWRkKCBnMHgubXVsKCB0ZXh0dXJlTm9kZS51diggcDIgKS5sZXZlbCggbG9kICkgKSwgZzF4Lm11bCggdGV4dHVyZU5vZGUudXYoIHAzICkubGV2ZWwoIGxvZCApICkgKSApO1xuXG5cdHJldHVybiBhLmFkZCggYiApO1xuXG59O1xuXG5leHBvcnQgY29uc3QgdGV4dHVyZUJpY3ViaWMgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdGV4dHVyZU5vZGUsIGxvZE5vZGUgPSBmbG9hdCggMyApIF0gKSA9PiB7XG5cblx0Y29uc3QgZkxvZFNpemUgPSB2ZWMyKCB0ZXh0dXJlTm9kZS5zaXplKCBpbnQoIGxvZE5vZGUgKSApICk7XG5cdGNvbnN0IGNMb2RTaXplID0gdmVjMiggdGV4dHVyZU5vZGUuc2l6ZSggaW50KCBsb2ROb2RlLmFkZCggMS4wICkgKSApICk7XG5cdGNvbnN0IGZMb2RTaXplSW52ID0gZGl2KCAxLjAsIGZMb2RTaXplICk7XG5cdGNvbnN0IGNMb2RTaXplSW52ID0gZGl2KCAxLjAsIGNMb2RTaXplICk7XG5cdGNvbnN0IGZTYW1wbGUgPSBiaWN1YmljKCB0ZXh0dXJlTm9kZSwgdmVjNCggZkxvZFNpemVJbnYsIGZMb2RTaXplICksIGZsb29yKCBsb2ROb2RlICkgKTtcblx0Y29uc3QgY1NhbXBsZSA9IGJpY3ViaWMoIHRleHR1cmVOb2RlLCB2ZWM0KCBjTG9kU2l6ZUludiwgY0xvZFNpemUgKSwgY2VpbCggbG9kTm9kZSApICk7XG5cblx0cmV0dXJuIGZyYWN0KCBsb2ROb2RlICkubWl4KCBmU2FtcGxlLCBjU2FtcGxlICk7XG5cbn0gKTtcbiIsImltcG9ydCBCUkRGX0xhbWJlcnQgZnJvbSAnLi9CU0RGL0JSREZfTGFtYmVydC5qcyc7XG5pbXBvcnQgQlJERl9HR1ggZnJvbSAnLi9CU0RGL0JSREZfR0dYLmpzJztcbmltcG9ydCBERkdBcHByb3ggZnJvbSAnLi9CU0RGL0RGR0FwcHJveC5qcyc7XG5pbXBvcnQgRW52aXJvbm1lbnRCUkRGIGZyb20gJy4vQlNERi9FbnZpcm9ubWVudEJSREYuanMnO1xuaW1wb3J0IEZfU2NobGljayBmcm9tICcuL0JTREYvRl9TY2hsaWNrLmpzJztcbmltcG9ydCBTY2hsaWNrX3RvX0YwIGZyb20gJy4vQlNERi9TY2hsaWNrX3RvX0YwLmpzJztcbmltcG9ydCBCUkRGX1NoZWVuIGZyb20gJy4vQlNERi9CUkRGX1NoZWVuLmpzJztcbmltcG9ydCB7IExUQ19FdmFsdWF0ZSwgTFRDX1V2IH0gZnJvbSAnLi9CU0RGL0xUQy5qcyc7XG5pbXBvcnQgTGlnaHRpbmdNb2RlbCBmcm9tICcuLi9jb3JlL0xpZ2h0aW5nTW9kZWwuanMnO1xuaW1wb3J0IHsgZGlmZnVzZUNvbG9yLCBzcGVjdWxhckNvbG9yLCBzcGVjdWxhckY5MCwgcm91Z2huZXNzLCBjbGVhcmNvYXQsIGNsZWFyY29hdFJvdWdobmVzcywgc2hlZW4sIHNoZWVuUm91Z2huZXNzLCBpcmlkZXNjZW5jZSwgaXJpZGVzY2VuY2VJT1IsIGlyaWRlc2NlbmNlVGhpY2tuZXNzLCBpb3IsIHRoaWNrbmVzcywgdHJhbnNtaXNzaW9uLCBhdHRlbnVhdGlvbkRpc3RhbmNlLCBhdHRlbnVhdGlvbkNvbG9yLCBkaXNwZXJzaW9uIH0gZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtZWROb3JtYWxWaWV3LCB0cmFuc2Zvcm1lZENsZWFyY29hdE5vcm1hbFZpZXcsIHRyYW5zZm9ybWVkTm9ybWFsV29ybGQgfSBmcm9tICcuLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcbmltcG9ydCB7IHBvc2l0aW9uVmlld0RpcmVjdGlvbiwgcG9zaXRpb25WaWV3LCBwb3NpdGlvbldvcmxkIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IEZuLCBmbG9hdCwgdmVjMiwgdmVjMywgdmVjNCwgbWF0MywgSWYgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICcuLi9tYXRoL0NvbmRpdGlvbmFsTm9kZS5qcyc7XG5pbXBvcnQgeyBtaXgsIG5vcm1hbGl6ZSwgcmVmcmFjdCwgbGVuZ3RoLCBjbGFtcCwgbG9nMiwgbG9nLCBleHAsIHNtb290aHN0ZXAgfSBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJztcbmltcG9ydCB7IGRpdiB9IGZyb20gJy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJztcbmltcG9ydCB7IGNhbWVyYVBvc2l0aW9uLCBjYW1lcmFQcm9qZWN0aW9uTWF0cml4LCBjYW1lcmFWaWV3TWF0cml4IH0gZnJvbSAnLi4vYWNjZXNzb3JzL0NhbWVyYS5qcyc7XG5pbXBvcnQgeyBtb2RlbFdvcmxkTWF0cml4IH0gZnJvbSAnLi4vYWNjZXNzb3JzL01vZGVsTm9kZS5qcyc7XG5pbXBvcnQgeyBzY3JlZW5TaXplIH0gZnJvbSAnLi4vZGlzcGxheS9TY3JlZW5Ob2RlLmpzJztcbmltcG9ydCB7IHZpZXdwb3J0TWlwVGV4dHVyZSB9IGZyb20gJy4uL2Rpc3BsYXkvVmlld3BvcnRUZXh0dXJlTm9kZS5qcyc7XG5pbXBvcnQgeyB0ZXh0dXJlQmljdWJpYyB9IGZyb20gJy4uL2FjY2Vzc29ycy9UZXh0dXJlQmljdWJpYy5qcyc7XG5pbXBvcnQgeyBMb29wIH0gZnJvbSAnLi4vdXRpbHMvTG9vcE5vZGUuanMnO1xuaW1wb3J0IHsgQmFja1NpZGUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuXG4vL1xuLy8gVHJhbnNtaXNzaW9uXG4vL1xuXG5jb25zdCBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgbiwgdiwgdGhpY2tuZXNzLCBpb3IsIG1vZGVsTWF0cml4IF0gKSA9PiB7XG5cblx0Ly8gRGlyZWN0aW9uIG9mIHJlZnJhY3RlZCBsaWdodC5cblx0Y29uc3QgcmVmcmFjdGlvblZlY3RvciA9IHZlYzMoIHJlZnJhY3QoIHYubmVnYXRlKCksIG5vcm1hbGl6ZSggbiApLCBkaXYoIDEuMCwgaW9yICkgKSApO1xuXG5cdC8vIENvbXB1dGUgcm90YXRpb24taW5kZXBlbmRhbnQgc2NhbGluZyBvZiB0aGUgbW9kZWwgbWF0cml4LlxuXHRjb25zdCBtb2RlbFNjYWxlID0gdmVjMyhcblx0XHRsZW5ndGgoIG1vZGVsTWF0cml4WyAwIF0ueHl6ICksXG5cdFx0bGVuZ3RoKCBtb2RlbE1hdHJpeFsgMSBdLnh5eiApLFxuXHRcdGxlbmd0aCggbW9kZWxNYXRyaXhbIDIgXS54eXogKVxuXHQpO1xuXG5cdC8vIFRoZSB0aGlja25lc3MgaXMgc3BlY2lmaWVkIGluIGxvY2FsIHNwYWNlLlxuXHRyZXR1cm4gbm9ybWFsaXplKCByZWZyYWN0aW9uVmVjdG9yICkubXVsKCB0aGlja25lc3MubXVsKCBtb2RlbFNjYWxlICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5Jyxcblx0dHlwZTogJ3ZlYzMnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICduJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAndicsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ3RoaWNrbmVzcycsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICdpb3InLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAnbW9kZWxNYXRyaXgnLCB0eXBlOiAnbWF0NCcgfVxuXHRdXG59ICk7XG5cbmNvbnN0IGFwcGx5SW9yVG9Sb3VnaG5lc3MgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcm91Z2huZXNzLCBpb3IgXSApID0+IHtcblxuXHQvLyBTY2FsZSByb3VnaG5lc3Mgd2l0aCBJT1Igc28gdGhhdCBhbiBJT1Igb2YgMS4wIHJlc3VsdHMgaW4gbm8gbWljcm9mYWNldCByZWZyYWN0aW9uIGFuZFxuXHQvLyBhbiBJT1Igb2YgMS41IHJlc3VsdHMgaW4gdGhlIGRlZmF1bHQgYW1vdW50IG9mIG1pY3JvZmFjZXQgcmVmcmFjdGlvbi5cblx0cmV0dXJuIHJvdWdobmVzcy5tdWwoIGNsYW1wKCBpb3IubXVsKCAyLjAgKS5zdWIoIDIuMCApLCAwLjAsIDEuMCApICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ2FwcGx5SW9yVG9Sb3VnaG5lc3MnLFxuXHR0eXBlOiAnZmxvYXQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdyb3VnaG5lc3MnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAnaW9yJywgdHlwZTogJ2Zsb2F0JyB9XG5cdF1cbn0gKTtcblxuY29uc3Qgdmlld3BvcnRCYWNrU2lkZVRleHR1cmUgPSAvKkBfX1BVUkVfXyovIHZpZXdwb3J0TWlwVGV4dHVyZSgpO1xuY29uc3Qgdmlld3BvcnRGcm9udFNpZGVUZXh0dXJlID0gLypAX19QVVJFX18qLyB2aWV3cG9ydE1pcFRleHR1cmUoKTtcblxuY29uc3QgZ2V0VHJhbnNtaXNzaW9uU2FtcGxlID0gLypAX19QVVJFX18qLyBGbiggKCBbIGZyYWdDb29yZCwgcm91Z2huZXNzLCBpb3IgXSwgeyBtYXRlcmlhbCB9ICkgPT4ge1xuXG5cdGNvbnN0IHZUZXh0dXJlID0gbWF0ZXJpYWwuc2lkZSA9PSBCYWNrU2lkZSA/IHZpZXdwb3J0QmFja1NpZGVUZXh0dXJlIDogdmlld3BvcnRGcm9udFNpZGVUZXh0dXJlO1xuXG5cdGNvbnN0IHRyYW5zbWlzc2lvblNhbXBsZSA9IHZUZXh0dXJlLnV2KCBmcmFnQ29vcmQgKTtcblx0Ly9jb25zdCB0cmFuc21pc3Npb25TYW1wbGUgPSB2aWV3cG9ydE1pcFRleHR1cmUoIGZyYWdDb29yZCApO1xuXG5cdGNvbnN0IGxvZCA9IGxvZzIoIHNjcmVlblNpemUueCApLm11bCggYXBwbHlJb3JUb1JvdWdobmVzcyggcm91Z2huZXNzLCBpb3IgKSApO1xuXG5cdHJldHVybiB0ZXh0dXJlQmljdWJpYyggdHJhbnNtaXNzaW9uU2FtcGxlLCBsb2QgKTtcblxufSApO1xuXG5jb25zdCB2b2x1bWVBdHRlbnVhdGlvbiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB0cmFuc21pc3Npb25EaXN0YW5jZSwgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSBdICkgPT4ge1xuXG5cdElmKCBhdHRlbnVhdGlvbkRpc3RhbmNlLm5vdEVxdWFsKCAwICksICgpID0+IHtcblxuXHRcdC8vIENvbXB1dGUgbGlnaHQgYXR0ZW51YXRpb24gdXNpbmcgQmVlcidzIGxhdy5cblx0XHRjb25zdCBhdHRlbnVhdGlvbkNvZWZmaWNpZW50ID0gbG9nKCBhdHRlbnVhdGlvbkNvbG9yICkubmVnYXRlKCkuZGl2KCBhdHRlbnVhdGlvbkRpc3RhbmNlICk7XG5cdFx0Y29uc3QgdHJhbnNtaXR0YW5jZSA9IGV4cCggYXR0ZW51YXRpb25Db2VmZmljaWVudC5uZWdhdGUoKS5tdWwoIHRyYW5zbWlzc2lvbkRpc3RhbmNlICkgKTtcblxuXHRcdHJldHVybiB0cmFuc21pdHRhbmNlO1xuXG5cdH0gKTtcblxuXHQvLyBBdHRlbnVhdGlvbiBkaXN0YW5jZSBpcyAr4oieLCBpLmUuIHRoZSB0cmFuc21pdHRlZCBjb2xvciBpcyBub3QgYXR0ZW51YXRlZCBhdCBhbGwuXG5cdHJldHVybiB2ZWMzKCAxLjAgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAndm9sdW1lQXR0ZW51YXRpb24nLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3RyYW5zbWlzc2lvbkRpc3RhbmNlJywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ2F0dGVudWF0aW9uQ29sb3InLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICdhdHRlbnVhdGlvbkRpc3RhbmNlJywgdHlwZTogJ2Zsb2F0JyB9XG5cdF1cbn0gKTtcblxuY29uc3QgZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBuLCB2LCByb3VnaG5lc3MsIGRpZmZ1c2VDb2xvciwgc3BlY3VsYXJDb2xvciwgc3BlY3VsYXJGOTAsIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCwgdmlld01hdHJpeCwgcHJvak1hdHJpeCwgaW9yLCB0aGlja25lc3MsIGF0dGVudWF0aW9uQ29sb3IsIGF0dGVudWF0aW9uRGlzdGFuY2UsIGRpc3BlcnNpb24gXSApID0+IHtcblxuXHRsZXQgdHJhbnNtaXR0ZWRMaWdodCwgdHJhbnNtaXR0YW5jZTtcblxuXHRpZiAoIGRpc3BlcnNpb24gKSB7XG5cblx0XHR0cmFuc21pdHRlZExpZ2h0ID0gdmVjNCgpLnRvVmFyKCk7XG5cdFx0dHJhbnNtaXR0YW5jZSA9IHZlYzMoKS50b1ZhcigpO1xuXG5cdFx0Y29uc3QgaGFsZlNwcmVhZCA9IGlvci5zdWIoIDEuMCApLm11bCggZGlzcGVyc2lvbi5tdWwoIDAuMDI1ICkgKTtcblx0XHRjb25zdCBpb3JzID0gdmVjMyggaW9yLnN1YiggaGFsZlNwcmVhZCApLCBpb3IsIGlvci5hZGQoIGhhbGZTcHJlYWQgKSApO1xuXG5cdFx0TG9vcCggeyBzdGFydDogMCwgZW5kOiAzIH0sICggeyBpIH0gKSA9PiB7XG5cblx0XHRcdGNvbnN0IGlvciA9IGlvcnMuZWxlbWVudCggaSApO1xuXG5cdFx0XHRjb25zdCB0cmFuc21pc3Npb25SYXkgPSBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkoIG4sIHYsIHRoaWNrbmVzcywgaW9yLCBtb2RlbE1hdHJpeCApO1xuXHRcdFx0Y29uc3QgcmVmcmFjdGVkUmF5RXhpdCA9IHBvc2l0aW9uLmFkZCggdHJhbnNtaXNzaW9uUmF5ICk7XG5cblx0XHRcdC8vIFByb2plY3QgcmVmcmFjdGVkIHZlY3RvciBvbiB0aGUgZnJhbWVidWZmZXIsIHdoaWxlIG1hcHBpbmcgdG8gbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMuXG5cdFx0XHRjb25zdCBuZGNQb3MgPSBwcm9qTWF0cml4Lm11bCggdmlld01hdHJpeC5tdWwoIHZlYzQoIHJlZnJhY3RlZFJheUV4aXQsIDEuMCApICkgKTtcblx0XHRcdGNvbnN0IHJlZnJhY3Rpb25Db29yZHMgPSB2ZWMyKCBuZGNQb3MueHkuZGl2KCBuZGNQb3MudyApICkudG9WYXIoKTtcblx0XHRcdHJlZnJhY3Rpb25Db29yZHMuYWRkQXNzaWduKCAxLjAgKTtcblx0XHRcdHJlZnJhY3Rpb25Db29yZHMuZGl2QXNzaWduKCAyLjAgKTtcblx0XHRcdHJlZnJhY3Rpb25Db29yZHMuYXNzaWduKCB2ZWMyKCByZWZyYWN0aW9uQ29vcmRzLngsIHJlZnJhY3Rpb25Db29yZHMueS5vbmVNaW51cygpICkgKTsgLy8gd2ViZ3B1XG5cblx0XHRcdC8vIFNhbXBsZSBmcmFtZWJ1ZmZlciB0byBnZXQgcGl4ZWwgdGhlIHJlZnJhY3RlZCByYXkgaGl0cy5cblx0XHRcdGNvbnN0IHRyYW5zbWlzc2lvblNhbXBsZSA9IGdldFRyYW5zbWlzc2lvblNhbXBsZSggcmVmcmFjdGlvbkNvb3Jkcywgcm91Z2huZXNzLCBpb3IgKTtcblxuXHRcdFx0dHJhbnNtaXR0ZWRMaWdodC5lbGVtZW50KCBpICkuYXNzaWduKCB0cmFuc21pc3Npb25TYW1wbGUuZWxlbWVudCggaSApICk7XG5cdFx0XHR0cmFuc21pdHRlZExpZ2h0LmEuYWRkQXNzaWduKCB0cmFuc21pc3Npb25TYW1wbGUuYSApO1xuXG5cdFx0XHR0cmFuc21pdHRhbmNlLmVsZW1lbnQoIGkgKS5hc3NpZ24oIGRpZmZ1c2VDb2xvci5lbGVtZW50KCBpICkubXVsKCB2b2x1bWVBdHRlbnVhdGlvbiggbGVuZ3RoKCB0cmFuc21pc3Npb25SYXkgKSwgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApLmVsZW1lbnQoIGkgKSApICk7XG5cblx0XHR9ICk7XG5cblx0XHR0cmFuc21pdHRlZExpZ2h0LmEuZGl2QXNzaWduKCAzLjAgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Y29uc3QgdHJhbnNtaXNzaW9uUmF5ID0gZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBuLCB2LCB0aGlja25lc3MsIGlvciwgbW9kZWxNYXRyaXggKTtcblx0XHRjb25zdCByZWZyYWN0ZWRSYXlFeGl0ID0gcG9zaXRpb24uYWRkKCB0cmFuc21pc3Npb25SYXkgKTtcblxuXHRcdC8vIFByb2plY3QgcmVmcmFjdGVkIHZlY3RvciBvbiB0aGUgZnJhbWVidWZmZXIsIHdoaWxlIG1hcHBpbmcgdG8gbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMuXG5cdFx0Y29uc3QgbmRjUG9zID0gcHJvak1hdHJpeC5tdWwoIHZpZXdNYXRyaXgubXVsKCB2ZWM0KCByZWZyYWN0ZWRSYXlFeGl0LCAxLjAgKSApICk7XG5cdFx0Y29uc3QgcmVmcmFjdGlvbkNvb3JkcyA9IHZlYzIoIG5kY1Bvcy54eS5kaXYoIG5kY1Bvcy53ICkgKS50b1ZhcigpO1xuXHRcdHJlZnJhY3Rpb25Db29yZHMuYWRkQXNzaWduKCAxLjAgKTtcblx0XHRyZWZyYWN0aW9uQ29vcmRzLmRpdkFzc2lnbiggMi4wICk7XG5cdFx0cmVmcmFjdGlvbkNvb3Jkcy5hc3NpZ24oIHZlYzIoIHJlZnJhY3Rpb25Db29yZHMueCwgcmVmcmFjdGlvbkNvb3Jkcy55Lm9uZU1pbnVzKCkgKSApOyAvLyB3ZWJncHVcblxuXHRcdC8vIFNhbXBsZSBmcmFtZWJ1ZmZlciB0byBnZXQgcGl4ZWwgdGhlIHJlZnJhY3RlZCByYXkgaGl0cy5cblx0XHR0cmFuc21pdHRlZExpZ2h0ID0gZ2V0VHJhbnNtaXNzaW9uU2FtcGxlKCByZWZyYWN0aW9uQ29vcmRzLCByb3VnaG5lc3MsIGlvciApO1xuXHRcdHRyYW5zbWl0dGFuY2UgPSBkaWZmdXNlQ29sb3IubXVsKCB2b2x1bWVBdHRlbnVhdGlvbiggbGVuZ3RoKCB0cmFuc21pc3Npb25SYXkgKSwgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApICk7XG5cblx0fVxuXG5cdGNvbnN0IGF0dGVudWF0ZWRDb2xvciA9IHRyYW5zbWl0dGFuY2UucmdiLm11bCggdHJhbnNtaXR0ZWRMaWdodC5yZ2IgKTtcblx0Y29uc3QgZG90TlYgPSBuLmRvdCggdiApLmNsYW1wKCk7XG5cblx0Ly8gR2V0IHRoZSBzcGVjdWxhciBjb21wb25lbnQuXG5cdGNvbnN0IEYgPSB2ZWMzKCBFbnZpcm9ubWVudEJSREYoIHsgLy8gbiwgdiwgc3BlY3VsYXJDb2xvciwgc3BlY3VsYXJGOTAsIHJvdWdobmVzc1xuXHRcdGRvdE5WLFxuXHRcdHNwZWN1bGFyQ29sb3IsXG5cdFx0c3BlY3VsYXJGOTAsXG5cdFx0cm91Z2huZXNzXG5cdH0gKSApO1xuXG5cdC8vIEFzIGxlc3MgbGlnaHQgaXMgdHJhbnNtaXR0ZWQsIHRoZSBvcGFjaXR5IHNob3VsZCBiZSBpbmNyZWFzZWQuIFRoaXMgc2ltcGxlIGFwcHJveGltYXRpb24gZG9lcyBhIGRlY2VudCBqb2Jcblx0Ly8gb2YgbW9kdWxhdGluZyBhIENTUyBiYWNrZ3JvdW5kLCBhbmQgaGFzIG5vIGVmZmVjdCB3aGVuIHRoZSBidWZmZXIgaXMgb3BhcXVlLCBkdWUgdG8gYSBzb2xpZCBvYmplY3Qgb3IgY2xlYXIgY29sb3IuXG5cdGNvbnN0IHRyYW5zbWl0dGFuY2VGYWN0b3IgPSB0cmFuc21pdHRhbmNlLnIuYWRkKCB0cmFuc21pdHRhbmNlLmcsIHRyYW5zbWl0dGFuY2UuYiApLmRpdiggMy4wICk7XG5cblx0cmV0dXJuIHZlYzQoIEYub25lTWludXMoKS5tdWwoIGF0dGVudWF0ZWRDb2xvciApLCB0cmFuc21pdHRlZExpZ2h0LmEub25lTWludXMoKS5tdWwoIHRyYW5zbWl0dGFuY2VGYWN0b3IgKS5vbmVNaW51cygpICk7XG5cbn0gKTtcblxuLy9cbi8vIElyaWRlc2NlbmNlXG4vL1xuXG4vLyBYWVogdG8gbGluZWFyLXNSR0IgY29sb3Igc3BhY2VcbmNvbnN0IFhZWl9UT19SRUM3MDkgPSAvKkBfX1BVUkVfXyovIG1hdDMoXG5cdDMuMjQwNDU0MiwgLSAwLjk2OTI2NjAsIDAuMDU1NjQzNCxcblx0LSAxLjUzNzEzODUsIDEuODc2MDEwOCwgLSAwLjIwNDAyNTksXG5cdC0gMC40OTg1MzE0LCAwLjA0MTU1NjAsIDEuMDU3MjI1MlxuKTtcblxuLy8gQXNzdW1lIGFpciBpbnRlcmZhY2UgZm9yIHRvcFxuLy8gTm90ZTogV2UgZG9uJ3QgaGFuZGxlIHRoZSBjYXNlIGZyZXNuZWwwID09IDFcbmNvbnN0IEZyZXNuZWwwVG9Jb3IgPSAoIGZyZXNuZWwwICkgPT4ge1xuXG5cdGNvbnN0IHNxcnRGMCA9IGZyZXNuZWwwLnNxcnQoKTtcblx0cmV0dXJuIHZlYzMoIDEuMCApLmFkZCggc3FydEYwICkuZGl2KCB2ZWMzKCAxLjAgKS5zdWIoIHNxcnRGMCApICk7XG5cbn07XG5cbi8vIGlvciBpcyBhIHZhbHVlIGJldHdlZW4gMS4wIGFuZCAzLjAuIDEuMCBpcyBhaXIgaW50ZXJmYWNlXG5jb25zdCBJb3JUb0ZyZXNuZWwwID0gKCB0cmFuc21pdHRlZElvciwgaW5jaWRlbnRJb3IgKSA9PiB7XG5cblx0cmV0dXJuIHRyYW5zbWl0dGVkSW9yLnN1YiggaW5jaWRlbnRJb3IgKS5kaXYoIHRyYW5zbWl0dGVkSW9yLmFkZCggaW5jaWRlbnRJb3IgKSApLnBvdzIoKTtcblxufTtcblxuLy8gRnJlc25lbCBlcXVhdGlvbnMgZm9yIGRpZWxlY3RyaWMvZGllbGVjdHJpYyBpbnRlcmZhY2VzLlxuLy8gUmVmOiBodHRwczovL2JlbGNvdXIuZ2l0aHViLmlvL2Jsb2cvcmVzZWFyY2gvMjAxNy8wNS8wMS9icmRmLXRoaW4tZmlsbS5odG1sXG4vLyBFdmFsdWF0aW9uIFhZWiBzZW5zaXRpdml0eSBjdXJ2ZXMgaW4gRm91cmllciBzcGFjZVxuY29uc3QgZXZhbFNlbnNpdGl2aXR5ID0gKCBPUEQsIHNoaWZ0ICkgPT4ge1xuXG5cdGNvbnN0IHBoYXNlID0gT1BELm11bCggMi4wICogTWF0aC5QSSAqIDEuMGUtOSApO1xuXHRjb25zdCB2YWwgPSB2ZWMzKCA1LjQ4NTZlLTEzLCA0LjQyMDFlLTEzLCA1LjI0ODFlLTEzICk7XG5cdGNvbnN0IHBvcyA9IHZlYzMoIDEuNjgxMGUrMDYsIDEuNzk1M2UrMDYsIDIuMjA4NGUrMDYgKTtcblx0Y29uc3QgVkFSID0gdmVjMyggNC4zMjc4ZSswOSwgOS4zMDQ2ZSswOSwgNi42MTIxZSswOSApO1xuXG5cdGNvbnN0IHggPSBmbG9hdCggOS43NDcwZS0xNCAqIE1hdGguc3FydCggMi4wICogTWF0aC5QSSAqIDQuNTI4MmUrMDkgKSApLm11bCggcGhhc2UubXVsKCAyLjIzOTllKzA2ICkuYWRkKCBzaGlmdC54ICkuY29zKCkgKS5tdWwoIHBoYXNlLnBvdzIoKS5tdWwoIC0gNC41MjgyZSswOSApLmV4cCgpICk7XG5cblx0bGV0IHh5eiA9IHZhbC5tdWwoIFZBUi5tdWwoIDIuMCAqIE1hdGguUEkgKS5zcXJ0KCkgKS5tdWwoIHBvcy5tdWwoIHBoYXNlICkuYWRkKCBzaGlmdCApLmNvcygpICkubXVsKCBwaGFzZS5wb3cyKCkubmVnYXRlKCkubXVsKCBWQVIgKS5leHAoKSApO1xuXHR4eXogPSB2ZWMzKCB4eXoueC5hZGQoIHggKSwgeHl6LnksIHh5ei56ICkuZGl2KCAxLjA2ODVlLTcgKTtcblxuXHRjb25zdCByZ2IgPSBYWVpfVE9fUkVDNzA5Lm11bCggeHl6ICk7XG5cblx0cmV0dXJuIHJnYjtcblxufTtcblxuY29uc3QgZXZhbElyaWRlc2NlbmNlID0gLypAX19QVVJFX18qLyBGbiggKCB7IG91dHNpZGVJT1IsIGV0YTIsIGNvc1RoZXRhMSwgdGhpbkZpbG1UaGlja25lc3MsIGJhc2VGMCB9ICkgPT4ge1xuXG5cdC8vIEZvcmNlIGlyaWRlc2NlbmNlSU9SIC0+IG91dHNpZGVJT1Igd2hlbiB0aGluRmlsbVRoaWNrbmVzcyAtPiAwLjBcblx0Y29uc3QgaXJpZGVzY2VuY2VJT1IgPSBtaXgoIG91dHNpZGVJT1IsIGV0YTIsIHNtb290aHN0ZXAoIDAuMCwgMC4wMywgdGhpbkZpbG1UaGlja25lc3MgKSApO1xuXHQvLyBFdmFsdWF0ZSB0aGUgY29zVGhldGEgb24gdGhlIGJhc2UgbGF5ZXIgKFNuZWxsIGxhdylcblx0Y29uc3Qgc2luVGhldGEyU3EgPSBvdXRzaWRlSU9SLmRpdiggaXJpZGVzY2VuY2VJT1IgKS5wb3cyKCkubXVsKCBjb3NUaGV0YTEucG93MigpLm9uZU1pbnVzKCkgKTtcblxuXHQvLyBIYW5kbGUgVElSOlxuXHRjb25zdCBjb3NUaGV0YTJTcSA9IHNpblRoZXRhMlNxLm9uZU1pbnVzKCk7XG5cblx0SWYoIGNvc1RoZXRhMlNxLmxlc3NUaGFuKCAwICksICgpID0+IHtcblxuXHRcdHJldHVybiB2ZWMzKCAxLjAgKTtcblxuXHR9ICk7XG5cblx0Y29uc3QgY29zVGhldGEyID0gY29zVGhldGEyU3Euc3FydCgpO1xuXG5cdC8vIEZpcnN0IGludGVyZmFjZVxuXHRjb25zdCBSMCA9IElvclRvRnJlc25lbDAoIGlyaWRlc2NlbmNlSU9SLCBvdXRzaWRlSU9SICk7XG5cdGNvbnN0IFIxMiA9IEZfU2NobGljayggeyBmMDogUjAsIGY5MDogMS4wLCBkb3RWSDogY29zVGhldGExIH0gKTtcblx0Ly9jb25zdCBSMjEgPSBSMTI7XG5cdGNvbnN0IFQxMjEgPSBSMTIub25lTWludXMoKTtcblx0Y29uc3QgcGhpMTIgPSBpcmlkZXNjZW5jZUlPUi5sZXNzVGhhbiggb3V0c2lkZUlPUiApLnNlbGVjdCggTWF0aC5QSSwgMC4wICk7XG5cdGNvbnN0IHBoaTIxID0gZmxvYXQoIE1hdGguUEkgKS5zdWIoIHBoaTEyICk7XG5cblx0Ly8gU2Vjb25kIGludGVyZmFjZVxuXHRjb25zdCBiYXNlSU9SID0gRnJlc25lbDBUb0lvciggYmFzZUYwLmNsYW1wKCAwLjAsIDAuOTk5OSApICk7IC8vIGd1YXJkIGFnYWluc3QgMS4wXG5cdGNvbnN0IFIxID0gSW9yVG9GcmVzbmVsMCggYmFzZUlPUiwgaXJpZGVzY2VuY2VJT1IudG9WZWMzKCkgKTtcblx0Y29uc3QgUjIzID0gRl9TY2hsaWNrKCB7IGYwOiBSMSwgZjkwOiAxLjAsIGRvdFZIOiBjb3NUaGV0YTIgfSApO1xuXHRjb25zdCBwaGkyMyA9IHZlYzMoXG5cdFx0YmFzZUlPUi54Lmxlc3NUaGFuKCBpcmlkZXNjZW5jZUlPUiApLnNlbGVjdCggTWF0aC5QSSwgMC4wICksXG5cdFx0YmFzZUlPUi55Lmxlc3NUaGFuKCBpcmlkZXNjZW5jZUlPUiApLnNlbGVjdCggTWF0aC5QSSwgMC4wICksXG5cdFx0YmFzZUlPUi56Lmxlc3NUaGFuKCBpcmlkZXNjZW5jZUlPUiApLnNlbGVjdCggTWF0aC5QSSwgMC4wIClcblx0KTtcblxuXHQvLyBQaGFzZSBzaGlmdFxuXHRjb25zdCBPUEQgPSBpcmlkZXNjZW5jZUlPUi5tdWwoIHRoaW5GaWxtVGhpY2tuZXNzLCBjb3NUaGV0YTIsIDIuMCApO1xuXHRjb25zdCBwaGkgPSB2ZWMzKCBwaGkyMSApLmFkZCggcGhpMjMgKTtcblxuXHQvLyBDb21wb3VuZCB0ZXJtc1xuXHRjb25zdCBSMTIzID0gUjEyLm11bCggUjIzICkuY2xhbXAoIDFlLTUsIDAuOTk5OSApO1xuXHRjb25zdCByMTIzID0gUjEyMy5zcXJ0KCk7XG5cdGNvbnN0IFJzID0gVDEyMS5wb3cyKCkubXVsKCBSMjMgKS5kaXYoIHZlYzMoIDEuMCApLnN1YiggUjEyMyApICk7XG5cblx0Ly8gUmVmbGVjdGFuY2UgdGVybSBmb3IgbSA9IDAgKERDIHRlcm0gYW1wbGl0dWRlKVxuXHRjb25zdCBDMCA9IFIxMi5hZGQoIFJzICk7XG5cdGNvbnN0IEkgPSBDMC50b1ZhcigpO1xuXG5cdC8vIFJlZmxlY3RhbmNlIHRlcm0gZm9yIG0gPiAwIChwYWlycyBvZiBkaXJhY3MpXG5cdGNvbnN0IENtID0gUnMuc3ViKCBUMTIxICkudG9WYXIoKTtcblxuXHRMb29wKCB7IHN0YXJ0OiAxLCBlbmQ6IDIsIGNvbmRpdGlvbjogJzw9JywgbmFtZTogJ20nIH0sICggeyBtIH0gKSA9PiB7XG5cblx0XHRDbS5tdWxBc3NpZ24oIHIxMjMgKTtcblx0XHRjb25zdCBTbSA9IGV2YWxTZW5zaXRpdml0eSggZmxvYXQoIG0gKS5tdWwoIE9QRCApLCBmbG9hdCggbSApLm11bCggcGhpICkgKS5tdWwoIDIuMCApO1xuXHRcdEkuYWRkQXNzaWduKCBDbS5tdWwoIFNtICkgKTtcblxuXHR9ICk7XG5cblx0Ly8gU2luY2Ugb3V0IG9mIGdhbXV0IGNvbG9ycyBtaWdodCBiZSBwcm9kdWNlZCwgbmVnYXRpdmUgY29sb3IgdmFsdWVzIGFyZSBjbGFtcGVkIHRvIDAuXG5cdHJldHVybiBJLm1heCggdmVjMyggMC4wICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnZXZhbElyaWRlc2NlbmNlJyxcblx0dHlwZTogJ3ZlYzMnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdvdXRzaWRlSU9SJywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ2V0YTInLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAnY29zVGhldGExJywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ3RoaW5GaWxtVGhpY2tuZXNzJywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ2Jhc2VGMCcsIHR5cGU6ICd2ZWMzJyB9XG5cdF1cbn0gKTtcblxuLy9cbi8vXHRTaGVlblxuLy9cblxuLy8gVGhpcyBpcyBhIGN1cnZlLWZpdCBhcHByb3htYXRpb24gdG8gdGhlIFwiQ2hhcmxpZSBzaGVlblwiIEJSREYgaW50ZWdyYXRlZCBvdmVyIHRoZSBoZW1pc3BoZXJlIGZyb21cbi8vIEVzdGV2ZXogYW5kIEt1bGxhIDIwMTcsIFwiUHJvZHVjdGlvbiBGcmllbmRseSBNaWNyb2ZhY2V0IFNoZWVuIEJSREZcIi4gVGhlIGFuYWx5c2lzIGNhbiBiZSBmb3VuZFxuLy8gaW4gdGhlIFNoZWVuIHNlY3Rpb24gb2YgaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xVDBEMVZTeVI0QWxscUlKVFFBcmFFSXpqbGI1aDRGS0gvdmlldz91c3A9c2hhcmluZ1xuY29uc3QgSUJMU2hlZW5CUkRGID0gLypAX19QVVJFX18qLyBGbiggKCB7IG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzIH0gKSA9PiB7XG5cblx0Y29uc3QgZG90TlYgPSBub3JtYWwuZG90KCB2aWV3RGlyICkuc2F0dXJhdGUoKTtcblxuXHRjb25zdCByMiA9IHJvdWdobmVzcy5wb3cyKCk7XG5cblx0Y29uc3QgYSA9IHNlbGVjdChcblx0XHRyb3VnaG5lc3MubGVzc1RoYW4oIDAuMjUgKSxcblx0XHRmbG9hdCggLSAzMzkuMiApLm11bCggcjIgKS5hZGQoIGZsb2F0KCAxNjEuNCApLm11bCggcm91Z2huZXNzICkgKS5zdWIoIDI1LjkgKSxcblx0XHRmbG9hdCggLSA4LjQ4ICkubXVsKCByMiApLmFkZCggZmxvYXQoIDE0LjMgKS5tdWwoIHJvdWdobmVzcyApICkuc3ViKCA5Ljk1IClcblx0KTtcblxuXHRjb25zdCBiID0gc2VsZWN0KFxuXHRcdHJvdWdobmVzcy5sZXNzVGhhbiggMC4yNSApLFxuXHRcdGZsb2F0KCA0NC4wICkubXVsKCByMiApLnN1YiggZmxvYXQoIDIzLjcgKS5tdWwoIHJvdWdobmVzcyApICkuYWRkKCAzLjI2ICksXG5cdFx0ZmxvYXQoIDEuOTcgKS5tdWwoIHIyICkuc3ViKCBmbG9hdCggMy4yNyApLm11bCggcm91Z2huZXNzICkgKS5hZGQoIDAuNzIgKVxuXHQpO1xuXG5cdGNvbnN0IERHID0gc2VsZWN0KCByb3VnaG5lc3MubGVzc1RoYW4oIDAuMjUgKSwgMC4wLCBmbG9hdCggMC4xICkubXVsKCByb3VnaG5lc3MgKS5zdWIoIDAuMDI1ICkgKS5hZGQoIGEubXVsKCBkb3ROViApLmFkZCggYiApLmV4cCgpICk7XG5cblx0cmV0dXJuIERHLm11bCggMS4wIC8gTWF0aC5QSSApLnNhdHVyYXRlKCk7XG5cbn0gKTtcblxuY29uc3QgY2xlYXJjb2F0RjAgPSB2ZWMzKCAwLjA0ICk7XG5jb25zdCBjbGVhcmNvYXRGOTAgPSBmbG9hdCggMSApO1xuXG4vL1xuXG5jbGFzcyBQaHlzaWNhbExpZ2h0aW5nTW9kZWwgZXh0ZW5kcyBMaWdodGluZ01vZGVsIHtcblxuXHRjb25zdHJ1Y3RvciggY2xlYXJjb2F0ID0gZmFsc2UsIHNoZWVuID0gZmFsc2UsIGlyaWRlc2NlbmNlID0gZmFsc2UsIGFuaXNvdHJvcHkgPSBmYWxzZSwgdHJhbnNtaXNzaW9uID0gZmFsc2UsIGRpc3BlcnNpb24gPSBmYWxzZSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmNsZWFyY29hdCA9IGNsZWFyY29hdDtcblx0XHR0aGlzLnNoZWVuID0gc2hlZW47XG5cdFx0dGhpcy5pcmlkZXNjZW5jZSA9IGlyaWRlc2NlbmNlO1xuXHRcdHRoaXMuYW5pc290cm9weSA9IGFuaXNvdHJvcHk7XG5cdFx0dGhpcy50cmFuc21pc3Npb24gPSB0cmFuc21pc3Npb247XG5cdFx0dGhpcy5kaXNwZXJzaW9uID0gZGlzcGVyc2lvbjtcblxuXHRcdHRoaXMuY2xlYXJjb2F0UmFkaWFuY2UgPSBudWxsO1xuXHRcdHRoaXMuY2xlYXJjb2F0U3BlY3VsYXJEaXJlY3QgPSBudWxsO1xuXHRcdHRoaXMuY2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCA9IG51bGw7XG5cdFx0dGhpcy5zaGVlblNwZWN1bGFyRGlyZWN0ID0gbnVsbDtcblx0XHR0aGlzLnNoZWVuU3BlY3VsYXJJbmRpcmVjdCA9IG51bGw7XG5cdFx0dGhpcy5pcmlkZXNjZW5jZUZyZXNuZWwgPSBudWxsO1xuXHRcdHRoaXMuaXJpZGVzY2VuY2VGMCA9IG51bGw7XG5cblx0fVxuXG5cdHN0YXJ0KCBjb250ZXh0ICkge1xuXG5cdFx0aWYgKCB0aGlzLmNsZWFyY29hdCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy5jbGVhcmNvYXRSYWRpYW5jZSA9IHZlYzMoKS50b1ZhciggJ2NsZWFyY29hdFJhZGlhbmNlJyApO1xuXHRcdFx0dGhpcy5jbGVhcmNvYXRTcGVjdWxhckRpcmVjdCA9IHZlYzMoKS50b1ZhciggJ2NsZWFyY29hdFNwZWN1bGFyRGlyZWN0JyApO1xuXHRcdFx0dGhpcy5jbGVhcmNvYXRTcGVjdWxhckluZGlyZWN0ID0gdmVjMygpLnRvVmFyKCAnY2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCcgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5zaGVlbiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy5zaGVlblNwZWN1bGFyRGlyZWN0ID0gdmVjMygpLnRvVmFyKCAnc2hlZW5TcGVjdWxhckRpcmVjdCcgKTtcblx0XHRcdHRoaXMuc2hlZW5TcGVjdWxhckluZGlyZWN0ID0gdmVjMygpLnRvVmFyKCAnc2hlZW5TcGVjdWxhckluZGlyZWN0JyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmlyaWRlc2NlbmNlID09PSB0cnVlICkge1xuXG5cdFx0XHRjb25zdCBkb3ROVmkgPSB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcuZG90KCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gKS5jbGFtcCgpO1xuXG5cdFx0XHR0aGlzLmlyaWRlc2NlbmNlRnJlc25lbCA9IGV2YWxJcmlkZXNjZW5jZSgge1xuXHRcdFx0XHRvdXRzaWRlSU9SOiBmbG9hdCggMS4wICksXG5cdFx0XHRcdGV0YTI6IGlyaWRlc2NlbmNlSU9SLFxuXHRcdFx0XHRjb3NUaGV0YTE6IGRvdE5WaSxcblx0XHRcdFx0dGhpbkZpbG1UaGlja25lc3M6IGlyaWRlc2NlbmNlVGhpY2tuZXNzLFxuXHRcdFx0XHRiYXNlRjA6IHNwZWN1bGFyQ29sb3Jcblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5pcmlkZXNjZW5jZUYwID0gU2NobGlja190b19GMCggeyBmOiB0aGlzLmlyaWRlc2NlbmNlRnJlc25lbCwgZjkwOiAxLjAsIGRvdFZIOiBkb3ROVmkgfSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnRyYW5zbWlzc2lvbiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbldvcmxkO1xuXHRcdFx0Y29uc3QgdiA9IGNhbWVyYVBvc2l0aW9uLnN1YiggcG9zaXRpb25Xb3JsZCApLm5vcm1hbGl6ZSgpOyAvLyBUT0RPOiBDcmVhdGUgTm9kZSBmb3IgdGhpcywgc2FtZSBpc3N1ZSBpbiBNYXRlcmlhbFhcblx0XHRcdGNvbnN0IG4gPSB0cmFuc2Zvcm1lZE5vcm1hbFdvcmxkO1xuXG5cdFx0XHRjb250ZXh0LmJhY2tkcm9wID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbihcblx0XHRcdFx0bixcblx0XHRcdFx0dixcblx0XHRcdFx0cm91Z2huZXNzLFxuXHRcdFx0XHRkaWZmdXNlQ29sb3IsXG5cdFx0XHRcdHNwZWN1bGFyQ29sb3IsXG5cdFx0XHRcdHNwZWN1bGFyRjkwLCAvLyBzcGVjdWxhckY5MFxuXHRcdFx0XHRwb3NpdGlvbiwgLy8gcG9zaXRpb25Xb3JsZFxuXHRcdFx0XHRtb2RlbFdvcmxkTWF0cml4LCAvLyBtb2RlbE1hdHJpeFxuXHRcdFx0XHRjYW1lcmFWaWV3TWF0cml4LCAvLyB2aWV3TWF0cml4XG5cdFx0XHRcdGNhbWVyYVByb2plY3Rpb25NYXRyaXgsIC8vIHByb2pNYXRyaXhcblx0XHRcdFx0aW9yLFxuXHRcdFx0XHR0aGlja25lc3MsXG5cdFx0XHRcdGF0dGVudWF0aW9uQ29sb3IsXG5cdFx0XHRcdGF0dGVudWF0aW9uRGlzdGFuY2UsXG5cdFx0XHRcdHRoaXMuZGlzcGVyc2lvbiA/IGRpc3BlcnNpb24gOiBudWxsXG5cdFx0XHQpO1xuXG5cdFx0XHRjb250ZXh0LmJhY2tkcm9wQWxwaGEgPSB0cmFuc21pc3Npb247XG5cblx0XHRcdGRpZmZ1c2VDb2xvci5hLm11bEFzc2lnbiggbWl4KCAxLCBjb250ZXh0LmJhY2tkcm9wLmEsIHRyYW5zbWlzc2lvbiApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIEZkZXotQWfDvGVyYSdzIFwiTXVsdGlwbGUtU2NhdHRlcmluZyBNaWNyb2ZhY2V0IE1vZGVsIGZvciBSZWFsLVRpbWUgSW1hZ2UgQmFzZWQgTGlnaHRpbmdcIlxuXHQvLyBBcHByb3hpbWF0ZXMgbXVsdGlzY2F0dGVyaW5nIGluIG9yZGVyIHRvIHByZXNlcnZlIGVuZXJneS5cblx0Ly8gaHR0cDovL3d3dy5qY2d0Lm9yZy9wdWJsaXNoZWQvMDAwOC8wMS8wMy9cblxuXHRjb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBzaW5nbGVTY2F0dGVyLCBtdWx0aVNjYXR0ZXIsIHNwZWN1bGFyRjkwICkge1xuXG5cdFx0Y29uc3QgZG90TlYgPSB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcuZG90KCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gKS5jbGFtcCgpOyAvLyBAIFRPRE86IE1vdmUgdG8gY29yZSBkb3ROVlxuXG5cdFx0Y29uc3QgZmFiID0gREZHQXBwcm94KCB7IHJvdWdobmVzcywgZG90TlYgfSApO1xuXG5cdFx0Y29uc3QgRnIgPSB0aGlzLmlyaWRlc2NlbmNlRjAgPyBpcmlkZXNjZW5jZS5taXgoIHNwZWN1bGFyQ29sb3IsIHRoaXMuaXJpZGVzY2VuY2VGMCApIDogc3BlY3VsYXJDb2xvcjtcblxuXHRcdGNvbnN0IEZzc0VzcyA9IEZyLm11bCggZmFiLnggKS5hZGQoIHNwZWN1bGFyRjkwLm11bCggZmFiLnkgKSApO1xuXG5cdFx0Y29uc3QgRXNzID0gZmFiLnguYWRkKCBmYWIueSApO1xuXHRcdGNvbnN0IEVtcyA9IEVzcy5vbmVNaW51cygpO1xuXG5cdFx0Y29uc3QgRmF2ZyA9IHNwZWN1bGFyQ29sb3IuYWRkKCBzcGVjdWxhckNvbG9yLm9uZU1pbnVzKCkubXVsKCAwLjA0NzYxOSApICk7IC8vIDEvMjFcblx0XHRjb25zdCBGbXMgPSBGc3NFc3MubXVsKCBGYXZnICkuZGl2KCBFbXMubXVsKCBGYXZnICkub25lTWludXMoKSApO1xuXG5cdFx0c2luZ2xlU2NhdHRlci5hZGRBc3NpZ24oIEZzc0VzcyApO1xuXHRcdG11bHRpU2NhdHRlci5hZGRBc3NpZ24oIEZtcy5tdWwoIEVtcyApICk7XG5cblx0fVxuXG5cdGRpcmVjdCggeyBsaWdodERpcmVjdGlvbiwgbGlnaHRDb2xvciwgcmVmbGVjdGVkTGlnaHQgfSApIHtcblxuXHRcdGNvbnN0IGRvdE5MID0gdHJhbnNmb3JtZWROb3JtYWxWaWV3LmRvdCggbGlnaHREaXJlY3Rpb24gKS5jbGFtcCgpO1xuXHRcdGNvbnN0IGlycmFkaWFuY2UgPSBkb3ROTC5tdWwoIGxpZ2h0Q29sb3IgKTtcblxuXHRcdGlmICggdGhpcy5zaGVlbiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy5zaGVlblNwZWN1bGFyRGlyZWN0LmFkZEFzc2lnbiggaXJyYWRpYW5jZS5tdWwoIEJSREZfU2hlZW4oIHsgbGlnaHREaXJlY3Rpb24gfSApICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5jbGVhcmNvYXQgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IGRvdE5MY2MgPSB0cmFuc2Zvcm1lZENsZWFyY29hdE5vcm1hbFZpZXcuZG90KCBsaWdodERpcmVjdGlvbiApLmNsYW1wKCk7XG5cdFx0XHRjb25zdCBjY0lycmFkaWFuY2UgPSBkb3ROTGNjLm11bCggbGlnaHRDb2xvciApO1xuXG5cdFx0XHR0aGlzLmNsZWFyY29hdFNwZWN1bGFyRGlyZWN0LmFkZEFzc2lnbiggY2NJcnJhZGlhbmNlLm11bCggQlJERl9HR1goIHsgbGlnaHREaXJlY3Rpb24sIGYwOiBjbGVhcmNvYXRGMCwgZjkwOiBjbGVhcmNvYXRGOTAsIHJvdWdobmVzczogY2xlYXJjb2F0Um91Z2huZXNzLCBub3JtYWxWaWV3OiB0cmFuc2Zvcm1lZENsZWFyY29hdE5vcm1hbFZpZXcgfSApICkgKTtcblxuXHRcdH1cblxuXHRcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UuYWRkQXNzaWduKCBpcnJhZGlhbmNlLm11bCggQlJERl9MYW1iZXJ0KCB7IGRpZmZ1c2VDb2xvcjogZGlmZnVzZUNvbG9yLnJnYiB9ICkgKSApO1xuXG5cdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIuYWRkQXNzaWduKCBpcnJhZGlhbmNlLm11bCggQlJERl9HR1goIHsgbGlnaHREaXJlY3Rpb24sIGYwOiBzcGVjdWxhckNvbG9yLCBmOTA6IDEsIHJvdWdobmVzcywgaXJpZGVzY2VuY2U6IHRoaXMuaXJpZGVzY2VuY2UsIGY6IHRoaXMuaXJpZGVzY2VuY2VGcmVzbmVsLCBVU0VfSVJJREVTQ0VOQ0U6IHRoaXMuaXJpZGVzY2VuY2UsIFVTRV9BTklTT1RST1BZOiB0aGlzLmFuaXNvdHJvcHkgfSApICkgKTtcblxuXHR9XG5cblx0ZGlyZWN0UmVjdEFyZWEoIHsgbGlnaHRDb2xvciwgbGlnaHRQb3NpdGlvbiwgaGFsZldpZHRoLCBoYWxmSGVpZ2h0LCByZWZsZWN0ZWRMaWdodCwgbHRjXzEsIGx0Y18yIH0gKSB7XG5cblx0XHRjb25zdCBwMCA9IGxpZ2h0UG9zaXRpb24uYWRkKCBoYWxmV2lkdGggKS5zdWIoIGhhbGZIZWlnaHQgKTsgLy8gY291bnRlcmNsb2Nrd2lzZTsgbGlnaHQgc2hpbmVzIGluIGxvY2FsIG5lZyB6IGRpcmVjdGlvblxuXHRcdGNvbnN0IHAxID0gbGlnaHRQb3NpdGlvbi5zdWIoIGhhbGZXaWR0aCApLnN1YiggaGFsZkhlaWdodCApO1xuXHRcdGNvbnN0IHAyID0gbGlnaHRQb3NpdGlvbi5zdWIoIGhhbGZXaWR0aCApLmFkZCggaGFsZkhlaWdodCApO1xuXHRcdGNvbnN0IHAzID0gbGlnaHRQb3NpdGlvbi5hZGQoIGhhbGZXaWR0aCApLmFkZCggaGFsZkhlaWdodCApO1xuXG5cdFx0Y29uc3QgTiA9IHRyYW5zZm9ybWVkTm9ybWFsVmlldztcblx0XHRjb25zdCBWID0gcG9zaXRpb25WaWV3RGlyZWN0aW9uO1xuXHRcdGNvbnN0IFAgPSBwb3NpdGlvblZpZXcudG9WYXIoKTtcblxuXHRcdGNvbnN0IHV2ID0gTFRDX1V2KCB7IE4sIFYsIHJvdWdobmVzcyB9ICk7XG5cblx0XHRjb25zdCB0MSA9IGx0Y18xLnV2KCB1diApLnRvVmFyKCk7XG5cdFx0Y29uc3QgdDIgPSBsdGNfMi51diggdXYgKS50b1ZhcigpO1xuXG5cdFx0Y29uc3QgbUludiA9IG1hdDMoXG5cdFx0XHR2ZWMzKCB0MS54LCAwLCB0MS55ICksXG5cdFx0XHR2ZWMzKCAwLCAxLCAwICksXG5cdFx0XHR2ZWMzKCB0MS56LCAwLCB0MS53IClcblx0XHQpLnRvVmFyKCk7XG5cblx0XHQvLyBMVEMgRnJlc25lbCBBcHByb3hpbWF0aW9uIGJ5IFN0ZXBoZW4gSGlsbFxuXHRcdC8vIGh0dHA6Ly9ibG9nLnNlbGZzaGFkb3cuY29tL3B1YmxpY2F0aW9ucy9zMjAxNi1hZHZhbmNlcy9zMjAxNl9sdGNfZnJlc25lbC5wZGZcblx0XHRjb25zdCBmcmVzbmVsID0gc3BlY3VsYXJDb2xvci5tdWwoIHQyLnggKS5hZGQoIHNwZWN1bGFyQ29sb3Iub25lTWludXMoKS5tdWwoIHQyLnkgKSApLnRvVmFyKCk7XG5cblx0XHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhci5hZGRBc3NpZ24oIGxpZ2h0Q29sb3IubXVsKCBmcmVzbmVsICkubXVsKCBMVENfRXZhbHVhdGUoIHsgTiwgViwgUCwgbUludiwgcDAsIHAxLCBwMiwgcDMgfSApICkgKTtcblxuXHRcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UuYWRkQXNzaWduKCBsaWdodENvbG9yLm11bCggZGlmZnVzZUNvbG9yICkubXVsKCBMVENfRXZhbHVhdGUoIHsgTiwgViwgUCwgbUludjogbWF0MyggMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSApLCBwMCwgcDEsIHAyLCBwMyB9ICkgKSApO1xuXG5cdH1cblxuXHRpbmRpcmVjdCggY29udGV4dCwgc3RhY2ssIGJ1aWxkZXIgKSB7XG5cblx0XHR0aGlzLmluZGlyZWN0RGlmZnVzZSggY29udGV4dCwgc3RhY2ssIGJ1aWxkZXIgKTtcblx0XHR0aGlzLmluZGlyZWN0U3BlY3VsYXIoIGNvbnRleHQsIHN0YWNrLCBidWlsZGVyICk7XG5cdFx0dGhpcy5hbWJpZW50T2NjbHVzaW9uKCBjb250ZXh0LCBzdGFjaywgYnVpbGRlciApO1xuXG5cdH1cblxuXHRpbmRpcmVjdERpZmZ1c2UoIHsgaXJyYWRpYW5jZSwgcmVmbGVjdGVkTGlnaHQgfSApIHtcblxuXHRcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZS5hZGRBc3NpZ24oIGlycmFkaWFuY2UubXVsKCBCUkRGX0xhbWJlcnQoIHsgZGlmZnVzZUNvbG9yIH0gKSApICk7XG5cblx0fVxuXG5cdGluZGlyZWN0U3BlY3VsYXIoIHsgcmFkaWFuY2UsIGlibElycmFkaWFuY2UsIHJlZmxlY3RlZExpZ2h0IH0gKSB7XG5cblx0XHRpZiAoIHRoaXMuc2hlZW4gPT09IHRydWUgKSB7XG5cblx0XHRcdHRoaXMuc2hlZW5TcGVjdWxhckluZGlyZWN0LmFkZEFzc2lnbiggaWJsSXJyYWRpYW5jZS5tdWwoXG5cdFx0XHRcdHNoZWVuLFxuXHRcdFx0XHRJQkxTaGVlbkJSREYoIHtcblx0XHRcdFx0XHRub3JtYWw6IHRyYW5zZm9ybWVkTm9ybWFsVmlldyxcblx0XHRcdFx0XHR2aWV3RGlyOiBwb3NpdGlvblZpZXdEaXJlY3Rpb24sXG5cdFx0XHRcdFx0cm91Z2huZXNzOiBzaGVlblJvdWdobmVzc1xuXHRcdFx0XHR9IClcblx0XHRcdCkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5jbGVhcmNvYXQgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IGRvdE5WY2MgPSB0cmFuc2Zvcm1lZENsZWFyY29hdE5vcm1hbFZpZXcuZG90KCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gKS5jbGFtcCgpO1xuXG5cdFx0XHRjb25zdCBjbGVhcmNvYXRFbnYgPSBFbnZpcm9ubWVudEJSREYoIHtcblx0XHRcdFx0ZG90TlY6IGRvdE5WY2MsXG5cdFx0XHRcdHNwZWN1bGFyQ29sb3I6IGNsZWFyY29hdEYwLFxuXHRcdFx0XHRzcGVjdWxhckY5MDogY2xlYXJjb2F0RjkwLFxuXHRcdFx0XHRyb3VnaG5lc3M6IGNsZWFyY29hdFJvdWdobmVzc1xuXHRcdFx0fSApO1xuXG5cdFx0XHR0aGlzLmNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QuYWRkQXNzaWduKCB0aGlzLmNsZWFyY29hdFJhZGlhbmNlLm11bCggY2xlYXJjb2F0RW52ICkgKTtcblxuXHRcdH1cblxuXHRcdC8vIEJvdGggaW5kaXJlY3Qgc3BlY3VsYXIgYW5kIGluZGlyZWN0IGRpZmZ1c2UgbGlnaHQgYWNjdW11bGF0ZSBoZXJlXG5cblx0XHRjb25zdCBzaW5nbGVTY2F0dGVyaW5nID0gdmVjMygpLnRvVmFyKCAnc2luZ2xlU2NhdHRlcmluZycgKTtcblx0XHRjb25zdCBtdWx0aVNjYXR0ZXJpbmcgPSB2ZWMzKCkudG9WYXIoICdtdWx0aVNjYXR0ZXJpbmcnICk7XG5cdFx0Y29uc3QgY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlID0gaWJsSXJyYWRpYW5jZS5tdWwoIDEgLyBNYXRoLlBJICk7XG5cblx0XHR0aGlzLmNvbXB1dGVNdWx0aXNjYXR0ZXJpbmcoIHNpbmdsZVNjYXR0ZXJpbmcsIG11bHRpU2NhdHRlcmluZywgc3BlY3VsYXJGOTAgKTtcblxuXHRcdGNvbnN0IHRvdGFsU2NhdHRlcmluZyA9IHNpbmdsZVNjYXR0ZXJpbmcuYWRkKCBtdWx0aVNjYXR0ZXJpbmcgKTtcblxuXHRcdGNvbnN0IGRpZmZ1c2UgPSBkaWZmdXNlQ29sb3IubXVsKCB0b3RhbFNjYXR0ZXJpbmcuci5tYXgoIHRvdGFsU2NhdHRlcmluZy5nICkubWF4KCB0b3RhbFNjYXR0ZXJpbmcuYiApLm9uZU1pbnVzKCkgKTtcblxuXHRcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIuYWRkQXNzaWduKCByYWRpYW5jZS5tdWwoIHNpbmdsZVNjYXR0ZXJpbmcgKSApO1xuXHRcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIuYWRkQXNzaWduKCBtdWx0aVNjYXR0ZXJpbmcubXVsKCBjb3NpbmVXZWlnaHRlZElycmFkaWFuY2UgKSApO1xuXG5cdFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlLmFkZEFzc2lnbiggZGlmZnVzZS5tdWwoIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZSApICk7XG5cblx0fVxuXG5cdGFtYmllbnRPY2NsdXNpb24oIHsgYW1iaWVudE9jY2x1c2lvbiwgcmVmbGVjdGVkTGlnaHQgfSApIHtcblxuXHRcdGNvbnN0IGRvdE5WID0gdHJhbnNmb3JtZWROb3JtYWxWaWV3LmRvdCggcG9zaXRpb25WaWV3RGlyZWN0aW9uICkuY2xhbXAoKTsgLy8gQCBUT0RPOiBNb3ZlIHRvIGNvcmUgZG90TlZcblxuXHRcdGNvbnN0IGFvTlYgPSBkb3ROVi5hZGQoIGFtYmllbnRPY2NsdXNpb24gKTtcblx0XHRjb25zdCBhb0V4cCA9IHJvdWdobmVzcy5tdWwoIC0gMTYuMCApLm9uZU1pbnVzKCkubmVnYXRlKCkuZXhwMigpO1xuXG5cdFx0Y29uc3QgYW9Ob2RlID0gYW1iaWVudE9jY2x1c2lvbi5zdWIoIGFvTlYucG93KCBhb0V4cCApLm9uZU1pbnVzKCkgKS5jbGFtcCgpO1xuXG5cdFx0aWYgKCB0aGlzLmNsZWFyY29hdCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy5jbGVhcmNvYXRTcGVjdWxhckluZGlyZWN0Lm11bEFzc2lnbiggYW1iaWVudE9jY2x1c2lvbiApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnNoZWVuID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLnNoZWVuU3BlY3VsYXJJbmRpcmVjdC5tdWxBc3NpZ24oIGFtYmllbnRPY2NsdXNpb24gKTtcblxuXHRcdH1cblxuXHRcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZS5tdWxBc3NpZ24oIGFtYmllbnRPY2NsdXNpb24gKTtcblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyLm11bEFzc2lnbiggYW9Ob2RlICk7XG5cblx0fVxuXG5cdGZpbmlzaCggY29udGV4dCApIHtcblxuXHRcdGNvbnN0IHsgb3V0Z29pbmdMaWdodCB9ID0gY29udGV4dDtcblxuXHRcdGlmICggdGhpcy5jbGVhcmNvYXQgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IGRvdE5WY2MgPSB0cmFuc2Zvcm1lZENsZWFyY29hdE5vcm1hbFZpZXcuZG90KCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gKS5jbGFtcCgpO1xuXG5cdFx0XHRjb25zdCBGY2MgPSBGX1NjaGxpY2soIHtcblx0XHRcdFx0ZG90Vkg6IGRvdE5WY2MsXG5cdFx0XHRcdGYwOiBjbGVhcmNvYXRGMCxcblx0XHRcdFx0ZjkwOiBjbGVhcmNvYXRGOTBcblx0XHRcdH0gKTtcblxuXHRcdFx0Y29uc3QgY2xlYXJjb2F0TGlnaHQgPSBvdXRnb2luZ0xpZ2h0Lm11bCggY2xlYXJjb2F0Lm11bCggRmNjICkub25lTWludXMoKSApLmFkZCggdGhpcy5jbGVhcmNvYXRTcGVjdWxhckRpcmVjdC5hZGQoIHRoaXMuY2xlYXJjb2F0U3BlY3VsYXJJbmRpcmVjdCApLm11bCggY2xlYXJjb2F0ICkgKTtcblxuXHRcdFx0b3V0Z29pbmdMaWdodC5hc3NpZ24oIGNsZWFyY29hdExpZ2h0ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuc2hlZW4gPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IHNoZWVuRW5lcmd5Q29tcCA9IHNoZWVuLnIubWF4KCBzaGVlbi5nICkubWF4KCBzaGVlbi5iICkubXVsKCAwLjE1NyApLm9uZU1pbnVzKCk7XG5cdFx0XHRjb25zdCBzaGVlbkxpZ2h0ID0gb3V0Z29pbmdMaWdodC5tdWwoIHNoZWVuRW5lcmd5Q29tcCApLmFkZCggdGhpcy5zaGVlblNwZWN1bGFyRGlyZWN0LCB0aGlzLnNoZWVuU3BlY3VsYXJJbmRpcmVjdCApO1xuXG5cdFx0XHRvdXRnb2luZ0xpZ2h0LmFzc2lnbiggc2hlZW5MaWdodCApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQaHlzaWNhbExpZ2h0aW5nTW9kZWw7XG4iLCJpbXBvcnQgeyBGbiwgaW50LCBmbG9hdCwgdmVjMiwgdmVjMywgdmVjNCwgSWYgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyBjb3MsIHNpbiwgYWJzLCBtYXgsIGV4cDIsIGxvZzIsIGNsYW1wLCBmcmFjdCwgbWl4LCBmbG9vciwgbm9ybWFsaXplLCBjcm9zcywgYWxsIH0gZnJvbSAnLi4vbWF0aC9NYXRoTm9kZS5qcyc7XG5pbXBvcnQgeyBtdWwgfSBmcm9tICcuLi9tYXRoL09wZXJhdG9yTm9kZS5qcyc7XG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICcuLi9tYXRoL0NvbmRpdGlvbmFsTm9kZS5qcyc7XG5pbXBvcnQgeyBMb29wLCBCcmVhayB9IGZyb20gJy4uL3V0aWxzL0xvb3BOb2RlLmpzJztcblxuLy8gVGhlc2UgZGVmaW5lcyBtdXN0IG1hdGNoIHdpdGggUE1SRU1HZW5lcmF0b3JcblxuY29uc3QgY3ViZVVWX3IwID0gLypAX19QVVJFX18qLyBmbG9hdCggMS4wICk7XG5jb25zdCBjdWJlVVZfbTAgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCAtIDIuMCApO1xuY29uc3QgY3ViZVVWX3IxID0gLypAX19QVVJFX18qLyBmbG9hdCggMC44ICk7XG5jb25zdCBjdWJlVVZfbTEgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCAtIDEuMCApO1xuY29uc3QgY3ViZVVWX3I0ID0gLypAX19QVVJFX18qLyBmbG9hdCggMC40ICk7XG5jb25zdCBjdWJlVVZfbTQgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCAyLjAgKTtcbmNvbnN0IGN1YmVVVl9yNSA9IC8qQF9fUFVSRV9fKi8gZmxvYXQoIDAuMzA1ICk7XG5jb25zdCBjdWJlVVZfbTUgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCAzLjAgKTtcbmNvbnN0IGN1YmVVVl9yNiA9IC8qQF9fUFVSRV9fKi8gZmxvYXQoIDAuMjEgKTtcbmNvbnN0IGN1YmVVVl9tNiA9IC8qQF9fUFVSRV9fKi8gZmxvYXQoIDQuMCApO1xuXG5jb25zdCBjdWJlVVZfbWluTWlwTGV2ZWwgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCA0LjAgKTtcbmNvbnN0IGN1YmVVVl9taW5UaWxlU2l6ZSA9IC8qQF9fUFVSRV9fKi8gZmxvYXQoIDE2LjAgKTtcblxuLy8gVGhlc2Ugc2hhZGVyIGZ1bmN0aW9ucyBjb252ZXJ0IGJldHdlZW4gdGhlIFVWIGNvb3JkaW5hdGVzIG9mIGEgc2luZ2xlIGZhY2Ugb2Zcbi8vIGEgY3ViZW1hcCwgdGhlIDAtNSBpbnRlZ2VyIGluZGV4IG9mIGEgY3ViZSBmYWNlLCBhbmQgdGhlIGRpcmVjdGlvbiB2ZWN0b3IgZm9yXG4vLyBzYW1wbGluZyBhIHRleHR1cmVDdWJlIChub3QgZ2VuZXJhbGx5IG5vcm1hbGl6ZWQgKS5cblxuY29uc3QgZ2V0RmFjZSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBkaXJlY3Rpb24gXSApID0+IHtcblxuXHRjb25zdCBhYnNEaXJlY3Rpb24gPSB2ZWMzKCBhYnMoIGRpcmVjdGlvbiApICkudG9WYXIoKTtcblx0Y29uc3QgZmFjZSA9IGZsb2F0KCAtIDEuMCApLnRvVmFyKCk7XG5cblx0SWYoIGFic0RpcmVjdGlvbi54LmdyZWF0ZXJUaGFuKCBhYnNEaXJlY3Rpb24ueiApLCAoKSA9PiB7XG5cblx0XHRJZiggYWJzRGlyZWN0aW9uLnguZ3JlYXRlclRoYW4oIGFic0RpcmVjdGlvbi55ICksICgpID0+IHtcblxuXHRcdFx0ZmFjZS5hc3NpZ24oIHNlbGVjdCggZGlyZWN0aW9uLnguZ3JlYXRlclRoYW4oIDAuMCApLCAwLjAsIDMuMCApICk7XG5cblx0XHR9ICkuRWxzZSggKCkgPT4ge1xuXG5cdFx0XHRmYWNlLmFzc2lnbiggc2VsZWN0KCBkaXJlY3Rpb24ueS5ncmVhdGVyVGhhbiggMC4wICksIDEuMCwgNC4wICkgKTtcblxuXHRcdH0gKTtcblxuXHR9ICkuRWxzZSggKCkgPT4ge1xuXG5cdFx0SWYoIGFic0RpcmVjdGlvbi56LmdyZWF0ZXJUaGFuKCBhYnNEaXJlY3Rpb24ueSApLCAoKSA9PiB7XG5cblx0XHRcdGZhY2UuYXNzaWduKCBzZWxlY3QoIGRpcmVjdGlvbi56LmdyZWF0ZXJUaGFuKCAwLjAgKSwgMi4wLCA1LjAgKSApO1xuXG5cdFx0fSApLkVsc2UoICgpID0+IHtcblxuXHRcdFx0ZmFjZS5hc3NpZ24oIHNlbGVjdCggZGlyZWN0aW9uLnkuZ3JlYXRlclRoYW4oIDAuMCApLCAxLjAsIDQuMCApICk7XG5cblx0XHR9ICk7XG5cblx0fSApO1xuXG5cdHJldHVybiBmYWNlO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdnZXRGYWNlJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnZGlyZWN0aW9uJywgdHlwZTogJ3ZlYzMnIH1cblx0XVxufSApO1xuXG4vLyBSSCBjb29yZGluYXRlIHN5c3RlbTsgUE1SRU0gZmFjZS1pbmRleGluZyBjb252ZW50aW9uXG5jb25zdCBnZXRVViA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBkaXJlY3Rpb24sIGZhY2UgXSApID0+IHtcblxuXHRjb25zdCB1diA9IHZlYzIoKS50b1ZhcigpO1xuXG5cdElmKCBmYWNlLmVxdWFsKCAwLjAgKSwgKCkgPT4ge1xuXG5cdFx0dXYuYXNzaWduKCB2ZWMyKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkgKS5kaXYoIGFicyggZGlyZWN0aW9uLnggKSApICk7IC8vIHBvcyB4XG5cblx0fSApLkVsc2VJZiggZmFjZS5lcXVhbCggMS4wICksICgpID0+IHtcblxuXHRcdHV2LmFzc2lnbiggdmVjMiggZGlyZWN0aW9uLngubmVnYXRlKCksIGRpcmVjdGlvbi56Lm5lZ2F0ZSgpICkuZGl2KCBhYnMoIGRpcmVjdGlvbi55ICkgKSApOyAvLyBwb3MgeVxuXG5cdH0gKS5FbHNlSWYoIGZhY2UuZXF1YWwoIDIuMCApLCAoKSA9PiB7XG5cblx0XHR1di5hc3NpZ24oIHZlYzIoIGRpcmVjdGlvbi54Lm5lZ2F0ZSgpLCBkaXJlY3Rpb24ueSApLmRpdiggYWJzKCBkaXJlY3Rpb24ueiApICkgKTsgLy8gcG9zIHpcblxuXHR9ICkuRWxzZUlmKCBmYWNlLmVxdWFsKCAzLjAgKSwgKCkgPT4ge1xuXG5cdFx0dXYuYXNzaWduKCB2ZWMyKCBkaXJlY3Rpb24uei5uZWdhdGUoKSwgZGlyZWN0aW9uLnkgKS5kaXYoIGFicyggZGlyZWN0aW9uLnggKSApICk7IC8vIG5lZyB4XG5cblx0fSApLkVsc2VJZiggZmFjZS5lcXVhbCggNC4wICksICgpID0+IHtcblxuXHRcdHV2LmFzc2lnbiggdmVjMiggZGlyZWN0aW9uLngubmVnYXRlKCksIGRpcmVjdGlvbi56ICkuZGl2KCBhYnMoIGRpcmVjdGlvbi55ICkgKSApOyAvLyBuZWcgeVxuXG5cdH0gKS5FbHNlKCAoKSA9PiB7XG5cblx0XHR1di5hc3NpZ24oIHZlYzIoIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApLmRpdiggYWJzKCBkaXJlY3Rpb24ueiApICkgKTsgLy8gbmVnIHpcblxuXHR9ICk7XG5cblx0cmV0dXJuIG11bCggMC41LCB1di5hZGQoIDEuMCApICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ2dldFVWJyxcblx0dHlwZTogJ3ZlYzInLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdkaXJlY3Rpb24nLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICdmYWNlJywgdHlwZTogJ2Zsb2F0JyB9XG5cdF1cbn0gKTtcblxuY29uc3Qgcm91Z2huZXNzVG9NaXAgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcm91Z2huZXNzIF0gKSA9PiB7XG5cblx0Y29uc3QgbWlwID0gZmxvYXQoIDAuMCApLnRvVmFyKCk7XG5cblx0SWYoIHJvdWdobmVzcy5ncmVhdGVyVGhhbkVxdWFsKCBjdWJlVVZfcjEgKSwgKCkgPT4ge1xuXG5cdFx0bWlwLmFzc2lnbiggY3ViZVVWX3IwLnN1Yiggcm91Z2huZXNzICkubXVsKCBjdWJlVVZfbTEuc3ViKCBjdWJlVVZfbTAgKSApLmRpdiggY3ViZVVWX3IwLnN1YiggY3ViZVVWX3IxICkgKS5hZGQoIGN1YmVVVl9tMCApICk7XG5cblx0fSApLkVsc2VJZiggcm91Z2huZXNzLmdyZWF0ZXJUaGFuRXF1YWwoIGN1YmVVVl9yNCApLCAoKSA9PiB7XG5cblx0XHRtaXAuYXNzaWduKCBjdWJlVVZfcjEuc3ViKCByb3VnaG5lc3MgKS5tdWwoIGN1YmVVVl9tNC5zdWIoIGN1YmVVVl9tMSApICkuZGl2KCBjdWJlVVZfcjEuc3ViKCBjdWJlVVZfcjQgKSApLmFkZCggY3ViZVVWX20xICkgKTtcblxuXHR9ICkuRWxzZUlmKCByb3VnaG5lc3MuZ3JlYXRlclRoYW5FcXVhbCggY3ViZVVWX3I1ICksICgpID0+IHtcblxuXHRcdG1pcC5hc3NpZ24oIGN1YmVVVl9yNC5zdWIoIHJvdWdobmVzcyApLm11bCggY3ViZVVWX201LnN1YiggY3ViZVVWX200ICkgKS5kaXYoIGN1YmVVVl9yNC5zdWIoIGN1YmVVVl9yNSApICkuYWRkKCBjdWJlVVZfbTQgKSApO1xuXG5cdH0gKS5FbHNlSWYoIHJvdWdobmVzcy5ncmVhdGVyVGhhbkVxdWFsKCBjdWJlVVZfcjYgKSwgKCkgPT4ge1xuXG5cdFx0bWlwLmFzc2lnbiggY3ViZVVWX3I1LnN1Yiggcm91Z2huZXNzICkubXVsKCBjdWJlVVZfbTYuc3ViKCBjdWJlVVZfbTUgKSApLmRpdiggY3ViZVVWX3I1LnN1YiggY3ViZVVWX3I2ICkgKS5hZGQoIGN1YmVVVl9tNSApICk7XG5cblx0fSApLkVsc2UoICgpID0+IHtcblxuXHRcdG1pcC5hc3NpZ24oIGZsb2F0KCAtIDIuMCApLm11bCggbG9nMiggbXVsKCAxLjE2LCByb3VnaG5lc3MgKSApICkgKTsgLy8gMS4xNiA9IDEuNzleMC4yNVxuXG5cdH0gKTtcblxuXHRyZXR1cm4gbWlwO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdyb3VnaG5lc3NUb01pcCcsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3JvdWdobmVzcycsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7XG5cbi8vIFJIIGNvb3JkaW5hdGUgc3lzdGVtOyBQTVJFTSBmYWNlLWluZGV4aW5nIGNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBnZXREaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdXZfaW1tdXRhYmxlLCBmYWNlIF0gKSA9PiB7XG5cblx0Y29uc3QgdXYgPSB1dl9pbW11dGFibGUudG9WYXIoKTtcblx0dXYuYXNzaWduKCBtdWwoIDIuMCwgdXYgKS5zdWIoIDEuMCApICk7XG5cdGNvbnN0IGRpcmVjdGlvbiA9IHZlYzMoIHV2LCAxLjAgKS50b1ZhcigpO1xuXG5cdElmKCBmYWNlLmVxdWFsKCAwLjAgKSwgKCkgPT4ge1xuXG5cdFx0ZGlyZWN0aW9uLmFzc2lnbiggZGlyZWN0aW9uLnp5eCApOyAvLyAoIDEsIHYsIHUgKSBwb3MgeFxuXG5cdH0gKS5FbHNlSWYoIGZhY2UuZXF1YWwoIDEuMCApLCAoKSA9PiB7XG5cblx0XHRkaXJlY3Rpb24uYXNzaWduKCBkaXJlY3Rpb24ueHp5ICk7XG5cdFx0ZGlyZWN0aW9uLnh6Lm11bEFzc2lnbiggLSAxLjAgKTsgLy8gKCAtdSwgMSwgLXYgKSBwb3MgeVxuXG5cdH0gKS5FbHNlSWYoIGZhY2UuZXF1YWwoIDIuMCApLCAoKSA9PiB7XG5cblx0XHRkaXJlY3Rpb24ueC5tdWxBc3NpZ24oIC0gMS4wICk7IC8vICggLXUsIHYsIDEgKSBwb3MgelxuXG5cdH0gKS5FbHNlSWYoIGZhY2UuZXF1YWwoIDMuMCApLCAoKSA9PiB7XG5cblx0XHRkaXJlY3Rpb24uYXNzaWduKCBkaXJlY3Rpb24uenl4ICk7XG5cdFx0ZGlyZWN0aW9uLnh6Lm11bEFzc2lnbiggLSAxLjAgKTsgLy8gKCAtMSwgdiwgLXUgKSBuZWcgeFxuXG5cdH0gKS5FbHNlSWYoIGZhY2UuZXF1YWwoIDQuMCApLCAoKSA9PiB7XG5cblx0XHRkaXJlY3Rpb24uYXNzaWduKCBkaXJlY3Rpb24ueHp5ICk7XG5cdFx0ZGlyZWN0aW9uLnh5Lm11bEFzc2lnbiggLSAxLjAgKTsgLy8gKCAtdSwgLTEsIHYgKSBuZWcgeVxuXG5cdH0gKS5FbHNlSWYoIGZhY2UuZXF1YWwoIDUuMCApLCAoKSA9PiB7XG5cblx0XHRkaXJlY3Rpb24uei5tdWxBc3NpZ24oIC0gMS4wICk7IC8vICggdSwgdiwgLTEgKSBuZWcgelNcblxuXHR9ICk7XG5cblx0cmV0dXJuIGRpcmVjdGlvbjtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnZ2V0RGlyZWN0aW9uJyxcblx0dHlwZTogJ3ZlYzMnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICd1dicsIHR5cGU6ICd2ZWMyJyB9LFxuXHRcdHsgbmFtZTogJ2ZhY2UnLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG4vL1xuXG5leHBvcnQgY29uc3QgdGV4dHVyZUN1YmVVViA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBlbnZNYXAsIHNhbXBsZURpcl9pbW11dGFibGUsIHJvdWdobmVzc19pbW11dGFibGUsIENVQkVVVl9URVhFTF9XSURUSCwgQ1VCRVVWX1RFWEVMX0hFSUdIVCwgQ1VCRVVWX01BWF9NSVAgXSApID0+IHtcblxuXHRjb25zdCByb3VnaG5lc3MgPSBmbG9hdCggcm91Z2huZXNzX2ltbXV0YWJsZSApO1xuXHRjb25zdCBzYW1wbGVEaXIgPSB2ZWMzKCBzYW1wbGVEaXJfaW1tdXRhYmxlICk7XG5cblx0Y29uc3QgbWlwID0gY2xhbXAoIHJvdWdobmVzc1RvTWlwKCByb3VnaG5lc3MgKSwgY3ViZVVWX20wLCBDVUJFVVZfTUFYX01JUCApO1xuXHRjb25zdCBtaXBGID0gZnJhY3QoIG1pcCApO1xuXHRjb25zdCBtaXBJbnQgPSBmbG9vciggbWlwICk7XG5cdGNvbnN0IGNvbG9yMCA9IHZlYzMoIGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpciwgbWlwSW50LCBDVUJFVVZfVEVYRUxfV0lEVEgsIENVQkVVVl9URVhFTF9IRUlHSFQsIENVQkVVVl9NQVhfTUlQICkgKS50b1ZhcigpO1xuXG5cdElmKCBtaXBGLm5vdEVxdWFsKCAwLjAgKSwgKCkgPT4ge1xuXG5cdFx0Y29uc3QgY29sb3IxID0gdmVjMyggYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyLCBtaXBJbnQuYWRkKCAxLjAgKSwgQ1VCRVVWX1RFWEVMX1dJRFRILCBDVUJFVVZfVEVYRUxfSEVJR0hULCBDVUJFVVZfTUFYX01JUCApICkudG9WYXIoKTtcblxuXHRcdGNvbG9yMC5hc3NpZ24oIG1peCggY29sb3IwLCBjb2xvcjEsIG1pcEYgKSApO1xuXG5cdH0gKTtcblxuXHRyZXR1cm4gY29sb3IwO1xuXG59ICk7XG5cbmNvbnN0IGJpbGluZWFyQ3ViZVVWID0gLypAX19QVVJFX18qLyBGbiggKCBbIGVudk1hcCwgZGlyZWN0aW9uX2ltbXV0YWJsZSwgbWlwSW50X2ltbXV0YWJsZSwgQ1VCRVVWX1RFWEVMX1dJRFRILCBDVUJFVVZfVEVYRUxfSEVJR0hULCBDVUJFVVZfTUFYX01JUCBdICkgPT4ge1xuXG5cdGNvbnN0IG1pcEludCA9IGZsb2F0KCBtaXBJbnRfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgZGlyZWN0aW9uID0gdmVjMyggZGlyZWN0aW9uX2ltbXV0YWJsZSApO1xuXHRjb25zdCBmYWNlID0gZmxvYXQoIGdldEZhY2UoIGRpcmVjdGlvbiApICkudG9WYXIoKTtcblx0Y29uc3QgZmlsdGVySW50ID0gZmxvYXQoIG1heCggY3ViZVVWX21pbk1pcExldmVsLnN1YiggbWlwSW50ICksIDAuMCApICkudG9WYXIoKTtcblx0bWlwSW50LmFzc2lnbiggbWF4KCBtaXBJbnQsIGN1YmVVVl9taW5NaXBMZXZlbCApICk7XG5cdGNvbnN0IGZhY2VTaXplID0gZmxvYXQoIGV4cDIoIG1pcEludCApICkudG9WYXIoKTtcblx0Y29uc3QgdXYgPSB2ZWMyKCBnZXRVViggZGlyZWN0aW9uLCBmYWNlICkubXVsKCBmYWNlU2l6ZS5zdWIoIDIuMCApICkuYWRkKCAxLjAgKSApLnRvVmFyKCk7XG5cblx0SWYoIGZhY2UuZ3JlYXRlclRoYW4oIDIuMCApLCAoKSA9PiB7XG5cblx0XHR1di55LmFkZEFzc2lnbiggZmFjZVNpemUgKTtcblx0XHRmYWNlLnN1YkFzc2lnbiggMy4wICk7XG5cblx0fSApO1xuXG5cdHV2LnguYWRkQXNzaWduKCBmYWNlLm11bCggZmFjZVNpemUgKSApO1xuXHR1di54LmFkZEFzc2lnbiggZmlsdGVySW50Lm11bCggbXVsKCAzLjAsIGN1YmVVVl9taW5UaWxlU2l6ZSApICkgKTtcblx0dXYueS5hZGRBc3NpZ24oIG11bCggNC4wLCBleHAyKCBDVUJFVVZfTUFYX01JUCApLnN1YiggZmFjZVNpemUgKSApICk7XG5cdHV2LngubXVsQXNzaWduKCBDVUJFVVZfVEVYRUxfV0lEVEggKTtcblx0dXYueS5tdWxBc3NpZ24oIENVQkVVVl9URVhFTF9IRUlHSFQgKTtcblxuXHRyZXR1cm4gZW52TWFwLnV2KCB1diApLmdyYWQoIHZlYzIoKSwgdmVjMigpICk7IC8vIGRpc2FibGUgYW5pc290cm9waWMgZmlsdGVyaW5nXG5cbn0gKTtcblxuY29uc3QgZ2V0U2FtcGxlID0gLypAX19QVVJFX18qLyBGbiggKCB7IGVudk1hcCwgbWlwSW50LCBvdXRwdXREaXJlY3Rpb24sIHRoZXRhLCBheGlzLCBDVUJFVVZfVEVYRUxfV0lEVEgsIENVQkVVVl9URVhFTF9IRUlHSFQsIENVQkVVVl9NQVhfTUlQIH0gKSA9PiB7XG5cblx0Y29uc3QgY29zVGhldGEgPSBjb3MoIHRoZXRhICk7XG5cblx0Ly8gUm9kcmlndWVzJyBheGlzLWFuZ2xlIHJvdGF0aW9uXG5cdGNvbnN0IHNhbXBsZURpcmVjdGlvbiA9IG91dHB1dERpcmVjdGlvbi5tdWwoIGNvc1RoZXRhIClcblx0XHQuYWRkKCBheGlzLmNyb3NzKCBvdXRwdXREaXJlY3Rpb24gKS5tdWwoIHNpbiggdGhldGEgKSApIClcblx0XHQuYWRkKCBheGlzLm11bCggYXhpcy5kb3QoIG91dHB1dERpcmVjdGlvbiApLm11bCggY29zVGhldGEub25lTWludXMoKSApICkgKTtcblxuXHRyZXR1cm4gYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyZWN0aW9uLCBtaXBJbnQsIENVQkVVVl9URVhFTF9XSURUSCwgQ1VCRVVWX1RFWEVMX0hFSUdIVCwgQ1VCRVVWX01BWF9NSVAgKTtcblxufSApO1xuXG5leHBvcnQgY29uc3QgYmx1ciA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBuLCBsYXRpdHVkaW5hbCwgcG9sZUF4aXMsIG91dHB1dERpcmVjdGlvbiwgd2VpZ2h0cywgc2FtcGxlcywgZFRoZXRhLCBtaXBJbnQsIGVudk1hcCwgQ1VCRVVWX1RFWEVMX1dJRFRILCBDVUJFVVZfVEVYRUxfSEVJR0hULCBDVUJFVVZfTUFYX01JUCB9ICkgPT4ge1xuXG5cdGNvbnN0IGF4aXMgPSB2ZWMzKCBzZWxlY3QoIGxhdGl0dWRpbmFsLCBwb2xlQXhpcywgY3Jvc3MoIHBvbGVBeGlzLCBvdXRwdXREaXJlY3Rpb24gKSApICkudG9WYXIoKTtcblxuXHRJZiggYWxsKCBheGlzLmVxdWFscyggdmVjMyggMC4wICkgKSApLCAoKSA9PiB7XG5cblx0XHRheGlzLmFzc2lnbiggdmVjMyggb3V0cHV0RGlyZWN0aW9uLnosIDAuMCwgb3V0cHV0RGlyZWN0aW9uLngubmVnYXRlKCkgKSApO1xuXG5cdH0gKTtcblxuXHRheGlzLmFzc2lnbiggbm9ybWFsaXplKCBheGlzICkgKTtcblxuXHRjb25zdCBnbF9GcmFnQ29sb3IgPSB2ZWMzKCkudG9WYXIoKTtcblx0Z2xfRnJhZ0NvbG9yLmFkZEFzc2lnbiggd2VpZ2h0cy5lbGVtZW50KCBpbnQoIDAgKSApLm11bCggZ2V0U2FtcGxlKCB7IHRoZXRhOiAwLjAsIGF4aXMsIG91dHB1dERpcmVjdGlvbiwgbWlwSW50LCBlbnZNYXAsIENVQkVVVl9URVhFTF9XSURUSCwgQ1VCRVVWX1RFWEVMX0hFSUdIVCwgQ1VCRVVWX01BWF9NSVAgfSApICkgKTtcblxuXHRMb29wKCB7IHN0YXJ0OiBpbnQoIDEgKSwgZW5kOiBuIH0sICggeyBpIH0gKSA9PiB7XG5cblx0XHRJZiggaS5ncmVhdGVyVGhhbkVxdWFsKCBzYW1wbGVzICksICgpID0+IHtcblxuXHRcdFx0QnJlYWsoKTtcblxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IHRoZXRhID0gZmxvYXQoIGRUaGV0YS5tdWwoIGZsb2F0KCBpICkgKSApLnRvVmFyKCk7XG5cdFx0Z2xfRnJhZ0NvbG9yLmFkZEFzc2lnbiggd2VpZ2h0cy5lbGVtZW50KCBpICkubXVsKCBnZXRTYW1wbGUoIHsgdGhldGE6IHRoZXRhLm11bCggLSAxLjAgKSwgYXhpcywgb3V0cHV0RGlyZWN0aW9uLCBtaXBJbnQsIGVudk1hcCwgQ1VCRVVWX1RFWEVMX1dJRFRILCBDVUJFVVZfVEVYRUxfSEVJR0hULCBDVUJFVVZfTUFYX01JUCB9ICkgKSApO1xuXHRcdGdsX0ZyYWdDb2xvci5hZGRBc3NpZ24oIHdlaWdodHMuZWxlbWVudCggaSApLm11bCggZ2V0U2FtcGxlKCB7IHRoZXRhLCBheGlzLCBvdXRwdXREaXJlY3Rpb24sIG1pcEludCwgZW52TWFwLCBDVUJFVVZfVEVYRUxfV0lEVEgsIENVQkVVVl9URVhFTF9IRUlHSFQsIENVQkVVVl9NQVhfTUlQIH0gKSApICk7XG5cblx0fSApO1xuXG5cdHJldHVybiB2ZWM0KCBnbF9GcmFnQ29sb3IsIDEgKTtcblxufSApO1xuIiwiaW1wb3J0IFRlbXBOb2RlIGZyb20gJy4uL2NvcmUvVGVtcE5vZGUuanMnO1xuaW1wb3J0IHsgdGV4dHVyZSB9IGZyb20gJy4uL2FjY2Vzc29ycy9UZXh0dXJlTm9kZS5qcyc7XG5pbXBvcnQgeyB0ZXh0dXJlQ3ViZVVWIH0gZnJvbSAnLi9QTVJFTVV0aWxzLmpzJztcbmltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5LCB2ZWMzIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5pbXBvcnQgeyBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uL3RleHR1cmVzL1RleHR1cmUuanMnO1xuXG5sZXQgX2dlbmVyYXRvciA9IG51bGw7XG5cbmNvbnN0IF9jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIF9nZW5lcmF0ZUN1YmVVVlNpemUoIGltYWdlSGVpZ2h0ICkge1xuXG5cdGNvbnN0IG1heE1pcCA9IE1hdGgubG9nMiggaW1hZ2VIZWlnaHQgKSAtIDI7XG5cblx0Y29uc3QgdGV4ZWxIZWlnaHQgPSAxLjAgLyBpbWFnZUhlaWdodDtcblxuXHRjb25zdCB0ZXhlbFdpZHRoID0gMS4wIC8gKCAzICogTWF0aC5tYXgoIE1hdGgucG93KCAyLCBtYXhNaXAgKSwgNyAqIDE2ICkgKTtcblxuXHRyZXR1cm4geyB0ZXhlbFdpZHRoLCB0ZXhlbEhlaWdodCwgbWF4TWlwIH07XG5cbn1cblxuZnVuY3Rpb24gX2dldFBNUkVNRnJvbVRleHR1cmUoIHRleHR1cmUgKSB7XG5cblx0bGV0IGNhY2hlVGV4dHVyZSA9IF9jYWNoZS5nZXQoIHRleHR1cmUgKTtcblxuXHRjb25zdCBwbXJlbVZlcnNpb24gPSBjYWNoZVRleHR1cmUgIT09IHVuZGVmaW5lZCA/IGNhY2hlVGV4dHVyZS5wbXJlbVZlcnNpb24gOiAtIDE7XG5cblx0aWYgKCBwbXJlbVZlcnNpb24gIT09IHRleHR1cmUucG1yZW1WZXJzaW9uICkge1xuXG5cdFx0Y29uc3QgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmlzQ3ViZVRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggaXNDdWJlTWFwUmVhZHkoIGltYWdlICkgKSB7XG5cblx0XHRcdFx0Y2FjaGVUZXh0dXJlID0gX2dlbmVyYXRvci5mcm9tQ3ViZW1hcCggdGV4dHVyZSwgY2FjaGVUZXh0dXJlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBpc0VxdWlyZWN0YW5ndWxhck1hcFJlYWR5KCBpbWFnZSApICkge1xuXG5cdFx0XHRcdGNhY2hlVGV4dHVyZSA9IF9nZW5lcmF0b3IuZnJvbUVxdWlyZWN0YW5ndWxhciggdGV4dHVyZSwgY2FjaGVUZXh0dXJlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNhY2hlVGV4dHVyZS5wbXJlbVZlcnNpb24gPSB0ZXh0dXJlLnBtcmVtVmVyc2lvbjtcblxuXHRcdF9jYWNoZS5zZXQoIHRleHR1cmUsIGNhY2hlVGV4dHVyZSApO1xuXG5cdH1cblxuXHRyZXR1cm4gY2FjaGVUZXh0dXJlLnRleHR1cmU7XG5cbn1cblxuY2xhc3MgUE1SRU1Ob2RlIGV4dGVuZHMgVGVtcE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnUE1SRU1Ob2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHZhbHVlLCB1dk5vZGUgPSBudWxsLCBsZXZlbE5vZGUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoICd2ZWMzJyApO1xuXG5cdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcblx0XHR0aGlzLl9wbXJlbSA9IG51bGw7XG5cblx0XHR0aGlzLnV2Tm9kZSA9IHV2Tm9kZTtcblx0XHR0aGlzLmxldmVsTm9kZSA9IGxldmVsTm9kZTtcblxuXHRcdHRoaXMuX2dlbmVyYXRvciA9IG51bGw7XG5cblx0XHRjb25zdCBkZWZhdWx0VGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG5cdFx0ZGVmYXVsdFRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcblxuXHRcdHRoaXMuX3RleHR1cmUgPSB0ZXh0dXJlKCBkZWZhdWx0VGV4dHVyZSApO1xuXG5cdFx0dGhpcy5fd2lkdGggPSB1bmlmb3JtKCAwICk7XG5cdFx0dGhpcy5faGVpZ2h0ID0gdW5pZm9ybSggMCApO1xuXHRcdHRoaXMuX21heE1pcCA9IHVuaWZvcm0oIDAgKTtcblxuXHRcdHRoaXMudXBkYXRlQmVmb3JlVHlwZSA9IE5vZGVVcGRhdGVUeXBlLlJFTkRFUjtcblxuXHR9XG5cblx0c2V0IHZhbHVlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cdFx0dGhpcy5fcG1yZW0gPSBudWxsO1xuXG5cdH1cblxuXHRnZXQgdmFsdWUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fdmFsdWU7XG5cblx0fVxuXG5cdHVwZGF0ZUZyb21UZXh0dXJlKCB0ZXh0dXJlICkge1xuXG5cdFx0Y29uc3QgY3ViZVVWU2l6ZSA9IF9nZW5lcmF0ZUN1YmVVVlNpemUoIHRleHR1cmUuaW1hZ2UuaGVpZ2h0ICk7XG5cblx0XHR0aGlzLl90ZXh0dXJlLnZhbHVlID0gdGV4dHVyZTtcblx0XHR0aGlzLl93aWR0aC52YWx1ZSA9IGN1YmVVVlNpemUudGV4ZWxXaWR0aDtcblx0XHR0aGlzLl9oZWlnaHQudmFsdWUgPSBjdWJlVVZTaXplLnRleGVsSGVpZ2h0O1xuXHRcdHRoaXMuX21heE1pcC52YWx1ZSA9IGN1YmVVVlNpemUubWF4TWlwO1xuXG5cdH1cblxuXHR1cGRhdGVCZWZvcmUoKSB7XG5cblx0XHRsZXQgcG1yZW0gPSB0aGlzLl9wbXJlbTtcblxuXHRcdGNvbnN0IHBtcmVtVmVyc2lvbiA9IHBtcmVtID8gcG1yZW0ucG1yZW1WZXJzaW9uIDogLSAxO1xuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLl92YWx1ZTtcblxuXHRcdGlmICggcG1yZW1WZXJzaW9uICE9PSB0ZXh0dXJlLnBtcmVtVmVyc2lvbiApIHtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLmlzUE1SRU1UZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHBtcmVtID0gdGV4dHVyZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRwbXJlbSA9IF9nZXRQTVJFTUZyb21UZXh0dXJlKCB0ZXh0dXJlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwbXJlbSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLl9wbXJlbSA9IHBtcmVtO1xuXG5cdFx0XHRcdHRoaXMudXBkYXRlRnJvbVRleHR1cmUoIHBtcmVtICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRpZiAoIF9nZW5lcmF0b3IgPT09IG51bGwgKSB7XG5cblx0XHRcdF9nZW5lcmF0b3IgPSBidWlsZGVyLmNyZWF0ZVBNUkVNR2VuZXJhdG9yKCk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0dGhpcy51cGRhdGVCZWZvcmUoIGJ1aWxkZXIgKTtcblxuXHRcdC8vXG5cblx0XHRsZXQgdXZOb2RlID0gdGhpcy51dk5vZGU7XG5cblx0XHRpZiAoIHV2Tm9kZSA9PT0gbnVsbCAmJiBidWlsZGVyLmNvbnRleHQuZ2V0VVYgKSB7XG5cblx0XHRcdHV2Tm9kZSA9IGJ1aWxkZXIuY29udGV4dC5nZXRVViggdGhpcyApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLnZhbHVlO1xuXG5cdFx0aWYgKCBidWlsZGVyLnJlbmRlcmVyLmNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSAmJiB0ZXh0dXJlLmlzUE1SRU1UZXh0dXJlICE9PSB0cnVlICYmIHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHR1dk5vZGUgPSB2ZWMzKCB1dk5vZGUueC5uZWdhdGUoKSwgdXZOb2RlLnl6ICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0bGV0IGxldmVsTm9kZSA9IHRoaXMubGV2ZWxOb2RlO1xuXG5cdFx0aWYgKCBsZXZlbE5vZGUgPT09IG51bGwgJiYgYnVpbGRlci5jb250ZXh0LmdldFRleHR1cmVMZXZlbCApIHtcblxuXHRcdFx0bGV2ZWxOb2RlID0gYnVpbGRlci5jb250ZXh0LmdldFRleHR1cmVMZXZlbCggdGhpcyApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHJldHVybiB0ZXh0dXJlQ3ViZVVWKCB0aGlzLl90ZXh0dXJlLCB1dk5vZGUsIGxldmVsTm9kZSwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgdGhpcy5fbWF4TWlwICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBNUkVNTm9kZTtcblxuZnVuY3Rpb24gaXNDdWJlTWFwUmVhZHkoIGltYWdlICkge1xuXG5cdGlmICggaW1hZ2UgPT09IG51bGwgfHwgaW1hZ2UgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcblxuXHRsZXQgY291bnQgPSAwO1xuXHRjb25zdCBsZW5ndGggPSA2O1xuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuXHRcdGlmICggaW1hZ2VbIGkgXSAhPT0gdW5kZWZpbmVkICkgY291bnQgKys7XG5cblx0fVxuXG5cdHJldHVybiBjb3VudCA9PT0gbGVuZ3RoO1xuXG5cbn1cblxuZnVuY3Rpb24gaXNFcXVpcmVjdGFuZ3VsYXJNYXBSZWFkeSggaW1hZ2UgKSB7XG5cblx0aWYgKCBpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdHJldHVybiBpbWFnZS5oZWlnaHQgPiAwO1xuXG59XG5cbmV4cG9ydCBjb25zdCBwbXJlbVRleHR1cmUgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggUE1SRU1Ob2RlICk7XG4iLCJpbXBvcnQgTGlnaHRpbmdOb2RlIGZyb20gJy4vTGlnaHRpbmdOb2RlLmpzJztcbmltcG9ydCB7IGNhY2hlIH0gZnJvbSAnLi4vY29yZS9DYWNoZU5vZGUuanMnO1xuaW1wb3J0IHsgcm91Z2huZXNzLCBjbGVhcmNvYXRSb3VnaG5lc3MgfSBmcm9tICcuLi9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XG5pbXBvcnQgeyBjYW1lcmFWaWV3TWF0cml4IH0gZnJvbSAnLi4vYWNjZXNzb3JzL0NhbWVyYS5qcyc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1lZENsZWFyY29hdE5vcm1hbFZpZXcsIHRyYW5zZm9ybWVkTm9ybWFsVmlldywgdHJhbnNmb3JtZWROb3JtYWxXb3JsZCB9IGZyb20gJy4uL2FjY2Vzc29ycy9Ob3JtYWwuanMnO1xuaW1wb3J0IHsgcG9zaXRpb25WaWV3RGlyZWN0aW9uIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IGZsb2F0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgcmVmZXJlbmNlIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1JlZmVyZW5jZU5vZGUuanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtZWRCZW50Tm9ybWFsVmlldyB9IGZyb20gJy4uL2FjY2Vzc29ycy9BY2Nlc3NvcnNVdGlscy5qcyc7XG5pbXBvcnQgeyBwbXJlbVRleHR1cmUgfSBmcm9tICcuLi9wbXJlbS9QTVJFTU5vZGUuanMnO1xuXG5jb25zdCBfZW52Tm9kZUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuY2xhc3MgRW52aXJvbm1lbnROb2RlIGV4dGVuZHMgTGlnaHRpbmdOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0Vudmlyb25tZW50Tm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBlbnZOb2RlID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmVudk5vZGUgPSBlbnZOb2RlO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHsgbWF0ZXJpYWwgfSA9IGJ1aWxkZXI7XG5cblx0XHRsZXQgZW52Tm9kZSA9IHRoaXMuZW52Tm9kZTtcblxuXHRcdGlmICggZW52Tm9kZS5pc1RleHR1cmVOb2RlIHx8IGVudk5vZGUuaXNNYXRlcmlhbFJlZmVyZW5jZU5vZGUgKSB7XG5cblx0XHRcdGNvbnN0IHZhbHVlID0gKCBlbnZOb2RlLmlzVGV4dHVyZU5vZGUgKSA/IGVudk5vZGUudmFsdWUgOiBtYXRlcmlhbFsgZW52Tm9kZS5wcm9wZXJ0eSBdO1xuXG5cdFx0XHRsZXQgY2FjaGVFbnZOb2RlID0gX2Vudk5vZGVDYWNoZS5nZXQoIHZhbHVlICk7XG5cblx0XHRcdGlmICggY2FjaGVFbnZOb2RlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y2FjaGVFbnZOb2RlID0gcG1yZW1UZXh0dXJlKCB2YWx1ZSApO1xuXG5cdFx0XHRcdF9lbnZOb2RlQ2FjaGUuc2V0KCB2YWx1ZSwgY2FjaGVFbnZOb2RlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZW52Tm9kZVx0PSBjYWNoZUVudk5vZGU7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgZW52TWFwID0gbWF0ZXJpYWwuZW52TWFwO1xuXHRcdGNvbnN0IGludGVuc2l0eSA9IGVudk1hcCA/IHJlZmVyZW5jZSggJ2Vudk1hcEludGVuc2l0eScsICdmbG9hdCcsIGJ1aWxkZXIubWF0ZXJpYWwgKSA6IHJlZmVyZW5jZSggJ2Vudmlyb25tZW50SW50ZW5zaXR5JywgJ2Zsb2F0JywgYnVpbGRlci5zY2VuZSApOyAvLyBAVE9ETzogQWRkIG1hdGVyaWFsRW52SW50ZW5zaXR5IGluIE1hdGVyaWFsTm9kZVxuXG5cdFx0Y29uc3QgdXNlQW5pc290cm9weSA9IG1hdGVyaWFsLnVzZUFuaXNvdHJvcHkgPT09IHRydWUgfHwgbWF0ZXJpYWwuYW5pc290cm9weSA+IDA7XG5cdFx0Y29uc3QgcmFkaWFuY2VOb3JtYWxWaWV3ID0gdXNlQW5pc290cm9weSA/IHRyYW5zZm9ybWVkQmVudE5vcm1hbFZpZXcgOiB0cmFuc2Zvcm1lZE5vcm1hbFZpZXc7XG5cblx0XHRjb25zdCByYWRpYW5jZSA9IGVudk5vZGUuY29udGV4dCggY3JlYXRlUmFkaWFuY2VDb250ZXh0KCByb3VnaG5lc3MsIHJhZGlhbmNlTm9ybWFsVmlldyApICkubXVsKCBpbnRlbnNpdHkgKTtcblx0XHRjb25zdCBpcnJhZGlhbmNlID0gZW52Tm9kZS5jb250ZXh0KCBjcmVhdGVJcnJhZGlhbmNlQ29udGV4dCggdHJhbnNmb3JtZWROb3JtYWxXb3JsZCApICkubXVsKCBNYXRoLlBJICkubXVsKCBpbnRlbnNpdHkgKTtcblxuXHRcdGNvbnN0IGlzb2xhdGVSYWRpYW5jZSA9IGNhY2hlKCByYWRpYW5jZSApO1xuXHRcdGNvbnN0IGlzb2xhdGVJcnJhZGlhbmNlID0gY2FjaGUoIGlycmFkaWFuY2UgKTtcblxuXHRcdC8vXG5cblx0XHRidWlsZGVyLmNvbnRleHQucmFkaWFuY2UuYWRkQXNzaWduKCBpc29sYXRlUmFkaWFuY2UgKTtcblxuXHRcdGJ1aWxkZXIuY29udGV4dC5pYmxJcnJhZGlhbmNlLmFkZEFzc2lnbiggaXNvbGF0ZUlycmFkaWFuY2UgKTtcblxuXHRcdC8vXG5cblx0XHRjb25zdCBjbGVhcmNvYXRSYWRpYW5jZSA9IGJ1aWxkZXIuY29udGV4dC5saWdodGluZ01vZGVsLmNsZWFyY29hdFJhZGlhbmNlO1xuXG5cdFx0aWYgKCBjbGVhcmNvYXRSYWRpYW5jZSApIHtcblxuXHRcdFx0Y29uc3QgY2xlYXJjb2F0UmFkaWFuY2VDb250ZXh0ID0gZW52Tm9kZS5jb250ZXh0KCBjcmVhdGVSYWRpYW5jZUNvbnRleHQoIGNsZWFyY29hdFJvdWdobmVzcywgdHJhbnNmb3JtZWRDbGVhcmNvYXROb3JtYWxWaWV3ICkgKS5tdWwoIGludGVuc2l0eSApO1xuXHRcdFx0Y29uc3QgaXNvbGF0ZUNsZWFyY29hdFJhZGlhbmNlID0gY2FjaGUoIGNsZWFyY29hdFJhZGlhbmNlQ29udGV4dCApO1xuXG5cdFx0XHRjbGVhcmNvYXRSYWRpYW5jZS5hZGRBc3NpZ24oIGlzb2xhdGVDbGVhcmNvYXRSYWRpYW5jZSApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBFbnZpcm9ubWVudE5vZGU7XG5cbmNvbnN0IGNyZWF0ZVJhZGlhbmNlQ29udGV4dCA9ICggcm91Z2huZXNzTm9kZSwgbm9ybWFsVmlld05vZGUgKSA9PiB7XG5cblx0bGV0IHJlZmxlY3RWZWMgPSBudWxsO1xuXG5cdHJldHVybiB7XG5cdFx0Z2V0VVY6ICgpID0+IHtcblxuXHRcdFx0aWYgKCByZWZsZWN0VmVjID09PSBudWxsICkge1xuXG5cdFx0XHRcdHJlZmxlY3RWZWMgPSBwb3NpdGlvblZpZXdEaXJlY3Rpb24ubmVnYXRlKCkucmVmbGVjdCggbm9ybWFsVmlld05vZGUgKTtcblxuXHRcdFx0XHQvLyBNaXhpbmcgdGhlIHJlZmxlY3Rpb24gd2l0aCB0aGUgbm9ybWFsIGlzIG1vcmUgYWNjdXJhdGUgYW5kIGtlZXBzIHJvdWdoIG9iamVjdHMgZnJvbSBnYXRoZXJpbmcgbGlnaHQgZnJvbSBiZWhpbmQgdGhlaXIgdGFuZ2VudCBwbGFuZS5cblx0XHRcdFx0cmVmbGVjdFZlYyA9IHJvdWdobmVzc05vZGUubXVsKCByb3VnaG5lc3NOb2RlICkubWl4KCByZWZsZWN0VmVjLCBub3JtYWxWaWV3Tm9kZSApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdHJlZmxlY3RWZWMgPSByZWZsZWN0VmVjLnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhVmlld01hdHJpeCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZWZsZWN0VmVjO1xuXG5cdFx0fSxcblx0XHRnZXRUZXh0dXJlTGV2ZWw6ICgpID0+IHtcblxuXHRcdFx0cmV0dXJuIHJvdWdobmVzc05vZGU7XG5cblx0XHR9XG5cdH07XG5cbn07XG5cbmNvbnN0IGNyZWF0ZUlycmFkaWFuY2VDb250ZXh0ID0gKCBub3JtYWxXb3JsZE5vZGUgKSA9PiB7XG5cblx0cmV0dXJuIHtcblx0XHRnZXRVVjogKCkgPT4ge1xuXG5cdFx0XHRyZXR1cm4gbm9ybWFsV29ybGROb2RlO1xuXG5cdFx0fSxcblx0XHRnZXRUZXh0dXJlTGV2ZWw6ICgpID0+IHtcblxuXHRcdFx0cmV0dXJuIGZsb2F0KCAxLjAgKTtcblxuXHRcdH1cblx0fTtcblxufTtcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi9Ob2RlTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgZGlmZnVzZUNvbG9yLCBtZXRhbG5lc3MsIHJvdWdobmVzcywgc3BlY3VsYXJDb2xvciwgc3BlY3VsYXJGOTAgfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XG5pbXBvcnQgeyBtaXggfSBmcm9tICcuLi8uLi9ub2Rlcy9tYXRoL01hdGhOb2RlLmpzJztcbmltcG9ydCB7IG1hdGVyaWFsUm91Z2huZXNzLCBtYXRlcmlhbE1ldGFsbmVzcyB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbE5vZGUuanMnO1xuaW1wb3J0IGdldFJvdWdobmVzcyBmcm9tICcuLi8uLi9ub2Rlcy9mdW5jdGlvbnMvbWF0ZXJpYWwvZ2V0Um91Z2huZXNzLmpzJztcbmltcG9ydCBQaHlzaWNhbExpZ2h0aW5nTW9kZWwgZnJvbSAnLi4vLi4vbm9kZXMvZnVuY3Rpb25zL1BoeXNpY2FsTGlnaHRpbmdNb2RlbC5qcyc7XG5pbXBvcnQgRW52aXJvbm1lbnROb2RlIGZyb20gJy4uLy4uL25vZGVzL2xpZ2h0aW5nL0Vudmlyb25tZW50Tm9kZS5qcyc7XG5pbXBvcnQgeyBmbG9hdCwgdmVjMywgdmVjNCB9IGZyb20gJy4uLy4uL25vZGVzL3RzbC9UU0xCYXNlLmpzJztcblxuaW1wb3J0IHsgTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfSBmcm9tICcuLi9NZXNoU3RhbmRhcmRNYXRlcmlhbC5qcyc7XG5cbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoKTtcblxuY2xhc3MgTWVzaFN0YW5kYXJkTm9kZU1hdGVyaWFsIGV4dGVuZHMgTm9kZU1hdGVyaWFsIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ01lc2hTdGFuZGFyZE5vZGVNYXRlcmlhbCc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNNZXNoU3RhbmRhcmROb2RlTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy5saWdodHMgPSB0cnVlO1xuXG5cdFx0dGhpcy5lbWlzc2l2ZU5vZGUgPSBudWxsO1xuXG5cdFx0dGhpcy5tZXRhbG5lc3NOb2RlID0gbnVsbDtcblx0XHR0aGlzLnJvdWdobmVzc05vZGUgPSBudWxsO1xuXG5cdFx0dGhpcy5zZXREZWZhdWx0VmFsdWVzKCBfZGVmYXVsdFZhbHVlcyApO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0c2V0dXBFbnZpcm9ubWVudCggYnVpbGRlciApIHtcblxuXHRcdGxldCBlbnZOb2RlID0gc3VwZXIuc2V0dXBFbnZpcm9ubWVudCggYnVpbGRlciApO1xuXG5cdFx0aWYgKCBlbnZOb2RlID09PSBudWxsICYmIGJ1aWxkZXIuZW52aXJvbm1lbnROb2RlICkge1xuXG5cdFx0XHRlbnZOb2RlID0gYnVpbGRlci5lbnZpcm9ubWVudE5vZGU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZW52Tm9kZSA/IG5ldyBFbnZpcm9ubWVudE5vZGUoIGVudk5vZGUgKSA6IG51bGw7XG5cblx0fVxuXG5cdHNldHVwTGlnaHRpbmdNb2RlbCggLypidWlsZGVyKi8gKSB7XG5cblx0XHRyZXR1cm4gbmV3IFBoeXNpY2FsTGlnaHRpbmdNb2RlbCgpO1xuXG5cdH1cblxuXHRzZXR1cFNwZWN1bGFyKCkge1xuXG5cdFx0Y29uc3Qgc3BlY3VsYXJDb2xvck5vZGUgPSBtaXgoIHZlYzMoIDAuMDQgKSwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzICk7XG5cblx0XHRzcGVjdWxhckNvbG9yLmFzc2lnbiggc3BlY3VsYXJDb2xvck5vZGUgKTtcblx0XHRzcGVjdWxhckY5MC5hc3NpZ24oIDEuMCApO1xuXG5cdH1cblxuXHRzZXR1cFZhcmlhbnRzKCkge1xuXG5cdFx0Ly8gTUVUQUxORVNTXG5cblx0XHRjb25zdCBtZXRhbG5lc3NOb2RlID0gdGhpcy5tZXRhbG5lc3NOb2RlID8gZmxvYXQoIHRoaXMubWV0YWxuZXNzTm9kZSApIDogbWF0ZXJpYWxNZXRhbG5lc3M7XG5cblx0XHRtZXRhbG5lc3MuYXNzaWduKCBtZXRhbG5lc3NOb2RlICk7XG5cblx0XHQvLyBST1VHSE5FU1NcblxuXHRcdGxldCByb3VnaG5lc3NOb2RlID0gdGhpcy5yb3VnaG5lc3NOb2RlID8gZmxvYXQoIHRoaXMucm91Z2huZXNzTm9kZSApIDogbWF0ZXJpYWxSb3VnaG5lc3M7XG5cdFx0cm91Z2huZXNzTm9kZSA9IGdldFJvdWdobmVzcyggeyByb3VnaG5lc3M6IHJvdWdobmVzc05vZGUgfSApO1xuXG5cdFx0cm91Z2huZXNzLmFzc2lnbiggcm91Z2huZXNzTm9kZSApO1xuXG5cdFx0Ly8gU1BFQ1VMQVIgQ09MT1JcblxuXHRcdHRoaXMuc2V0dXBTcGVjdWxhcigpO1xuXG5cdFx0Ly8gRElGRlVTRSBDT0xPUlxuXG5cdFx0ZGlmZnVzZUNvbG9yLmFzc2lnbiggdmVjNCggZGlmZnVzZUNvbG9yLnJnYi5tdWwoIG1ldGFsbmVzc05vZGUub25lTWludXMoKSApLCBkaWZmdXNlQ29sb3IuYSApICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMuZW1pc3NpdmVOb2RlID0gc291cmNlLmVtaXNzaXZlTm9kZTtcblxuXHRcdHRoaXMubWV0YWxuZXNzTm9kZSA9IHNvdXJjZS5tZXRhbG5lc3NOb2RlO1xuXHRcdHRoaXMucm91Z2huZXNzTm9kZSA9IHNvdXJjZS5yb3VnaG5lc3NOb2RlO1xuXG5cdFx0cmV0dXJuIHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBNZXNoU3RhbmRhcmROb2RlTWF0ZXJpYWw7XG4iLCJpbXBvcnQgeyBjbGVhcmNvYXQsIGNsZWFyY29hdFJvdWdobmVzcywgc2hlZW4sIHNoZWVuUm91Z2huZXNzLCBpcmlkZXNjZW5jZSwgaXJpZGVzY2VuY2VJT1IsIGlyaWRlc2NlbmNlVGhpY2tuZXNzLCBzcGVjdWxhckNvbG9yLCBzcGVjdWxhckY5MCwgZGlmZnVzZUNvbG9yLCBtZXRhbG5lc3MsIHJvdWdobmVzcywgYW5pc290cm9weSwgYWxwaGFULCBhbmlzb3Ryb3B5VCwgYW5pc290cm9weUIsIGlvciwgdHJhbnNtaXNzaW9uLCB0aGlja25lc3MsIGF0dGVudWF0aW9uRGlzdGFuY2UsIGF0dGVudWF0aW9uQ29sb3IsIGRpc3BlcnNpb24gfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XG5pbXBvcnQgeyBtYXRlcmlhbENsZWFyY29hdCwgbWF0ZXJpYWxDbGVhcmNvYXRSb3VnaG5lc3MsIG1hdGVyaWFsQ2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbFNoZWVuLCBtYXRlcmlhbFNoZWVuUm91Z2huZXNzLCBtYXRlcmlhbElyaWRlc2NlbmNlLCBtYXRlcmlhbElyaWRlc2NlbmNlSU9SLCBtYXRlcmlhbElyaWRlc2NlbmNlVGhpY2tuZXNzLCBtYXRlcmlhbFNwZWN1bGFySW50ZW5zaXR5LCBtYXRlcmlhbFNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsQW5pc290cm9weSwgbWF0ZXJpYWxJT1IsIG1hdGVyaWFsVHJhbnNtaXNzaW9uLCBtYXRlcmlhbFRoaWNrbmVzcywgbWF0ZXJpYWxBdHRlbnVhdGlvbkRpc3RhbmNlLCBtYXRlcmlhbEF0dGVudWF0aW9uQ29sb3IsIG1hdGVyaWFsRGlzcGVyc2lvbiB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbE5vZGUuanMnO1xuaW1wb3J0IHsgZmxvYXQsIHZlYzIsIHZlYzMsIElmIH0gZnJvbSAnLi4vLi4vbm9kZXMvdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IGdldFJvdWdobmVzcyBmcm9tICcuLi8uLi9ub2Rlcy9mdW5jdGlvbnMvbWF0ZXJpYWwvZ2V0Um91Z2huZXNzLmpzJztcbmltcG9ydCB7IFRCTlZpZXdNYXRyaXggfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvQWNjZXNzb3JzVXRpbHMuanMnO1xuaW1wb3J0IFBoeXNpY2FsTGlnaHRpbmdNb2RlbCBmcm9tICcuLi8uLi9ub2Rlcy9mdW5jdGlvbnMvUGh5c2ljYWxMaWdodGluZ01vZGVsLmpzJztcbmltcG9ydCBNZXNoU3RhbmRhcmROb2RlTWF0ZXJpYWwgZnJvbSAnLi9NZXNoU3RhbmRhcmROb2RlTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgbWl4LCBwb3cyLCBtaW4gfSBmcm9tICcuLi8uLi9ub2Rlcy9tYXRoL01hdGhOb2RlLmpzJztcblxuaW1wb3J0IHsgTWVzaFBoeXNpY2FsTWF0ZXJpYWwgfSBmcm9tICcuLi9NZXNoUGh5c2ljYWxNYXRlcmlhbC5qcyc7XG5cbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgTWVzaFBoeXNpY2FsTWF0ZXJpYWwoKTtcblxuY2xhc3MgTWVzaFBoeXNpY2FsTm9kZU1hdGVyaWFsIGV4dGVuZHMgTWVzaFN0YW5kYXJkTm9kZU1hdGVyaWFsIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ01lc2hQaHlzaWNhbE5vZGVNYXRlcmlhbCc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNNZXNoUGh5c2ljYWxOb2RlTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy5jbGVhcmNvYXROb2RlID0gbnVsbDtcblx0XHR0aGlzLmNsZWFyY29hdFJvdWdobmVzc05vZGUgPSBudWxsO1xuXHRcdHRoaXMuY2xlYXJjb2F0Tm9ybWFsTm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLnNoZWVuTm9kZSA9IG51bGw7XG5cdFx0dGhpcy5zaGVlblJvdWdobmVzc05vZGUgPSBudWxsO1xuXG5cdFx0dGhpcy5pcmlkZXNjZW5jZU5vZGUgPSBudWxsO1xuXHRcdHRoaXMuaXJpZGVzY2VuY2VJT1JOb2RlID0gbnVsbDtcblx0XHR0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLnNwZWN1bGFySW50ZW5zaXR5Tm9kZSA9IG51bGw7XG5cdFx0dGhpcy5zcGVjdWxhckNvbG9yTm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLmlvck5vZGUgPSBudWxsO1xuXHRcdHRoaXMudHJhbnNtaXNzaW9uTm9kZSA9IG51bGw7XG5cdFx0dGhpcy50aGlja25lc3NOb2RlID0gbnVsbDtcblx0XHR0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2VOb2RlID0gbnVsbDtcblx0XHR0aGlzLmF0dGVudWF0aW9uQ29sb3JOb2RlID0gbnVsbDtcblx0XHR0aGlzLmRpc3BlcnNpb25Ob2RlID0gbnVsbDtcblxuXHRcdHRoaXMuYW5pc290cm9weU5vZGUgPSBudWxsO1xuXG5cdFx0dGhpcy5zZXREZWZhdWx0VmFsdWVzKCBfZGVmYXVsdFZhbHVlcyApO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Z2V0IHVzZUNsZWFyY29hdCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmNsZWFyY29hdCA+IDAgfHwgdGhpcy5jbGVhcmNvYXROb2RlICE9PSBudWxsO1xuXG5cdH1cblxuXHRnZXQgdXNlSXJpZGVzY2VuY2UoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pcmlkZXNjZW5jZSA+IDAgfHwgdGhpcy5pcmlkZXNjZW5jZU5vZGUgIT09IG51bGw7XG5cblx0fVxuXG5cdGdldCB1c2VTaGVlbigpIHtcblxuXHRcdHJldHVybiB0aGlzLnNoZWVuID4gMCB8fCB0aGlzLnNoZWVuTm9kZSAhPT0gbnVsbDtcblxuXHR9XG5cblx0Z2V0IHVzZUFuaXNvdHJvcHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hbmlzb3Ryb3B5ID4gMCB8fCB0aGlzLmFuaXNvdHJvcHlOb2RlICE9PSBudWxsO1xuXG5cdH1cblxuXHRnZXQgdXNlVHJhbnNtaXNzaW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNtaXNzaW9uID4gMCB8fCB0aGlzLnRyYW5zbWlzc2lvbk5vZGUgIT09IG51bGw7XG5cblx0fVxuXG5cdGdldCB1c2VEaXNwZXJzaW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGlzcGVyc2lvbiA+IDAgfHwgdGhpcy5kaXNwZXJzaW9uTm9kZSAhPT0gbnVsbDtcblxuXHR9XG5cblx0c2V0dXBTcGVjdWxhcigpIHtcblxuXHRcdGNvbnN0IGlvck5vZGUgPSB0aGlzLmlvck5vZGUgPyBmbG9hdCggdGhpcy5pb3JOb2RlICkgOiBtYXRlcmlhbElPUjtcblxuXHRcdGlvci5hc3NpZ24oIGlvck5vZGUgKTtcblx0XHRzcGVjdWxhckNvbG9yLmFzc2lnbiggbWl4KCBtaW4oIHBvdzIoIGlvci5zdWIoIDEuMCApLmRpdiggaW9yLmFkZCggMS4wICkgKSApLm11bCggbWF0ZXJpYWxTcGVjdWxhckNvbG9yICksIHZlYzMoIDEuMCApICkubXVsKCBtYXRlcmlhbFNwZWN1bGFySW50ZW5zaXR5ICksIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzcyApICk7XG5cdFx0c3BlY3VsYXJGOTAuYXNzaWduKCBtaXgoIG1hdGVyaWFsU3BlY3VsYXJJbnRlbnNpdHksIDEuMCwgbWV0YWxuZXNzICkgKTtcblxuXHR9XG5cblx0c2V0dXBMaWdodGluZ01vZGVsKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdHJldHVybiBuZXcgUGh5c2ljYWxMaWdodGluZ01vZGVsKCB0aGlzLnVzZUNsZWFyY29hdCwgdGhpcy51c2VTaGVlbiwgdGhpcy51c2VJcmlkZXNjZW5jZSwgdGhpcy51c2VBbmlzb3Ryb3B5LCB0aGlzLnVzZVRyYW5zbWlzc2lvbiwgdGhpcy51c2VEaXNwZXJzaW9uICk7XG5cblx0fVxuXG5cdHNldHVwVmFyaWFudHMoIGJ1aWxkZXIgKSB7XG5cblx0XHRzdXBlci5zZXR1cFZhcmlhbnRzKCBidWlsZGVyICk7XG5cblx0XHQvLyBDTEVBUkNPQVRcblxuXHRcdGlmICggdGhpcy51c2VDbGVhcmNvYXQgKSB7XG5cblx0XHRcdGNvbnN0IGNsZWFyY29hdE5vZGUgPSB0aGlzLmNsZWFyY29hdE5vZGUgPyBmbG9hdCggdGhpcy5jbGVhcmNvYXROb2RlICkgOiBtYXRlcmlhbENsZWFyY29hdDtcblx0XHRcdGNvbnN0IGNsZWFyY29hdFJvdWdobmVzc05vZGUgPSB0aGlzLmNsZWFyY29hdFJvdWdobmVzc05vZGUgPyBmbG9hdCggdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NOb2RlICkgOiBtYXRlcmlhbENsZWFyY29hdFJvdWdobmVzcztcblxuXHRcdFx0Y2xlYXJjb2F0LmFzc2lnbiggY2xlYXJjb2F0Tm9kZSApO1xuXHRcdFx0Y2xlYXJjb2F0Um91Z2huZXNzLmFzc2lnbiggZ2V0Um91Z2huZXNzKCB7IHJvdWdobmVzczogY2xlYXJjb2F0Um91Z2huZXNzTm9kZSB9ICkgKTtcblxuXHRcdH1cblxuXHRcdC8vIFNIRUVOXG5cblx0XHRpZiAoIHRoaXMudXNlU2hlZW4gKSB7XG5cblx0XHRcdGNvbnN0IHNoZWVuTm9kZSA9IHRoaXMuc2hlZW5Ob2RlID8gdmVjMyggdGhpcy5zaGVlbk5vZGUgKSA6IG1hdGVyaWFsU2hlZW47XG5cdFx0XHRjb25zdCBzaGVlblJvdWdobmVzc05vZGUgPSB0aGlzLnNoZWVuUm91Z2huZXNzTm9kZSA/IGZsb2F0KCB0aGlzLnNoZWVuUm91Z2huZXNzTm9kZSApIDogbWF0ZXJpYWxTaGVlblJvdWdobmVzcztcblxuXHRcdFx0c2hlZW4uYXNzaWduKCBzaGVlbk5vZGUgKTtcblx0XHRcdHNoZWVuUm91Z2huZXNzLmFzc2lnbiggc2hlZW5Sb3VnaG5lc3NOb2RlICk7XG5cblx0XHR9XG5cblx0XHQvLyBJUklERVNDRU5DRVxuXG5cdFx0aWYgKCB0aGlzLnVzZUlyaWRlc2NlbmNlICkge1xuXG5cdFx0XHRjb25zdCBpcmlkZXNjZW5jZU5vZGUgPSB0aGlzLmlyaWRlc2NlbmNlTm9kZSA/IGZsb2F0KCB0aGlzLmlyaWRlc2NlbmNlTm9kZSApIDogbWF0ZXJpYWxJcmlkZXNjZW5jZTtcblx0XHRcdGNvbnN0IGlyaWRlc2NlbmNlSU9STm9kZSA9IHRoaXMuaXJpZGVzY2VuY2VJT1JOb2RlID8gZmxvYXQoIHRoaXMuaXJpZGVzY2VuY2VJT1JOb2RlICkgOiBtYXRlcmlhbElyaWRlc2NlbmNlSU9SO1xuXHRcdFx0Y29uc3QgaXJpZGVzY2VuY2VUaGlja25lc3NOb2RlID0gdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc05vZGUgPyBmbG9hdCggdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc05vZGUgKSA6IG1hdGVyaWFsSXJpZGVzY2VuY2VUaGlja25lc3M7XG5cblx0XHRcdGlyaWRlc2NlbmNlLmFzc2lnbiggaXJpZGVzY2VuY2VOb2RlICk7XG5cdFx0XHRpcmlkZXNjZW5jZUlPUi5hc3NpZ24oIGlyaWRlc2NlbmNlSU9STm9kZSApO1xuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3MuYXNzaWduKCBpcmlkZXNjZW5jZVRoaWNrbmVzc05vZGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIEFOSVNPVFJPUFlcblxuXHRcdGlmICggdGhpcy51c2VBbmlzb3Ryb3B5ICkge1xuXG5cdFx0XHRjb25zdCBhbmlzb3Ryb3B5ViA9ICggdGhpcy5hbmlzb3Ryb3B5Tm9kZSA/IHZlYzIoIHRoaXMuYW5pc290cm9weU5vZGUgKSA6IG1hdGVyaWFsQW5pc290cm9weSApLnRvVmFyKCk7XG5cblx0XHRcdGFuaXNvdHJvcHkuYXNzaWduKCBhbmlzb3Ryb3B5Vi5sZW5ndGgoKSApO1xuXG5cdFx0XHRJZiggYW5pc290cm9weS5lcXVhbCggMC4wICksICgpID0+IHtcblxuXHRcdFx0XHRhbmlzb3Ryb3B5Vi5hc3NpZ24oIHZlYzIoIDEuMCwgMC4wICkgKTtcblxuXHRcdFx0fSApLkVsc2UoICgpID0+IHtcblxuXHRcdFx0XHRhbmlzb3Ryb3B5Vi5kaXZBc3NpZ24oIHZlYzIoIGFuaXNvdHJvcHkgKSApO1xuXHRcdFx0XHRhbmlzb3Ryb3B5LmFzc2lnbiggYW5pc290cm9weS5zYXR1cmF0ZSgpICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gUm91Z2huZXNzIGFsb25nIHRoZSBhbmlzb3Ryb3B5IGJpdGFuZ2VudCBpcyB0aGUgbWF0ZXJpYWwgcm91Z2huZXNzLCB3aGlsZSB0aGUgdGFuZ2VudCByb3VnaG5lc3MgaW5jcmVhc2VzIHdpdGggYW5pc290cm9weS5cblx0XHRcdGFscGhhVC5hc3NpZ24oIGFuaXNvdHJvcHkucG93MigpLm1peCggcm91Z2huZXNzLnBvdzIoKSwgMS4wICkgKTtcblxuXHRcdFx0YW5pc290cm9weVQuYXNzaWduKCBUQk5WaWV3TWF0cml4WyAwIF0ubXVsKCBhbmlzb3Ryb3B5Vi54ICkuYWRkKCBUQk5WaWV3TWF0cml4WyAxIF0ubXVsKCBhbmlzb3Ryb3B5Vi55ICkgKSApO1xuXHRcdFx0YW5pc290cm9weUIuYXNzaWduKCBUQk5WaWV3TWF0cml4WyAxIF0ubXVsKCBhbmlzb3Ryb3B5Vi54ICkuc3ViKCBUQk5WaWV3TWF0cml4WyAwIF0ubXVsKCBhbmlzb3Ryb3B5Vi55ICkgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gVFJBTlNNSVNTSU9OXG5cblx0XHRpZiAoIHRoaXMudXNlVHJhbnNtaXNzaW9uICkge1xuXG5cdFx0XHRjb25zdCB0cmFuc21pc3Npb25Ob2RlID0gdGhpcy50cmFuc21pc3Npb25Ob2RlID8gZmxvYXQoIHRoaXMudHJhbnNtaXNzaW9uTm9kZSApIDogbWF0ZXJpYWxUcmFuc21pc3Npb247XG5cdFx0XHRjb25zdCB0aGlja25lc3NOb2RlID0gdGhpcy50aGlja25lc3NOb2RlID8gZmxvYXQoIHRoaXMudGhpY2tuZXNzTm9kZSApIDogbWF0ZXJpYWxUaGlja25lc3M7XG5cdFx0XHRjb25zdCBhdHRlbnVhdGlvbkRpc3RhbmNlTm9kZSA9IHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZU5vZGUgPyBmbG9hdCggdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlTm9kZSApIDogbWF0ZXJpYWxBdHRlbnVhdGlvbkRpc3RhbmNlO1xuXHRcdFx0Y29uc3QgYXR0ZW51YXRpb25Db2xvck5vZGUgPSB0aGlzLmF0dGVudWF0aW9uQ29sb3JOb2RlID8gdmVjMyggdGhpcy5hdHRlbnVhdGlvbkNvbG9yTm9kZSApIDogbWF0ZXJpYWxBdHRlbnVhdGlvbkNvbG9yO1xuXG5cdFx0XHR0cmFuc21pc3Npb24uYXNzaWduKCB0cmFuc21pc3Npb25Ob2RlICk7XG5cdFx0XHR0aGlja25lc3MuYXNzaWduKCB0aGlja25lc3NOb2RlICk7XG5cdFx0XHRhdHRlbnVhdGlvbkRpc3RhbmNlLmFzc2lnbiggYXR0ZW51YXRpb25EaXN0YW5jZU5vZGUgKTtcblx0XHRcdGF0dGVudWF0aW9uQ29sb3IuYXNzaWduKCBhdHRlbnVhdGlvbkNvbG9yTm9kZSApO1xuXG5cdFx0XHRpZiAoIHRoaXMudXNlRGlzcGVyc2lvbiApIHtcblxuXHRcdFx0XHRjb25zdCBkaXNwZXJzaW9uTm9kZSA9IHRoaXMuZGlzcGVyc2lvbk5vZGUgPyBmbG9hdCggdGhpcy5kaXNwZXJzaW9uTm9kZSApIDogbWF0ZXJpYWxEaXNwZXJzaW9uO1xuXG5cdFx0XHRcdGRpc3BlcnNpb24uYXNzaWduKCBkaXNwZXJzaW9uTm9kZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldHVwQ2xlYXJjb2F0Tm9ybWFsKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY2xlYXJjb2F0Tm9ybWFsTm9kZSA/IHZlYzMoIHRoaXMuY2xlYXJjb2F0Tm9ybWFsTm9kZSApIDogbWF0ZXJpYWxDbGVhcmNvYXROb3JtYWw7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0YnVpbGRlci5jb250ZXh0LnNldHVwQ2xlYXJjb2F0Tm9ybWFsID0gKCkgPT4gdGhpcy5zZXR1cENsZWFyY29hdE5vcm1hbCggYnVpbGRlciApO1xuXG5cdFx0c3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0dGhpcy5jbGVhcmNvYXROb2RlID0gc291cmNlLmNsZWFyY29hdE5vZGU7XG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NOb2RlID0gc291cmNlLmNsZWFyY29hdFJvdWdobmVzc05vZGU7XG5cdFx0dGhpcy5jbGVhcmNvYXROb3JtYWxOb2RlID0gc291cmNlLmNsZWFyY29hdE5vcm1hbE5vZGU7XG5cblx0XHR0aGlzLnNoZWVuTm9kZSA9IHNvdXJjZS5zaGVlbk5vZGU7XG5cdFx0dGhpcy5zaGVlblJvdWdobmVzc05vZGUgPSBzb3VyY2Uuc2hlZW5Sb3VnaG5lc3NOb2RlO1xuXG5cdFx0dGhpcy5pcmlkZXNjZW5jZU5vZGUgPSBzb3VyY2UuaXJpZGVzY2VuY2VOb2RlO1xuXHRcdHRoaXMuaXJpZGVzY2VuY2VJT1JOb2RlID0gc291cmNlLmlyaWRlc2NlbmNlSU9STm9kZTtcblx0XHR0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTm9kZSA9IHNvdXJjZS5pcmlkZXNjZW5jZVRoaWNrbmVzc05vZGU7XG5cblx0XHR0aGlzLnNwZWN1bGFySW50ZW5zaXR5Tm9kZSA9IHNvdXJjZS5zcGVjdWxhckludGVuc2l0eU5vZGU7XG5cdFx0dGhpcy5zcGVjdWxhckNvbG9yTm9kZSA9IHNvdXJjZS5zcGVjdWxhckNvbG9yTm9kZTtcblxuXHRcdHRoaXMudHJhbnNtaXNzaW9uTm9kZSA9IHNvdXJjZS50cmFuc21pc3Npb25Ob2RlO1xuXHRcdHRoaXMudGhpY2tuZXNzTm9kZSA9IHNvdXJjZS50aGlja25lc3NOb2RlO1xuXHRcdHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZU5vZGUgPSBzb3VyY2UuYXR0ZW51YXRpb25EaXN0YW5jZU5vZGU7XG5cdFx0dGhpcy5hdHRlbnVhdGlvbkNvbG9yTm9kZSA9IHNvdXJjZS5hdHRlbnVhdGlvbkNvbG9yTm9kZTtcblx0XHR0aGlzLmRpc3BlcnNpb25Ob2RlID0gc291cmNlLmRpc3BlcnNpb25Ob2RlO1xuXG5cdFx0dGhpcy5hbmlzb3Ryb3B5Tm9kZSA9IHNvdXJjZS5hbmlzb3Ryb3B5Tm9kZTtcblxuXHRcdHJldHVybiBzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWVzaFBoeXNpY2FsTm9kZU1hdGVyaWFsO1xuIiwiaW1wb3J0IE1lc2hQaHlzaWNhbE5vZGVNYXRlcmlhbCBmcm9tICcuL01lc2hQaHlzaWNhbE5vZGVNYXRlcmlhbC5qcyc7XG5pbXBvcnQgUGh5c2ljYWxMaWdodGluZ01vZGVsIGZyb20gJy4uLy4uL25vZGVzL2Z1bmN0aW9ucy9QaHlzaWNhbExpZ2h0aW5nTW9kZWwuanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtZWROb3JtYWxWaWV3IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL05vcm1hbC5qcyc7XG5pbXBvcnQgeyBwb3NpdGlvblZpZXdEaXJlY3Rpb24gfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgZmxvYXQsIHZlYzMgfSBmcm9tICcuLi8uLi9ub2Rlcy90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIFNTU0xpZ2h0aW5nTW9kZWwgZXh0ZW5kcyBQaHlzaWNhbExpZ2h0aW5nTW9kZWwge1xuXG5cdGNvbnN0cnVjdG9yKCB1c2VDbGVhcmNvYXQsIHVzZVNoZWVuLCB1c2VJcmlkZXNjZW5jZSwgdXNlU1NTICkge1xuXG5cdFx0c3VwZXIoIHVzZUNsZWFyY29hdCwgdXNlU2hlZW4sIHVzZUlyaWRlc2NlbmNlICk7XG5cblx0XHR0aGlzLnVzZVNTUyA9IHVzZVNTUztcblxuXHR9XG5cblx0ZGlyZWN0KCB7IGxpZ2h0RGlyZWN0aW9uLCBsaWdodENvbG9yLCByZWZsZWN0ZWRMaWdodCB9LCBzdGFjaywgYnVpbGRlciApIHtcblxuXHRcdGlmICggdGhpcy51c2VTU1MgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gYnVpbGRlci5tYXRlcmlhbDtcblxuXHRcdFx0Y29uc3QgeyB0aGlja25lc3NDb2xvck5vZGUsIHRoaWNrbmVzc0Rpc3RvcnRpb25Ob2RlLCB0aGlja25lc3NBbWJpZW50Tm9kZSwgdGhpY2tuZXNzQXR0ZW51YXRpb25Ob2RlLCB0aGlja25lc3NQb3dlck5vZGUsIHRoaWNrbmVzc1NjYWxlTm9kZSB9ID0gbWF0ZXJpYWw7XG5cblx0XHRcdGNvbnN0IHNjYXR0ZXJpbmdIYWxmID0gbGlnaHREaXJlY3Rpb24uYWRkKCB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcubXVsKCB0aGlja25lc3NEaXN0b3J0aW9uTm9kZSApICkubm9ybWFsaXplKCk7XG5cdFx0XHRjb25zdCBzY2F0dGVyaW5nRG90ID0gZmxvYXQoIHBvc2l0aW9uVmlld0RpcmVjdGlvbi5kb3QoIHNjYXR0ZXJpbmdIYWxmLm5lZ2F0ZSgpICkuc2F0dXJhdGUoKS5wb3coIHRoaWNrbmVzc1Bvd2VyTm9kZSApLm11bCggdGhpY2tuZXNzU2NhbGVOb2RlICkgKTtcblx0XHRcdGNvbnN0IHNjYXR0ZXJpbmdJbGx1ID0gdmVjMyggc2NhdHRlcmluZ0RvdC5hZGQoIHRoaWNrbmVzc0FtYmllbnROb2RlICkubXVsKCB0aGlja25lc3NDb2xvck5vZGUgKSApO1xuXG5cdFx0XHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlLmFkZEFzc2lnbiggc2NhdHRlcmluZ0lsbHUubXVsKCB0aGlja25lc3NBdHRlbnVhdGlvbk5vZGUubXVsKCBsaWdodENvbG9yICkgKSApO1xuXG5cdFx0fVxuXG5cdFx0c3VwZXIuZGlyZWN0KCB7IGxpZ2h0RGlyZWN0aW9uLCBsaWdodENvbG9yLCByZWZsZWN0ZWRMaWdodCB9LCBzdGFjaywgYnVpbGRlciApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBNZXNoU1NTTm9kZU1hdGVyaWFsIGV4dGVuZHMgTWVzaFBoeXNpY2FsTm9kZU1hdGVyaWFsIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ01lc2hTU1NOb2RlTWF0ZXJpYWwnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCBwYXJhbWV0ZXJzICk7XG5cblx0XHR0aGlzLnRoaWNrbmVzc0NvbG9yTm9kZSA9IG51bGw7XG5cdFx0dGhpcy50aGlja25lc3NEaXN0b3J0aW9uTm9kZSA9IGZsb2F0KCAwLjEgKTtcblx0XHR0aGlzLnRoaWNrbmVzc0FtYmllbnROb2RlID0gZmxvYXQoIDAuMCApO1xuXHRcdHRoaXMudGhpY2tuZXNzQXR0ZW51YXRpb25Ob2RlID0gZmxvYXQoIC4xICk7XG5cdFx0dGhpcy50aGlja25lc3NQb3dlck5vZGUgPSBmbG9hdCggMi4wICk7XG5cdFx0dGhpcy50aGlja25lc3NTY2FsZU5vZGUgPSBmbG9hdCggMTAuMCApO1xuXG5cdH1cblxuXHRnZXQgdXNlU1NTKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudGhpY2tuZXNzQ29sb3JOb2RlICE9PSBudWxsO1xuXG5cdH1cblxuXHRzZXR1cExpZ2h0aW5nTW9kZWwoIC8qYnVpbGRlciovICkge1xuXG5cdFx0cmV0dXJuIG5ldyBTU1NMaWdodGluZ01vZGVsKCB0aGlzLnVzZUNsZWFyY29hdCwgdGhpcy51c2VTaGVlbiwgdGhpcy51c2VJcmlkZXNjZW5jZSwgdGhpcy51c2VTU1MgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0dGhpcy50aGlja25lc3NDb2xvck5vZGUgPSBzb3VyY2UudGhpY2tuZXNzQ29sb3JOb2RlO1xuXHRcdHRoaXMudGhpY2tuZXNzRGlzdG9ydGlvbk5vZGUgPSBzb3VyY2UudGhpY2tuZXNzRGlzdG9ydGlvbk5vZGU7XG5cdFx0dGhpcy50aGlja25lc3NBbWJpZW50Tm9kZSA9IHNvdXJjZS50aGlja25lc3NBbWJpZW50Tm9kZTtcblx0XHR0aGlzLnRoaWNrbmVzc0F0dGVudWF0aW9uTm9kZSA9IHNvdXJjZS50aGlja25lc3NBdHRlbnVhdGlvbk5vZGU7XG5cdFx0dGhpcy50aGlja25lc3NQb3dlck5vZGUgPSBzb3VyY2UudGhpY2tuZXNzUG93ZXJOb2RlO1xuXHRcdHRoaXMudGhpY2tuZXNzU2NhbGVOb2RlID0gc291cmNlLnRoaWNrbmVzc1NjYWxlTm9kZTtcblxuXHRcdHJldHVybiBzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWVzaFNTU05vZGVNYXRlcmlhbDtcbiIsImltcG9ydCBMaWdodGluZ01vZGVsIGZyb20gJy4uL2NvcmUvTGlnaHRpbmdNb2RlbC5qcyc7XG5pbXBvcnQgQlJERl9MYW1iZXJ0IGZyb20gJy4vQlNERi9CUkRGX0xhbWJlcnQuanMnO1xuaW1wb3J0IHsgZGlmZnVzZUNvbG9yIH0gZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xuaW1wb3J0IHsgbm9ybWFsR2VvbWV0cnkgfSBmcm9tICcuLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcbmltcG9ydCB7IEZuLCBmbG9hdCwgdmVjMiwgdmVjMyB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IG1peCwgc21vb3Roc3RlcCB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xuaW1wb3J0IHsgbWF0ZXJpYWxSZWZlcmVuY2UgfSBmcm9tICcuLi9hY2Nlc3NvcnMvTWF0ZXJpYWxSZWZlcmVuY2VOb2RlLmpzJztcblxuY29uc3QgZ2V0R3JhZGllbnRJcnJhZGlhbmNlID0gLypAX19QVVJFX18qLyBGbiggKCB7IG5vcm1hbCwgbGlnaHREaXJlY3Rpb24sIGJ1aWxkZXIgfSApID0+IHtcblxuXHQvLyBkb3ROTCB3aWxsIGJlIGZyb20gLTEuMCB0byAxLjBcblx0Y29uc3QgZG90TkwgPSBub3JtYWwuZG90KCBsaWdodERpcmVjdGlvbiApO1xuXHRjb25zdCBjb29yZCA9IHZlYzIoIGRvdE5MLm11bCggMC41ICkuYWRkKCAwLjUgKSwgMC4wICk7XG5cblx0aWYgKCBidWlsZGVyLm1hdGVyaWFsLmdyYWRpZW50TWFwICkge1xuXG5cdFx0Y29uc3QgZ3JhZGllbnRNYXAgPSBtYXRlcmlhbFJlZmVyZW5jZSggJ2dyYWRpZW50TWFwJywgJ3RleHR1cmUnICkuY29udGV4dCggeyBnZXRVVjogKCkgPT4gY29vcmQgfSApO1xuXG5cdFx0cmV0dXJuIHZlYzMoIGdyYWRpZW50TWFwLnIgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Y29uc3QgZncgPSBjb29yZC5md2lkdGgoKS5tdWwoIDAuNSApO1xuXG5cdFx0cmV0dXJuIG1peCggdmVjMyggMC43ICksIHZlYzMoIDEuMCApLCBzbW9vdGhzdGVwKCBmbG9hdCggMC43ICkuc3ViKCBmdy54ICksIGZsb2F0KCAwLjcgKS5hZGQoIGZ3LnggKSwgY29vcmQueCApICk7XG5cblx0fVxuXG59ICk7XG5cbmNsYXNzIFRvb25MaWdodGluZ01vZGVsIGV4dGVuZHMgTGlnaHRpbmdNb2RlbCB7XG5cblx0ZGlyZWN0KCB7IGxpZ2h0RGlyZWN0aW9uLCBsaWdodENvbG9yLCByZWZsZWN0ZWRMaWdodCB9LCBzdGFjaywgYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IGlycmFkaWFuY2UgPSBnZXRHcmFkaWVudElycmFkaWFuY2UoIHsgbm9ybWFsOiBub3JtYWxHZW9tZXRyeSwgbGlnaHREaXJlY3Rpb24sIGJ1aWxkZXIgfSApLm11bCggbGlnaHRDb2xvciApO1xuXG5cdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZS5hZGRBc3NpZ24oIGlycmFkaWFuY2UubXVsKCBCUkRGX0xhbWJlcnQoIHsgZGlmZnVzZUNvbG9yOiBkaWZmdXNlQ29sb3IucmdiIH0gKSApICk7XG5cblx0fVxuXG5cdGluZGlyZWN0KCB7IGFtYmllbnRPY2NsdXNpb24sIGlycmFkaWFuY2UsIHJlZmxlY3RlZExpZ2h0IH0gKSB7XG5cblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UuYWRkQXNzaWduKCBpcnJhZGlhbmNlLm11bCggQlJERl9MYW1iZXJ0KCB7IGRpZmZ1c2VDb2xvciB9ICkgKSApO1xuXG5cdFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlLm11bEFzc2lnbiggYW1iaWVudE9jY2x1c2lvbiApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBUb29uTGlnaHRpbmdNb2RlbDtcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi9Ob2RlTWF0ZXJpYWwuanMnO1xuaW1wb3J0IFRvb25MaWdodGluZ01vZGVsIGZyb20gJy4uLy4uL25vZGVzL2Z1bmN0aW9ucy9Ub29uTGlnaHRpbmdNb2RlbC5qcyc7XG5cbmltcG9ydCB7IE1lc2hUb29uTWF0ZXJpYWwgfSBmcm9tICcuLi9NZXNoVG9vbk1hdGVyaWFsLmpzJztcblxuY29uc3QgX2RlZmF1bHRWYWx1ZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBNZXNoVG9vbk1hdGVyaWFsKCk7XG5cbmNsYXNzIE1lc2hUb29uTm9kZU1hdGVyaWFsIGV4dGVuZHMgTm9kZU1hdGVyaWFsIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ01lc2hUb29uTm9kZU1hdGVyaWFsJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc01lc2hUb29uTm9kZU1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMubGlnaHRzID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2V0RGVmYXVsdFZhbHVlcyggX2RlZmF1bHRWYWx1ZXMgKTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdHNldHVwTGlnaHRpbmdNb2RlbCggLypidWlsZGVyKi8gKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRvb25MaWdodGluZ01vZGVsKCk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lc2hUb29uTm9kZU1hdGVyaWFsO1xuIiwiaW1wb3J0IFRlbXBOb2RlIGZyb20gJy4uL2NvcmUvVGVtcE5vZGUuanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtZWROb3JtYWxWaWV3IH0gZnJvbSAnLi4vYWNjZXNzb3JzL05vcm1hbC5qcyc7XG5pbXBvcnQgeyBwb3NpdGlvblZpZXdEaXJlY3Rpb24gfSBmcm9tICcuLi9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgbm9kZUltbXV0YWJsZSwgdmVjMiwgdmVjMyB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY2xhc3MgTWF0Y2FwVVZOb2RlIGV4dGVuZHMgVGVtcE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnTWF0Y2FwVVZOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlciggJ3ZlYzInICk7XG5cblx0fVxuXG5cdHNldHVwKCkge1xuXG5cdFx0Y29uc3QgeCA9IHZlYzMoIHBvc2l0aW9uVmlld0RpcmVjdGlvbi56LCAwLCBwb3NpdGlvblZpZXdEaXJlY3Rpb24ueC5uZWdhdGUoKSApLm5vcm1hbGl6ZSgpO1xuXHRcdGNvbnN0IHkgPSBwb3NpdGlvblZpZXdEaXJlY3Rpb24uY3Jvc3MoIHggKTtcblxuXHRcdHJldHVybiB2ZWMyKCB4LmRvdCggdHJhbnNmb3JtZWROb3JtYWxWaWV3ICksIHkuZG90KCB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcgKSApLm11bCggMC40OTUgKS5hZGQoIDAuNSApOyAvLyAwLjQ5NSB0byByZW1vdmUgYXJ0aWZhY3RzIGNhdXNlZCBieSB1bmRlcnNpemVkIG1hdGNhcCBkaXNrc1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXRjYXBVVk5vZGU7XG5cbmV4cG9ydCBjb25zdCBtYXRjYXBVViA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0Y2FwVVZOb2RlICk7XG4iLCJpbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4vTm9kZU1hdGVyaWFsLmpzJztcbmltcG9ydCB7IG1hdGVyaWFsUmVmZXJlbmNlIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL01hdGVyaWFsUmVmZXJlbmNlTm9kZS5qcyc7XG5pbXBvcnQgeyBkaWZmdXNlQ29sb3IgfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XG5pbXBvcnQgeyB2ZWMzIH0gZnJvbSAnLi4vLi4vbm9kZXMvdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgbWl4IH0gZnJvbSAnLi4vLi4vbm9kZXMvbWF0aC9NYXRoTm9kZS5qcyc7XG5pbXBvcnQgeyBtYXRjYXBVViB9IGZyb20gJy4uLy4uL25vZGVzL3V0aWxzL01hdGNhcFVWTm9kZS5qcyc7XG5cbmltcG9ydCB7IE1lc2hNYXRjYXBNYXRlcmlhbCB9IGZyb20gJy4uL01lc2hNYXRjYXBNYXRlcmlhbC5qcyc7XG5cbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgTWVzaE1hdGNhcE1hdGVyaWFsKCk7XG5cbmNsYXNzIE1lc2hNYXRjYXBOb2RlTWF0ZXJpYWwgZXh0ZW5kcyBOb2RlTWF0ZXJpYWwge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnTWVzaE1hdGNhcE5vZGVNYXRlcmlhbCc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7XG5cblx0XHR0aGlzLmlzTWVzaE1hdGNhcE5vZGVNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRzZXR1cFZhcmlhbnRzKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgdXYgPSBtYXRjYXBVVjtcblxuXHRcdGxldCBtYXRjYXBDb2xvcjtcblxuXHRcdGlmICggYnVpbGRlci5tYXRlcmlhbC5tYXRjYXAgKSB7XG5cblx0XHRcdG1hdGNhcENvbG9yID0gbWF0ZXJpYWxSZWZlcmVuY2UoICdtYXRjYXAnLCAndGV4dHVyZScgKS5jb250ZXh0KCB7IGdldFVWOiAoKSA9PiB1diB9ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtYXRjYXBDb2xvciA9IHZlYzMoIG1peCggMC4yLCAwLjgsIHV2LnkgKSApOyAvLyBkZWZhdWx0IGlmIG1hdGNhcCBpcyBtaXNzaW5nXG5cblx0XHR9XG5cblx0XHRkaWZmdXNlQ29sb3IucmdiLm11bEFzc2lnbiggbWF0Y2FwQ29sb3IucmdiICk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgTWVzaE1hdGNhcE5vZGVNYXRlcmlhbDtcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi9Ob2RlTWF0ZXJpYWwuanMnO1xuXG5pbXBvcnQgeyBQb2ludHNNYXRlcmlhbCB9IGZyb20gJy4uL1BvaW50c01hdGVyaWFsLmpzJztcblxuY29uc3QgX2RlZmF1bHRWYWx1ZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBQb2ludHNNYXRlcmlhbCgpO1xuXG5jbGFzcyBQb2ludHNOb2RlTWF0ZXJpYWwgZXh0ZW5kcyBOb2RlTWF0ZXJpYWwge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnUG9pbnRzTm9kZU1hdGVyaWFsJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc1BvaW50c05vZGVNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0dGhpcy5zaXplTm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLnNpemVOb2RlID0gc291cmNlLnNpemVOb2RlO1xuXG5cdFx0cmV0dXJuIHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQb2ludHNOb2RlTWF0ZXJpYWw7XG4iLCJpbXBvcnQgVGVtcE5vZGUgZnJvbSAnLi4vY29yZS9UZW1wTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlUHJveHksIHZlYzQsIG1hdDIsIG1hdDQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyBjb3MsIHNpbiB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xuXG5jbGFzcyBSb3RhdGVOb2RlIGV4dGVuZHMgVGVtcE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnUm90YXRlTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBwb3NpdGlvbk5vZGUsIHJvdGF0aW9uTm9kZSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnBvc2l0aW9uTm9kZSA9IHBvc2l0aW9uTm9kZTtcblx0XHR0aGlzLnJvdGF0aW9uTm9kZSA9IHJvdGF0aW9uTm9kZTtcblxuXHR9XG5cblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5wb3NpdGlvbk5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCB7IHJvdGF0aW9uTm9kZSwgcG9zaXRpb25Ob2RlIH0gPSB0aGlzO1xuXG5cdFx0Y29uc3Qgbm9kZVR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0XHRpZiAoIG5vZGVUeXBlID09PSAndmVjMicgKSB7XG5cblx0XHRcdGNvbnN0IGNvc0FuZ2xlID0gcm90YXRpb25Ob2RlLmNvcygpO1xuXHRcdFx0Y29uc3Qgc2luQW5nbGUgPSByb3RhdGlvbk5vZGUuc2luKCk7XG5cblx0XHRcdGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbWF0Mihcblx0XHRcdFx0Y29zQW5nbGUsIHNpbkFuZ2xlLFxuXHRcdFx0XHRzaW5BbmdsZS5uZWdhdGUoKSwgY29zQW5nbGVcblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiByb3RhdGlvbk1hdHJpeC5tdWwoIHBvc2l0aW9uTm9kZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3Qgcm90YXRpb24gPSByb3RhdGlvbk5vZGU7XG5cdFx0XHRjb25zdCByb3RhdGlvblhNYXRyaXggPSBtYXQ0KCB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAwLjAgKSwgdmVjNCggMC4wLCBjb3MoIHJvdGF0aW9uLnggKSwgc2luKCByb3RhdGlvbi54ICkubmVnYXRlKCksIDAuMCApLCB2ZWM0KCAwLjAsIHNpbiggcm90YXRpb24ueCApLCBjb3MoIHJvdGF0aW9uLnggKSwgMC4wICksIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApICk7XG5cdFx0XHRjb25zdCByb3RhdGlvbllNYXRyaXggPSBtYXQ0KCB2ZWM0KCBjb3MoIHJvdGF0aW9uLnkgKSwgMC4wLCBzaW4oIHJvdGF0aW9uLnkgKSwgMC4wICksIHZlYzQoIDAuMCwgMS4wLCAwLjAsIDAuMCApLCB2ZWM0KCBzaW4oIHJvdGF0aW9uLnkgKS5uZWdhdGUoKSwgMC4wLCBjb3MoIHJvdGF0aW9uLnkgKSwgMC4wICksIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApICk7XG5cdFx0XHRjb25zdCByb3RhdGlvblpNYXRyaXggPSBtYXQ0KCB2ZWM0KCBjb3MoIHJvdGF0aW9uLnogKSwgc2luKCByb3RhdGlvbi56ICkubmVnYXRlKCksIDAuMCwgMC4wICksIHZlYzQoIHNpbiggcm90YXRpb24ueiApLCBjb3MoIHJvdGF0aW9uLnogKSwgMC4wLCAwLjAgKSwgdmVjNCggMC4wLCAwLjAsIDEuMCwgMC4wICksIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApICk7XG5cblx0XHRcdHJldHVybiByb3RhdGlvblhNYXRyaXgubXVsKCByb3RhdGlvbllNYXRyaXggKS5tdWwoIHJvdGF0aW9uWk1hdHJpeCApLm11bCggdmVjNCggcG9zaXRpb25Ob2RlLCAxLjAgKSApLnh5ejtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUm90YXRlTm9kZTtcblxuZXhwb3J0IGNvbnN0IHJvdGF0ZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBSb3RhdGVOb2RlICk7XG4iLCJpbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4vTm9kZU1hdGVyaWFsLmpzJztcbmltcG9ydCB7IGNhbWVyYVByb2plY3Rpb25NYXRyaXggfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvQ2FtZXJhLmpzJztcbmltcG9ydCB7IG1hdGVyaWFsUm90YXRpb24gfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTWF0ZXJpYWxOb2RlLmpzJztcbmltcG9ydCB7IG1vZGVsVmlld01hdHJpeCwgbW9kZWxXb3JsZE1hdHJpeCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9Nb2RlbE5vZGUuanMnO1xuaW1wb3J0IHsgcG9zaXRpb25Mb2NhbCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyByb3RhdGUgfSBmcm9tICcuLi8uLi9ub2Rlcy91dGlscy9Sb3RhdGVOb2RlLmpzJztcbmltcG9ydCB7IGZsb2F0LCB2ZWMyLCB2ZWMzLCB2ZWM0IH0gZnJvbSAnLi4vLi4vbm9kZXMvdHNsL1RTTEJhc2UuanMnO1xuXG5pbXBvcnQgeyBTcHJpdGVNYXRlcmlhbCB9IGZyb20gJy4uL1Nwcml0ZU1hdGVyaWFsLmpzJztcbmltcG9ydCB7IHJlZmVyZW5jZSB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9SZWZlcmVuY2VCYXNlTm9kZS5qcyc7XG5cbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgU3ByaXRlTWF0ZXJpYWwoKTtcblxuY2xhc3MgU3ByaXRlTm9kZU1hdGVyaWFsIGV4dGVuZHMgTm9kZU1hdGVyaWFsIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1Nwcml0ZU5vZGVNYXRlcmlhbCc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNTcHJpdGVOb2RlTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTtcblx0XHR0aGlzLl91c2VTaXplQXR0ZW51YXRpb24gPSB0cnVlO1xuXG5cdFx0dGhpcy5wb3NpdGlvbk5vZGUgPSBudWxsO1xuXHRcdHRoaXMucm90YXRpb25Ob2RlID0gbnVsbDtcblx0XHR0aGlzLnNjYWxlTm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRzZXR1cFBvc2l0aW9uKCB7IG9iamVjdCwgY2FtZXJhLCBjb250ZXh0IH0gKSB7XG5cblx0XHRjb25zdCBzaXplQXR0ZW51YXRpb24gPSB0aGlzLnNpemVBdHRlbnVhdGlvbjtcblxuXHRcdC8vIDwgVkVSVEVYIFNUQUdFID5cblxuXHRcdGNvbnN0IHsgcG9zaXRpb25Ob2RlLCByb3RhdGlvbk5vZGUsIHNjYWxlTm9kZSB9ID0gdGhpcztcblxuXHRcdGNvbnN0IHZlcnRleCA9IHBvc2l0aW9uTG9jYWw7XG5cblx0XHRsZXQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeC5tdWwoIHZlYzMoIHBvc2l0aW9uTm9kZSB8fCAwICkgKTtcblxuXHRcdGxldCBzY2FsZSA9IHZlYzIoIG1vZGVsV29ybGRNYXRyaXhbIDAgXS54eXoubGVuZ3RoKCksIG1vZGVsV29ybGRNYXRyaXhbIDEgXS54eXoubGVuZ3RoKCkgKTtcblxuXHRcdGlmICggc2NhbGVOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRzY2FsZSA9IHNjYWxlLm11bCggc2NhbGVOb2RlICk7XG5cblx0XHR9XG5cblxuXHRcdGlmICggISBzaXplQXR0ZW51YXRpb24gKSB7XG5cblx0XHRcdGlmICggY2FtZXJhLmlzUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0c2NhbGUgPSBzY2FsZS5tdWwoIG12UG9zaXRpb24uei5uZWdhdGUoKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IG9ydGhvU2NhbGUgPSBmbG9hdCggMi4wICkuZGl2KCBjYW1lcmFQcm9qZWN0aW9uTWF0cml4LmVsZW1lbnQoIDEgKS5lbGVtZW50KCAxICkgKTtcblx0XHRcdFx0c2NhbGUgPSBzY2FsZS5tdWwoIG9ydGhvU2NhbGUubXVsKCAyICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0bGV0IGFsaWduZWRQb3NpdGlvbiA9IHZlcnRleC54eTtcblxuXHRcdGlmICggb2JqZWN0LmNlbnRlciAmJiBvYmplY3QuY2VudGVyLmlzVmVjdG9yMiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3QgY2VudGVyID0gcmVmZXJlbmNlKCAnY2VudGVyJywgJ3ZlYzInICk7XG5cblx0XHRcdGFsaWduZWRQb3NpdGlvbiA9IGFsaWduZWRQb3NpdGlvbi5zdWIoIGNlbnRlci5zdWIoIDAuNSApICk7XG5cblx0XHR9XG5cblx0XHRhbGlnbmVkUG9zaXRpb24gPSBhbGlnbmVkUG9zaXRpb24ubXVsKCBzY2FsZSApO1xuXG5cdFx0Y29uc3Qgcm90YXRpb24gPSBmbG9hdCggcm90YXRpb25Ob2RlIHx8IG1hdGVyaWFsUm90YXRpb24gKTtcblxuXHRcdGNvbnN0IHJvdGF0ZWRQb3NpdGlvbiA9IHJvdGF0ZSggYWxpZ25lZFBvc2l0aW9uLCByb3RhdGlvbiApO1xuXG5cdFx0bXZQb3NpdGlvbiA9IHZlYzQoIG12UG9zaXRpb24ueHkuYWRkKCByb3RhdGVkUG9zaXRpb24gKSwgbXZQb3NpdGlvbi56dyApO1xuXG5cdFx0Y29uc3QgbW9kZWxWaWV3UHJvamVjdGlvbiA9IGNhbWVyYVByb2plY3Rpb25NYXRyaXgubXVsKCBtdlBvc2l0aW9uICk7XG5cblx0XHRjb250ZXh0LnZlcnRleCA9IHZlcnRleDtcblxuXHRcdHJldHVybiBtb2RlbFZpZXdQcm9qZWN0aW9uO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLnBvc2l0aW9uTm9kZSA9IHNvdXJjZS5wb3NpdGlvbk5vZGU7XG5cdFx0dGhpcy5yb3RhdGlvbk5vZGUgPSBzb3VyY2Uucm90YXRpb25Ob2RlO1xuXHRcdHRoaXMuc2NhbGVOb2RlID0gc291cmNlLnNjYWxlTm9kZTtcblxuXHRcdHJldHVybiBzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHR9XG5cblx0Z2V0IHNpemVBdHRlbnVhdGlvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLl91c2VTaXplQXR0ZW51YXRpb247XG5cblx0fVxuXG5cdHNldCBzaXplQXR0ZW51YXRpb24oIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLl91c2VTaXplQXR0ZW51YXRpb24gIT09IHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLl91c2VTaXplQXR0ZW51YXRpb24gPSB2YWx1ZTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTcHJpdGVOb2RlTWF0ZXJpYWw7XG4iLCJpbXBvcnQgTGlnaHRpbmdNb2RlbCBmcm9tICcuLi9jb3JlL0xpZ2h0aW5nTW9kZWwuanMnO1xuaW1wb3J0IHsgZGlmZnVzZUNvbG9yIH0gZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xuaW1wb3J0IHsgZmxvYXQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIFNoYWRvd01hc2tNb2RlbCBleHRlbmRzIExpZ2h0aW5nTW9kZWwge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuc2hhZG93Tm9kZSA9IGZsb2F0KCAxICkudG9WYXIoICdzaGFkb3dNYXNrJyApO1xuXG5cdH1cblxuXHRkaXJlY3QoIHsgc2hhZG93TWFzayB9ICkge1xuXG5cdFx0dGhpcy5zaGFkb3dOb2RlLm11bEFzc2lnbiggc2hhZG93TWFzayApO1xuXG5cdH1cblxuXHRmaW5pc2goIGNvbnRleHQgKSB7XG5cblx0XHRkaWZmdXNlQ29sb3IuYS5tdWxBc3NpZ24oIHRoaXMuc2hhZG93Tm9kZS5vbmVNaW51cygpICk7XG5cblx0XHRjb250ZXh0Lm91dGdvaW5nTGlnaHQucmdiLmFzc2lnbiggZGlmZnVzZUNvbG9yLnJnYiApOyAvLyBUT0RPOiBPcHRpbWl6ZSBMaWdodHNOb2RlIHRvIGF2b2lkIHRoaXMgYXNzaWdubWVudFxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTaGFkb3dNYXNrTW9kZWw7XG4iLCJpbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4vTm9kZU1hdGVyaWFsLmpzJztcbmltcG9ydCBTaGFkb3dNYXNrTW9kZWwgZnJvbSAnLi4vLi4vbm9kZXMvZnVuY3Rpb25zL1NoYWRvd01hc2tNb2RlbC5qcyc7XG5cbmltcG9ydCB7IFNoYWRvd01hdGVyaWFsIH0gZnJvbSAnLi4vU2hhZG93TWF0ZXJpYWwuanMnO1xuXG5jb25zdCBfZGVmYXVsdFZhbHVlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFNoYWRvd01hdGVyaWFsKCk7XG5cbmNsYXNzIFNoYWRvd05vZGVNYXRlcmlhbCBleHRlbmRzIE5vZGVNYXRlcmlhbCB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdTaGFkb3dOb2RlTWF0ZXJpYWwnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzU2hhZG93Tm9kZU1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMubGlnaHRzID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2V0RGVmYXVsdFZhbHVlcyggX2RlZmF1bHRWYWx1ZXMgKTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdHNldHVwTGlnaHRpbmdNb2RlbCggLypidWlsZGVyKi8gKSB7XG5cblx0XHRyZXR1cm4gbmV3IFNoYWRvd01hc2tNb2RlbCgpO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTaGFkb3dOb2RlTWF0ZXJpYWw7XG4iLCJpbXBvcnQgVGV4dHVyZU5vZGUgZnJvbSAnLi9UZXh0dXJlTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlUHJveHksIHZlYzMsIEZuLCBJZiB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY29uc3Qgbm9ybWFsID0gRm4oICggeyB0ZXh0dXJlLCB1diB9ICkgPT4ge1xuXG5cdGNvbnN0IGVwc2lsb24gPSAwLjAwMDE7XG5cblx0Y29uc3QgcmV0ID0gdmVjMygpLnRvVmFyKCk7XG5cblx0SWYoIHV2LngubGVzc1RoYW4oIGVwc2lsb24gKSwgKCkgPT4ge1xuXG5cdFx0cmV0LmFzc2lnbiggdmVjMyggMSwgMCwgMCApICk7XG5cblx0fSApLkVsc2VJZiggdXYueS5sZXNzVGhhbiggZXBzaWxvbiApLCAoKSA9PiB7XG5cblx0XHRyZXQuYXNzaWduKCB2ZWMzKCAwLCAxLCAwICkgKTtcblxuXHR9ICkuRWxzZUlmKCB1di56Lmxlc3NUaGFuKCBlcHNpbG9uICksICgpID0+IHtcblxuXHRcdHJldC5hc3NpZ24oIHZlYzMoIDAsIDAsIDEgKSApO1xuXG5cdH0gKS5FbHNlSWYoIHV2LnguZ3JlYXRlclRoYW4oIDEgLSBlcHNpbG9uICksICgpID0+IHtcblxuXHRcdHJldC5hc3NpZ24oIHZlYzMoIC0gMSwgMCwgMCApICk7XG5cblx0fSApLkVsc2VJZiggdXYueS5ncmVhdGVyVGhhbiggMSAtIGVwc2lsb24gKSwgKCkgPT4ge1xuXG5cdFx0cmV0LmFzc2lnbiggdmVjMyggMCwgLSAxLCAwICkgKTtcblxuXHR9ICkuRWxzZUlmKCB1di56LmdyZWF0ZXJUaGFuKCAxIC0gZXBzaWxvbiApLCAoKSA9PiB7XG5cblx0XHRyZXQuYXNzaWduKCB2ZWMzKCAwLCAwLCAtIDEgKSApO1xuXG5cdH0gKS5FbHNlKCAoKSA9PiB7XG5cblx0XHRjb25zdCBzdGVwID0gMC4wMTtcblxuXHRcdGNvbnN0IHggPSB0ZXh0dXJlLnV2KCB1di5hZGQoIHZlYzMoIC0gc3RlcCwgMC4wLCAwLjAgKSApICkuci5zdWIoIHRleHR1cmUudXYoIHV2LmFkZCggdmVjMyggc3RlcCwgMC4wLCAwLjAgKSApICkuciApO1xuXHRcdGNvbnN0IHkgPSB0ZXh0dXJlLnV2KCB1di5hZGQoIHZlYzMoIDAuMCwgLSBzdGVwLCAwLjAgKSApICkuci5zdWIoIHRleHR1cmUudXYoIHV2LmFkZCggdmVjMyggMC4wLCBzdGVwLCAwLjAgKSApICkuciApO1xuXHRcdGNvbnN0IHogPSB0ZXh0dXJlLnV2KCB1di5hZGQoIHZlYzMoIDAuMCwgMC4wLCAtIHN0ZXAgKSApICkuci5zdWIoIHRleHR1cmUudXYoIHV2LmFkZCggdmVjMyggMC4wLCAwLjAsIHN0ZXAgKSApICkuciApO1xuXG5cdFx0cmV0LmFzc2lnbiggdmVjMyggeCwgeSwgeiApICk7XG5cblx0fSApO1xuXG5cdHJldHVybiByZXQubm9ybWFsaXplKCk7XG5cbn0gKTtcblxuXG5jbGFzcyBUZXh0dXJlM0ROb2RlIGV4dGVuZHMgVGV4dHVyZU5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnVGV4dHVyZTNETm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCB2YWx1ZSwgdXZOb2RlID0gbnVsbCwgbGV2ZWxOb2RlID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCB2YWx1ZSwgdXZOb2RlLCBsZXZlbE5vZGUgKTtcblxuXHRcdHRoaXMuaXNUZXh0dXJlM0ROb2RlID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0SW5wdXRUeXBlKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdHJldHVybiAndGV4dHVyZTNEJztcblxuXHR9XG5cblx0Z2V0RGVmYXVsdFVWKCkge1xuXG5cdFx0cmV0dXJuIHZlYzMoIDAuNSwgMC41LCAwLjUgKTtcblxuXHR9XG5cblx0c2V0VXBkYXRlTWF0cml4KCAvKnVwZGF0ZU1hdHJpeCovICkgeyB9IC8vIElnbm9yZSAudXBkYXRlTWF0cml4IGZvciAzZCBUZXh0dXJlTm9kZVxuXG5cdHNldHVwVVYoIGJ1aWxkZXIsIHV2Tm9kZSApIHtcblxuXHRcdHJldHVybiB1dk5vZGU7XG5cblx0fVxuXG5cdGdlbmVyYXRlVVYoIGJ1aWxkZXIsIHV2Tm9kZSApIHtcblxuXHRcdHJldHVybiB1dk5vZGUuYnVpbGQoIGJ1aWxkZXIsICd2ZWMzJyApO1xuXG5cdH1cblxuXHRub3JtYWwoIHV2Tm9kZSApIHtcblxuXHRcdHJldHVybiBub3JtYWwoIHsgdGV4dHVyZTogdGhpcywgdXY6IHV2Tm9kZSB9ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRleHR1cmUzRE5vZGU7XG5cbmV4cG9ydCBjb25zdCB0ZXh0dXJlM0QgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggVGV4dHVyZTNETm9kZSApO1xuIiwiaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuL05vZGVNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBwcm9wZXJ0eSB9IGZyb20gJy4uLy4uL25vZGVzL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcbmltcG9ydCB7IG1hdGVyaWFsUmVmZXJlbmNlIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL01hdGVyaWFsUmVmZXJlbmNlTm9kZS5qcyc7XG5pbXBvcnQgeyBtb2RlbFdvcmxkTWF0cml4SW52ZXJzZSB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9Nb2RlbE5vZGUuanMnO1xuaW1wb3J0IHsgY2FtZXJhUG9zaXRpb24gfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvQ2FtZXJhLmpzJztcbmltcG9ydCB7IHBvc2l0aW9uR2VvbWV0cnkgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgRm4sIHZhcnlpbmcsIGZsb2F0LCB2ZWMyLCB2ZWMzLCB2ZWM0IH0gZnJvbSAnLi4vLi4vbm9kZXMvdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgbWluLCBtYXggfSBmcm9tICcuLi8uLi9ub2Rlcy9tYXRoL01hdGhOb2RlLmpzJztcbmltcG9ydCB7IExvb3AsIEJyZWFrIH0gZnJvbSAnLi4vLi4vbm9kZXMvdXRpbHMvTG9vcE5vZGUuanMnO1xuaW1wb3J0IHsgdGV4dHVyZTNEIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL1RleHR1cmUzRE5vZGUuanMnO1xuXG5jbGFzcyBWb2x1bWVOb2RlTWF0ZXJpYWwgZXh0ZW5kcyBOb2RlTWF0ZXJpYWwge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnVm9sdW1lTm9kZU1hdGVyaWFsJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtcyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7XG5cdFx0dGhpcy5pc1ZvbHVtZU5vZGVNYXRlcmlhbCA9IHRydWU7XG5cdFx0dGhpcy50ZXN0Tm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1zICk7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgbWFwID0gdGV4dHVyZTNEKCB0aGlzLm1hcCwgbnVsbCwgMCApO1xuXG5cdFx0Y29uc3QgaGl0Qm94ID0gRm4oICggeyBvcmlnLCBkaXIgfSApID0+IHtcblxuXHRcdFx0Y29uc3QgYm94X21pbiA9IHZlYzMoIC0gMC41ICk7XG5cdFx0XHRjb25zdCBib3hfbWF4ID0gdmVjMyggMC41ICk7XG5cblx0XHRcdGNvbnN0IGludl9kaXIgPSBkaXIucmVjaXByb2NhbCgpO1xuXG5cdFx0XHRjb25zdCB0bWluX3RtcCA9IGJveF9taW4uc3ViKCBvcmlnICkubXVsKCBpbnZfZGlyICk7XG5cdFx0XHRjb25zdCB0bWF4X3RtcCA9IGJveF9tYXguc3ViKCBvcmlnICkubXVsKCBpbnZfZGlyICk7XG5cblx0XHRcdGNvbnN0IHRtaW4gPSBtaW4oIHRtaW5fdG1wLCB0bWF4X3RtcCApO1xuXHRcdFx0Y29uc3QgdG1heCA9IG1heCggdG1pbl90bXAsIHRtYXhfdG1wICk7XG5cblx0XHRcdGNvbnN0IHQwID0gbWF4KCB0bWluLngsIG1heCggdG1pbi55LCB0bWluLnogKSApO1xuXHRcdFx0Y29uc3QgdDEgPSBtaW4oIHRtYXgueCwgbWluKCB0bWF4LnksIHRtYXgueiApICk7XG5cblx0XHRcdHJldHVybiB2ZWMyKCB0MCwgdDEgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMuZnJhZ21lbnROb2RlID0gRm4oICgpID0+IHtcblxuXHRcdFx0Y29uc3Qgdk9yaWdpbiA9IHZhcnlpbmcoIHZlYzMoIG1vZGVsV29ybGRNYXRyaXhJbnZlcnNlLm11bCggdmVjNCggY2FtZXJhUG9zaXRpb24sIDEuMCApICkgKSApO1xuXHRcdFx0Y29uc3QgdkRpcmVjdGlvbiA9IHZhcnlpbmcoIHBvc2l0aW9uR2VvbWV0cnkuc3ViKCB2T3JpZ2luICkgKTtcblxuXHRcdFx0Y29uc3QgcmF5RGlyID0gdkRpcmVjdGlvbi5ub3JtYWxpemUoKTtcblx0XHRcdGNvbnN0IGJvdW5kcyA9IHZlYzIoIGhpdEJveCggeyBvcmlnOiB2T3JpZ2luLCBkaXI6IHJheURpciB9ICkgKS50b1ZhcigpO1xuXG5cdFx0XHRib3VuZHMueC5ncmVhdGVyVGhhbiggYm91bmRzLnkgKS5kaXNjYXJkKCk7XG5cblx0XHRcdGJvdW5kcy5hc3NpZ24oIHZlYzIoIG1heCggYm91bmRzLngsIDAuMCApLCBib3VuZHMueSApICk7XG5cblx0XHRcdGNvbnN0IHAgPSB2ZWMzKCB2T3JpZ2luLmFkZCggYm91bmRzLngubXVsKCByYXlEaXIgKSApICkudG9WYXIoKTtcblx0XHRcdGNvbnN0IGluYyA9IHZlYzMoIHJheURpci5hYnMoKS5yZWNpcHJvY2FsKCkgKS50b1ZhcigpO1xuXHRcdFx0Y29uc3QgZGVsdGEgPSBmbG9hdCggbWluKCBpbmMueCwgbWluKCBpbmMueSwgaW5jLnogKSApICkudG9WYXIoICdkZWx0YScgKTsgLy8gdXNlZCAnZGVsdGEnIG5hbWUgaW4gbG9vcFxuXG5cdFx0XHRkZWx0YS5kaXZBc3NpZ24oIG1hdGVyaWFsUmVmZXJlbmNlKCAnc3RlcHMnLCAnZmxvYXQnICkgKTtcblxuXHRcdFx0Y29uc3QgYWMgPSB2ZWM0KCBtYXRlcmlhbFJlZmVyZW5jZSggJ2Jhc2UnLCAnY29sb3InICksIDAuMCApLnRvVmFyKCk7XG5cblx0XHRcdExvb3AoIHsgdHlwZTogJ2Zsb2F0Jywgc3RhcnQ6IGJvdW5kcy54LCBlbmQ6IGJvdW5kcy55LCB1cGRhdGU6ICcrPSBkZWx0YScgfSwgKCkgPT4ge1xuXG5cdFx0XHRcdGNvbnN0IGQgPSBwcm9wZXJ0eSggJ2Zsb2F0JywgJ2QnICkuYXNzaWduKCBtYXAudXYoIHAuYWRkKCAwLjUgKSApLnIgKTtcblxuXHRcdFx0XHRpZiAoIHRoaXMudGVzdE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnRlc3ROb2RlKCB7IG1hcDogbWFwLCBtYXBWYWx1ZTogZCwgcHJvYmU6IHAsIGZpbmFsQ29sb3I6IGFjIH0gKS5hcHBlbmQoKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gZGVmYXVsdCB0byBzaG93IHN1cmZhY2Ugb2YgbWVzaFxuXHRcdFx0XHRcdGFjLmEuYXNzaWduKCAxICk7XG5cdFx0XHRcdFx0QnJlYWsoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cC5hZGRBc3NpZ24oIHJheURpci5tdWwoIGRlbHRhICkgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRhYy5hLmVxdWFsKCAwICkuZGlzY2FyZCgpO1xuXG5cdFx0XHRyZXR1cm4gdmVjNCggYWMgKTtcblxuXHRcdH0gKSgpO1xuXG5cdFx0c3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVm9sdW1lTm9kZU1hdGVyaWFsO1xuIiwiY2xhc3MgQW5pbWF0aW9uIHtcblxuXHRjb25zdHJ1Y3Rvciggbm9kZXMsIGluZm8gKSB7XG5cblx0XHR0aGlzLm5vZGVzID0gbm9kZXM7XG5cdFx0dGhpcy5pbmZvID0gaW5mbztcblxuXHRcdHRoaXMuX2NvbnRleHQgPSBzZWxmO1xuXHRcdHRoaXMuX2FuaW1hdGlvbkxvb3AgPSBudWxsO1xuXHRcdHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG5cblx0fVxuXG5cdHN0YXJ0KCkge1xuXG5cdFx0Y29uc3QgdXBkYXRlID0gKCB0aW1lLCBmcmFtZSApID0+IHtcblxuXHRcdFx0dGhpcy5fcmVxdWVzdElkID0gdGhpcy5fY29udGV4dC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXMuaW5mby5hdXRvUmVzZXQgPT09IHRydWUgKSB0aGlzLmluZm8ucmVzZXQoKTtcblxuXHRcdFx0dGhpcy5ub2Rlcy5ub2RlRnJhbWUudXBkYXRlKCk7XG5cblx0XHRcdHRoaXMuaW5mby5mcmFtZSA9IHRoaXMubm9kZXMubm9kZUZyYW1lLmZyYW1lSWQ7XG5cblx0XHRcdGlmICggdGhpcy5fYW5pbWF0aW9uTG9vcCAhPT0gbnVsbCApIHRoaXMuX2FuaW1hdGlvbkxvb3AoIHRpbWUsIGZyYW1lICk7XG5cblx0XHR9O1xuXG5cdFx0dXBkYXRlKCk7XG5cblx0fVxuXG5cdHN0b3AoKSB7XG5cblx0XHR0aGlzLl9jb250ZXh0LmNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aGlzLl9yZXF1ZXN0SWQgKTtcblxuXHRcdHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG5cblx0fVxuXG5cdHNldEFuaW1hdGlvbkxvb3AoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5fYW5pbWF0aW9uTG9vcCA9IGNhbGxiYWNrO1xuXG5cdH1cblxuXHRzZXRDb250ZXh0KCBjb250ZXh0ICkge1xuXG5cdFx0dGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLnN0b3AoKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0aW9uO1xuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhaW5NYXAge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy53ZWFrTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuXHR9XG5cblx0Z2V0KCBrZXlzICkge1xuXG5cdFx0bGV0IG1hcCA9IHRoaXMud2Vha01hcDtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRtYXAgPSBtYXAuZ2V0KCBrZXlzWyBpIF0gKTtcblxuXHRcdFx0aWYgKCBtYXAgPT09IHVuZGVmaW5lZCApIHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbWFwLmdldCgga2V5c1sga2V5cy5sZW5ndGggLSAxIF0gKTtcblxuXHR9XG5cblx0c2V0KCBrZXlzLCB2YWx1ZSApIHtcblxuXHRcdGxldCBtYXAgPSB0aGlzLndlYWtNYXA7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qga2V5ID0ga2V5c1sgaSBdO1xuXG5cdFx0XHRpZiAoIG1hcC5oYXMoIGtleSApID09PSBmYWxzZSApIG1hcC5zZXQoIGtleSwgbmV3IFdlYWtNYXAoKSApO1xuXG5cdFx0XHRtYXAgPSBtYXAuZ2V0KCBrZXkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXAuc2V0KCBrZXlzWyBrZXlzLmxlbmd0aCAtIDEgXSwgdmFsdWUgKTtcblxuXHR9XG5cblx0ZGVsZXRlKCBrZXlzICkge1xuXG5cdFx0bGV0IG1hcCA9IHRoaXMud2Vha01hcDtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRtYXAgPSBtYXAuZ2V0KCBrZXlzWyBpIF0gKTtcblxuXHRcdFx0aWYgKCBtYXAgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXAuZGVsZXRlKCBrZXlzWyBrZXlzLmxlbmd0aCAtIDEgXSApO1xuXG5cdH1cblxufVxuIiwiaW1wb3J0IHsgaGFzaFN0cmluZyB9IGZyb20gJy4uLy4uL25vZGVzL2NvcmUvTm9kZVV0aWxzLmpzJztcblxubGV0IF9pZCA9IDA7XG5cbmZ1bmN0aW9uIGdldEtleXMoIG9iaiApIHtcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIG9iaiApO1xuXG5cdGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiggb2JqICk7XG5cblx0d2hpbGUgKCBwcm90byApIHtcblxuXHRcdGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoIHByb3RvICk7XG5cblx0XHRmb3IgKCBjb25zdCBrZXkgaW4gZGVzY3JpcHRvcnMgKSB7XG5cblx0XHRcdGlmICggZGVzY3JpcHRvcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JzWyBrZXkgXTtcblxuXHRcdFx0XHRpZiAoIGRlc2NyaXB0b3IgJiYgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ID09PSAnZnVuY3Rpb24nICkge1xuXG5cdFx0XHRcdFx0a2V5cy5wdXNoKCBrZXkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKCBwcm90byApO1xuXG5cdH1cblxuXHRyZXR1cm4ga2V5cztcblxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJPYmplY3Qge1xuXG5cdGNvbnN0cnVjdG9yKCBub2RlcywgZ2VvbWV0cmllcywgcmVuZGVyZXIsIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIHJlbmRlckNvbnRleHQsIGNsaXBwaW5nQ29udGV4dCApIHtcblxuXHRcdHRoaXMuX25vZGVzID0gbm9kZXM7XG5cdFx0dGhpcy5fZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG5cblx0XHR0aGlzLmlkID0gX2lkICsrO1xuXG5cdFx0dGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXHRcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdFx0dGhpcy5saWdodHNOb2RlID0gbGlnaHRzTm9kZTtcblx0XHR0aGlzLmNvbnRleHQgPSByZW5kZXJDb250ZXh0O1xuXG5cdFx0dGhpcy5nZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblx0XHR0aGlzLnZlcnNpb24gPSBtYXRlcmlhbC52ZXJzaW9uO1xuXG5cdFx0dGhpcy5kcmF3UmFuZ2UgPSBudWxsO1xuXG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcblx0XHR0aGlzLnBpcGVsaW5lID0gbnVsbDtcblx0XHR0aGlzLnZlcnRleEJ1ZmZlcnMgPSBudWxsO1xuXHRcdHRoaXMuZHJhd1BhcmFtcyA9IG51bGw7XG5cblx0XHR0aGlzLmJ1bmRsZSA9IG51bGw7XG5cblx0XHR0aGlzLmNsaXBwaW5nQ29udGV4dCA9IGNsaXBwaW5nQ29udGV4dDtcblx0XHR0aGlzLmNsaXBwaW5nQ29udGV4dENhY2hlS2V5ID0gY2xpcHBpbmdDb250ZXh0ICE9PSBudWxsID8gY2xpcHBpbmdDb250ZXh0LmNhY2hlS2V5IDogJyc7XG5cblx0XHR0aGlzLmluaXRpYWxOb2Rlc0NhY2hlS2V5ID0gdGhpcy5nZXREeW5hbWljQ2FjaGVLZXkoKTtcblx0XHR0aGlzLmluaXRpYWxDYWNoZUtleSA9IHRoaXMuZ2V0Q2FjaGVLZXkoKTtcblxuXHRcdHRoaXMuX25vZGVCdWlsZGVyU3RhdGUgPSBudWxsO1xuXHRcdHRoaXMuX2JpbmRpbmdzID0gbnVsbDtcblx0XHR0aGlzLl9tb25pdG9yID0gbnVsbDtcblxuXHRcdHRoaXMub25EaXNwb3NlID0gbnVsbDtcblxuXHRcdHRoaXMuaXNSZW5kZXJPYmplY3QgPSB0cnVlO1xuXG5cdFx0dGhpcy5vbk1hdGVyaWFsRGlzcG9zZSA9ICgpID0+IHtcblxuXHRcdFx0dGhpcy5kaXNwb3NlKCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5tYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIHRoaXMub25NYXRlcmlhbERpc3Bvc2UgKTtcblxuXHR9XG5cblx0dXBkYXRlQ2xpcHBpbmcoIHBhcmVudCApIHtcblxuXHRcdHRoaXMuY2xpcHBpbmdDb250ZXh0ID0gcGFyZW50O1xuXG5cdH1cblxuXHRnZXQgY2xpcHBpbmdOZWVkc1VwZGF0ZSgpIHtcblxuXHRcdGlmICggdGhpcy5jbGlwcGluZ0NvbnRleHQgPT09IG51bGwgfHwgdGhpcy5jbGlwcGluZ0NvbnRleHQuY2FjaGVLZXkgPT09IHRoaXMuY2xpcHBpbmdDb250ZXh0Q2FjaGVLZXkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHR0aGlzLmNsaXBwaW5nQ29udGV4dENhY2hlS2V5ID0gdGhpcy5jbGlwcGluZ0NvbnRleHQuY2FjaGVLZXk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0IGhhcmR3YXJlQ2xpcHBpbmdQbGFuZXMoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXRlcmlhbC5oYXJkd2FyZUNsaXBwaW5nID09PSB0cnVlID8gdGhpcy5jbGlwcGluZ0NvbnRleHQudW5pb25DbGlwcGluZ0NvdW50IDogMDtcblxuXHR9XG5cblx0Z2V0Tm9kZUJ1aWxkZXJTdGF0ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9ub2RlQnVpbGRlclN0YXRlIHx8ICggdGhpcy5fbm9kZUJ1aWxkZXJTdGF0ZSA9IHRoaXMuX25vZGVzLmdldEZvclJlbmRlciggdGhpcyApICk7XG5cblx0fVxuXG5cdGdldE1vbml0b3IoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fbW9uaXRvciB8fCAoIHRoaXMuX21vbml0b3IgPSB0aGlzLmdldE5vZGVCdWlsZGVyU3RhdGUoKS5tb25pdG9yICk7XG5cblx0fVxuXG5cdGdldEJpbmRpbmdzKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2JpbmRpbmdzIHx8ICggdGhpcy5fYmluZGluZ3MgPSB0aGlzLmdldE5vZGVCdWlsZGVyU3RhdGUoKS5jcmVhdGVCaW5kaW5ncygpICk7XG5cblx0fVxuXG5cdGdldEluZGV4KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2dlb21ldHJpZXMuZ2V0SW5kZXgoIHRoaXMgKTtcblxuXHR9XG5cblx0Z2V0SW5kaXJlY3QoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fZ2VvbWV0cmllcy5nZXRJbmRpcmVjdCggdGhpcyApO1xuXG5cdH1cblxuXHRnZXRDaGFpbkFycmF5KCkge1xuXG5cdFx0cmV0dXJuIFsgdGhpcy5vYmplY3QsIHRoaXMubWF0ZXJpYWwsIHRoaXMuY29udGV4dCwgdGhpcy5saWdodHNOb2RlIF07XG5cblx0fVxuXG5cdHNldEdlb21ldHJ5KCBnZW9tZXRyeSApIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xuXG5cdH1cblxuXHRnZXRBdHRyaWJ1dGVzKCkge1xuXG5cdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZXMgIT09IG51bGwgKSByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Y29uc3Qgbm9kZUF0dHJpYnV0ZXMgPSB0aGlzLmdldE5vZGVCdWlsZGVyU3RhdGUoKS5ub2RlQXR0cmlidXRlcztcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gW107XG5cdFx0Y29uc3QgdmVydGV4QnVmZmVycyA9IG5ldyBTZXQoKTtcblxuXHRcdGZvciAoIGNvbnN0IG5vZGVBdHRyaWJ1dGUgb2Ygbm9kZUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGVBdHRyaWJ1dGUubm9kZSAmJiBub2RlQXR0cmlidXRlLm5vZGUuYXR0cmlidXRlID8gbm9kZUF0dHJpYnV0ZS5ub2RlLmF0dHJpYnV0ZSA6IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggbm9kZUF0dHJpYnV0ZS5uYW1lICk7XG5cblx0XHRcdGlmICggYXR0cmlidXRlID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuXHRcdFx0YXR0cmlidXRlcy5wdXNoKCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0Y29uc3QgYnVmZmVyQXR0cmlidXRlID0gYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPyBhdHRyaWJ1dGUuZGF0YSA6IGF0dHJpYnV0ZTtcblx0XHRcdHZlcnRleEJ1ZmZlcnMuYWRkKCBidWZmZXJBdHRyaWJ1dGUgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cdFx0dGhpcy52ZXJ0ZXhCdWZmZXJzID0gQXJyYXkuZnJvbSggdmVydGV4QnVmZmVycy52YWx1ZXMoKSApO1xuXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZXM7XG5cblx0fVxuXG5cdGdldFZlcnRleEJ1ZmZlcnMoKSB7XG5cblx0XHRpZiAoIHRoaXMudmVydGV4QnVmZmVycyA9PT0gbnVsbCApIHRoaXMuZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0cmV0dXJuIHRoaXMudmVydGV4QnVmZmVycztcblxuXHR9XG5cblx0Z2V0RHJhd1BhcmFtZXRlcnMoKSB7XG5cblx0XHRjb25zdCB7IG9iamVjdCwgbWF0ZXJpYWwsIGdlb21ldHJ5LCBncm91cCwgZHJhd1JhbmdlIH0gPSB0aGlzO1xuXG5cdFx0Y29uc3QgZHJhd1BhcmFtcyA9IHRoaXMuZHJhd1BhcmFtcyB8fCAoIHRoaXMuZHJhd1BhcmFtcyA9IHtcblx0XHRcdHZlcnRleENvdW50OiAwLFxuXHRcdFx0Zmlyc3RWZXJ0ZXg6IDAsXG5cdFx0XHRpbnN0YW5jZUNvdW50OiAwLFxuXHRcdFx0Zmlyc3RJbnN0YW5jZTogMFxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXHRcdGNvbnN0IGhhc0luZGV4ID0gKCBpbmRleCAhPT0gbnVsbCApO1xuXHRcdGNvbnN0IGluc3RhbmNlQ291bnQgPSBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID8gZ2VvbWV0cnkuaW5zdGFuY2VDb3VudCA6ICggb2JqZWN0LmNvdW50ID4gMSA/IG9iamVjdC5jb3VudCA6IDEgKTtcblxuXHRcdGlmICggaW5zdGFuY2VDb3VudCA9PT0gMCApIHJldHVybiBudWxsO1xuXG5cdFx0ZHJhd1BhcmFtcy5pbnN0YW5jZUNvdW50ID0gaW5zdGFuY2VDb3VudDtcblxuXHRcdGlmICggb2JqZWN0LmlzQmF0Y2hlZE1lc2ggPT09IHRydWUgKSByZXR1cm4gZHJhd1BhcmFtcztcblxuXHRcdGxldCByYW5nZUZhY3RvciA9IDE7XG5cblx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSAmJiAhIG9iamVjdC5pc1BvaW50cyAmJiAhIG9iamVjdC5pc0xpbmVTZWdtZW50cyAmJiAhIG9iamVjdC5pc0xpbmUgJiYgISBvYmplY3QuaXNMaW5lTG9vcCApIHtcblxuXHRcdFx0cmFuZ2VGYWN0b3IgPSAyO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGZpcnN0VmVydGV4ID0gZHJhd1JhbmdlLnN0YXJ0ICogcmFuZ2VGYWN0b3I7XG5cdFx0bGV0IGxhc3RWZXJ0ZXggPSAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICogcmFuZ2VGYWN0b3I7XG5cblx0XHRpZiAoIGdyb3VwICE9PSBudWxsICkge1xuXG5cdFx0XHRmaXJzdFZlcnRleCA9IE1hdGgubWF4KCBmaXJzdFZlcnRleCwgZ3JvdXAuc3RhcnQgKiByYW5nZUZhY3RvciApO1xuXHRcdFx0bGFzdFZlcnRleCA9IE1hdGgubWluKCBsYXN0VmVydGV4LCAoIGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQgKSAqIHJhbmdlRmFjdG9yICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0bGV0IGl0ZW1Db3VudCA9IEluZmluaXR5O1xuXG5cdFx0aWYgKCBoYXNJbmRleCApIHtcblxuXHRcdFx0aXRlbUNvdW50ID0gaW5kZXguY291bnQ7XG5cblx0XHR9IGVsc2UgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRpdGVtQ291bnQgPSBwb3NpdGlvbi5jb3VudDtcblxuXHRcdH1cblxuXHRcdGZpcnN0VmVydGV4ID0gTWF0aC5tYXgoIGZpcnN0VmVydGV4LCAwICk7XG5cdFx0bGFzdFZlcnRleCA9IE1hdGgubWluKCBsYXN0VmVydGV4LCBpdGVtQ291bnQgKTtcblxuXHRcdGNvbnN0IGNvdW50ID0gbGFzdFZlcnRleCAtIGZpcnN0VmVydGV4O1xuXG5cdFx0aWYgKCBjb3VudCA8IDAgfHwgY291bnQgPT09IEluZmluaXR5ICkgcmV0dXJuIG51bGw7XG5cblx0XHRkcmF3UGFyYW1zLnZlcnRleENvdW50ID0gY291bnQ7XG5cdFx0ZHJhd1BhcmFtcy5maXJzdFZlcnRleCA9IGZpcnN0VmVydGV4O1xuXG5cdFx0cmV0dXJuIGRyYXdQYXJhbXM7XG5cblx0fVxuXG5cdGdldEdlb21ldHJ5Q2FjaGVLZXkoKSB7XG5cblx0XHRjb25zdCB7IGdlb21ldHJ5IH0gPSB0aGlzO1xuXG5cdFx0bGV0IGNhY2hlS2V5ID0gJyc7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKCBnZW9tZXRyeS5hdHRyaWJ1dGVzICkuc29ydCgpICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdGNhY2hlS2V5ICs9IG5hbWUgKyAnLCc7XG5cblx0XHRcdGlmICggYXR0cmlidXRlLmRhdGEgKSBjYWNoZUtleSArPSBhdHRyaWJ1dGUuZGF0YS5zdHJpZGUgKyAnLCc7XG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5vZmZzZXQgKSBjYWNoZUtleSArPSBhdHRyaWJ1dGUub2Zmc2V0ICsgJywnO1xuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXRlbVNpemUgKSBjYWNoZUtleSArPSBhdHRyaWJ1dGUuaXRlbVNpemUgKyAnLCc7XG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5ub3JtYWxpemVkICkgY2FjaGVLZXkgKz0gJ24sJztcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkuaW5kZXggKSB7XG5cblx0XHRcdGNhY2hlS2V5ICs9ICdpbmRleCwnO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNhY2hlS2V5O1xuXG5cdH1cblxuXHRnZXRNYXRlcmlhbENhY2hlS2V5KCkge1xuXG5cdFx0Y29uc3QgeyBvYmplY3QsIG1hdGVyaWFsIH0gPSB0aGlzO1xuXG5cdFx0bGV0IGNhY2hlS2V5ID0gbWF0ZXJpYWwuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCk7XG5cblx0XHRmb3IgKCBjb25zdCBwcm9wZXJ0eSBvZiBnZXRLZXlzKCBtYXRlcmlhbCApICkge1xuXG5cdFx0XHRpZiAoIC9eKGlzW0EtWl18Xyl8Xih2aXNpYmxlfHZlcnNpb258dXVpZHxuYW1lfG9wYWNpdHl8dXNlckRhdGEpJC8udGVzdCggcHJvcGVydHkgKSApIGNvbnRpbnVlO1xuXG5cdFx0XHRjb25zdCB2YWx1ZSA9IG1hdGVyaWFsWyBwcm9wZXJ0eSBdO1xuXG5cdFx0XHRsZXQgdmFsdWVLZXk7XG5cblx0XHRcdGlmICggdmFsdWUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gc29tZSBtYXRlcmlhbCB2YWx1ZXMgcmVxdWlyZSBhIGZvcm1hdHRpbmdcblxuXHRcdFx0XHRjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gJ251bWJlcicgKSB7XG5cblx0XHRcdFx0XHR2YWx1ZUtleSA9IHZhbHVlICE9PSAwID8gJzEnIDogJzAnOyAvLyBDb252ZXJ0IHRvIG9uL29mZiwgaW1wb3J0YW50IGZvciBjbGVhcmNvYXQsIHRyYW5zbWlzc2lvbiwgZXRjXG5cblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ29iamVjdCcgKSB7XG5cblx0XHRcdFx0XHR2YWx1ZUtleSA9ICd7JztcblxuXHRcdFx0XHRcdGlmICggdmFsdWUuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0XHR2YWx1ZUtleSArPSB2YWx1ZS5tYXBwaW5nO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFsdWVLZXkgKz0gJ30nO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YWx1ZUtleSA9IFN0cmluZyggdmFsdWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFsdWVLZXkgPSBTdHJpbmcoIHZhbHVlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y2FjaGVLZXkgKz0gLypwcm9wZXJ0eSArICc6JyArKi8gdmFsdWVLZXkgKyAnLCc7XG5cblx0XHR9XG5cblx0XHRjYWNoZUtleSArPSB0aGlzLmNsaXBwaW5nQ29udGV4dENhY2hlS2V5ICsgJywnO1xuXG5cdFx0aWYgKCBvYmplY3QuZ2VvbWV0cnkgKSB7XG5cblx0XHRcdGNhY2hlS2V5ICs9IHRoaXMuZ2V0R2VvbWV0cnlDYWNoZUtleSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3Quc2tlbGV0b24gKSB7XG5cblx0XHRcdGNhY2hlS2V5ICs9IG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGggKyAnLCc7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMgKSB7XG5cblx0XHRcdGNhY2hlS2V5ICs9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoICsgJywnO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaXNCYXRjaGVkTWVzaCApIHtcblxuXHRcdFx0Y2FjaGVLZXkgKz0gb2JqZWN0Ll9tYXRyaWNlc1RleHR1cmUudXVpZCArICcsJztcblxuXHRcdFx0aWYgKCBvYmplY3QuX2NvbG9yc1RleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y2FjaGVLZXkgKz0gb2JqZWN0Ll9jb2xvcnNUZXh0dXJlLnV1aWQgKyAnLCc7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0LmNvdW50ID4gMSApIHtcblxuXHRcdFx0Ly8gVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzI5MDY2I2lzc3VlY29tbWVudC0yMjY5NDAwODUwXG5cblx0XHRcdGNhY2hlS2V5ICs9IG9iamVjdC51dWlkICsgJywnO1xuXG5cdFx0fVxuXG5cdFx0Y2FjaGVLZXkgKz0gb2JqZWN0LnJlY2VpdmVTaGFkb3cgKyAnLCc7XG5cblx0XHRyZXR1cm4gaGFzaFN0cmluZyggY2FjaGVLZXkgKTtcblxuXHR9XG5cblx0Z2V0IG5lZWRzR2VvbWV0cnlVcGRhdGUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZW9tZXRyeS5pZCAhPT0gdGhpcy5vYmplY3QuZ2VvbWV0cnkuaWQ7XG5cblx0fVxuXG5cdGdldCBuZWVkc1VwZGF0ZSgpIHtcblxuXHRcdHJldHVybiAvKnRoaXMub2JqZWN0LnN0YXRpYyAhPT0gdHJ1ZSAmJiovICggdGhpcy5pbml0aWFsTm9kZXNDYWNoZUtleSAhPT0gdGhpcy5nZXREeW5hbWljQ2FjaGVLZXkoKSB8fCB0aGlzLmNsaXBwaW5nTmVlZHNVcGRhdGUgKTtcblxuXHR9XG5cblx0Z2V0RHluYW1pY0NhY2hlS2V5KCkge1xuXG5cdFx0Ly8gRW52aXJvbm1lbnQgTm9kZXMgQ2FjaGUgS2V5XG5cblx0XHRsZXQgY2FjaGVLZXkgPSB0aGlzLl9ub2Rlcy5nZXRDYWNoZUtleSggdGhpcy5zY2VuZSwgdGhpcy5saWdodHNOb2RlICk7XG5cblx0XHRpZiAoIHRoaXMub2JqZWN0LnJlY2VpdmVTaGFkb3cgKSB7XG5cblx0XHRcdGNhY2hlS2V5ICs9IDE7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2FjaGVLZXk7XG5cblx0fVxuXG5cdGdldENhY2hlS2V5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWF0ZXJpYWxDYWNoZUtleSgpICsgdGhpcy5nZXREeW5hbWljQ2FjaGVLZXkoKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMubWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCB0aGlzLm9uTWF0ZXJpYWxEaXNwb3NlICk7XG5cblx0XHR0aGlzLm9uRGlzcG9zZSgpO1xuXG5cdH1cblxufVxuIiwiaW1wb3J0IENoYWluTWFwIGZyb20gJy4vQ2hhaW5NYXAuanMnO1xuaW1wb3J0IFJlbmRlck9iamVjdCBmcm9tICcuL1JlbmRlck9iamVjdC5qcyc7XG5cbmNvbnN0IGNoYWluQXJyYXkgPSBbXTtcblxuY2xhc3MgUmVuZGVyT2JqZWN0cyB7XG5cblx0Y29uc3RydWN0b3IoIHJlbmRlcmVyLCBub2RlcywgZ2VvbWV0cmllcywgcGlwZWxpbmVzLCBiaW5kaW5ncywgaW5mbyApIHtcblxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblx0XHR0aGlzLm5vZGVzID0gbm9kZXM7XG5cdFx0dGhpcy5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcblx0XHR0aGlzLnBpcGVsaW5lcyA9IHBpcGVsaW5lcztcblx0XHR0aGlzLmJpbmRpbmdzID0gYmluZGluZ3M7XG5cdFx0dGhpcy5pbmZvID0gaW5mbztcblxuXHRcdHRoaXMuY2hhaW5NYXBzID0ge307XG5cblx0fVxuXG5cdGdldCggb2JqZWN0LCBtYXRlcmlhbCwgc2NlbmUsIGNhbWVyYSwgbGlnaHRzTm9kZSwgcmVuZGVyQ29udGV4dCwgY2xpcHBpbmdDb250ZXh0LCBwYXNzSWQgKSB7XG5cblx0XHRjb25zdCBjaGFpbk1hcCA9IHRoaXMuZ2V0Q2hhaW5NYXAoIHBhc3NJZCApO1xuXG5cdFx0Ly8gcmV1c2UgY2hhaW5BcnJheVxuXHRcdGNoYWluQXJyYXlbIDAgXSA9IG9iamVjdDtcblx0XHRjaGFpbkFycmF5WyAxIF0gPSBtYXRlcmlhbDtcblx0XHRjaGFpbkFycmF5WyAyIF0gPSByZW5kZXJDb250ZXh0O1xuXHRcdGNoYWluQXJyYXlbIDMgXSA9IGxpZ2h0c05vZGU7XG5cblx0XHRsZXQgcmVuZGVyT2JqZWN0ID0gY2hhaW5NYXAuZ2V0KCBjaGFpbkFycmF5ICk7XG5cblx0XHRpZiAoIHJlbmRlck9iamVjdCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZW5kZXJPYmplY3QgPSB0aGlzLmNyZWF0ZVJlbmRlck9iamVjdCggdGhpcy5ub2RlcywgdGhpcy5nZW9tZXRyaWVzLCB0aGlzLnJlbmRlcmVyLCBvYmplY3QsIG1hdGVyaWFsLCBzY2VuZSwgY2FtZXJhLCBsaWdodHNOb2RlLCByZW5kZXJDb250ZXh0LCBjbGlwcGluZ0NvbnRleHQsIHBhc3NJZCApO1xuXG5cdFx0XHRjaGFpbk1hcC5zZXQoIGNoYWluQXJyYXksIHJlbmRlck9iamVjdCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVuZGVyT2JqZWN0LnVwZGF0ZUNsaXBwaW5nKCBjbGlwcGluZ0NvbnRleHQgKTtcblxuXHRcdFx0aWYgKCByZW5kZXJPYmplY3QubmVlZHNHZW9tZXRyeVVwZGF0ZSApIHtcblxuXHRcdFx0XHRyZW5kZXJPYmplY3Quc2V0R2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVuZGVyT2JqZWN0LnZlcnNpb24gIT09IG1hdGVyaWFsLnZlcnNpb24gfHwgcmVuZGVyT2JqZWN0Lm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdGlmICggcmVuZGVyT2JqZWN0LmluaXRpYWxDYWNoZUtleSAhPT0gcmVuZGVyT2JqZWN0LmdldENhY2hlS2V5KCkgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJPYmplY3QuZGlzcG9zZSgpO1xuXG5cdFx0XHRcdFx0cmVuZGVyT2JqZWN0ID0gdGhpcy5nZXQoIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIHJlbmRlckNvbnRleHQsIGNsaXBwaW5nQ29udGV4dCwgcGFzc0lkICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJlbmRlck9iamVjdC52ZXJzaW9uID0gbWF0ZXJpYWwudmVyc2lvbjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiByZW5kZXJPYmplY3Q7XG5cblx0fVxuXG5cdGdldENoYWluTWFwKCBwYXNzSWQgPSAnZGVmYXVsdCcgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jaGFpbk1hcHNbIHBhc3NJZCBdIHx8ICggdGhpcy5jaGFpbk1hcHNbIHBhc3NJZCBdID0gbmV3IENoYWluTWFwKCkgKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuY2hhaW5NYXBzID0ge307XG5cblx0fVxuXG5cdGNyZWF0ZVJlbmRlck9iamVjdCggbm9kZXMsIGdlb21ldHJpZXMsIHJlbmRlcmVyLCBvYmplY3QsIG1hdGVyaWFsLCBzY2VuZSwgY2FtZXJhLCBsaWdodHNOb2RlLCByZW5kZXJDb250ZXh0LCBjbGlwcGluZ0NvbnRleHQsIHBhc3NJZCApIHtcblxuXHRcdGNvbnN0IGNoYWluTWFwID0gdGhpcy5nZXRDaGFpbk1hcCggcGFzc0lkICk7XG5cblx0XHRjb25zdCByZW5kZXJPYmplY3QgPSBuZXcgUmVuZGVyT2JqZWN0KCBub2RlcywgZ2VvbWV0cmllcywgcmVuZGVyZXIsIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIHJlbmRlckNvbnRleHQsIGNsaXBwaW5nQ29udGV4dCApO1xuXG5cdFx0cmVuZGVyT2JqZWN0Lm9uRGlzcG9zZSA9ICgpID0+IHtcblxuXHRcdFx0dGhpcy5waXBlbGluZXMuZGVsZXRlKCByZW5kZXJPYmplY3QgKTtcblx0XHRcdHRoaXMuYmluZGluZ3MuZGVsZXRlKCByZW5kZXJPYmplY3QgKTtcblx0XHRcdHRoaXMubm9kZXMuZGVsZXRlKCByZW5kZXJPYmplY3QgKTtcblxuXHRcdFx0Y2hhaW5NYXAuZGVsZXRlKCByZW5kZXJPYmplY3QuZ2V0Q2hhaW5BcnJheSgpICk7XG5cblx0XHR9O1xuXG5cdFx0cmV0dXJuIHJlbmRlck9iamVjdDtcblxuXHR9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJPYmplY3RzO1xuIiwiY2xhc3MgRGF0YU1hcCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLmRhdGEgPSBuZXcgV2Vha01hcCgpO1xuXG5cdH1cblxuXHRnZXQoIG9iamVjdCApIHtcblxuXHRcdGxldCBtYXAgPSB0aGlzLmRhdGEuZ2V0KCBvYmplY3QgKTtcblxuXHRcdGlmICggbWFwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hcCA9IHt9O1xuXHRcdFx0dGhpcy5kYXRhLnNldCggb2JqZWN0LCBtYXAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXA7XG5cblx0fVxuXG5cdGRlbGV0ZSggb2JqZWN0ICkge1xuXG5cdFx0bGV0IG1hcDtcblxuXHRcdGlmICggdGhpcy5kYXRhLmhhcyggb2JqZWN0ICkgKSB7XG5cblx0XHRcdG1hcCA9IHRoaXMuZGF0YS5nZXQoIG9iamVjdCApO1xuXG5cdFx0XHR0aGlzLmRhdGEuZGVsZXRlKCBvYmplY3QgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXA7XG5cblx0fVxuXG5cdGhhcyggb2JqZWN0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5oYXMoIG9iamVjdCApO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5kYXRhID0gbmV3IFdlYWtNYXAoKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YU1hcDtcbiIsImV4cG9ydCBjb25zdCBBdHRyaWJ1dGVUeXBlID0ge1xuXHRWRVJURVg6IDEsXG5cdElOREVYOiAyLFxuXHRTVE9SQUdFOiAzLFxuXHRJTkRJUkVDVDogNFxufTtcblxuLy8gc2l6ZSBvZiBhIGNodW5rIGluIGJ5dGVzIChTVEQxNDAgbGF5b3V0KVxuXG5leHBvcnQgY29uc3QgR1BVX0NIVU5LX0JZVEVTID0gMTY7XG5cbi8vIEBUT0RPOiBNb3ZlIHRvIHNyYy9jb25zdGFudHMuanNcblxuZXhwb3J0IGNvbnN0IEJsZW5kQ29sb3JGYWN0b3IgPSAyMTE7XG5leHBvcnQgY29uc3QgT25lTWludXNCbGVuZENvbG9yRmFjdG9yID0gMjEyO1xuIiwiaW1wb3J0IERhdGFNYXAgZnJvbSAnLi9EYXRhTWFwLmpzJztcbmltcG9ydCB7IEF0dHJpYnV0ZVR5cGUgfSBmcm9tICcuL0NvbnN0YW50cy5qcyc7XG5cbmltcG9ydCB7IER5bmFtaWNEcmF3VXNhZ2UgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuXG5jbGFzcyBBdHRyaWJ1dGVzIGV4dGVuZHMgRGF0YU1hcCB7XG5cblx0Y29uc3RydWN0b3IoIGJhY2tlbmQgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcblxuXHR9XG5cblx0ZGVsZXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRjb25zdCBhdHRyaWJ1dGVEYXRhID0gc3VwZXIuZGVsZXRlKCBhdHRyaWJ1dGUgKTtcblxuXHRcdGlmICggYXR0cmlidXRlRGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmJhY2tlbmQuZGVzdHJveUF0dHJpYnV0ZSggYXR0cmlidXRlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYXR0cmlidXRlRGF0YTtcblxuXHR9XG5cblx0dXBkYXRlKCBhdHRyaWJ1dGUsIHR5cGUgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gdGhpcy5nZXQoIGF0dHJpYnV0ZSApO1xuXG5cdFx0aWYgKCBkYXRhLnZlcnNpb24gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCB0eXBlID09PSBBdHRyaWJ1dGVUeXBlLlZFUlRFWCApIHtcblxuXHRcdFx0XHR0aGlzLmJhY2tlbmQuY3JlYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gQXR0cmlidXRlVHlwZS5JTkRFWCApIHtcblxuXHRcdFx0XHR0aGlzLmJhY2tlbmQuY3JlYXRlSW5kZXhBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBBdHRyaWJ1dGVUeXBlLlNUT1JBR0UgKSB7XG5cblx0XHRcdFx0dGhpcy5iYWNrZW5kLmNyZWF0ZVN0b3JhZ2VBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBBdHRyaWJ1dGVUeXBlLklORElSRUNUICkge1xuXG5cdFx0XHRcdHRoaXMuYmFja2VuZC5jcmVhdGVJbmRpcmVjdFN0b3JhZ2VBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRhdGEudmVyc2lvbiA9IHRoaXMuX2dldEJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkudmVyc2lvbjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGJ1ZmZlckF0dHJpYnV0ZSA9IHRoaXMuX2dldEJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICk7XG5cblx0XHRcdGlmICggZGF0YS52ZXJzaW9uIDwgYnVmZmVyQXR0cmlidXRlLnZlcnNpb24gfHwgYnVmZmVyQXR0cmlidXRlLnVzYWdlID09PSBEeW5hbWljRHJhd1VzYWdlICkge1xuXG5cdFx0XHRcdHRoaXMuYmFja2VuZC51cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdGRhdGEudmVyc2lvbiA9IGJ1ZmZlckF0dHJpYnV0ZS52ZXJzaW9uO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdF9nZXRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuXHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcblxuXHRcdHJldHVybiBhdHRyaWJ1dGU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEF0dHJpYnV0ZXM7XG4iLCJpbXBvcnQgRGF0YU1hcCBmcm9tICcuL0RhdGFNYXAuanMnO1xuaW1wb3J0IHsgQXR0cmlidXRlVHlwZSB9IGZyb20gJy4vQ29uc3RhbnRzLmpzJztcblxuaW1wb3J0IHsgVWludDE2QnVmZmVyQXR0cmlidXRlLCBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5cbmZ1bmN0aW9uIGFycmF5TmVlZHNVaW50MzIoIGFycmF5ICkge1xuXG5cdC8vIGFzc3VtZXMgbGFyZ2VyIHZhbHVlcyB1c3VhbGx5IG9uIGxhc3RcblxuXHRmb3IgKCBsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS0gaSApIHtcblxuXHRcdGlmICggYXJyYXlbIGkgXSA+PSA2NTUzNSApIHJldHVybiB0cnVlOyAvLyBhY2NvdW50IGZvciBQUklNSVRJVkVfUkVTVEFSVF9GSVhFRF9JTkRFWCwgIzI0NTY1XG5cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcblxufVxuXG5mdW5jdGlvbiBnZXRXaXJlZnJhbWVWZXJzaW9uKCBnZW9tZXRyeSApIHtcblxuXHRyZXR1cm4gKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApID8gZ2VvbWV0cnkuaW5kZXgudmVyc2lvbiA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmVyc2lvbjtcblxufVxuXG5mdW5jdGlvbiBnZXRXaXJlZnJhbWVJbmRleCggZ2VvbWV0cnkgKSB7XG5cblx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXG5cdGNvbnN0IGdlb21ldHJ5SW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0Y29uc3QgZ2VvbWV0cnlQb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0aWYgKCBnZW9tZXRyeUluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0Y29uc3QgYXJyYXkgPSBnZW9tZXRyeUluZGV4LmFycmF5O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRjb25zdCBhID0gYXJyYXlbIGkgKyAwIF07XG5cdFx0XHRjb25zdCBiID0gYXJyYXlbIGkgKyAxIF07XG5cdFx0XHRjb25zdCBjID0gYXJyYXlbIGkgKyAyIF07XG5cblx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYiwgYywgYywgYSApO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRjb25zdCBhcnJheSA9IGdlb21ldHJ5UG9zaXRpb24uYXJyYXk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSAoIGFycmF5Lmxlbmd0aCAvIDMgKSAtIDE7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdGNvbnN0IGEgPSBpICsgMDtcblx0XHRcdGNvbnN0IGIgPSBpICsgMTtcblx0XHRcdGNvbnN0IGMgPSBpICsgMjtcblxuXHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBiLCBjLCBjLCBhICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyAoIGFycmF5TmVlZHNVaW50MzIoIGluZGljZXMgKSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSApKCBpbmRpY2VzLCAxICk7XG5cdGF0dHJpYnV0ZS52ZXJzaW9uID0gZ2V0V2lyZWZyYW1lVmVyc2lvbiggZ2VvbWV0cnkgKTtcblxuXHRyZXR1cm4gYXR0cmlidXRlO1xuXG59XG5cbmNsYXNzIEdlb21ldHJpZXMgZXh0ZW5kcyBEYXRhTWFwIHtcblxuXHRjb25zdHJ1Y3RvciggYXR0cmlidXRlcywgaW5mbyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXHRcdHRoaXMuaW5mbyA9IGluZm87XG5cblx0XHR0aGlzLndpcmVmcmFtZXMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdFx0dGhpcy5hdHRyaWJ1dGVDYWxsID0gbmV3IFdlYWtNYXAoKTtcblxuXHR9XG5cblx0aGFzKCByZW5kZXJPYmplY3QgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHJlbmRlck9iamVjdC5nZW9tZXRyeTtcblxuXHRcdHJldHVybiBzdXBlci5oYXMoIGdlb21ldHJ5ICkgJiYgdGhpcy5nZXQoIGdlb21ldHJ5ICkuaW5pdGlhbGl6ZWQgPT09IHRydWU7XG5cblx0fVxuXG5cdHVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICkge1xuXG5cdFx0aWYgKCB0aGlzLmhhcyggcmVuZGVyT2JqZWN0ICkgPT09IGZhbHNlICkgdGhpcy5pbml0R2VvbWV0cnkoIHJlbmRlck9iamVjdCApO1xuXG5cdFx0dGhpcy51cGRhdGVBdHRyaWJ1dGVzKCByZW5kZXJPYmplY3QgKTtcblxuXHR9XG5cblx0aW5pdEdlb21ldHJ5KCByZW5kZXJPYmplY3QgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHJlbmRlck9iamVjdC5nZW9tZXRyeTtcblx0XHRjb25zdCBnZW9tZXRyeURhdGEgPSB0aGlzLmdldCggZ2VvbWV0cnkgKTtcblxuXHRcdGdlb21ldHJ5RGF0YS5pbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHR0aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XG5cblx0XHRjb25zdCBvbkRpc3Bvc2UgPSAoKSA9PiB7XG5cblx0XHRcdHRoaXMuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcblxuXHRcdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IHJlbmRlck9iamVjdC5nZXRBdHRyaWJ1dGVzKCk7XG5cblx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmRlbGV0ZSggaW5kZXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBjb25zdCBnZW9tZXRyeUF0dHJpYnV0ZSBvZiBnZW9tZXRyeUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmRlbGV0ZSggZ2VvbWV0cnlBdHRyaWJ1dGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB3aXJlZnJhbWVBdHRyaWJ1dGUgPSB0aGlzLndpcmVmcmFtZXMuZ2V0KCBnZW9tZXRyeSApO1xuXG5cdFx0XHRpZiAoIHdpcmVmcmFtZUF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlcy5kZWxldGUoIHdpcmVmcmFtZUF0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25EaXNwb3NlICk7XG5cblx0XHR9O1xuXG5cdFx0Z2VvbWV0cnkuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UgKTtcblxuXHR9XG5cblx0dXBkYXRlQXR0cmlidXRlcyggcmVuZGVyT2JqZWN0ICkge1xuXG5cdFx0Ly8gYXR0cmlidXRlc1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHJlbmRlck9iamVjdC5nZXRBdHRyaWJ1dGVzKCk7XG5cblx0XHRmb3IgKCBjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcyApIHtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXNTdG9yYWdlQnVmZmVyQXR0cmlidXRlIHx8IGF0dHJpYnV0ZS5pc1N0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0dGhpcy51cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgQXR0cmlidXRlVHlwZS5TVE9SQUdFICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy51cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgQXR0cmlidXRlVHlwZS5WRVJURVggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kZXhlc1xuXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmdldEluZGV4KCByZW5kZXJPYmplY3QgKTtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMudXBkYXRlQXR0cmlidXRlKCBpbmRleCwgQXR0cmlidXRlVHlwZS5JTkRFWCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaXJlY3RcblxuXHRcdGNvbnN0IGluZGlyZWN0ID0gcmVuZGVyT2JqZWN0Lmdlb21ldHJ5LmluZGlyZWN0O1xuXG5cdFx0aWYgKCBpbmRpcmVjdCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy51cGRhdGVBdHRyaWJ1dGUoIGluZGlyZWN0LCBBdHRyaWJ1dGVUeXBlLklORElSRUNUICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCB0eXBlICkge1xuXG5cdFx0Y29uc3QgY2FsbElkID0gdGhpcy5pbmZvLnJlbmRlci5jYWxscztcblxuXHRcdGlmICggISBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZUNhbGwuZ2V0KCBhdHRyaWJ1dGUgKSAhPT0gY2FsbElkICkge1xuXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlcy51cGRhdGUoIGF0dHJpYnV0ZSwgdHlwZSApO1xuXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlQ2FsbC5zZXQoIGF0dHJpYnV0ZSwgY2FsbElkICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggdGhpcy5hdHRyaWJ1dGVDYWxsLmdldCggYXR0cmlidXRlICkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZXMudXBkYXRlKCBhdHRyaWJ1dGUsIHR5cGUgKTtcblxuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZUNhbGwuc2V0KCBhdHRyaWJ1dGUsIGNhbGxJZCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmF0dHJpYnV0ZUNhbGwuZ2V0KCBhdHRyaWJ1dGUuZGF0YSApICE9PSBjYWxsSWQgKSB7XG5cblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLnVwZGF0ZSggYXR0cmlidXRlLCB0eXBlICk7XG5cblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVDYWxsLnNldCggYXR0cmlidXRlLmRhdGEsIGNhbGxJZCApO1xuXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlQ2FsbC5zZXQoIGF0dHJpYnV0ZSwgY2FsbElkICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Z2V0SW5kaXJlY3QoIHJlbmRlck9iamVjdCApIHtcblxuXHRcdHJldHVybiByZW5kZXJPYmplY3QuZ2VvbWV0cnkuaW5kaXJlY3Q7XG5cblx0fVxuXG5cdGdldEluZGV4KCByZW5kZXJPYmplY3QgKSB7XG5cblx0XHRjb25zdCB7IGdlb21ldHJ5LCBtYXRlcmlhbCB9ID0gcmVuZGVyT2JqZWN0O1xuXG5cdFx0bGV0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cblx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3Qgd2lyZWZyYW1lcyA9IHRoaXMud2lyZWZyYW1lcztcblxuXHRcdFx0bGV0IHdpcmVmcmFtZUF0dHJpYnV0ZSA9IHdpcmVmcmFtZXMuZ2V0KCBnZW9tZXRyeSApO1xuXG5cdFx0XHRpZiAoIHdpcmVmcmFtZUF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHdpcmVmcmFtZUF0dHJpYnV0ZSA9IGdldFdpcmVmcmFtZUluZGV4KCBnZW9tZXRyeSApO1xuXG5cdFx0XHRcdHdpcmVmcmFtZXMuc2V0KCBnZW9tZXRyeSwgd2lyZWZyYW1lQXR0cmlidXRlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHdpcmVmcmFtZUF0dHJpYnV0ZS52ZXJzaW9uICE9PSBnZXRXaXJlZnJhbWVWZXJzaW9uKCBnZW9tZXRyeSApICkge1xuXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlcy5kZWxldGUoIHdpcmVmcmFtZUF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdHdpcmVmcmFtZUF0dHJpYnV0ZSA9IGdldFdpcmVmcmFtZUluZGV4KCBnZW9tZXRyeSApO1xuXG5cdFx0XHRcdHdpcmVmcmFtZXMuc2V0KCBnZW9tZXRyeSwgd2lyZWZyYW1lQXR0cmlidXRlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aW5kZXggPSB3aXJlZnJhbWVBdHRyaWJ1dGU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXg7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEdlb21ldHJpZXM7XG4iLCJjbGFzcyBJbmZvIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMuYXV0b1Jlc2V0ID0gdHJ1ZTtcblxuXHRcdHRoaXMuZnJhbWUgPSAwO1xuXHRcdHRoaXMuY2FsbHMgPSAwO1xuXG5cdFx0dGhpcy5yZW5kZXIgPSB7XG5cdFx0XHRjYWxsczogMCxcblx0XHRcdGZyYW1lQ2FsbHM6IDAsXG5cdFx0XHRkcmF3Q2FsbHM6IDAsXG5cdFx0XHR0cmlhbmdsZXM6IDAsXG5cdFx0XHRwb2ludHM6IDAsXG5cdFx0XHRsaW5lczogMCxcblx0XHRcdHRpbWVzdGFtcDogMCxcblx0XHRcdHByZXZpb3VzRnJhbWVDYWxsczogMCxcblx0XHRcdHRpbWVzdGFtcENhbGxzOiAwXG5cdFx0fTtcblxuXHRcdHRoaXMuY29tcHV0ZSA9IHtcblx0XHRcdGNhbGxzOiAwLFxuXHRcdFx0ZnJhbWVDYWxsczogMCxcblx0XHRcdHRpbWVzdGFtcDogMCxcblx0XHRcdHByZXZpb3VzRnJhbWVDYWxsczogMCxcblx0XHRcdHRpbWVzdGFtcENhbGxzOiAwXG5cdFx0fTtcblxuXHRcdHRoaXMubWVtb3J5ID0ge1xuXHRcdFx0Z2VvbWV0cmllczogMCxcblx0XHRcdHRleHR1cmVzOiAwXG5cdFx0fTtcblxuXHR9XG5cblx0dXBkYXRlKCBvYmplY3QsIGNvdW50LCBpbnN0YW5jZUNvdW50ICkge1xuXG5cdFx0dGhpcy5yZW5kZXIuZHJhd0NhbGxzICsrO1xuXG5cdFx0aWYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc1Nwcml0ZSApIHtcblxuXHRcdFx0dGhpcy5yZW5kZXIudHJpYW5nbGVzICs9IGluc3RhbmNlQ291bnQgKiAoIGNvdW50IC8gMyApO1xuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzUG9pbnRzICkge1xuXG5cdFx0XHR0aGlzLnJlbmRlci5wb2ludHMgKz0gaW5zdGFuY2VDb3VudCAqIGNvdW50O1xuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGluZVNlZ21lbnRzICkge1xuXG5cdFx0XHR0aGlzLnJlbmRlci5saW5lcyArPSBpbnN0YW5jZUNvdW50ICogKCBjb3VudCAvIDIgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xpbmUgKSB7XG5cblx0XHRcdHRoaXMucmVuZGVyLmxpbmVzICs9IGluc3RhbmNlQ291bnQgKiAoIGNvdW50IC0gMSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdQVUluZm86IFVua25vd24gb2JqZWN0IHR5cGUuJyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGVUaW1lc3RhbXAoIHR5cGUsIHRpbWUgKSB7XG5cblx0XHRpZiAoIHRoaXNbIHR5cGUgXS50aW1lc3RhbXBDYWxscyA9PT0gMCApIHtcblxuXHRcdFx0dGhpc1sgdHlwZSBdLnRpbWVzdGFtcCA9IDA7XG5cblx0XHR9XG5cblxuXHRcdHRoaXNbIHR5cGUgXS50aW1lc3RhbXAgKz0gdGltZTtcblxuXHRcdHRoaXNbIHR5cGUgXS50aW1lc3RhbXBDYWxscyArKztcblxuXG5cdFx0aWYgKCB0aGlzWyB0eXBlIF0udGltZXN0YW1wQ2FsbHMgPj0gdGhpc1sgdHlwZSBdLnByZXZpb3VzRnJhbWVDYWxscyApIHtcblxuXHRcdFx0dGhpc1sgdHlwZSBdLnRpbWVzdGFtcENhbGxzID0gMDtcblxuXHRcdH1cblxuXG5cdH1cblxuXHRyZXNldCgpIHtcblxuXHRcdGNvbnN0IHByZXZpb3VzUmVuZGVyRnJhbWVDYWxscyA9IHRoaXMucmVuZGVyLmZyYW1lQ2FsbHM7XG5cdFx0dGhpcy5yZW5kZXIucHJldmlvdXNGcmFtZUNhbGxzID0gcHJldmlvdXNSZW5kZXJGcmFtZUNhbGxzO1xuXG5cdFx0Y29uc3QgcHJldmlvdXNDb21wdXRlRnJhbWVDYWxscyA9IHRoaXMuY29tcHV0ZS5mcmFtZUNhbGxzO1xuXHRcdHRoaXMuY29tcHV0ZS5wcmV2aW91c0ZyYW1lQ2FsbHMgPSBwcmV2aW91c0NvbXB1dGVGcmFtZUNhbGxzO1xuXG5cblx0XHR0aGlzLnJlbmRlci5kcmF3Q2FsbHMgPSAwO1xuXHRcdHRoaXMucmVuZGVyLmZyYW1lQ2FsbHMgPSAwO1xuXHRcdHRoaXMuY29tcHV0ZS5mcmFtZUNhbGxzID0gMDtcblxuXHRcdHRoaXMucmVuZGVyLnRyaWFuZ2xlcyA9IDA7XG5cdFx0dGhpcy5yZW5kZXIucG9pbnRzID0gMDtcblx0XHR0aGlzLnJlbmRlci5saW5lcyA9IDA7XG5cblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMucmVzZXQoKTtcblxuXHRcdHRoaXMuY2FsbHMgPSAwO1xuXG5cdFx0dGhpcy5yZW5kZXIuY2FsbHMgPSAwO1xuXHRcdHRoaXMuY29tcHV0ZS5jYWxscyA9IDA7XG5cblx0XHR0aGlzLnJlbmRlci50aW1lc3RhbXAgPSAwO1xuXHRcdHRoaXMuY29tcHV0ZS50aW1lc3RhbXAgPSAwO1xuXHRcdHRoaXMubWVtb3J5Lmdlb21ldHJpZXMgPSAwO1xuXHRcdHRoaXMubWVtb3J5LnRleHR1cmVzID0gMDtcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBJbmZvO1xuIiwiY2xhc3MgUGlwZWxpbmUge1xuXG5cdGNvbnN0cnVjdG9yKCBjYWNoZUtleSApIHtcblxuXHRcdHRoaXMuY2FjaGVLZXkgPSBjYWNoZUtleTtcblxuXHRcdHRoaXMudXNlZFRpbWVzID0gMDtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGlwZWxpbmU7XG4iLCJpbXBvcnQgUGlwZWxpbmUgZnJvbSAnLi9QaXBlbGluZS5qcyc7XG5cbmNsYXNzIFJlbmRlclBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuXG5cdGNvbnN0cnVjdG9yKCBjYWNoZUtleSwgdmVydGV4UHJvZ3JhbSwgZnJhZ21lbnRQcm9ncmFtICkge1xuXG5cdFx0c3VwZXIoIGNhY2hlS2V5ICk7XG5cblx0XHR0aGlzLnZlcnRleFByb2dyYW0gPSB2ZXJ0ZXhQcm9ncmFtO1xuXHRcdHRoaXMuZnJhZ21lbnRQcm9ncmFtID0gZnJhZ21lbnRQcm9ncmFtO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJQaXBlbGluZTtcbiIsImltcG9ydCBQaXBlbGluZSBmcm9tICcuL1BpcGVsaW5lLmpzJztcblxuY2xhc3MgQ29tcHV0ZVBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuXG5cdGNvbnN0cnVjdG9yKCBjYWNoZUtleSwgY29tcHV0ZVByb2dyYW0gKSB7XG5cblx0XHRzdXBlciggY2FjaGVLZXkgKTtcblxuXHRcdHRoaXMuY29tcHV0ZVByb2dyYW0gPSBjb21wdXRlUHJvZ3JhbTtcblxuXHRcdHRoaXMuaXNDb21wdXRlUGlwZWxpbmUgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDb21wdXRlUGlwZWxpbmU7XG4iLCJsZXQgX2lkID0gMDtcblxuY2xhc3MgUHJvZ3JhbW1hYmxlU3RhZ2Uge1xuXG5cdGNvbnN0cnVjdG9yKCBjb2RlLCB0eXBlLCB0cmFuc2Zvcm1zID0gbnVsbCwgYXR0cmlidXRlcyA9IG51bGwgKSB7XG5cblx0XHR0aGlzLmlkID0gX2lkICsrO1xuXG5cdFx0dGhpcy5jb2RlID0gY29kZTtcblx0XHR0aGlzLnN0YWdlID0gdHlwZTtcblx0XHR0aGlzLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zO1xuXHRcdHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cblx0XHR0aGlzLnVzZWRUaW1lcyA9IDA7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb2dyYW1tYWJsZVN0YWdlO1xuIiwiaW1wb3J0IERhdGFNYXAgZnJvbSAnLi9EYXRhTWFwLmpzJztcbmltcG9ydCBSZW5kZXJQaXBlbGluZSBmcm9tICcuL1JlbmRlclBpcGVsaW5lLmpzJztcbmltcG9ydCBDb21wdXRlUGlwZWxpbmUgZnJvbSAnLi9Db21wdXRlUGlwZWxpbmUuanMnO1xuaW1wb3J0IFByb2dyYW1tYWJsZVN0YWdlIGZyb20gJy4vUHJvZ3JhbW1hYmxlU3RhZ2UuanMnO1xuXG5jbGFzcyBQaXBlbGluZXMgZXh0ZW5kcyBEYXRhTWFwIHtcblxuXHRjb25zdHJ1Y3RvciggYmFja2VuZCwgbm9kZXMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcblx0XHR0aGlzLm5vZGVzID0gbm9kZXM7XG5cblx0XHR0aGlzLmJpbmRpbmdzID0gbnVsbDsgLy8gc2V0IGJ5IHRoZSBiaW5kaW5nc1xuXG5cdFx0dGhpcy5jYWNoZXMgPSBuZXcgTWFwKCk7XG5cdFx0dGhpcy5wcm9ncmFtcyA9IHtcblx0XHRcdHZlcnRleDogbmV3IE1hcCgpLFxuXHRcdFx0ZnJhZ21lbnQ6IG5ldyBNYXAoKSxcblx0XHRcdGNvbXB1dGU6IG5ldyBNYXAoKVxuXHRcdH07XG5cblx0fVxuXG5cdGdldEZvckNvbXB1dGUoIGNvbXB1dGVOb2RlLCBiaW5kaW5ncyApIHtcblxuXHRcdGNvbnN0IHsgYmFja2VuZCB9ID0gdGhpcztcblxuXHRcdGNvbnN0IGRhdGEgPSB0aGlzLmdldCggY29tcHV0ZU5vZGUgKTtcblxuXHRcdGlmICggdGhpcy5fbmVlZHNDb21wdXRlVXBkYXRlKCBjb21wdXRlTm9kZSApICkge1xuXG5cdFx0XHRjb25zdCBwcmV2aW91c1BpcGVsaW5lID0gZGF0YS5waXBlbGluZTtcblxuXHRcdFx0aWYgKCBwcmV2aW91c1BpcGVsaW5lICkge1xuXG5cdFx0XHRcdHByZXZpb3VzUGlwZWxpbmUudXNlZFRpbWVzIC0tO1xuXHRcdFx0XHRwcmV2aW91c1BpcGVsaW5lLmNvbXB1dGVQcm9ncmFtLnVzZWRUaW1lcyAtLTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBnZXQgc2hhZGVyXG5cblx0XHRcdGNvbnN0IG5vZGVCdWlsZGVyU3RhdGUgPSB0aGlzLm5vZGVzLmdldEZvckNvbXB1dGUoIGNvbXB1dGVOb2RlICk7XG5cblx0XHRcdC8vIHByb2dyYW1tYWJsZSBzdGFnZVxuXG5cdFx0XHRsZXQgc3RhZ2VDb21wdXRlID0gdGhpcy5wcm9ncmFtcy5jb21wdXRlLmdldCggbm9kZUJ1aWxkZXJTdGF0ZS5jb21wdXRlU2hhZGVyICk7XG5cblx0XHRcdGlmICggc3RhZ2VDb21wdXRlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBwcmV2aW91c1BpcGVsaW5lICYmIHByZXZpb3VzUGlwZWxpbmUuY29tcHV0ZVByb2dyYW0udXNlZFRpbWVzID09PSAwICkgdGhpcy5fcmVsZWFzZVByb2dyYW0oIHByZXZpb3VzUGlwZWxpbmUuY29tcHV0ZVByb2dyYW0gKTtcblxuXHRcdFx0XHRzdGFnZUNvbXB1dGUgPSBuZXcgUHJvZ3JhbW1hYmxlU3RhZ2UoIG5vZGVCdWlsZGVyU3RhdGUuY29tcHV0ZVNoYWRlciwgJ2NvbXB1dGUnLCBub2RlQnVpbGRlclN0YXRlLnRyYW5zZm9ybXMsIG5vZGVCdWlsZGVyU3RhdGUubm9kZUF0dHJpYnV0ZXMgKTtcblx0XHRcdFx0dGhpcy5wcm9ncmFtcy5jb21wdXRlLnNldCggbm9kZUJ1aWxkZXJTdGF0ZS5jb21wdXRlU2hhZGVyLCBzdGFnZUNvbXB1dGUgKTtcblxuXHRcdFx0XHRiYWNrZW5kLmNyZWF0ZVByb2dyYW0oIHN0YWdlQ29tcHV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGRldGVybWluZSBjb21wdXRlIHBpcGVsaW5lXG5cblx0XHRcdGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5fZ2V0Q29tcHV0ZUNhY2hlS2V5KCBjb21wdXRlTm9kZSwgc3RhZ2VDb21wdXRlICk7XG5cblx0XHRcdGxldCBwaXBlbGluZSA9IHRoaXMuY2FjaGVzLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdFx0aWYgKCBwaXBlbGluZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggcHJldmlvdXNQaXBlbGluZSAmJiBwcmV2aW91c1BpcGVsaW5lLnVzZWRUaW1lcyA9PT0gMCApIHRoaXMuX3JlbGVhc2VQaXBlbGluZSggcHJldmlvdXNQaXBlbGluZSApO1xuXG5cdFx0XHRcdHBpcGVsaW5lID0gdGhpcy5fZ2V0Q29tcHV0ZVBpcGVsaW5lKCBjb21wdXRlTm9kZSwgc3RhZ2VDb21wdXRlLCBjYWNoZUtleSwgYmluZGluZ3MgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBrZWVwIHRyYWNrIG9mIGFsbCB1c2VkIHRpbWVzXG5cblx0XHRcdHBpcGVsaW5lLnVzZWRUaW1lcyArKztcblx0XHRcdHN0YWdlQ29tcHV0ZS51c2VkVGltZXMgKys7XG5cblx0XHRcdC8vXG5cblx0XHRcdGRhdGEudmVyc2lvbiA9IGNvbXB1dGVOb2RlLnZlcnNpb247XG5cdFx0XHRkYXRhLnBpcGVsaW5lID0gcGlwZWxpbmU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YS5waXBlbGluZTtcblxuXHR9XG5cblx0Z2V0Rm9yUmVuZGVyKCByZW5kZXJPYmplY3QsIHByb21pc2VzID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IHsgYmFja2VuZCB9ID0gdGhpcztcblxuXHRcdGNvbnN0IGRhdGEgPSB0aGlzLmdldCggcmVuZGVyT2JqZWN0ICk7XG5cblx0XHRpZiAoIHRoaXMuX25lZWRzUmVuZGVyVXBkYXRlKCByZW5kZXJPYmplY3QgKSApIHtcblxuXHRcdFx0Y29uc3QgcHJldmlvdXNQaXBlbGluZSA9IGRhdGEucGlwZWxpbmU7XG5cblx0XHRcdGlmICggcHJldmlvdXNQaXBlbGluZSApIHtcblxuXHRcdFx0XHRwcmV2aW91c1BpcGVsaW5lLnVzZWRUaW1lcyAtLTtcblx0XHRcdFx0cHJldmlvdXNQaXBlbGluZS52ZXJ0ZXhQcm9ncmFtLnVzZWRUaW1lcyAtLTtcblx0XHRcdFx0cHJldmlvdXNQaXBlbGluZS5mcmFnbWVudFByb2dyYW0udXNlZFRpbWVzIC0tO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdldCBzaGFkZXJcblxuXHRcdFx0Y29uc3Qgbm9kZUJ1aWxkZXJTdGF0ZSA9IHJlbmRlck9iamVjdC5nZXROb2RlQnVpbGRlclN0YXRlKCk7XG5cblx0XHRcdC8vIHByb2dyYW1tYWJsZSBzdGFnZXNcblxuXHRcdFx0bGV0IHN0YWdlVmVydGV4ID0gdGhpcy5wcm9ncmFtcy52ZXJ0ZXguZ2V0KCBub2RlQnVpbGRlclN0YXRlLnZlcnRleFNoYWRlciApO1xuXG5cdFx0XHRpZiAoIHN0YWdlVmVydGV4ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBwcmV2aW91c1BpcGVsaW5lICYmIHByZXZpb3VzUGlwZWxpbmUudmVydGV4UHJvZ3JhbS51c2VkVGltZXMgPT09IDAgKSB0aGlzLl9yZWxlYXNlUHJvZ3JhbSggcHJldmlvdXNQaXBlbGluZS52ZXJ0ZXhQcm9ncmFtICk7XG5cblx0XHRcdFx0c3RhZ2VWZXJ0ZXggPSBuZXcgUHJvZ3JhbW1hYmxlU3RhZ2UoIG5vZGVCdWlsZGVyU3RhdGUudmVydGV4U2hhZGVyLCAndmVydGV4JyApO1xuXHRcdFx0XHR0aGlzLnByb2dyYW1zLnZlcnRleC5zZXQoIG5vZGVCdWlsZGVyU3RhdGUudmVydGV4U2hhZGVyLCBzdGFnZVZlcnRleCApO1xuXG5cdFx0XHRcdGJhY2tlbmQuY3JlYXRlUHJvZ3JhbSggc3RhZ2VWZXJ0ZXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgc3RhZ2VGcmFnbWVudCA9IHRoaXMucHJvZ3JhbXMuZnJhZ21lbnQuZ2V0KCBub2RlQnVpbGRlclN0YXRlLmZyYWdtZW50U2hhZGVyICk7XG5cblx0XHRcdGlmICggc3RhZ2VGcmFnbWVudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggcHJldmlvdXNQaXBlbGluZSAmJiBwcmV2aW91c1BpcGVsaW5lLmZyYWdtZW50UHJvZ3JhbS51c2VkVGltZXMgPT09IDAgKSB0aGlzLl9yZWxlYXNlUHJvZ3JhbSggcHJldmlvdXNQaXBlbGluZS5mcmFnbWVudFByb2dyYW0gKTtcblxuXHRcdFx0XHRzdGFnZUZyYWdtZW50ID0gbmV3IFByb2dyYW1tYWJsZVN0YWdlKCBub2RlQnVpbGRlclN0YXRlLmZyYWdtZW50U2hhZGVyLCAnZnJhZ21lbnQnICk7XG5cdFx0XHRcdHRoaXMucHJvZ3JhbXMuZnJhZ21lbnQuc2V0KCBub2RlQnVpbGRlclN0YXRlLmZyYWdtZW50U2hhZGVyLCBzdGFnZUZyYWdtZW50ICk7XG5cblx0XHRcdFx0YmFja2VuZC5jcmVhdGVQcm9ncmFtKCBzdGFnZUZyYWdtZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZGV0ZXJtaW5lIHJlbmRlciBwaXBlbGluZVxuXG5cdFx0XHRjb25zdCBjYWNoZUtleSA9IHRoaXMuX2dldFJlbmRlckNhY2hlS2V5KCByZW5kZXJPYmplY3QsIHN0YWdlVmVydGV4LCBzdGFnZUZyYWdtZW50ICk7XG5cblx0XHRcdGxldCBwaXBlbGluZSA9IHRoaXMuY2FjaGVzLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdFx0aWYgKCBwaXBlbGluZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggcHJldmlvdXNQaXBlbGluZSAmJiBwcmV2aW91c1BpcGVsaW5lLnVzZWRUaW1lcyA9PT0gMCApIHRoaXMuX3JlbGVhc2VQaXBlbGluZSggcHJldmlvdXNQaXBlbGluZSApO1xuXG5cdFx0XHRcdHBpcGVsaW5lID0gdGhpcy5fZ2V0UmVuZGVyUGlwZWxpbmUoIHJlbmRlck9iamVjdCwgc3RhZ2VWZXJ0ZXgsIHN0YWdlRnJhZ21lbnQsIGNhY2hlS2V5LCBwcm9taXNlcyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlbmRlck9iamVjdC5waXBlbGluZSA9IHBpcGVsaW5lO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGtlZXAgdHJhY2sgb2YgYWxsIHVzZWQgdGltZXNcblxuXHRcdFx0cGlwZWxpbmUudXNlZFRpbWVzICsrO1xuXHRcdFx0c3RhZ2VWZXJ0ZXgudXNlZFRpbWVzICsrO1xuXHRcdFx0c3RhZ2VGcmFnbWVudC51c2VkVGltZXMgKys7XG5cblx0XHRcdC8vXG5cblx0XHRcdGRhdGEucGlwZWxpbmUgPSBwaXBlbGluZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhLnBpcGVsaW5lO1xuXG5cdH1cblxuXHRkZWxldGUoIG9iamVjdCApIHtcblxuXHRcdGNvbnN0IHBpcGVsaW5lID0gdGhpcy5nZXQoIG9iamVjdCApLnBpcGVsaW5lO1xuXG5cdFx0aWYgKCBwaXBlbGluZSApIHtcblxuXHRcdFx0Ly8gcGlwZWxpbmVcblxuXHRcdFx0cGlwZWxpbmUudXNlZFRpbWVzIC0tO1xuXG5cdFx0XHRpZiAoIHBpcGVsaW5lLnVzZWRUaW1lcyA9PT0gMCApIHRoaXMuX3JlbGVhc2VQaXBlbGluZSggcGlwZWxpbmUgKTtcblxuXHRcdFx0Ly8gcHJvZ3JhbXNcblxuXHRcdFx0aWYgKCBwaXBlbGluZS5pc0NvbXB1dGVQaXBlbGluZSApIHtcblxuXHRcdFx0XHRwaXBlbGluZS5jb21wdXRlUHJvZ3JhbS51c2VkVGltZXMgLS07XG5cblx0XHRcdFx0aWYgKCBwaXBlbGluZS5jb21wdXRlUHJvZ3JhbS51c2VkVGltZXMgPT09IDAgKSB0aGlzLl9yZWxlYXNlUHJvZ3JhbSggcGlwZWxpbmUuY29tcHV0ZVByb2dyYW0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRwaXBlbGluZS5mcmFnbWVudFByb2dyYW0udXNlZFRpbWVzIC0tO1xuXHRcdFx0XHRwaXBlbGluZS52ZXJ0ZXhQcm9ncmFtLnVzZWRUaW1lcyAtLTtcblxuXHRcdFx0XHRpZiAoIHBpcGVsaW5lLnZlcnRleFByb2dyYW0udXNlZFRpbWVzID09PSAwICkgdGhpcy5fcmVsZWFzZVByb2dyYW0oIHBpcGVsaW5lLnZlcnRleFByb2dyYW0gKTtcblx0XHRcdFx0aWYgKCBwaXBlbGluZS5mcmFnbWVudFByb2dyYW0udXNlZFRpbWVzID09PSAwICkgdGhpcy5fcmVsZWFzZVByb2dyYW0oIHBpcGVsaW5lLmZyYWdtZW50UHJvZ3JhbSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc3VwZXIuZGVsZXRlKCBvYmplY3QgKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHN1cGVyLmRpc3Bvc2UoKTtcblxuXHRcdHRoaXMuY2FjaGVzID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMucHJvZ3JhbXMgPSB7XG5cdFx0XHR2ZXJ0ZXg6IG5ldyBNYXAoKSxcblx0XHRcdGZyYWdtZW50OiBuZXcgTWFwKCksXG5cdFx0XHRjb21wdXRlOiBuZXcgTWFwKClcblx0XHR9O1xuXG5cdH1cblxuXHR1cGRhdGVGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApIHtcblxuXHRcdHRoaXMuZ2V0Rm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKTtcblxuXHR9XG5cblx0X2dldENvbXB1dGVQaXBlbGluZSggY29tcHV0ZU5vZGUsIHN0YWdlQ29tcHV0ZSwgY2FjaGVLZXksIGJpbmRpbmdzICkge1xuXG5cdFx0Ly8gY2hlY2sgZm9yIGV4aXN0aW5nIHBpcGVsaW5lXG5cblx0XHRjYWNoZUtleSA9IGNhY2hlS2V5IHx8IHRoaXMuX2dldENvbXB1dGVDYWNoZUtleSggY29tcHV0ZU5vZGUsIHN0YWdlQ29tcHV0ZSApO1xuXG5cdFx0bGV0IHBpcGVsaW5lID0gdGhpcy5jYWNoZXMuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0aWYgKCBwaXBlbGluZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwaXBlbGluZSA9IG5ldyBDb21wdXRlUGlwZWxpbmUoIGNhY2hlS2V5LCBzdGFnZUNvbXB1dGUgKTtcblxuXHRcdFx0dGhpcy5jYWNoZXMuc2V0KCBjYWNoZUtleSwgcGlwZWxpbmUgKTtcblxuXHRcdFx0dGhpcy5iYWNrZW5kLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSggcGlwZWxpbmUsIGJpbmRpbmdzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcGlwZWxpbmU7XG5cblx0fVxuXG5cdF9nZXRSZW5kZXJQaXBlbGluZSggcmVuZGVyT2JqZWN0LCBzdGFnZVZlcnRleCwgc3RhZ2VGcmFnbWVudCwgY2FjaGVLZXksIHByb21pc2VzICkge1xuXG5cdFx0Ly8gY2hlY2sgZm9yIGV4aXN0aW5nIHBpcGVsaW5lXG5cblx0XHRjYWNoZUtleSA9IGNhY2hlS2V5IHx8IHRoaXMuX2dldFJlbmRlckNhY2hlS2V5KCByZW5kZXJPYmplY3QsIHN0YWdlVmVydGV4LCBzdGFnZUZyYWdtZW50ICk7XG5cblx0XHRsZXQgcGlwZWxpbmUgPSB0aGlzLmNhY2hlcy5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRpZiAoIHBpcGVsaW5lID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBpcGVsaW5lID0gbmV3IFJlbmRlclBpcGVsaW5lKCBjYWNoZUtleSwgc3RhZ2VWZXJ0ZXgsIHN0YWdlRnJhZ21lbnQgKTtcblxuXHRcdFx0dGhpcy5jYWNoZXMuc2V0KCBjYWNoZUtleSwgcGlwZWxpbmUgKTtcblxuXHRcdFx0cmVuZGVyT2JqZWN0LnBpcGVsaW5lID0gcGlwZWxpbmU7XG5cblx0XHRcdHRoaXMuYmFja2VuZC5jcmVhdGVSZW5kZXJQaXBlbGluZSggcmVuZGVyT2JqZWN0LCBwcm9taXNlcyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBpcGVsaW5lO1xuXG5cdH1cblxuXHRfZ2V0Q29tcHV0ZUNhY2hlS2V5KCBjb21wdXRlTm9kZSwgc3RhZ2VDb21wdXRlICkge1xuXG5cdFx0cmV0dXJuIGNvbXB1dGVOb2RlLmlkICsgJywnICsgc3RhZ2VDb21wdXRlLmlkO1xuXG5cdH1cblxuXHRfZ2V0UmVuZGVyQ2FjaGVLZXkoIHJlbmRlck9iamVjdCwgc3RhZ2VWZXJ0ZXgsIHN0YWdlRnJhZ21lbnQgKSB7XG5cblx0XHRyZXR1cm4gc3RhZ2VWZXJ0ZXguaWQgKyAnLCcgKyBzdGFnZUZyYWdtZW50LmlkICsgJywnICsgdGhpcy5iYWNrZW5kLmdldFJlbmRlckNhY2hlS2V5KCByZW5kZXJPYmplY3QgKTtcblxuXHR9XG5cblx0X3JlbGVhc2VQaXBlbGluZSggcGlwZWxpbmUgKSB7XG5cblx0XHR0aGlzLmNhY2hlcy5kZWxldGUoIHBpcGVsaW5lLmNhY2hlS2V5ICk7XG5cblx0fVxuXG5cdF9yZWxlYXNlUHJvZ3JhbSggcHJvZ3JhbSApIHtcblxuXHRcdGNvbnN0IGNvZGUgPSBwcm9ncmFtLmNvZGU7XG5cdFx0Y29uc3Qgc3RhZ2UgPSBwcm9ncmFtLnN0YWdlO1xuXG5cdFx0dGhpcy5wcm9ncmFtc1sgc3RhZ2UgXS5kZWxldGUoIGNvZGUgKTtcblxuXHR9XG5cblx0X25lZWRzQ29tcHV0ZVVwZGF0ZSggY29tcHV0ZU5vZGUgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gdGhpcy5nZXQoIGNvbXB1dGVOb2RlICk7XG5cblx0XHRyZXR1cm4gZGF0YS5waXBlbGluZSA9PT0gdW5kZWZpbmVkIHx8IGRhdGEudmVyc2lvbiAhPT0gY29tcHV0ZU5vZGUudmVyc2lvbjtcblxuXHR9XG5cblx0X25lZWRzUmVuZGVyVXBkYXRlKCByZW5kZXJPYmplY3QgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gdGhpcy5nZXQoIHJlbmRlck9iamVjdCApO1xuXG5cdFx0cmV0dXJuIGRhdGEucGlwZWxpbmUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmJhY2tlbmQubmVlZHNSZW5kZXJVcGRhdGUoIHJlbmRlck9iamVjdCApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQaXBlbGluZXM7XG4iLCJpbXBvcnQgRGF0YU1hcCBmcm9tICcuL0RhdGFNYXAuanMnO1xuaW1wb3J0IHsgQXR0cmlidXRlVHlwZSB9IGZyb20gJy4vQ29uc3RhbnRzLmpzJztcblxuY2xhc3MgQmluZGluZ3MgZXh0ZW5kcyBEYXRhTWFwIHtcblxuXHRjb25zdHJ1Y3RvciggYmFja2VuZCwgbm9kZXMsIHRleHR1cmVzLCBhdHRyaWJ1dGVzLCBwaXBlbGluZXMsIGluZm8gKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcblx0XHR0aGlzLnRleHR1cmVzID0gdGV4dHVyZXM7XG5cdFx0dGhpcy5waXBlbGluZXMgPSBwaXBlbGluZXM7XG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblx0XHR0aGlzLm5vZGVzID0gbm9kZXM7XG5cdFx0dGhpcy5pbmZvID0gaW5mbztcblxuXHRcdHRoaXMucGlwZWxpbmVzLmJpbmRpbmdzID0gdGhpczsgLy8gYXNzaWduIGJpbmRpbmdzIHRvIHBpcGVsaW5lc1xuXG5cdH1cblxuXHRnZXRGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzID0gcmVuZGVyT2JqZWN0LmdldEJpbmRpbmdzKCk7XG5cblx0XHRmb3IgKCBjb25zdCBiaW5kR3JvdXAgb2YgYmluZGluZ3MgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwRGF0YSA9IHRoaXMuZ2V0KCBiaW5kR3JvdXAgKTtcblxuXHRcdFx0aWYgKCBncm91cERhdGEuYmluZEdyb3VwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gZWFjaCBvYmplY3QgZGVmaW5lcyBhbiBhcnJheSBvZiBiaW5kaW5ncyAodWJvcywgdGV4dHVyZXMsIHNhbXBsZXJzIGV0Yy4pXG5cblx0XHRcdFx0dGhpcy5faW5pdCggYmluZEdyb3VwICk7XG5cblx0XHRcdFx0dGhpcy5iYWNrZW5kLmNyZWF0ZUJpbmRpbmdzKCBiaW5kR3JvdXAsIGJpbmRpbmdzLCAwICk7XG5cblx0XHRcdFx0Z3JvdXBEYXRhLmJpbmRHcm91cCA9IGJpbmRHcm91cDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJpbmRpbmdzO1xuXG5cdH1cblxuXHRnZXRGb3JDb21wdXRlKCBjb21wdXRlTm9kZSApIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5ub2Rlcy5nZXRGb3JDb21wdXRlKCBjb21wdXRlTm9kZSApLmJpbmRpbmdzO1xuXG5cdFx0Zm9yICggY29uc3QgYmluZEdyb3VwIG9mIGJpbmRpbmdzICkge1xuXG5cdFx0XHRjb25zdCBncm91cERhdGEgPSB0aGlzLmdldCggYmluZEdyb3VwICk7XG5cblx0XHRcdGlmICggZ3JvdXBEYXRhLmJpbmRHcm91cCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuX2luaXQoIGJpbmRHcm91cCApO1xuXG5cdFx0XHRcdHRoaXMuYmFja2VuZC5jcmVhdGVCaW5kaW5ncyggYmluZEdyb3VwLCBiaW5kaW5ncywgMCApO1xuXG5cdFx0XHRcdGdyb3VwRGF0YS5iaW5kR3JvdXAgPSBiaW5kR3JvdXA7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBiaW5kaW5ncztcblxuXHR9XG5cblx0dXBkYXRlRm9yQ29tcHV0ZSggY29tcHV0ZU5vZGUgKSB7XG5cblx0XHR0aGlzLl91cGRhdGVCaW5kaW5ncyggdGhpcy5nZXRGb3JDb21wdXRlKCBjb21wdXRlTm9kZSApICk7XG5cblx0fVxuXG5cdHVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICkge1xuXG5cdFx0dGhpcy5fdXBkYXRlQmluZGluZ3MoIHRoaXMuZ2V0Rm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKSApO1xuXG5cdH1cblxuXHRfdXBkYXRlQmluZGluZ3MoIGJpbmRpbmdzICkge1xuXG5cdFx0Zm9yICggY29uc3QgYmluZEdyb3VwIG9mIGJpbmRpbmdzICkge1xuXG5cdFx0XHR0aGlzLl91cGRhdGUoIGJpbmRHcm91cCwgYmluZGluZ3MgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0X2luaXQoIGJpbmRHcm91cCApIHtcblxuXHRcdGZvciAoIGNvbnN0IGJpbmRpbmcgb2YgYmluZEdyb3VwLmJpbmRpbmdzICkge1xuXG5cdFx0XHRpZiAoIGJpbmRpbmcuaXNTYW1wbGVkVGV4dHVyZSApIHtcblxuXHRcdFx0XHR0aGlzLnRleHR1cmVzLnVwZGF0ZVRleHR1cmUoIGJpbmRpbmcudGV4dHVyZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBiaW5kaW5nLmlzU3RvcmFnZUJ1ZmZlciApIHtcblxuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBiaW5kaW5nLmF0dHJpYnV0ZTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlVHlwZSA9IGF0dHJpYnV0ZS5pc0luZGlyZWN0U3RvcmFnZUJ1ZmZlckF0dHJpYnV0ZSA/IEF0dHJpYnV0ZVR5cGUuSU5ESVJFQ1QgOiBBdHRyaWJ1dGVUeXBlLlNUT1JBR0U7XG5cblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLnVwZGF0ZSggYXR0cmlidXRlLCBhdHRyaWJ1dGVUeXBlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0X3VwZGF0ZSggYmluZEdyb3VwLCBiaW5kaW5ncyApIHtcblxuXHRcdGNvbnN0IHsgYmFja2VuZCB9ID0gdGhpcztcblxuXHRcdGxldCBuZWVkc0JpbmRpbmdzVXBkYXRlID0gZmFsc2U7XG5cdFx0bGV0IGNhY2hlQmluZGluZ3MgPSB0cnVlO1xuXHRcdGxldCBjYWNoZUluZGV4ID0gMDtcblx0XHRsZXQgdmVyc2lvbiA9IDA7XG5cblx0XHQvLyBpdGVyYXRlIG92ZXIgYWxsIGJpbmRpbmdzIGFuZCBjaGVjayBpZiBidWZmZXIgdXBkYXRlcyBvciBhIG5ldyBiaW5kaW5nIGdyb3VwIGlzIHJlcXVpcmVkXG5cblx0XHRmb3IgKCBjb25zdCBiaW5kaW5nIG9mIGJpbmRHcm91cC5iaW5kaW5ncyApIHtcblxuXHRcdFx0aWYgKCBiaW5kaW5nLmlzTm9kZVVuaWZvcm1zR3JvdXAgKSB7XG5cblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9IHRoaXMubm9kZXMudXBkYXRlR3JvdXAoIGJpbmRpbmcgKTtcblxuXHRcdFx0XHRpZiAoICEgdXBkYXRlZCApIGNvbnRpbnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYmluZGluZy5pc1VuaWZvcm1CdWZmZXIgKSB7XG5cblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9IGJpbmRpbmcudXBkYXRlKCk7XG5cblx0XHRcdFx0aWYgKCB1cGRhdGVkICkge1xuXG5cdFx0XHRcdFx0YmFja2VuZC51cGRhdGVCaW5kaW5nKCBiaW5kaW5nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBiaW5kaW5nLmlzU2FtcGxlciApIHtcblxuXHRcdFx0XHRiaW5kaW5nLnVwZGF0ZSgpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBiaW5kaW5nLmlzU2FtcGxlZFRleHR1cmUgKSB7XG5cblx0XHRcdFx0Y29uc3QgdGV4dHVyZXNUZXh0dXJlRGF0YSA9IHRoaXMudGV4dHVyZXMuZ2V0KCBiaW5kaW5nLnRleHR1cmUgKTtcblxuXHRcdFx0XHRpZiAoIGJpbmRpbmcubmVlZHNCaW5kaW5nc1VwZGF0ZSggdGV4dHVyZXNUZXh0dXJlRGF0YS5nZW5lcmF0aW9uICkgKSBuZWVkc0JpbmRpbmdzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gYmluZGluZy51cGRhdGUoKTtcblxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gYmluZGluZy50ZXh0dXJlO1xuXG5cdFx0XHRcdGlmICggdXBkYXRlZCApIHtcblxuXHRcdFx0XHRcdHRoaXMudGV4dHVyZXMudXBkYXRlVGV4dHVyZSggdGV4dHVyZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IGJhY2tlbmQuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlRGF0YS5leHRlcm5hbFRleHR1cmUgIT09IHVuZGVmaW5lZCB8fCB0ZXh0dXJlc1RleHR1cmVEYXRhLmlzRGVmYXVsdFRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRjYWNoZUJpbmRpbmdzID0gZmFsc2U7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNhY2hlSW5kZXggPSBjYWNoZUluZGV4ICogMTAgKyB0ZXh0dXJlLmlkO1xuXHRcdFx0XHRcdHZlcnNpb24gKz0gdGV4dHVyZS52ZXJzaW9uO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGJhY2tlbmQuaXNXZWJHUFVCYWNrZW5kID09PSB0cnVlICYmIHRleHR1cmVEYXRhLnRleHR1cmUgPT09IHVuZGVmaW5lZCAmJiB0ZXh0dXJlRGF0YS5leHRlcm5hbFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIFRPRE86IFJlbW92ZSB0aGlzIG9uY2Ugd2UgZm91bmQgd2h5IHVwZGF0ZWQgPT09IGZhbHNlIGlzbid0IGJvdW5kIHRvIGEgdGV4dHVyZSBpbiB0aGUgV2ViR1BVIGJhY2tlbmRcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnQmluZGluZ3MuX3VwZGF0ZTogYmluZGluZyBzaG91bGQgYmUgYXZhaWxhYmxlOicsIGJpbmRpbmcsIHVwZGF0ZWQsIHRleHR1cmUsIGJpbmRpbmcudGV4dHVyZU5vZGUudmFsdWUsIG5lZWRzQmluZGluZ3NVcGRhdGUgKTtcblxuXHRcdFx0XHRcdHRoaXMudGV4dHVyZXMudXBkYXRlVGV4dHVyZSggdGV4dHVyZSApO1xuXHRcdFx0XHRcdG5lZWRzQmluZGluZ3NVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRleHR1cmUuaXNTdG9yYWdlVGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmVEYXRhID0gdGhpcy5nZXQoIHRleHR1cmUgKTtcblxuXHRcdFx0XHRcdGlmICggYmluZGluZy5zdG9yZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZURhdGEubmVlZHNNaXBtYXAgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy50ZXh0dXJlcy5uZWVkc01pcG1hcHMoIHRleHR1cmUgKSAmJiB0ZXh0dXJlRGF0YS5uZWVkc01pcG1hcCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5iYWNrZW5kLmdlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSApO1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlRGF0YS5uZWVkc01pcG1hcCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBuZWVkc0JpbmRpbmdzVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLmJhY2tlbmQudXBkYXRlQmluZGluZ3MoIGJpbmRHcm91cCwgYmluZGluZ3MsIGNhY2hlQmluZGluZ3MgPyBjYWNoZUluZGV4IDogMCwgdmVyc2lvbiApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCaW5kaW5ncztcbiIsImltcG9ydCB7IERvdWJsZVNpZGUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuXG5mdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcblxuXHRpZiAoIGEuZ3JvdXBPcmRlciAhPT0gYi5ncm91cE9yZGVyICkge1xuXG5cdFx0cmV0dXJuIGEuZ3JvdXBPcmRlciAtIGIuZ3JvdXBPcmRlcjtcblxuXHR9IGVsc2UgaWYgKCBhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyICkge1xuXG5cdFx0cmV0dXJuIGEucmVuZGVyT3JkZXIgLSBiLnJlbmRlck9yZGVyO1xuXG5cdH0gZWxzZSBpZiAoIGEubWF0ZXJpYWwuaWQgIT09IGIubWF0ZXJpYWwuaWQgKSB7XG5cblx0XHRyZXR1cm4gYS5tYXRlcmlhbC5pZCAtIGIubWF0ZXJpYWwuaWQ7XG5cblx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XG5cblx0XHRyZXR1cm4gYS56IC0gYi56O1xuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcblxuXHRpZiAoIGEuZ3JvdXBPcmRlciAhPT0gYi5ncm91cE9yZGVyICkge1xuXG5cdFx0cmV0dXJuIGEuZ3JvdXBPcmRlciAtIGIuZ3JvdXBPcmRlcjtcblxuXHR9IGVsc2UgaWYgKCBhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyICkge1xuXG5cdFx0cmV0dXJuIGEucmVuZGVyT3JkZXIgLSBiLnJlbmRlck9yZGVyO1xuXG5cdH0gZWxzZSBpZiAoIGEueiAhPT0gYi56ICkge1xuXG5cdFx0cmV0dXJuIGIueiAtIGEuejtcblxuXHR9IGVsc2Uge1xuXG5cdFx0cmV0dXJuIGEuaWQgLSBiLmlkO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBuZWVkc0RvdWJsZVBhc3MoIG1hdGVyaWFsICkge1xuXG5cdGNvbnN0IGhhc1RyYW5zbWlzc2lvbiA9IG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDAgfHwgbWF0ZXJpYWwudHJhbnNtaXNzaW9uTm9kZTtcblxuXHRyZXR1cm4gaGFzVHJhbnNtaXNzaW9uICYmIG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUgJiYgbWF0ZXJpYWwuZm9yY2VTaW5nbGVQYXNzID09PSBmYWxzZTtcblxufVxuXG5jbGFzcyBSZW5kZXJMaXN0IHtcblxuXHRjb25zdHJ1Y3RvciggbGlnaHRpbmcsIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHR0aGlzLnJlbmRlckl0ZW1zID0gW107XG5cdFx0dGhpcy5yZW5kZXJJdGVtc0luZGV4ID0gMDtcblxuXHRcdHRoaXMub3BhcXVlID0gW107XG5cdFx0dGhpcy50cmFuc3BhcmVudERvdWJsZVBhc3MgPSBbXTtcblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gW107XG5cdFx0dGhpcy5idW5kbGVzID0gW107XG5cblx0XHR0aGlzLmxpZ2h0c05vZGUgPSBsaWdodGluZy5nZXROb2RlKCBzY2VuZSwgY2FtZXJhICk7XG5cdFx0dGhpcy5saWdodHNBcnJheSA9IFtdO1xuXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xuXHRcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG5cdFx0dGhpcy5vY2NsdXNpb25RdWVyeUNvdW50ID0gMDtcblxuXHR9XG5cblx0YmVnaW4oKSB7XG5cblx0XHR0aGlzLnJlbmRlckl0ZW1zSW5kZXggPSAwO1xuXG5cdFx0dGhpcy5vcGFxdWUubGVuZ3RoID0gMDtcblx0XHR0aGlzLnRyYW5zcGFyZW50RG91YmxlUGFzcy5sZW5ndGggPSAwO1xuXHRcdHRoaXMudHJhbnNwYXJlbnQubGVuZ3RoID0gMDtcblx0XHR0aGlzLmJ1bmRsZXMubGVuZ3RoID0gMDtcblxuXHRcdHRoaXMubGlnaHRzQXJyYXkubGVuZ3RoID0gMDtcblxuXHRcdHRoaXMub2NjbHVzaW9uUXVlcnlDb3VudCA9IDA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0TmV4dFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCwgY2xpcHBpbmdDb250ZXh0ICkge1xuXG5cdFx0bGV0IHJlbmRlckl0ZW0gPSB0aGlzLnJlbmRlckl0ZW1zWyB0aGlzLnJlbmRlckl0ZW1zSW5kZXggXTtcblxuXHRcdGlmICggcmVuZGVySXRlbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZW5kZXJJdGVtID0ge1xuXHRcdFx0XHRpZDogb2JqZWN0LmlkLFxuXHRcdFx0XHRvYmplY3Q6IG9iamVjdCxcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxuXHRcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWwsXG5cdFx0XHRcdGdyb3VwT3JkZXI6IGdyb3VwT3JkZXIsXG5cdFx0XHRcdHJlbmRlck9yZGVyOiBvYmplY3QucmVuZGVyT3JkZXIsXG5cdFx0XHRcdHo6IHosXG5cdFx0XHRcdGdyb3VwOiBncm91cCxcblx0XHRcdFx0Y2xpcHBpbmdDb250ZXh0OiBjbGlwcGluZ0NvbnRleHRcblx0XHRcdH07XG5cblx0XHRcdHRoaXMucmVuZGVySXRlbXNbIHRoaXMucmVuZGVySXRlbXNJbmRleCBdID0gcmVuZGVySXRlbTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlbmRlckl0ZW0uaWQgPSBvYmplY3QuaWQ7XG5cdFx0XHRyZW5kZXJJdGVtLm9iamVjdCA9IG9iamVjdDtcblx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHRcdHJlbmRlckl0ZW0ubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXBPcmRlciA9IGdyb3VwT3JkZXI7XG5cdFx0XHRyZW5kZXJJdGVtLnJlbmRlck9yZGVyID0gb2JqZWN0LnJlbmRlck9yZGVyO1xuXHRcdFx0cmVuZGVySXRlbS56ID0gejtcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXAgPSBncm91cDtcblx0XHRcdHJlbmRlckl0ZW0uY2xpcHBpbmdDb250ZXh0ID0gY2xpcHBpbmdDb250ZXh0O1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5yZW5kZXJJdGVtc0luZGV4ICsrO1xuXG5cdFx0cmV0dXJuIHJlbmRlckl0ZW07XG5cblx0fVxuXG5cdHB1c2goIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCwgY2xpcHBpbmdDb250ZXh0ICkge1xuXG5cdFx0Y29uc3QgcmVuZGVySXRlbSA9IHRoaXMuZ2V0TmV4dFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCwgY2xpcHBpbmdDb250ZXh0ICk7XG5cblx0XHRpZiAoIG9iamVjdC5vY2NsdXNpb25UZXN0ID09PSB0cnVlICkgdGhpcy5vY2NsdXNpb25RdWVyeUNvdW50ICsrO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSB8fCBtYXRlcmlhbC50cmFuc21pc3Npb24gPiAwICkge1xuXG5cdFx0XHRpZiAoIG5lZWRzRG91YmxlUGFzcyggbWF0ZXJpYWwgKSApIHRoaXMudHJhbnNwYXJlbnREb3VibGVQYXNzLnB1c2goIHJlbmRlckl0ZW0gKTtcblxuXHRcdFx0dGhpcy50cmFuc3BhcmVudC5wdXNoKCByZW5kZXJJdGVtICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLm9wYXF1ZS5wdXNoKCByZW5kZXJJdGVtICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVuc2hpZnQoIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCwgY2xpcHBpbmdDb250ZXh0ICkge1xuXG5cdFx0Y29uc3QgcmVuZGVySXRlbSA9IHRoaXMuZ2V0TmV4dFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCwgY2xpcHBpbmdDb250ZXh0ICk7XG5cblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlIHx8IG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDAgKSB7XG5cblx0XHRcdGlmICggbmVlZHNEb3VibGVQYXNzKCBtYXRlcmlhbCApICkgdGhpcy50cmFuc3BhcmVudERvdWJsZVBhc3MudW5zaGlmdCggcmVuZGVySXRlbSApO1xuXG5cdFx0XHR0aGlzLnRyYW5zcGFyZW50LnVuc2hpZnQoIHJlbmRlckl0ZW0gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMub3BhcXVlLnVuc2hpZnQoIHJlbmRlckl0ZW0gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cHVzaEJ1bmRsZSggZ3JvdXAgKSB7XG5cblx0XHR0aGlzLmJ1bmRsZXMucHVzaCggZ3JvdXAgKTtcblxuXHR9XG5cblx0cHVzaExpZ2h0KCBsaWdodCApIHtcblxuXHRcdHRoaXMubGlnaHRzQXJyYXkucHVzaCggbGlnaHQgKTtcblxuXHR9XG5cblx0c29ydCggY3VzdG9tT3BhcXVlU29ydCwgY3VzdG9tVHJhbnNwYXJlbnRTb3J0ICkge1xuXG5cdFx0aWYgKCB0aGlzLm9wYXF1ZS5sZW5ndGggPiAxICkgdGhpcy5vcGFxdWUuc29ydCggY3VzdG9tT3BhcXVlU29ydCB8fCBwYWludGVyU29ydFN0YWJsZSApO1xuXHRcdGlmICggdGhpcy50cmFuc3BhcmVudERvdWJsZVBhc3MubGVuZ3RoID4gMSApIHRoaXMudHJhbnNwYXJlbnREb3VibGVQYXNzLnNvcnQoIGN1c3RvbVRyYW5zcGFyZW50U29ydCB8fCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKTtcblx0XHRpZiAoIHRoaXMudHJhbnNwYXJlbnQubGVuZ3RoID4gMSApIHRoaXMudHJhbnNwYXJlbnQuc29ydCggY3VzdG9tVHJhbnNwYXJlbnRTb3J0IHx8IHJldmVyc2VQYWludGVyU29ydFN0YWJsZSApO1xuXG5cdH1cblxuXHRmaW5pc2goKSB7XG5cblx0XHQvLyB1cGRhdGUgbGlnaHRzXG5cblx0XHR0aGlzLmxpZ2h0c05vZGUuc2V0TGlnaHRzKCB0aGlzLmxpZ2h0c0FycmF5ICk7XG5cblx0XHQvLyBDbGVhciByZWZlcmVuY2VzIGZyb20gaW5hY3RpdmUgcmVuZGVySXRlbXMgaW4gdGhlIGxpc3RcblxuXHRcdGZvciAoIGxldCBpID0gdGhpcy5yZW5kZXJJdGVtc0luZGV4LCBpbCA9IHRoaXMucmVuZGVySXRlbXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHJlbmRlckl0ZW0gPSB0aGlzLnJlbmRlckl0ZW1zWyBpIF07XG5cblx0XHRcdGlmICggcmVuZGVySXRlbS5pZCA9PT0gbnVsbCApIGJyZWFrO1xuXG5cdFx0XHRyZW5kZXJJdGVtLmlkID0gbnVsbDtcblx0XHRcdHJlbmRlckl0ZW0ub2JqZWN0ID0gbnVsbDtcblx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBudWxsO1xuXHRcdFx0cmVuZGVySXRlbS5tYXRlcmlhbCA9IG51bGw7XG5cdFx0XHRyZW5kZXJJdGVtLmdyb3VwT3JkZXIgPSBudWxsO1xuXHRcdFx0cmVuZGVySXRlbS5yZW5kZXJPcmRlciA9IG51bGw7XG5cdFx0XHRyZW5kZXJJdGVtLnogPSBudWxsO1xuXHRcdFx0cmVuZGVySXRlbS5ncm91cCA9IG51bGw7XG5cdFx0XHRyZW5kZXJJdGVtLmNsaXBwaW5nQ29udGV4dCA9IG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlckxpc3Q7XG4iLCJpbXBvcnQgQ2hhaW5NYXAgZnJvbSAnLi9DaGFpbk1hcC5qcyc7XG5pbXBvcnQgUmVuZGVyTGlzdCBmcm9tICcuL1JlbmRlckxpc3QuanMnO1xuXG5jbGFzcyBSZW5kZXJMaXN0cyB7XG5cblx0Y29uc3RydWN0b3IoIGxpZ2h0aW5nICkge1xuXG5cdFx0dGhpcy5saWdodGluZyA9IGxpZ2h0aW5nO1xuXG5cdFx0dGhpcy5saXN0cyA9IG5ldyBDaGFpbk1hcCgpO1xuXG5cdH1cblxuXHRnZXQoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRjb25zdCBsaXN0cyA9IHRoaXMubGlzdHM7XG5cdFx0Y29uc3Qga2V5cyA9IFsgc2NlbmUsIGNhbWVyYSBdO1xuXG5cdFx0bGV0IGxpc3QgPSBsaXN0cy5nZXQoIGtleXMgKTtcblxuXHRcdGlmICggbGlzdCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRsaXN0ID0gbmV3IFJlbmRlckxpc3QoIHRoaXMubGlnaHRpbmcsIHNjZW5lLCBjYW1lcmEgKTtcblx0XHRcdGxpc3RzLnNldCgga2V5cywgbGlzdCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxpc3Q7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmxpc3RzID0gbmV3IENoYWluTWFwKCk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlckxpc3RzO1xuIiwiaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yNC5qcyc7XG5pbXBvcnQgeyBoYXNoQXJyYXkgfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL05vZGVVdGlscy5qcyc7XG5cbmxldCBpZCA9IDA7XG5cbmNsYXNzIFJlbmRlckNvbnRleHQge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5pZCA9IGlkICsrO1xuXG5cdFx0dGhpcy5jb2xvciA9IHRydWU7XG5cdFx0dGhpcy5jbGVhckNvbG9yID0gdHJ1ZTtcblx0XHR0aGlzLmNsZWFyQ29sb3JWYWx1ZSA9IHsgcjogMCwgZzogMCwgYjogMCwgYTogMSB9O1xuXG5cdFx0dGhpcy5kZXB0aCA9IHRydWU7XG5cdFx0dGhpcy5jbGVhckRlcHRoID0gdHJ1ZTtcblx0XHR0aGlzLmNsZWFyRGVwdGhWYWx1ZSA9IDE7XG5cblx0XHR0aGlzLnN0ZW5jaWwgPSBmYWxzZTtcblx0XHR0aGlzLmNsZWFyU3RlbmNpbCA9IHRydWU7XG5cdFx0dGhpcy5jbGVhclN0ZW5jaWxWYWx1ZSA9IDE7XG5cblx0XHR0aGlzLnZpZXdwb3J0ID0gZmFsc2U7XG5cdFx0dGhpcy52aWV3cG9ydFZhbHVlID0gbmV3IFZlY3RvcjQoKTtcblxuXHRcdHRoaXMuc2Npc3NvciA9IGZhbHNlO1xuXHRcdHRoaXMuc2Npc3NvclZhbHVlID0gbmV3IFZlY3RvcjQoKTtcblxuXHRcdHRoaXMudGV4dHVyZXMgPSBudWxsO1xuXHRcdHRoaXMuZGVwdGhUZXh0dXJlID0gbnVsbDtcblx0XHR0aGlzLmFjdGl2ZUN1YmVGYWNlID0gMDtcblx0XHR0aGlzLnNhbXBsZUNvdW50ID0gMTtcblxuXHRcdHRoaXMud2lkdGggPSAwO1xuXHRcdHRoaXMuaGVpZ2h0ID0gMDtcblxuXHRcdHRoaXMuaXNSZW5kZXJDb250ZXh0ID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0Q2FjaGVLZXkoKSB7XG5cblx0XHRyZXR1cm4gZ2V0Q2FjaGVLZXkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENhY2hlS2V5KCByZW5kZXJDb250ZXh0ICkge1xuXG5cdGNvbnN0IHsgdGV4dHVyZXMsIGFjdGl2ZUN1YmVGYWNlIH0gPSByZW5kZXJDb250ZXh0O1xuXG5cdGNvbnN0IHZhbHVlcyA9IFsgYWN0aXZlQ3ViZUZhY2UgXTtcblxuXHRmb3IgKCBjb25zdCB0ZXh0dXJlIG9mIHRleHR1cmVzICkge1xuXG5cdFx0dmFsdWVzLnB1c2goIHRleHR1cmUuaWQgKTtcblxuXHR9XG5cblx0cmV0dXJuIGhhc2hBcnJheSggdmFsdWVzICk7XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyQ29udGV4dDtcbiIsImltcG9ydCBDaGFpbk1hcCBmcm9tICcuL0NoYWluTWFwLmpzJztcbmltcG9ydCBSZW5kZXJDb250ZXh0IGZyb20gJy4vUmVuZGVyQ29udGV4dC5qcyc7XG5cbmNsYXNzIFJlbmRlckNvbnRleHRzIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMuY2hhaW5NYXBzID0ge307XG5cblx0fVxuXG5cdGdldCggc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0ID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IGNoYWluS2V5ID0gWyBzY2VuZSwgY2FtZXJhIF07XG5cblx0XHRsZXQgYXR0YWNobWVudFN0YXRlO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgPT09IG51bGwgKSB7XG5cblx0XHRcdGF0dGFjaG1lbnRTdGF0ZSA9ICdkZWZhdWx0JztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGZvcm1hdCA9IHJlbmRlclRhcmdldC50ZXh0dXJlLmZvcm1hdDtcblx0XHRcdGNvbnN0IGNvdW50ID0gcmVuZGVyVGFyZ2V0LnRleHR1cmVzLmxlbmd0aDtcblxuXHRcdFx0YXR0YWNobWVudFN0YXRlID0gYCR7IGNvdW50IH06JHsgZm9ybWF0IH06JHsgcmVuZGVyVGFyZ2V0LnNhbXBsZXMgfTokeyByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgfTokeyByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciB9YDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGNoYWluTWFwID0gdGhpcy5nZXRDaGFpbk1hcCggYXR0YWNobWVudFN0YXRlICk7XG5cblx0XHRsZXQgcmVuZGVyU3RhdGUgPSBjaGFpbk1hcC5nZXQoIGNoYWluS2V5ICk7XG5cblx0XHRpZiAoIHJlbmRlclN0YXRlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJlbmRlclN0YXRlID0gbmV3IFJlbmRlckNvbnRleHQoKTtcblxuXHRcdFx0Y2hhaW5NYXAuc2V0KCBjaGFpbktleSwgcmVuZGVyU3RhdGUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ICE9PSBudWxsICkgcmVuZGVyU3RhdGUuc2FtcGxlQ291bnQgPSByZW5kZXJUYXJnZXQuc2FtcGxlcyA9PT0gMCA/IDEgOiByZW5kZXJUYXJnZXQuc2FtcGxlcztcblxuXHRcdHJldHVybiByZW5kZXJTdGF0ZTtcblxuXHR9XG5cblx0Z2V0Q2hhaW5NYXAoIGF0dGFjaG1lbnRTdGF0ZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmNoYWluTWFwc1sgYXR0YWNobWVudFN0YXRlIF0gfHwgKCB0aGlzLmNoYWluTWFwc1sgYXR0YWNobWVudFN0YXRlIF0gPSBuZXcgQ2hhaW5NYXAoKSApO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5jaGFpbk1hcHMgPSB7fTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyQ29udGV4dHM7XG4iLCJpbXBvcnQgRGF0YU1hcCBmcm9tICcuL0RhdGFNYXAuanMnO1xuXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IERlcHRoVGV4dHVyZSB9IGZyb20gJy4uLy4uL3RleHR1cmVzL0RlcHRoVGV4dHVyZS5qcyc7XG5pbXBvcnQgeyBEZXB0aFN0ZW5jaWxGb3JtYXQsIERlcHRoRm9ybWF0LCBVbnNpZ25lZEludFR5cGUsIFVuc2lnbmVkSW50MjQ4VHlwZSwgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nLCBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsIEN1YmVSZWZyYWN0aW9uTWFwcGluZywgVW5zaWduZWRCeXRlVHlwZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IF9zaXplID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBUZXh0dXJlcyBleHRlbmRzIERhdGFNYXAge1xuXG5cdGNvbnN0cnVjdG9yKCByZW5kZXJlciwgYmFja2VuZCwgaW5mbyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcblx0XHR0aGlzLmluZm8gPSBpbmZvO1xuXG5cdH1cblxuXHR1cGRhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCwgYWN0aXZlTWlwbWFwTGV2ZWwgPSAwICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdGNvbnN0IHNhbXBsZUNvdW50ID0gcmVuZGVyVGFyZ2V0LnNhbXBsZXMgPT09IDAgPyAxIDogcmVuZGVyVGFyZ2V0LnNhbXBsZXM7XG5cdFx0Y29uc3QgZGVwdGhUZXh0dXJlTWlwcyA9IHJlbmRlclRhcmdldERhdGEuZGVwdGhUZXh0dXJlTWlwcyB8fCAoIHJlbmRlclRhcmdldERhdGEuZGVwdGhUZXh0dXJlTWlwcyA9IHt9ICk7XG5cblx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlcztcblxuXHRcdGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoIHRleHR1cmVzWyAwIF0gKTtcblxuXHRcdGNvbnN0IG1pcFdpZHRoID0gc2l6ZS53aWR0aCA+PiBhY3RpdmVNaXBtYXBMZXZlbDtcblx0XHRjb25zdCBtaXBIZWlnaHQgPSBzaXplLmhlaWdodCA+PiBhY3RpdmVNaXBtYXBMZXZlbDtcblxuXHRcdGxldCBkZXB0aFRleHR1cmUgPSByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlIHx8IGRlcHRoVGV4dHVyZU1pcHNbIGFjdGl2ZU1pcG1hcExldmVsIF07XG5cdFx0Y29uc3QgdXNlRGVwdGhUZXh0dXJlID0gcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID09PSB0cnVlIHx8IHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID09PSB0cnVlO1xuXG5cdFx0bGV0IHRleHR1cmVOZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0aWYgKCBkZXB0aFRleHR1cmUgPT09IHVuZGVmaW5lZCAmJiB1c2VEZXB0aFRleHR1cmUgKSB7XG5cblx0XHRcdGRlcHRoVGV4dHVyZSA9IG5ldyBEZXB0aFRleHR1cmUoKTtcblx0XHRcdGRlcHRoVGV4dHVyZS5mb3JtYXQgPSByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA/IERlcHRoU3RlbmNpbEZvcm1hdCA6IERlcHRoRm9ybWF0O1xuXHRcdFx0ZGVwdGhUZXh0dXJlLnR5cGUgPSByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA/IFVuc2lnbmVkSW50MjQ4VHlwZSA6IFVuc2lnbmVkSW50VHlwZTsgLy8gRmxvYXRUeXBlXG5cdFx0XHRkZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggPSBtaXBXaWR0aDtcblx0XHRcdGRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgPSBtaXBIZWlnaHQ7XG5cblx0XHRcdGRlcHRoVGV4dHVyZU1pcHNbIGFjdGl2ZU1pcG1hcExldmVsIF0gPSBkZXB0aFRleHR1cmU7XG5cblx0XHR9XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldERhdGEud2lkdGggIT09IHNpemUud2lkdGggfHwgc2l6ZS5oZWlnaHQgIT09IHJlbmRlclRhcmdldERhdGEuaGVpZ2h0ICkge1xuXG5cdFx0XHR0ZXh0dXJlTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRpZiAoIGRlcHRoVGV4dHVyZSApIHtcblxuXHRcdFx0XHRkZXB0aFRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRkZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggPSBtaXBXaWR0aDtcblx0XHRcdFx0ZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCA9IG1pcEhlaWdodDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmVuZGVyVGFyZ2V0RGF0YS53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0cmVuZGVyVGFyZ2V0RGF0YS5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRyZW5kZXJUYXJnZXREYXRhLnRleHR1cmVzID0gdGV4dHVyZXM7XG5cdFx0cmVuZGVyVGFyZ2V0RGF0YS5kZXB0aFRleHR1cmUgPSBkZXB0aFRleHR1cmUgfHwgbnVsbDtcblx0XHRyZW5kZXJUYXJnZXREYXRhLmRlcHRoID0gcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyO1xuXHRcdHJlbmRlclRhcmdldERhdGEuc3RlbmNpbCA9IHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyO1xuXHRcdHJlbmRlclRhcmdldERhdGEucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXREYXRhLnNhbXBsZUNvdW50ICE9PSBzYW1wbGVDb3VudCApIHtcblxuXHRcdFx0dGV4dHVyZU5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBkZXB0aFRleHR1cmUgKSB7XG5cblx0XHRcdFx0ZGVwdGhUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZW5kZXJUYXJnZXREYXRhLnNhbXBsZUNvdW50ID0gc2FtcGxlQ291bnQ7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHsgc2FtcGxlQ291bnQgfTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IHRleHR1cmVzWyBpIF07XG5cblx0XHRcdGlmICggdGV4dHVyZU5lZWRzVXBkYXRlICkgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdHRoaXMudXBkYXRlVGV4dHVyZSggdGV4dHVyZSwgb3B0aW9ucyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkZXB0aFRleHR1cmUgKSB7XG5cblx0XHRcdHRoaXMudXBkYXRlVGV4dHVyZSggZGVwdGhUZXh0dXJlLCBvcHRpb25zICk7XG5cblx0XHR9XG5cblx0XHQvLyBkaXNwb3NlIGhhbmRsZXJcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0RGF0YS5pbml0aWFsaXplZCAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0RGF0YS5pbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHRcdC8vIGRpc3Bvc2VcblxuXHRcdFx0Y29uc3Qgb25EaXNwb3NlID0gKCkgPT4ge1xuXG5cdFx0XHRcdHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uRGlzcG9zZSApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHRoaXMuX2Rlc3Ryb3lUZXh0dXJlKCB0ZXh0dXJlc1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZGVwdGhUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0dGhpcy5fZGVzdHJveVRleHR1cmUoIGRlcHRoVGV4dHVyZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdH07XG5cblx0XHRcdHJlbmRlclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uRGlzcG9zZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGVUZXh0dXJlKCB0ZXh0dXJlLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IHRoaXMuZ2V0KCB0ZXh0dXJlICk7XG5cdFx0aWYgKCB0ZXh0dXJlRGF0YS5pbml0aWFsaXplZCA9PT0gdHJ1ZSAmJiB0ZXh0dXJlRGF0YS52ZXJzaW9uID09PSB0ZXh0dXJlLnZlcnNpb24gKSByZXR1cm47XG5cblx0XHRjb25zdCBpc1JlbmRlclRhcmdldCA9IHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlIHx8IHRleHR1cmUuaXNEZXB0aFRleHR1cmUgfHwgdGV4dHVyZS5pc0ZyYW1lYnVmZmVyVGV4dHVyZTtcblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXG5cdFx0aWYgKCBpc1JlbmRlclRhcmdldCAmJiB0ZXh0dXJlRGF0YS5pbml0aWFsaXplZCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Ly8gaXQncyBhbiB1cGRhdGVcblxuXHRcdFx0YmFja2VuZC5kZXN0cm95U2FtcGxlciggdGV4dHVyZSApO1xuXHRcdFx0YmFja2VuZC5kZXN0cm95VGV4dHVyZSggdGV4dHVyZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGlmICggdGV4dHVyZS5pc0ZyYW1lYnVmZmVyVGV4dHVyZSApIHtcblxuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS50eXBlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmUudHlwZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBkZXB0aCB9ID0gdGhpcy5nZXRTaXplKCB0ZXh0dXJlICk7XG5cblx0XHRvcHRpb25zLndpZHRoID0gd2lkdGg7XG5cdFx0b3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0b3B0aW9ucy5kZXB0aCA9IGRlcHRoO1xuXHRcdG9wdGlvbnMubmVlZHNNaXBtYXBzID0gdGhpcy5uZWVkc01pcG1hcHMoIHRleHR1cmUgKTtcblx0XHRvcHRpb25zLmxldmVscyA9IG9wdGlvbnMubmVlZHNNaXBtYXBzID8gdGhpcy5nZXRNaXBMZXZlbHMoIHRleHR1cmUsIHdpZHRoLCBoZWlnaHQgKSA6IDE7XG5cblx0XHQvL1xuXG5cdFx0aWYgKCBpc1JlbmRlclRhcmdldCB8fCB0ZXh0dXJlLmlzU3RvcmFnZVRleHR1cmUgPT09IHRydWUgKSB7XG5cblx0XHRcdGJhY2tlbmQuY3JlYXRlU2FtcGxlciggdGV4dHVyZSApO1xuXHRcdFx0YmFja2VuZC5jcmVhdGVUZXh0dXJlKCB0ZXh0dXJlLCBvcHRpb25zICk7XG5cblx0XHRcdHRleHR1cmVEYXRhLmdlbmVyYXRpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBuZWVkc0NyZWF0ZSA9IHRleHR1cmVEYXRhLmluaXRpYWxpemVkICE9PSB0cnVlO1xuXG5cdFx0XHRpZiAoIG5lZWRzQ3JlYXRlICkgYmFja2VuZC5jcmVhdGVTYW1wbGVyKCB0ZXh0dXJlICk7XG5cblx0XHRcdGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCApIHtcblxuXHRcdFx0XHRjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG5cblx0XHRcdFx0aWYgKCBpbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIHVuZGVmaW5lZC4nICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIGluY29tcGxldGUuJyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIHRleHR1cmUuaW1hZ2VzICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBpbWFnZXMgPSBbXTtcblxuXHRcdFx0XHRcdFx0Zm9yICggY29uc3QgaW1hZ2Ugb2YgdGV4dHVyZS5pbWFnZXMgKSB7XG5cblx0XHRcdFx0XHRcdFx0aW1hZ2VzLnB1c2goIGltYWdlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0b3B0aW9ucy5pbWFnZXMgPSBpbWFnZXM7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRvcHRpb25zLmltYWdlID0gaW1hZ2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHRleHR1cmVEYXRhLmlzRGVmYXVsdFRleHR1cmUgPT09IHVuZGVmaW5lZCB8fCB0ZXh0dXJlRGF0YS5pc0RlZmF1bHRUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRiYWNrZW5kLmNyZWF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKTtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZURhdGEuaXNEZWZhdWx0VGV4dHVyZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGV4dHVyZURhdGEuZ2VuZXJhdGlvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdGV4dHVyZS5zb3VyY2UuZGF0YVJlYWR5ID09PSB0cnVlICkgYmFja2VuZC51cGRhdGVUZXh0dXJlKCB0ZXh0dXJlLCBvcHRpb25zICk7XG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMubmVlZHNNaXBtYXBzICYmIHRleHR1cmUubWlwbWFwcy5sZW5ndGggPT09IDAgKSBiYWNrZW5kLmdlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBhc3luYyB1cGRhdGVcblxuXHRcdFx0XHRiYWNrZW5kLmNyZWF0ZURlZmF1bHRUZXh0dXJlKCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0dGV4dHVyZURhdGEuaXNEZWZhdWx0VGV4dHVyZSA9IHRydWU7XG5cdFx0XHRcdHRleHR1cmVEYXRhLmdlbmVyYXRpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGRpc3Bvc2UgaGFuZGxlclxuXG5cdFx0aWYgKCB0ZXh0dXJlRGF0YS5pbml0aWFsaXplZCAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0dGV4dHVyZURhdGEuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHRcdFx0dGV4dHVyZURhdGEuZ2VuZXJhdGlvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuXHRcdFx0Ly9cblxuXHRcdFx0dGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcblxuXHRcdFx0Ly8gZGlzcG9zZVxuXG5cdFx0XHRjb25zdCBvbkRpc3Bvc2UgPSAoKSA9PiB7XG5cblx0XHRcdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uRGlzcG9zZSApO1xuXG5cdFx0XHRcdHRoaXMuX2Rlc3Ryb3lUZXh0dXJlKCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0dGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyAtLTtcblxuXHRcdFx0fTtcblxuXHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uRGlzcG9zZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHRleHR1cmVEYXRhLnZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cblx0fVxuXG5cdGdldFNpemUoIHRleHR1cmUsIHRhcmdldCA9IF9zaXplICkge1xuXG5cdFx0bGV0IGltYWdlID0gdGV4dHVyZS5pbWFnZXMgPyB0ZXh0dXJlLmltYWdlc1sgMCBdIDogdGV4dHVyZS5pbWFnZTtcblxuXHRcdGlmICggaW1hZ2UgKSB7XG5cblx0XHRcdGlmICggaW1hZ2UuaW1hZ2UgIT09IHVuZGVmaW5lZCApIGltYWdlID0gaW1hZ2UuaW1hZ2U7XG5cblx0XHRcdHRhcmdldC53aWR0aCA9IGltYWdlLndpZHRoIHx8IDE7XG5cdFx0XHR0YXJnZXQuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0IHx8IDE7XG5cdFx0XHR0YXJnZXQuZGVwdGggPSB0ZXh0dXJlLmlzQ3ViZVRleHR1cmUgPyA2IDogKCBpbWFnZS5kZXB0aCB8fCAxICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0YXJnZXQud2lkdGggPSB0YXJnZXQuaGVpZ2h0ID0gdGFyZ2V0LmRlcHRoID0gMTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGdldE1pcExldmVscyggdGV4dHVyZSwgd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdGxldCBtaXBMZXZlbENvdW50O1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggdGV4dHVyZS5taXBtYXBzICkge1xuXG5cdFx0XHRcdG1pcExldmVsQ291bnQgPSB0ZXh0dXJlLm1pcG1hcHMubGVuZ3RoO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG1pcExldmVsQ291bnQgPSAxO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtaXBMZXZlbENvdW50ID0gTWF0aC5mbG9vciggTWF0aC5sb2cyKCBNYXRoLm1heCggd2lkdGgsIGhlaWdodCApICkgKSArIDE7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbWlwTGV2ZWxDb3VudDtcblxuXHR9XG5cblx0bmVlZHNNaXBtYXBzKCB0ZXh0dXJlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaXNFbnZpcm9ubWVudFRleHR1cmUoIHRleHR1cmUgKSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgPT09IHRydWUgfHwgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XG5cblx0fVxuXG5cdGlzRW52aXJvbm1lbnRUZXh0dXJlKCB0ZXh0dXJlICkge1xuXG5cdFx0Y29uc3QgbWFwcGluZyA9IHRleHR1cmUubWFwcGluZztcblxuXHRcdHJldHVybiAoIG1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nIHx8IG1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nICkgfHwgKCBtYXBwaW5nID09PSBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nICk7XG5cblx0fVxuXG5cdF9kZXN0cm95VGV4dHVyZSggdGV4dHVyZSApIHtcblxuXHRcdHRoaXMuYmFja2VuZC5kZXN0cm95U2FtcGxlciggdGV4dHVyZSApO1xuXHRcdHRoaXMuYmFja2VuZC5kZXN0cm95VGV4dHVyZSggdGV4dHVyZSApO1xuXG5cdFx0dGhpcy5kZWxldGUoIHRleHR1cmUgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dHVyZXM7XG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL21hdGgvQ29sb3IuanMnO1xuXG5jbGFzcyBDb2xvcjQgZXh0ZW5kcyBDb2xvciB7XG5cblx0Y29uc3RydWN0b3IoIHIsIGcsIGIsIGEgPSAxICkge1xuXG5cdFx0c3VwZXIoIHIsIGcsIGIgKTtcblxuXHRcdHRoaXMuYSA9IGE7XG5cblx0fVxuXG5cdHNldCggciwgZywgYiwgYSA9IDEgKSB7XG5cblx0XHR0aGlzLmEgPSBhO1xuXG5cdFx0cmV0dXJuIHN1cGVyLnNldCggciwgZywgYiApO1xuXG5cdH1cblxuXHRjb3B5KCBjb2xvciApIHtcblxuXHRcdGlmICggY29sb3IuYSAhPT0gdW5kZWZpbmVkICkgdGhpcy5hID0gY29sb3IuYTtcblxuXHRcdHJldHVybiBzdXBlci5jb3B5KCBjb2xvciApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbG9yNDtcbiIsImltcG9ydCB7IG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgUHJvcGVydHlOb2RlIGZyb20gJy4vUHJvcGVydHlOb2RlLmpzJztcblxuY2xhc3MgUGFyYW1ldGVyTm9kZSBleHRlbmRzIFByb3BlcnR5Tm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdQYXJhbWV0ZXJOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIG5vZGVUeXBlLCBuYW1lID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCBub2RlVHlwZSwgbmFtZSApO1xuXG5cdFx0dGhpcy5pc1BhcmFtZXRlck5vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRnZXRIYXNoKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudXVpZDtcblxuXHR9XG5cblx0Z2VuZXJhdGUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5uYW1lO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXJhbWV0ZXJOb2RlO1xuXG5leHBvcnQgY29uc3QgcGFyYW1ldGVyID0gKCB0eXBlLCBuYW1lICkgPT4gbm9kZU9iamVjdCggbmV3IFBhcmFtZXRlck5vZGUoIHR5cGUsIG5hbWUgKSApO1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJy4uL21hdGgvQ29uZGl0aW9uYWxOb2RlLmpzJztcbmltcG9ydCB7IFNoYWRlck5vZGUsIG5vZGVQcm94eSwgZ2V0Q3VycmVudFN0YWNrLCBzZXRDdXJyZW50U3RhY2sgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIFN0YWNrTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnU3RhY2tOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHBhcmVudCA9IG51bGwgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5ub2RlcyA9IFtdO1xuXHRcdHRoaXMub3V0cHV0Tm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuXHRcdHRoaXMuX2N1cnJlbnRDb25kID0gbnVsbDtcblxuXHRcdHRoaXMuaXNTdGFja05vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLm91dHB1dE5vZGUgPyB0aGlzLm91dHB1dE5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSA6ICd2b2lkJztcblxuXHR9XG5cblx0YWRkKCBub2RlICkge1xuXG5cdFx0dGhpcy5ub2Rlcy5wdXNoKCBub2RlICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0SWYoIGJvb2xOb2RlLCBtZXRob2QgKSB7XG5cblx0XHRjb25zdCBtZXRob2ROb2RlID0gbmV3IFNoYWRlck5vZGUoIG1ldGhvZCApO1xuXHRcdHRoaXMuX2N1cnJlbnRDb25kID0gc2VsZWN0KCBib29sTm9kZSwgbWV0aG9kTm9kZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuYWRkKCB0aGlzLl9jdXJyZW50Q29uZCApO1xuXG5cdH1cblxuXHRFbHNlSWYoIGJvb2xOb2RlLCBtZXRob2QgKSB7XG5cblx0XHRjb25zdCBtZXRob2ROb2RlID0gbmV3IFNoYWRlck5vZGUoIG1ldGhvZCApO1xuXHRcdGNvbnN0IGlmTm9kZSA9IHNlbGVjdCggYm9vbE5vZGUsIG1ldGhvZE5vZGUgKTtcblxuXHRcdHRoaXMuX2N1cnJlbnRDb25kLmVsc2VOb2RlID0gaWZOb2RlO1xuXHRcdHRoaXMuX2N1cnJlbnRDb25kID0gaWZOb2RlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdEVsc2UoIG1ldGhvZCApIHtcblxuXHRcdHRoaXMuX2N1cnJlbnRDb25kLmVsc2VOb2RlID0gbmV3IFNoYWRlck5vZGUoIG1ldGhvZCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGJ1aWxkKCBidWlsZGVyLCAuLi5wYXJhbXMgKSB7XG5cblx0XHRjb25zdCBwcmV2aW91c1N0YWNrID0gZ2V0Q3VycmVudFN0YWNrKCk7XG5cblx0XHRzZXRDdXJyZW50U3RhY2soIHRoaXMgKTtcblxuXHRcdGZvciAoIGNvbnN0IG5vZGUgb2YgdGhpcy5ub2RlcyApIHtcblxuXHRcdFx0bm9kZS5idWlsZCggYnVpbGRlciwgJ3ZvaWQnICk7XG5cblx0XHR9XG5cblx0XHRzZXRDdXJyZW50U3RhY2soIHByZXZpb3VzU3RhY2sgKTtcblxuXHRcdHJldHVybiB0aGlzLm91dHB1dE5vZGUgPyB0aGlzLm91dHB1dE5vZGUuYnVpbGQoIGJ1aWxkZXIsIC4uLnBhcmFtcyApIDogc3VwZXIuYnVpbGQoIGJ1aWxkZXIsIC4uLnBhcmFtcyApO1xuXG5cdH1cblxuXHQvL1xuXG5cdGVsc2UoIC4uLnBhcmFtcyApIHsgLy8gQGRlcHJlY2F0ZWQsIHIxNjhcblxuXHRcdGNvbnNvbGUud2FybiggJ1RTTC5TdGFja05vZGU6IC5lbHNlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuRWxzZSgpLicgKTtcblx0XHRyZXR1cm4gdGhpcy5FbHNlKCAuLi5wYXJhbXMgKTtcblxuXHR9XG5cblx0ZWxzZWlmKCAuLi5wYXJhbXMgKSB7IC8vIEBkZXByZWNhdGVkLCByMTY4XG5cblx0XHRjb25zb2xlLndhcm4oICdUU0wuU3RhY2tOb2RlOiAuZWxzZWlmKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuRWxzZUlmKCkuJyApO1xuXHRcdHJldHVybiB0aGlzLkVsc2VJZiggLi4ucGFyYW1zICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0YWNrTm9kZTtcblxuZXhwb3J0IGNvbnN0IHN0YWNrID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFN0YWNrTm9kZSApO1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi9Ob2RlLmpzJztcblxuY2xhc3MgU3RydWN0VHlwZU5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1N0cnVjdFR5cGVOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHR5cGVzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZXMgPSB0eXBlcztcblx0XHR0aGlzLmlzU3RydWN0VHlwZU5vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRnZXRNZW1iZXJUeXBlcygpIHtcblxuXHRcdHJldHVybiB0aGlzLnR5cGVzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTdHJ1Y3RUeXBlTm9kZTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgU3RydWN0VHlwZU5vZGUgZnJvbSAnLi9TdHJ1Y3RUeXBlTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIE91dHB1dFN0cnVjdE5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ091dHB1dFN0cnVjdE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggLi4ubWVtYmVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLm1lbWJlcnMgPSBtZW1iZXJzO1xuXG5cdFx0dGhpcy5pc091dHB1dFN0cnVjdE5vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdHN1cGVyLnNldHVwKCBidWlsZGVyICk7XG5cblx0XHRjb25zdCBtZW1iZXJzID0gdGhpcy5tZW1iZXJzO1xuXHRcdGNvbnN0IHR5cGVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBtZW1iZXJzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dHlwZXMucHVzaCggbWVtYmVyc1sgaSBdLmdldE5vZGVUeXBlKCBidWlsZGVyICkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMubm9kZVR5cGUgPSBidWlsZGVyLmdldFN0cnVjdFR5cGVGcm9tTm9kZSggbmV3IFN0cnVjdFR5cGVOb2RlKCB0eXBlcyApICkubmFtZTtcblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcblxuXHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0T3V0cHV0U3RydWN0TmFtZSgpO1xuXHRcdGNvbnN0IG1lbWJlcnMgPSB0aGlzLm1lbWJlcnM7XG5cblx0XHRjb25zdCBzdHJ1Y3RQcmVmaXggPSBwcm9wZXJ0eU5hbWUgIT09ICcnID8gcHJvcGVydHlOYW1lICsgJy4nIDogJyc7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBtZW1iZXJzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgc25pcHBldCA9IG1lbWJlcnNbIGkgXS5idWlsZCggYnVpbGRlciwgb3V0cHV0ICk7XG5cblx0XHRcdGJ1aWxkZXIuYWRkTGluZUZsb3dDb2RlKCBgJHsgc3RydWN0UHJlZml4IH1tJHsgaSB9ID0gJHsgc25pcHBldCB9YCwgdGhpcyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb3BlcnR5TmFtZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgT3V0cHV0U3RydWN0Tm9kZTtcblxuZXhwb3J0IGNvbnN0IG91dHB1dFN0cnVjdCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPdXRwdXRTdHJ1Y3ROb2RlICk7XG4iLCJpbXBvcnQgT3V0cHV0U3RydWN0Tm9kZSBmcm9tICcuL091dHB1dFN0cnVjdE5vZGUuanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5LCB2ZWM0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dHVyZUluZGV4KCB0ZXh0dXJlcywgbmFtZSApIHtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRpZiAoIHRleHR1cmVzWyBpIF0ubmFtZSA9PT0gbmFtZSApIHtcblxuXHRcdFx0cmV0dXJuIGk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiAtIDE7XG5cbn1cblxuY2xhc3MgTVJUTm9kZSBleHRlbmRzIE91dHB1dFN0cnVjdE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnTVJUTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBvdXRwdXROb2RlcyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLm91dHB1dE5vZGVzID0gb3V0cHV0Tm9kZXM7XG5cblx0XHR0aGlzLmlzTVJUTm9kZSA9IHRydWU7XG5cblx0fVxuXG5cdGhhcyggbmFtZSApIHtcblxuXHRcdHJldHVybiB0aGlzLm91dHB1dE5vZGVzWyBuYW1lIF0gIT09IHVuZGVmaW5lZDtcblxuXHR9XG5cblx0Z2V0KCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMub3V0cHV0Tm9kZXNbIG5hbWUgXTtcblxuXHR9XG5cblx0bWVyZ2UoIG1ydE5vZGUgKSB7XG5cblx0XHRjb25zdCBvdXRwdXRzID0geyAuLi50aGlzLm91dHB1dE5vZGVzLCAuLi5tcnROb2RlLm91dHB1dE5vZGVzIH07XG5cblx0XHRyZXR1cm4gbXJ0KCBvdXRwdXRzICk7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3Qgb3V0cHV0Tm9kZXMgPSB0aGlzLm91dHB1dE5vZGVzO1xuXHRcdGNvbnN0IG1ydCA9IGJ1aWxkZXIucmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cblx0XHRjb25zdCBtZW1iZXJzID0gW107XG5cblx0XHRjb25zdCB0ZXh0dXJlcyA9IG1ydC50ZXh0dXJlcztcblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gb3V0cHV0Tm9kZXMgKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gZ2V0VGV4dHVyZUluZGV4KCB0ZXh0dXJlcywgbmFtZSApO1xuXG5cdFx0XHRtZW1iZXJzWyBpbmRleCBdID0gdmVjNCggb3V0cHV0Tm9kZXNbIG5hbWUgXSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5tZW1iZXJzID0gbWVtYmVycztcblxuXHRcdHJldHVybiBzdXBlci5zZXR1cCggYnVpbGRlciApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBNUlROb2RlO1xuXG5leHBvcnQgY29uc3QgbXJ0ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1SVE5vZGUgKTtcbiIsImltcG9ydCB7IEZuIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5leHBvcnQgY29uc3QgaGFzaCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBzZWVkIF0gKSA9PiB7XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvWGxHY1JoLCBvcmlnaW5hbGx5IGZyb20gcGNnLXJhbmRvbS5vcmdcblxuXHRjb25zdCBzdGF0ZSA9IHNlZWQudG9VaW50KCkubXVsKCA3NDc3OTY0MDUgKS5hZGQoIDI4OTEzMzY0NTMgKTtcblx0Y29uc3Qgd29yZCA9IHN0YXRlLnNoaWZ0UmlnaHQoIHN0YXRlLnNoaWZ0UmlnaHQoIDI4ICkuYWRkKCA0ICkgKS5iaXRYb3IoIHN0YXRlICkubXVsKCAyNzc4MDM3MzcgKTtcblx0Y29uc3QgcmVzdWx0ID0gd29yZC5zaGlmdFJpZ2h0KCAyMiApLmJpdFhvciggd29yZCApO1xuXG5cdHJldHVybiByZXN1bHQudG9GbG9hdCgpLm11bCggMSAvIDIgKiogMzIgKTsgLy8gQ29udmVydCB0byByYW5nZSBbMCwgMSlcblxufSApO1xuIiwiaW1wb3J0IHsgc3ViLCBtdWwsIGRpdiwgYWRkIH0gZnJvbSAnLi9PcGVyYXRvck5vZGUuanMnO1xuaW1wb3J0IHsgUEksIHBvdywgc2luIH0gZnJvbSAnLi9NYXRoTm9kZS5qcyc7XG5cbi8vIHJlbWFwcGluZyBmdW5jdGlvbnMgaHR0cHM6Ly9pcXVpbGV6bGVzLm9yZy9hcnRpY2xlcy9mdW5jdGlvbnMvXG5leHBvcnQgY29uc3QgcGFyYWJvbGEgPSAoIHgsIGsgKSA9PiBwb3coIG11bCggNC4wLCB4Lm11bCggc3ViKCAxLjAsIHggKSApICksIGsgKTtcbmV4cG9ydCBjb25zdCBnYWluID0gKCB4LCBrICkgPT4geC5sZXNzVGhhbiggMC41ICkgPyBwYXJhYm9sYSggeC5tdWwoIDIuMCApLCBrICkuZGl2KCAyLjAgKSA6IHN1YiggMS4wLCBwYXJhYm9sYSggbXVsKCBzdWIoIDEuMCwgeCApLCAyLjAgKSwgayApLmRpdiggMi4wICkgKTtcbmV4cG9ydCBjb25zdCBwY3VydmUgPSAoIHgsIGEsIGIgKSA9PiBwb3coIGRpdiggcG93KCB4LCBhICksIGFkZCggcG93KCB4LCBhICksIHBvdyggc3ViKCAxLjAsIHggKSwgYiApICkgKSwgMS4wIC8gYSApO1xuZXhwb3J0IGNvbnN0IHNpbmMgPSAoIHgsIGsgKSA9PiBzaW4oIFBJLm11bCggay5tdWwoIHggKS5zdWIoIDEuMCApICkgKS5kaXYoIFBJLm11bCggay5tdWwoIHggKS5zdWIoIDEuMCApICkgKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jYWJiaWJvL2dsc2wtdHJpLW5vaXNlLTNkXG5cbmltcG9ydCB7IExvb3AgfSBmcm9tICcuLi91dGlscy9Mb29wTm9kZS5qcyc7XG5pbXBvcnQgeyBmbG9hdCwgdmVjMywgRm4gfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmV4cG9ydCBjb25zdCB0cmkgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgeCBdICkgPT4ge1xuXG5cdHJldHVybiB4LmZyYWN0KCkuc3ViKCAuNSApLmFicygpO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICd0cmknLFxuXHR0eXBlOiAnZmxvYXQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ2Zsb2F0JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IHRyaTMgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcCBdICkgPT4ge1xuXG5cdHJldHVybiB2ZWMzKCB0cmkoIHAuei5hZGQoIHRyaSggcC55Lm11bCggMS4gKSApICkgKSwgdHJpKCBwLnouYWRkKCB0cmkoIHAueC5tdWwoIDEuICkgKSApICksIHRyaSggcC55LmFkZCggdHJpKCBwLngubXVsKCAxLiApICkgKSApICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ3RyaTMnLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjMycgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCB0cmlOb2lzZTNEID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlLCBzcGQsIHRpbWUgXSApID0+IHtcblxuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB6ID0gZmxvYXQoIDEuNCApLnRvVmFyKCk7XG5cdGNvbnN0IHJ6ID0gZmxvYXQoIDAuMCApLnRvVmFyKCk7XG5cdGNvbnN0IGJwID0gdmVjMyggcCApLnRvVmFyKCk7XG5cblx0TG9vcCggeyBzdGFydDogZmxvYXQoIDAuMCApLCBlbmQ6IGZsb2F0KCAzLjAgKSwgdHlwZTogJ2Zsb2F0JywgY29uZGl0aW9uOiAnPD0nIH0sICgpID0+IHtcblxuXHRcdGNvbnN0IGRnID0gdmVjMyggdHJpMyggYnAubXVsKCAyLjAgKSApICkudG9WYXIoKTtcblx0XHRwLmFkZEFzc2lnbiggZGcuYWRkKCB0aW1lLm11bCggZmxvYXQoIDAuMSApLm11bCggc3BkICkgKSApICk7XG5cdFx0YnAubXVsQXNzaWduKCAxLjggKTtcblx0XHR6Lm11bEFzc2lnbiggMS41ICk7XG5cdFx0cC5tdWxBc3NpZ24oIDEuMiApO1xuXG5cdFx0Y29uc3QgdCA9IGZsb2F0KCB0cmkoIHAuei5hZGQoIHRyaSggcC54LmFkZCggdHJpKCBwLnkgKSApICkgKSApICkudG9WYXIoKTtcblx0XHRyei5hZGRBc3NpZ24oIHQuZGl2KCB6ICkgKTtcblx0XHRicC5hZGRBc3NpZ24oIDAuMTQgKTtcblxuXHR9ICk7XG5cblx0cmV0dXJuIHJ6O1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICd0cmlOb2lzZTNEJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ3NwZCcsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICd0aW1lJywgdHlwZTogJ2Zsb2F0JyB9XG5cdF1cbn0gKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIEZ1bmN0aW9uT3ZlcmxvYWRpbmdOb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdGdW5jdGlvbk92ZXJsb2FkaW5nTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBmdW5jdGlvbk5vZGVzID0gW10sIC4uLnBhcmFtZXRlcnNOb2RlcyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmZ1bmN0aW9uTm9kZXMgPSBmdW5jdGlvbk5vZGVzO1xuXHRcdHRoaXMucGFyYW1ldGVyc05vZGVzID0gcGFyYW1ldGVyc05vZGVzO1xuXG5cdFx0dGhpcy5fY2FuZGlkYXRlRm5DYWxsID0gbnVsbDtcblxuXHRcdHRoaXMuZ2xvYmFsID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0Tm9kZVR5cGUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5mdW5jdGlvbk5vZGVzWyAwIF0uc2hhZGVyTm9kZS5sYXlvdXQudHlwZTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBwYXJhbXMgPSB0aGlzLnBhcmFtZXRlcnNOb2RlcztcblxuXHRcdGxldCBjYW5kaWRhdGVGbkNhbGwgPSB0aGlzLl9jYW5kaWRhdGVGbkNhbGw7XG5cblx0XHRpZiAoIGNhbmRpZGF0ZUZuQ2FsbCA9PT0gbnVsbCApIHtcblxuXHRcdFx0bGV0IGNhbmRpZGF0ZUZuID0gbnVsbDtcblx0XHRcdGxldCBjYW5kaWRhdGVTY29yZSA9IC0gMTtcblxuXHRcdFx0Zm9yICggY29uc3QgZnVuY3Rpb25Ob2RlIG9mIHRoaXMuZnVuY3Rpb25Ob2RlcyApIHtcblxuXHRcdFx0XHRjb25zdCBzaGFkZXJOb2RlID0gZnVuY3Rpb25Ob2RlLnNoYWRlck5vZGU7XG5cdFx0XHRcdGNvbnN0IGxheW91dCA9IHNoYWRlck5vZGUubGF5b3V0O1xuXG5cdFx0XHRcdGlmICggbGF5b3V0ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnRnVuY3Rpb25PdmVybG9hZGluZ05vZGU6IEZ1bmN0aW9uTm9kZSBtdXN0IGJlIGEgbGF5b3V0LicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgaW5wdXRzID0gbGF5b3V0LmlucHV0cztcblxuXHRcdFx0XHRpZiAoIHBhcmFtcy5sZW5ndGggPT09IGlucHV0cy5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHRsZXQgc2NvcmUgPSAwO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgcGFyYW0gPSBwYXJhbXNbIGkgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGlucHV0ID0gaW5wdXRzWyBpIF07XG5cblx0XHRcdFx0XHRcdGlmICggcGFyYW0uZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSA9PT0gaW5wdXQudHlwZSApIHtcblxuXHRcdFx0XHRcdFx0XHRzY29yZSArKztcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRzY29yZSA9IDA7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggc2NvcmUgPiBjYW5kaWRhdGVTY29yZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FuZGlkYXRlRm4gPSBmdW5jdGlvbk5vZGU7XG5cdFx0XHRcdFx0XHRjYW5kaWRhdGVTY29yZSA9IHNjb3JlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jYW5kaWRhdGVGbkNhbGwgPSBjYW5kaWRhdGVGbkNhbGwgPSBjYW5kaWRhdGVGbiggLi4ucGFyYW1zICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2FuZGlkYXRlRm5DYWxsO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBGdW5jdGlvbk92ZXJsb2FkaW5nTm9kZTtcblxuY29uc3Qgb3ZlcmxvYWRpbmdCYXNlRm4gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggRnVuY3Rpb25PdmVybG9hZGluZ05vZGUgKTtcblxuZXhwb3J0IGNvbnN0IG92ZXJsb2FkaW5nRm4gPSAoIGZ1bmN0aW9uTm9kZXMgKSA9PiAoIC4uLnBhcmFtcyApID0+IG92ZXJsb2FkaW5nQmFzZUZuKCBmdW5jdGlvbk5vZGVzLCAuLi5wYXJhbXMgKTtcbiIsImltcG9ydCB7IHJlbmRlckdyb3VwIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcbmltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcblxuZXhwb3J0IGNvbnN0IHRpbWUgPSAvKkBfX1BVUkVfXyovIHVuaWZvcm0oIDAgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCBmcmFtZSApID0+IGZyYW1lLnRpbWUgKTtcbmV4cG9ydCBjb25zdCBkZWx0YVRpbWUgPSAvKkBfX1BVUkVfXyovIHVuaWZvcm0oIDAgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCBmcmFtZSApID0+IGZyYW1lLmRlbHRhVGltZSApO1xuZXhwb3J0IGNvbnN0IGZyYW1lSWQgPSAvKkBfX1BVUkVfXyovIHVuaWZvcm0oIDAsICd1aW50JyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApLm9uUmVuZGVyVXBkYXRlKCAoIGZyYW1lICkgPT4gZnJhbWUuZnJhbWVJZCApO1xuXG4vLyBEZXByZWNhdGVkXG5cbmV4cG9ydCBjb25zdCB0aW1lckxvY2FsID0gKCB0aW1lU2NhbGUgPSAxICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE3MFxuXG5cdGNvbnNvbGUud2FybiggJ1RTTDogdGltZXJMb2NhbCgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBcInRpbWVcIiBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIHRpbWUubXVsKCB0aW1lU2NhbGUgKTtcblxufTtcblxuZXhwb3J0IGNvbnN0IHRpbWVyR2xvYmFsID0gKCB0aW1lU2NhbGUgPSAxICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE3MFxuXG5cdGNvbnNvbGUud2FybiggJ1RTTDogdGltZXJHbG9iYWwoKSBpcyBkZXByZWNhdGVkLiBVc2UgXCJ0aW1lXCIgaW5zdGVhZC4nICk7XG5cdHJldHVybiB0aW1lLm11bCggdGltZVNjYWxlICk7XG5cbn07XG5cbmV4cG9ydCBjb25zdCB0aW1lckRlbHRhID0gKCB0aW1lU2NhbGUgPSAxICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE3MFxuXG5cdGNvbnNvbGUud2FybiggJ1RTTDogdGltZXJEZWx0YSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBcImRlbHRhVGltZVwiIGluc3RlYWQuJyApO1xuXHRyZXR1cm4gZGVsdGFUaW1lLm11bCggdGltZVNjYWxlICk7XG5cbn07XG4iLCJpbXBvcnQgeyB0aW1lIH0gZnJvbSAnLi9UaW1lci5qcyc7XG5cbmV4cG9ydCBjb25zdCBvc2NTaW5lID0gKCB0ID0gdGltZSApID0+IHQuYWRkKCAwLjc1ICkubXVsKCBNYXRoLlBJICogMiApLnNpbigpLm11bCggMC41ICkuYWRkKCAwLjUgKTtcbmV4cG9ydCBjb25zdCBvc2NTcXVhcmUgPSAoIHQgPSB0aW1lICkgPT4gdC5mcmFjdCgpLnJvdW5kKCk7XG5leHBvcnQgY29uc3Qgb3NjVHJpYW5nbGUgPSAoIHQgPSB0aW1lICkgPT4gdC5hZGQoIDAuNSApLmZyYWN0KCkubXVsKCAyICkuc3ViKCAxICkuYWJzKCk7XG5leHBvcnQgY29uc3Qgb3NjU2F3dG9vdGggPSAoIHQgPSB0aW1lICkgPT4gdC5mcmFjdCgpO1xuIiwiaW1wb3J0IHsgRm4sIHZlYzIgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyByb3RhdGUgfSBmcm9tICcuL1JvdGF0ZU5vZGUuanMnO1xuXG5leHBvcnQgY29uc3Qgcm90YXRlVVYgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdXYsIHJvdGF0aW9uLCBjZW50ZXIgPSB2ZWMyKCAwLjUgKSBdICkgPT4ge1xuXG5cdHJldHVybiByb3RhdGUoIHV2LnN1YiggY2VudGVyICksIHJvdGF0aW9uICkuYWRkKCBjZW50ZXIgKTtcblxufSApO1xuXG5leHBvcnQgY29uc3Qgc3BoZXJpemVVViA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB1diwgc3RyZW5ndGgsIGNlbnRlciA9IHZlYzIoIDAuNSApIF0gKSA9PiB7XG5cblx0Y29uc3QgZGVsdGEgPSB1di5zdWIoIGNlbnRlciApO1xuXHRjb25zdCBkZWx0YTIgPSBkZWx0YS5kb3QoIGRlbHRhICk7XG5cdGNvbnN0IGRlbHRhNCA9IGRlbHRhMi5tdWwoIGRlbHRhMiApO1xuXHRjb25zdCBkZWx0YU9mZnNldCA9IGRlbHRhNC5tdWwoIHN0cmVuZ3RoICk7XG5cblx0cmV0dXJuIHV2LmFkZCggZGVsdGEubXVsKCBkZWx0YU9mZnNldCApICk7XG5cbn0gKTtcbiIsImltcG9ydCB7IG1vZGVsV29ybGRNYXRyaXggfSBmcm9tICcuLi9hY2Nlc3NvcnMvTW9kZWxOb2RlLmpzJztcbmltcG9ydCB7IGNhbWVyYVZpZXdNYXRyaXgsIGNhbWVyYVByb2plY3Rpb25NYXRyaXggfSBmcm9tICcuLi9hY2Nlc3NvcnMvQ2FtZXJhLmpzJztcbmltcG9ydCB7IHBvc2l0aW9uTG9jYWwgfSBmcm9tICcuLi9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgRm4sIGRlZmluZWQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBiaWxsYm9hcmRpbmcgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgcG9zaXRpb24gPSBudWxsLCBob3Jpem9udGFsID0gdHJ1ZSwgdmVydGljYWwgPSBmYWxzZSB9ICkgPT4ge1xuXG5cdGxldCB3b3JsZE1hdHJpeDtcblxuXHRpZiAoIHBvc2l0aW9uICE9PSBudWxsICkge1xuXG5cdFx0d29ybGRNYXRyaXggPSBtb2RlbFdvcmxkTWF0cml4LnRvVmFyKCk7XG5cdFx0d29ybGRNYXRyaXhbIDMgXVsgMCBdID0gcG9zaXRpb24ueDtcblx0XHR3b3JsZE1hdHJpeFsgMyBdWyAxIF0gPSBwb3NpdGlvbi55O1xuXHRcdHdvcmxkTWF0cml4WyAzIF1bIDIgXSA9IHBvc2l0aW9uLno7XG5cblx0fSBlbHNlIHtcblxuXHRcdHdvcmxkTWF0cml4ID0gbW9kZWxXb3JsZE1hdHJpeDtcblxuXHR9XG5cblx0Y29uc3QgbW9kZWxWaWV3TWF0cml4ID0gY2FtZXJhVmlld01hdHJpeC5tdWwoIHdvcmxkTWF0cml4ICk7XG5cblx0aWYgKCBkZWZpbmVkKCBob3Jpem9udGFsICkgKSB7XG5cblx0XHRtb2RlbFZpZXdNYXRyaXhbIDAgXVsgMCBdID0gbW9kZWxXb3JsZE1hdHJpeFsgMCBdLmxlbmd0aCgpO1xuXHRcdG1vZGVsVmlld01hdHJpeFsgMCBdWyAxIF0gPSAwO1xuXHRcdG1vZGVsVmlld01hdHJpeFsgMCBdWyAyIF0gPSAwO1xuXG5cdH1cblxuXHRpZiAoIGRlZmluZWQoIHZlcnRpY2FsICkgKSB7XG5cblx0XHRtb2RlbFZpZXdNYXRyaXhbIDEgXVsgMCBdID0gMDtcblx0XHRtb2RlbFZpZXdNYXRyaXhbIDEgXVsgMSBdID0gbW9kZWxXb3JsZE1hdHJpeFsgMSBdLmxlbmd0aCgpO1xuXHRcdG1vZGVsVmlld01hdHJpeFsgMSBdWyAyIF0gPSAwO1xuXG5cdH1cblxuXHRtb2RlbFZpZXdNYXRyaXhbIDIgXVsgMCBdID0gMDtcblx0bW9kZWxWaWV3TWF0cml4WyAyIF1bIDEgXSA9IDA7XG5cdG1vZGVsVmlld01hdHJpeFsgMiBdWyAyIF0gPSAxO1xuXG5cdHJldHVybiBjYW1lcmFQcm9qZWN0aW9uTWF0cml4Lm11bCggbW9kZWxWaWV3TWF0cml4ICkubXVsKCBwb3NpdGlvbkxvY2FsICk7XG5cbn0gKTtcbiIsImltcG9ydCB7IEZuIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgc2NyZWVuVVYgfSBmcm9tICcuLi9kaXNwbGF5L1NjcmVlbk5vZGUuanMnO1xuaW1wb3J0IHsgdmlld3BvcnREZXB0aFRleHR1cmUgfSBmcm9tICcuLi9kaXNwbGF5L1ZpZXdwb3J0RGVwdGhUZXh0dXJlTm9kZS5qcyc7XG5pbXBvcnQgeyBsaW5lYXJEZXB0aCB9IGZyb20gJy4uL2Rpc3BsYXkvVmlld3BvcnREZXB0aE5vZGUuanMnO1xuXG5leHBvcnQgY29uc3Qgdmlld3BvcnRTYWZlVVYgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdXYgPSBudWxsIF0gKSA9PiB7XG5cblx0Y29uc3QgZGVwdGggPSBsaW5lYXJEZXB0aCgpO1xuXHRjb25zdCBkZXB0aERpZmYgPSBsaW5lYXJEZXB0aCggdmlld3BvcnREZXB0aFRleHR1cmUoIHV2ICkgKS5zdWIoIGRlcHRoICk7XG5cdGNvbnN0IGZpbmFsVVYgPSBkZXB0aERpZmYubGVzc1RoYW4oIDAgKS5zZWxlY3QoIHNjcmVlblVWLCB1diApO1xuXG5cdHJldHVybiBmaW5hbFVWO1xuXG59ICk7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xuaW1wb3J0IHsgdXYgfSBmcm9tICcuLi9hY2Nlc3NvcnMvVVYuanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5LCBmbG9hdCwgdmVjMiB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY2xhc3MgU3ByaXRlU2hlZXRVVk5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1Nwcml0ZVNoZWV0VVZOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGNvdW50Tm9kZSwgdXZOb2RlID0gdXYoKSwgZnJhbWVOb2RlID0gZmxvYXQoIDAgKSApIHtcblxuXHRcdHN1cGVyKCAndmVjMicgKTtcblxuXHRcdHRoaXMuY291bnROb2RlID0gY291bnROb2RlO1xuXHRcdHRoaXMudXZOb2RlID0gdXZOb2RlO1xuXHRcdHRoaXMuZnJhbWVOb2RlID0gZnJhbWVOb2RlO1xuXG5cdH1cblxuXHRzZXR1cCgpIHtcblxuXHRcdGNvbnN0IHsgZnJhbWVOb2RlLCB1dk5vZGUsIGNvdW50Tm9kZSB9ID0gdGhpcztcblxuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY291bnROb2RlO1xuXG5cdFx0Y29uc3QgZnJhbWVOdW0gPSBmcmFtZU5vZGUubW9kKCB3aWR0aC5tdWwoIGhlaWdodCApICkuZmxvb3IoKTtcblxuXHRcdGNvbnN0IGNvbHVtbiA9IGZyYW1lTnVtLm1vZCggd2lkdGggKTtcblx0XHRjb25zdCByb3cgPSBoZWlnaHQuc3ViKCBmcmFtZU51bS5hZGQoIDEgKS5kaXYoIHdpZHRoICkuY2VpbCgpICk7XG5cblx0XHRjb25zdCBzY2FsZSA9IGNvdW50Tm9kZS5yZWNpcHJvY2FsKCk7XG5cdFx0Y29uc3QgdXZGcmFtZU9mZnNldCA9IHZlYzIoIGNvbHVtbiwgcm93ICk7XG5cblx0XHRyZXR1cm4gdXZOb2RlLmFkZCggdXZGcmFtZU9mZnNldCApLm11bCggc2NhbGUgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3ByaXRlU2hlZXRVVk5vZGU7XG5cbmV4cG9ydCBjb25zdCBzcHJpdGVzaGVldFVWID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFNwcml0ZVNoZWV0VVZOb2RlICk7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xuaW1wb3J0IHsgYWRkIH0gZnJvbSAnLi4vbWF0aC9PcGVyYXRvck5vZGUuanMnO1xuaW1wb3J0IHsgbm9ybWFsTG9jYWwgfSBmcm9tICcuLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcbmltcG9ydCB7IHBvc2l0aW9uTG9jYWwgfSBmcm9tICcuLi9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgdGV4dHVyZSB9IGZyb20gJy4uL2FjY2Vzc29ycy9UZXh0dXJlTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlUHJveHksIGZsb2F0LCB2ZWMzIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5jbGFzcyBUcmlwbGFuYXJUZXh0dXJlc05vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1RyaXBsYW5hclRleHR1cmVzTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCB0ZXh0dXJlWE5vZGUsIHRleHR1cmVZTm9kZSA9IG51bGwsIHRleHR1cmVaTm9kZSA9IG51bGwsIHNjYWxlTm9kZSA9IGZsb2F0KCAxICksIHBvc2l0aW9uTm9kZSA9IHBvc2l0aW9uTG9jYWwsIG5vcm1hbE5vZGUgPSBub3JtYWxMb2NhbCApIHtcblxuXHRcdHN1cGVyKCAndmVjNCcgKTtcblxuXHRcdHRoaXMudGV4dHVyZVhOb2RlID0gdGV4dHVyZVhOb2RlO1xuXHRcdHRoaXMudGV4dHVyZVlOb2RlID0gdGV4dHVyZVlOb2RlO1xuXHRcdHRoaXMudGV4dHVyZVpOb2RlID0gdGV4dHVyZVpOb2RlO1xuXG5cdFx0dGhpcy5zY2FsZU5vZGUgPSBzY2FsZU5vZGU7XG5cblx0XHR0aGlzLnBvc2l0aW9uTm9kZSA9IHBvc2l0aW9uTm9kZTtcblx0XHR0aGlzLm5vcm1hbE5vZGUgPSBub3JtYWxOb2RlO1xuXG5cdH1cblxuXHRzZXR1cCgpIHtcblxuXHRcdGNvbnN0IHsgdGV4dHVyZVhOb2RlLCB0ZXh0dXJlWU5vZGUsIHRleHR1cmVaTm9kZSwgc2NhbGVOb2RlLCBwb3NpdGlvbk5vZGUsIG5vcm1hbE5vZGUgfSA9IHRoaXM7XG5cblx0XHQvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9rZWlqaXJvL1N0YW5kYXJkVHJpcGxhbmFyXG5cblx0XHQvLyBCbGVuZGluZyBmYWN0b3Igb2YgdHJpcGxhbmFyIG1hcHBpbmdcblx0XHRsZXQgYmYgPSBub3JtYWxOb2RlLmFicygpLm5vcm1hbGl6ZSgpO1xuXHRcdGJmID0gYmYuZGl2KCBiZi5kb3QoIHZlYzMoIDEuMCApICkgKTtcblxuXHRcdC8vIFRyaXBsYW5hciBtYXBwaW5nXG5cdFx0Y29uc3QgdHggPSBwb3NpdGlvbk5vZGUueXoubXVsKCBzY2FsZU5vZGUgKTtcblx0XHRjb25zdCB0eSA9IHBvc2l0aW9uTm9kZS56eC5tdWwoIHNjYWxlTm9kZSApO1xuXHRcdGNvbnN0IHR6ID0gcG9zaXRpb25Ob2RlLnh5Lm11bCggc2NhbGVOb2RlICk7XG5cblx0XHQvLyBCYXNlIGNvbG9yXG5cdFx0Y29uc3QgdGV4dHVyZVggPSB0ZXh0dXJlWE5vZGUudmFsdWU7XG5cdFx0Y29uc3QgdGV4dHVyZVkgPSB0ZXh0dXJlWU5vZGUgIT09IG51bGwgPyB0ZXh0dXJlWU5vZGUudmFsdWUgOiB0ZXh0dXJlWDtcblx0XHRjb25zdCB0ZXh0dXJlWiA9IHRleHR1cmVaTm9kZSAhPT0gbnVsbCA/IHRleHR1cmVaTm9kZS52YWx1ZSA6IHRleHR1cmVYO1xuXG5cdFx0Y29uc3QgY3ggPSB0ZXh0dXJlKCB0ZXh0dXJlWCwgdHggKS5tdWwoIGJmLnggKTtcblx0XHRjb25zdCBjeSA9IHRleHR1cmUoIHRleHR1cmVZLCB0eSApLm11bCggYmYueSApO1xuXHRcdGNvbnN0IGN6ID0gdGV4dHVyZSggdGV4dHVyZVosIHR6ICkubXVsKCBiZi56ICk7XG5cblx0XHRyZXR1cm4gYWRkKCBjeCwgY3ksIGN6ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyaXBsYW5hclRleHR1cmVzTm9kZTtcblxuZXhwb3J0IGNvbnN0IHRyaXBsYW5hclRleHR1cmVzID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFRyaXBsYW5hclRleHR1cmVzTm9kZSApO1xuZXhwb3J0IGNvbnN0IHRyaXBsYW5hclRleHR1cmUgPSAoIC4uLnBhcmFtcyApID0+IHRyaXBsYW5hclRleHR1cmVzKCAuLi5wYXJhbXMgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgVGV4dHVyZU5vZGUgZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcbmltcG9ydCB7IG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHNjcmVlblVWIH0gZnJvbSAnLi4vZGlzcGxheS9TY3JlZW5Ob2RlLmpzJztcblxuaW1wb3J0IHsgSGFsZkZsb2F0VHlwZSwgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLCBXZWJHUFVDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IFBsYW5lIH0gZnJvbSAnLi4vLi4vbWF0aC9QbGFuZS5qcyc7XG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4uLy4uL2NvcmUvT2JqZWN0M0QuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBSZW5kZXJUYXJnZXQgfSBmcm9tICcuLi8uLi9jb3JlL1JlbmRlclRhcmdldC5qcyc7XG5pbXBvcnQgeyBEZXB0aFRleHR1cmUgfSBmcm9tICcuLi8uLi90ZXh0dXJlcy9EZXB0aFRleHR1cmUuanMnO1xuXG5jb25zdCBfcmVmbGVjdG9yUGxhbmUgPSBuZXcgUGxhbmUoKTtcbmNvbnN0IF9ub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3JlZmxlY3RvcldvcmxkUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2NhbWVyYVdvcmxkUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3JvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9sb29rQXRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKTtcbmNvbnN0IGNsaXBQbGFuZSA9IG5ldyBWZWN0b3I0KCk7XG5cbmNvbnN0IF92aWV3ID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3EgPSBuZXcgVmVjdG9yNCgpO1xuXG5jb25zdCBfc2l6ZSA9IG5ldyBWZWN0b3IyKCk7XG5cbmNvbnN0IF9kZWZhdWx0UlQgPSBuZXcgUmVuZGVyVGFyZ2V0KCk7XG5jb25zdCBfZGVmYXVsdFVWID0gc2NyZWVuVVYuZmxpcFgoKTtcblxuX2RlZmF1bHRSVC5kZXB0aFRleHR1cmUgPSBuZXcgRGVwdGhUZXh0dXJlKCAxLCAxICk7XG5cbmxldCBfaW5SZWZsZWN0b3IgPSBmYWxzZTtcblxuY2xhc3MgUmVmbGVjdG9yTm9kZSBleHRlbmRzIFRleHR1cmVOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1JlZmxlY3Rvck5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoIHBhcmFtZXRlcnMuZGVmYXVsdFRleHR1cmUgfHwgX2RlZmF1bHRSVC50ZXh0dXJlLCBfZGVmYXVsdFVWICk7XG5cblx0XHR0aGlzLl9yZWZsZWN0b3JCYXNlTm9kZSA9IHBhcmFtZXRlcnMucmVmbGVjdG9yIHx8IG5ldyBSZWZsZWN0b3JCYXNlTm9kZSggdGhpcywgcGFyYW1ldGVycyApO1xuXHRcdHRoaXMuX2RlcHRoTm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLnNldFVwZGF0ZU1hdHJpeCggZmFsc2UgKTtcblxuXHR9XG5cblx0Z2V0IHJlZmxlY3RvcigpIHtcblxuXHRcdHJldHVybiB0aGlzLl9yZWZsZWN0b3JCYXNlTm9kZTtcblxuXHR9XG5cblx0Z2V0IHRhcmdldCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9yZWZsZWN0b3JCYXNlTm9kZS50YXJnZXQ7XG5cblx0fVxuXG5cdGdldERlcHRoTm9kZSgpIHtcblxuXHRcdGlmICggdGhpcy5fZGVwdGhOb2RlID09PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuX3JlZmxlY3RvckJhc2VOb2RlLmRlcHRoICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlJlZmxlY3Rvck5vZGU6IERlcHRoIG5vZGUgY2FuIG9ubHkgYmUgcmVxdWVzdGVkIHdoZW4gdGhlIHJlZmxlY3RvciBpcyBjcmVhdGVkIHdpdGggeyBkZXB0aDogdHJ1ZSB9LiAnICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZGVwdGhOb2RlID0gbm9kZU9iamVjdCggbmV3IFJlZmxlY3Rvck5vZGUoIHtcblx0XHRcdFx0ZGVmYXVsdFRleHR1cmU6IF9kZWZhdWx0UlQuZGVwdGhUZXh0dXJlLFxuXHRcdFx0XHRyZWZsZWN0b3I6IHRoaXMuX3JlZmxlY3RvckJhc2VOb2RlXG5cdFx0XHR9ICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9kZXB0aE5vZGU7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Ly8gaWdub3JlIGlmIHVzZWQgaW4gcG9zdC1wcm9jZXNzaW5nXG5cdFx0aWYgKCAhIGJ1aWxkZXIub2JqZWN0LmlzUXVhZE1lc2ggKSB0aGlzLl9yZWZsZWN0b3JCYXNlTm9kZS5idWlsZCggYnVpbGRlciApO1xuXG5cdFx0cmV0dXJuIHN1cGVyLnNldHVwKCBidWlsZGVyICk7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnJlZmxlY3Rvck5vZGUgKTtcblx0XHR0ZXh0dXJlLl9yZWZsZWN0b3JCYXNlTm9kZSA9IHRoaXMuX3JlZmxlY3RvckJhc2VOb2RlO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG59XG5cblxuY2xhc3MgUmVmbGVjdG9yQmFzZU5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1JlZmxlY3RvckJhc2VOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHRleHR1cmVOb2RlLCBwYXJhbWV0ZXJzID0ge30gKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0Y29uc3Qge1xuXHRcdFx0dGFyZ2V0ID0gbmV3IE9iamVjdDNEKCksXG5cdFx0XHRyZXNvbHV0aW9uID0gMSxcblx0XHRcdGdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlLFxuXHRcdFx0Ym91bmNlcyA9IHRydWUsXG5cdFx0XHRkZXB0aCA9IGZhbHNlXG5cdFx0fSA9IHBhcmFtZXRlcnM7XG5cblx0XHQvL1xuXG5cdFx0dGhpcy50ZXh0dXJlTm9kZSA9IHRleHR1cmVOb2RlO1xuXG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdFx0dGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcblx0XHR0aGlzLmJvdW5jZXMgPSBib3VuY2VzO1xuXHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcblxuXHRcdHRoaXMudXBkYXRlQmVmb3JlVHlwZSA9IGJvdW5jZXMgPyBOb2RlVXBkYXRlVHlwZS5SRU5ERVIgOiBOb2RlVXBkYXRlVHlwZS5GUkFNRTtcblxuXHRcdHRoaXMudmlydHVhbENhbWVyYXMgPSBuZXcgV2Vha01hcCgpO1xuXHRcdHRoaXMucmVuZGVyVGFyZ2V0cyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0fVxuXG5cdF91cGRhdGVSZXNvbHV0aW9uKCByZW5kZXJUYXJnZXQsIHJlbmRlcmVyICkge1xuXG5cdFx0Y29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcblxuXHRcdHJlbmRlcmVyLmdldERyYXdpbmdCdWZmZXJTaXplKCBfc2l6ZSApO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LnNldFNpemUoIE1hdGgucm91bmQoIF9zaXplLndpZHRoICogcmVzb2x1dGlvbiApLCBNYXRoLnJvdW5kKCBfc2l6ZS5oZWlnaHQgKiByZXNvbHV0aW9uICkgKTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHR0aGlzLl91cGRhdGVSZXNvbHV0aW9uKCBfZGVmYXVsdFJULCBidWlsZGVyLnJlbmRlcmVyICk7XG5cblx0XHRyZXR1cm4gc3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0Z2V0VmlydHVhbENhbWVyYSggY2FtZXJhICkge1xuXG5cdFx0bGV0IHZpcnR1YWxDYW1lcmEgPSB0aGlzLnZpcnR1YWxDYW1lcmFzLmdldCggY2FtZXJhICk7XG5cblx0XHRpZiAoIHZpcnR1YWxDYW1lcmEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmlydHVhbENhbWVyYSA9IGNhbWVyYS5jbG9uZSgpO1xuXG5cdFx0XHR0aGlzLnZpcnR1YWxDYW1lcmFzLnNldCggY2FtZXJhLCB2aXJ0dWFsQ2FtZXJhICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdmlydHVhbENhbWVyYTtcblxuXHR9XG5cblx0Z2V0UmVuZGVyVGFyZ2V0KCBjYW1lcmEgKSB7XG5cblx0XHRsZXQgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXRzLmdldCggY2FtZXJhICk7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZW5kZXJUYXJnZXQgPSBuZXcgUmVuZGVyVGFyZ2V0KCAwLCAwLCB7IHR5cGU6IEhhbGZGbG9hdFR5cGUgfSApO1xuXG5cdFx0XHRpZiAoIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuZGVwdGggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSA9IG5ldyBEZXB0aFRleHR1cmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJlbmRlclRhcmdldHMuc2V0KCBjYW1lcmEsIHJlbmRlclRhcmdldCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlbmRlclRhcmdldDtcblxuXHR9XG5cblx0dXBkYXRlQmVmb3JlKCBmcmFtZSApIHtcblxuXHRcdGlmICggdGhpcy5ib3VuY2VzID09PSBmYWxzZSAmJiBfaW5SZWZsZWN0b3IgKSByZXR1cm47XG5cblx0XHRfaW5SZWZsZWN0b3IgPSB0cnVlO1xuXG5cdFx0Y29uc3QgeyBzY2VuZSwgY2FtZXJhLCByZW5kZXJlciwgbWF0ZXJpYWwgfSA9IGZyYW1lO1xuXHRcdGNvbnN0IHsgdGFyZ2V0IH0gPSB0aGlzO1xuXG5cdFx0Y29uc3QgdmlydHVhbENhbWVyYSA9IHRoaXMuZ2V0VmlydHVhbENhbWVyYSggY2FtZXJhICk7XG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5nZXRSZW5kZXJUYXJnZXQoIHZpcnR1YWxDYW1lcmEgKTtcblxuXHRcdHJlbmRlcmVyLmdldERyYXdpbmdCdWZmZXJTaXplKCBfc2l6ZSApO1xuXG5cdFx0dGhpcy5fdXBkYXRlUmVzb2x1dGlvbiggcmVuZGVyVGFyZ2V0LCByZW5kZXJlciApO1xuXG5cdFx0Ly9cblxuXHRcdF9yZWZsZWN0b3JXb3JsZFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0X2NhbWVyYVdvcmxkUG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdF9yb3RhdGlvbk1hdHJpeC5leHRyYWN0Um90YXRpb24oIHRhcmdldC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0X25vcm1hbC5zZXQoIDAsIDAsIDEgKTtcblx0XHRfbm9ybWFsLmFwcGx5TWF0cml4NCggX3JvdGF0aW9uTWF0cml4ICk7XG5cblx0XHRfdmlldy5zdWJWZWN0b3JzKCBfcmVmbGVjdG9yV29ybGRQb3NpdGlvbiwgX2NhbWVyYVdvcmxkUG9zaXRpb24gKTtcblxuXHRcdC8vIEF2b2lkIHJlbmRlcmluZyB3aGVuIHJlZmxlY3RvciBpcyBmYWNpbmcgYXdheVxuXG5cdFx0aWYgKCBfdmlldy5kb3QoIF9ub3JtYWwgKSA+IDAgKSByZXR1cm47XG5cblx0XHRfdmlldy5yZWZsZWN0KCBfbm9ybWFsICkubmVnYXRlKCk7XG5cdFx0X3ZpZXcuYWRkKCBfcmVmbGVjdG9yV29ybGRQb3NpdGlvbiApO1xuXG5cdFx0X3JvdGF0aW9uTWF0cml4LmV4dHJhY3RSb3RhdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cblx0XHRfbG9va0F0UG9zaXRpb24uc2V0KCAwLCAwLCAtIDEgKTtcblx0XHRfbG9va0F0UG9zaXRpb24uYXBwbHlNYXRyaXg0KCBfcm90YXRpb25NYXRyaXggKTtcblx0XHRfbG9va0F0UG9zaXRpb24uYWRkKCBfY2FtZXJhV29ybGRQb3NpdGlvbiApO1xuXG5cdFx0X3RhcmdldC5zdWJWZWN0b3JzKCBfcmVmbGVjdG9yV29ybGRQb3NpdGlvbiwgX2xvb2tBdFBvc2l0aW9uICk7XG5cdFx0X3RhcmdldC5yZWZsZWN0KCBfbm9ybWFsICkubmVnYXRlKCk7XG5cdFx0X3RhcmdldC5hZGQoIF9yZWZsZWN0b3JXb3JsZFBvc2l0aW9uICk7XG5cblx0XHQvL1xuXG5cdFx0dmlydHVhbENhbWVyYS5jb29yZGluYXRlU3lzdGVtID0gY2FtZXJhLmNvb3JkaW5hdGVTeXN0ZW07XG5cdFx0dmlydHVhbENhbWVyYS5wb3NpdGlvbi5jb3B5KCBfdmlldyApO1xuXHRcdHZpcnR1YWxDYW1lcmEudXAuc2V0KCAwLCAxLCAwICk7XG5cdFx0dmlydHVhbENhbWVyYS51cC5hcHBseU1hdHJpeDQoIF9yb3RhdGlvbk1hdHJpeCApO1xuXHRcdHZpcnR1YWxDYW1lcmEudXAucmVmbGVjdCggX25vcm1hbCApO1xuXHRcdHZpcnR1YWxDYW1lcmEubG9va0F0KCBfdGFyZ2V0ICk7XG5cblx0XHR2aXJ0dWFsQ2FtZXJhLm5lYXIgPSBjYW1lcmEubmVhcjtcblx0XHR2aXJ0dWFsQ2FtZXJhLmZhciA9IGNhbWVyYS5mYXI7XG5cblx0XHR2aXJ0dWFsQ2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0dmlydHVhbENhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHQvLyBOb3cgdXBkYXRlIHByb2plY3Rpb24gbWF0cml4IHdpdGggbmV3IGNsaXAgcGxhbmUsIGltcGxlbWVudGluZyBjb2RlIGZyb206IGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvb2JsaXF1ZS5odG1sXG5cdFx0Ly8gUGFwZXIgZXhwbGFpbmluZyB0aGlzIHRlY2huaXF1ZTogaHR0cDovL3d3dy50ZXJhdGhvbi5jb20vbGVuZ3llbC9MZW5neWVsLU9ibGlxdWUucGRmXG5cdFx0X3JlZmxlY3RvclBsYW5lLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBfbm9ybWFsLCBfcmVmbGVjdG9yV29ybGRQb3NpdGlvbiApO1xuXHRcdF9yZWZsZWN0b3JQbGFuZS5hcHBseU1hdHJpeDQoIHZpcnR1YWxDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0XHRjbGlwUGxhbmUuc2V0KCBfcmVmbGVjdG9yUGxhbmUubm9ybWFsLngsIF9yZWZsZWN0b3JQbGFuZS5ub3JtYWwueSwgX3JlZmxlY3RvclBsYW5lLm5vcm1hbC56LCBfcmVmbGVjdG9yUGxhbmUuY29uc3RhbnQgKTtcblxuXHRcdGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSB2aXJ0dWFsQ2FtZXJhLnByb2plY3Rpb25NYXRyaXg7XG5cblx0XHRfcS54ID0gKCBNYXRoLnNpZ24oIGNsaXBQbGFuZS54ICkgKyBwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyA4IF0gKSAvIHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXTtcblx0XHRfcS55ID0gKCBNYXRoLnNpZ24oIGNsaXBQbGFuZS55ICkgKyBwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyA5IF0gKSAvIHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDUgXTtcblx0XHRfcS56ID0gLSAxLjA7XG5cdFx0X3EudyA9ICggMS4wICsgcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMTAgXSApIC8gcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMTQgXTtcblxuXHRcdC8vIENhbGN1bGF0ZSB0aGUgc2NhbGVkIHBsYW5lIHZlY3RvclxuXHRcdGNsaXBQbGFuZS5tdWx0aXBseVNjYWxhciggMS4wIC8gY2xpcFBsYW5lLmRvdCggX3EgKSApO1xuXG5cdFx0Y29uc3QgY2xpcEJpYXMgPSAwO1xuXG5cdFx0Ly8gUmVwbGFjaW5nIHRoZSB0aGlyZCByb3cgb2YgdGhlIHByb2plY3Rpb24gbWF0cml4XG5cdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMiBdID0gY2xpcFBsYW5lLng7XG5cdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgNiBdID0gY2xpcFBsYW5lLnk7XG5cdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMTAgXSA9ICggcmVuZGVyZXIuY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApID8gKCBjbGlwUGxhbmUueiAtIGNsaXBCaWFzICkgOiAoIGNsaXBQbGFuZS56ICsgMS4wIC0gY2xpcEJpYXMgKTtcblx0XHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAxNCBdID0gY2xpcFBsYW5lLnc7XG5cblx0XHQvL1xuXG5cdFx0dGhpcy50ZXh0dXJlTm9kZS52YWx1ZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXG5cdFx0aWYgKCB0aGlzLmRlcHRoID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLnRleHR1cmVOb2RlLmdldERlcHRoTm9kZSgpLnZhbHVlID0gcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZTtcblxuXHRcdH1cblxuXHRcdG1hdGVyaWFsLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRjb25zdCBjdXJyZW50TVJUID0gcmVuZGVyZXIuZ2V0TVJUKCk7XG5cblx0XHRyZW5kZXJlci5zZXRNUlQoIG51bGwgKTtcblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgdmlydHVhbENhbWVyYSApO1xuXG5cdFx0cmVuZGVyZXIuc2V0TVJUKCBjdXJyZW50TVJUICk7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdXJyZW50UmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRtYXRlcmlhbC52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdF9pblJlZmxlY3RvciA9IGZhbHNlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgY29uc3QgcmVmbGVjdG9yID0gKCBwYXJhbWV0ZXJzICkgPT4gbm9kZU9iamVjdCggbmV3IFJlZmxlY3Rvck5vZGUoIHBhcmFtZXRlcnMgKSApO1xuXG5leHBvcnQgZGVmYXVsdCBSZWZsZWN0b3JOb2RlO1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi8uLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi4vLi4vb2JqZWN0cy9NZXNoLmpzJztcbmltcG9ydCB7IE9ydGhvZ3JhcGhpY0NhbWVyYSB9IGZyb20gJy4uLy4uL2NhbWVyYXMvT3J0aG9ncmFwaGljQ2FtZXJhLmpzJztcblxuLy8gSGVscGVyIGZvciBwYXNzZXMgdGhhdCBuZWVkIHRvIGZpbGwgdGhlIHZpZXdwb3J0IHdpdGggYSBzaW5nbGUgcXVhZC5cblxuY29uc3QgX2NhbWVyYSA9IC8qQF9fUFVSRV9fKi8gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSAxLCAxLCAxLCAtIDEsIDAsIDEgKTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIxMzU4XG5cbmNsYXNzIFF1YWRHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggZmxpcFkgPSBmYWxzZSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHRjb25zdCB1diA9IGZsaXBZID09PSBmYWxzZSA/IFsgMCwgLSAxLCAwLCAxLCAyLCAxIF0gOiBbIDAsIDIsIDAsIDAsIDIsIDAgXTtcblxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggWyAtIDEsIDMsIDAsIC0gMSwgLSAxLCAwLCAzLCAtIDEsIDAgXSwgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1diwgMiApICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9nZW9tZXRyeSA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YWRHZW9tZXRyeSgpO1xuXG5jbGFzcyBRdWFkTWVzaCBleHRlbmRzIE1lc2gge1xuXG5cdGNvbnN0cnVjdG9yKCBtYXRlcmlhbCA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggX2dlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy5jYW1lcmEgPSBfY2FtZXJhO1xuXG5cdFx0dGhpcy5pc1F1YWRNZXNoID0gdHJ1ZTtcblxuXHR9XG5cblx0cmVuZGVyQXN5bmMoIHJlbmRlcmVyICkge1xuXG5cdFx0cmV0dXJuIHJlbmRlcmVyLnJlbmRlckFzeW5jKCB0aGlzLCBfY2FtZXJhICk7XG5cblx0fVxuXG5cdHJlbmRlciggcmVuZGVyZXIgKSB7XG5cblx0XHRyZW5kZXJlci5yZW5kZXIoIHRoaXMsIF9jYW1lcmEgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUXVhZE1lc2g7XG4iLCJpbXBvcnQgeyBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuaW1wb3J0IFRleHR1cmVOb2RlIGZyb20gJy4uL2FjY2Vzc29ycy9UZXh0dXJlTm9kZS5qcyc7XG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHV2IH0gZnJvbSAnLi4vYWNjZXNzb3JzL1VWLmpzJztcbmltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi4vLi4vbWF0ZXJpYWxzL25vZGVzL05vZGVNYXRlcmlhbC5qcyc7XG5pbXBvcnQgUXVhZE1lc2ggZnJvbSAnLi4vLi4vcmVuZGVyZXJzL2NvbW1vbi9RdWFkTWVzaC5qcyc7XG5cbmltcG9ydCB7IFJlbmRlclRhcmdldCB9IGZyb20gJy4uLy4uL2NvcmUvUmVuZGVyVGFyZ2V0LmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgSGFsZkZsb2F0VHlwZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IF9zaXplID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xuXG5jbGFzcyBSVFROb2RlIGV4dGVuZHMgVGV4dHVyZU5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnUlRUTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBub2RlLCB3aWR0aCA9IG51bGwsIGhlaWdodCA9IG51bGwsIG9wdGlvbnMgPSB7IHR5cGU6IEhhbGZGbG9hdFR5cGUgfSApIHtcblxuXHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IG5ldyBSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcblxuXHRcdHN1cGVyKCByZW5kZXJUYXJnZXQudGV4dHVyZSwgdXYoKSApO1xuXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHR0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcblxuXHRcdHRoaXMudGV4dHVyZU5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy51cGRhdGVNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5cdFx0dGhpcy5fcnR0Tm9kZSA9IG51bGw7XG5cdFx0dGhpcy5fcXVhZE1lc2ggPSBuZXcgUXVhZE1lc2goIG5ldyBOb2RlTWF0ZXJpYWwoKSApO1xuXG5cdFx0dGhpcy51cGRhdGVCZWZvcmVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuUkVOREVSO1xuXG5cdH1cblxuXHRnZXQgYXV0b1NpemUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy53aWR0aCA9PT0gbnVsbDtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHR0aGlzLl9ydHROb2RlID0gdGhpcy5ub2RlLmNvbnRleHQoIGJ1aWxkZXIuZ2V0U2hhcmVkQ29udGV4dCgpICk7XG5cdFx0dGhpcy5fcXVhZE1lc2gubWF0ZXJpYWwubmFtZSA9ICdSVFQnO1xuXHRcdHRoaXMuX3F1YWRNZXNoLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiBzdXBlci5zZXR1cCggYnVpbGRlciApO1xuXG5cdH1cblxuXHRzZXRTaXplKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0Y29uc3QgZWZmZWN0aXZlV2lkdGggPSB3aWR0aCAqIHRoaXMucGl4ZWxSYXRpbztcblx0XHRjb25zdCBlZmZlY3RpdmVIZWlnaHQgPSBoZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG5cblx0XHR0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKCBlZmZlY3RpdmVXaWR0aCwgZWZmZWN0aXZlSGVpZ2h0ICk7XG5cblx0XHR0aGlzLnRleHR1cmVOZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdHNldFBpeGVsUmF0aW8oIHBpeGVsUmF0aW8gKSB7XG5cblx0XHR0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXG5cdFx0dGhpcy5zZXRTaXplKCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCApO1xuXG5cdH1cblxuXHR1cGRhdGVCZWZvcmUoIHsgcmVuZGVyZXIgfSApIHtcblxuXHRcdGlmICggdGhpcy50ZXh0dXJlTmVlZHNVcGRhdGUgPT09IGZhbHNlICYmIHRoaXMuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR0aGlzLnRleHR1cmVOZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0Ly9cblxuXHRcdGlmICggdGhpcy5hdXRvU2l6ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy5waXhlbFJhdGlvID0gcmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpO1xuXG5cdFx0XHRjb25zdCBzaXplID0gcmVuZGVyZXIuZ2V0U2l6ZSggX3NpemUgKTtcblxuXHRcdFx0dGhpcy5zZXRTaXplKCBzaXplLndpZHRoLCBzaXplLmhlaWdodCApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHRoaXMuX3F1YWRNZXNoLm1hdGVyaWFsLmZyYWdtZW50Tm9kZSA9IHRoaXMuX3J0dE5vZGU7XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCB0aGlzLnJlbmRlclRhcmdldCApO1xuXG5cdFx0dGhpcy5fcXVhZE1lc2gucmVuZGVyKCByZW5kZXJlciApO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdXJyZW50UmVuZGVyVGFyZ2V0ICk7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0Y29uc3QgbmV3Tm9kZSA9IG5ldyBUZXh0dXJlTm9kZSggdGhpcy52YWx1ZSwgdGhpcy51dk5vZGUsIHRoaXMubGV2ZWxOb2RlICk7XG5cdFx0bmV3Tm9kZS5zYW1wbGVyID0gdGhpcy5zYW1wbGVyO1xuXHRcdG5ld05vZGUucmVmZXJlbmNlTm9kZSA9IHRoaXM7XG5cblx0XHRyZXR1cm4gbmV3Tm9kZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUlRUTm9kZTtcblxuZXhwb3J0IGNvbnN0IHJ0dCA9ICggbm9kZSwgLi4ucGFyYW1zICkgPT4gbm9kZU9iamVjdCggbmV3IFJUVE5vZGUoIG5vZGVPYmplY3QoIG5vZGUgKSwgLi4ucGFyYW1zICkgKTtcblxuZXhwb3J0IGNvbnN0IGNvbnZlcnRUb1RleHR1cmUgPSAoIG5vZGUsIC4uLnBhcmFtcyApID0+IHtcblxuXHRpZiAoIG5vZGUuaXNUZXh0dXJlTm9kZSApIHJldHVybiBub2RlO1xuXHRpZiAoIG5vZGUuaXNQYXNzTm9kZSApIHJldHVybiBub2RlLmdldFRleHR1cmVOb2RlKCk7XG5cblx0cmV0dXJuIHJ0dCggbm9kZSwgLi4ucGFyYW1zICk7XG5cbn07XG4iLCJpbXBvcnQgeyBhYnMsIGNyb3NzLCBmbG9hdCwgRm4sIG5vcm1hbGl6ZSwgaXZlYzIsIHN1YiwgdmVjMiwgdmVjMywgdmVjNCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IHRleHR1cmVTaXplIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVTaXplTm9kZS5qcyc7XG5pbXBvcnQgeyB0ZXh0dXJlTG9hZCB9IGZyb20gJy4uL2FjY2Vzc29ycy9UZXh0dXJlTm9kZS5qcyc7XG5pbXBvcnQgeyBXZWJHUFVDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcblxuLyoqXG4qIENvbXB1dGVzIGEgcG9zaXRpb24gaW4gdmlldyBzcGFjZSBiYXNlZCBvbiBhIGZyYWdtZW50J3Mgc2NyZWVuIHBvc2l0aW9uIGV4cHJlc3NlZCBhcyB1diBjb29yZGluYXRlcywgdGhlIGZyYWdtZW50c1xuKiBkZXB0aCB2YWx1ZSBhbmQgdGhlIGNhbWVyYSdzIGludmVyc2UgcHJvamVjdGlvbiBtYXRyaXguXG4qXG4qIEBwYXJhbSB7dmVjMn0gc2NyZWVuUG9zaXRpb24gLSBUaGUgZnJhZ21lbnQncyBzY3JlZW4gcG9zaXRpb24gZXhwcmVzc2VkIGFzIHV2IGNvb3JkaW5hdGVzLlxuKiBAcGFyYW0ge2Zsb2F0fSBkZXB0aCAtIFRoZSBmcmFnbWVudCdzIGRlcHRoIHZhbHVlLlxuKiBAcGFyYW0ge21hdDR9IHByb2plY3Rpb25NYXRyaXhJbnZlcnNlIC0gVGhlIGNhbWVyYSdzIGludmVyc2UgcHJvamVjdGlvbiBtYXRyaXguXG4qIEByZXR1cm4ge3ZlYzN9IFRoZSBmcmFnbWVudHMgcG9zaXRpb24gaW4gdmlldyBzcGFjZS5cbiovXG5leHBvcnQgY29uc3QgZ2V0Vmlld1Bvc2l0aW9uID0gLypAX19QVVJFX18qLyBGbiggKCBbIHNjcmVlblBvc2l0aW9uLCBkZXB0aCwgcHJvamVjdGlvbk1hdHJpeEludmVyc2UgXSwgYnVpbGRlciApID0+IHtcblxuXHRsZXQgY2xpcFNwYWNlUG9zaXRpb247XG5cblx0aWYgKCBidWlsZGVyLnJlbmRlcmVyLmNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gKSB7XG5cblx0XHRzY3JlZW5Qb3NpdGlvbiA9IHZlYzIoIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnkub25lTWludXMoKSApLm11bCggMi4wICkuc3ViKCAxLjAgKTtcblx0XHRjbGlwU3BhY2VQb3NpdGlvbiA9IHZlYzQoIHZlYzMoIHNjcmVlblBvc2l0aW9uLCBkZXB0aCApLCAxLjAgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Y2xpcFNwYWNlUG9zaXRpb24gPSB2ZWM0KCB2ZWMzKCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55Lm9uZU1pbnVzKCksIGRlcHRoICkubXVsKCAyLjAgKS5zdWIoIDEuMCApLCAxLjAgKTtcblxuXHR9XG5cblx0Y29uc3Qgdmlld1NwYWNlUG9zaXRpb24gPSB2ZWM0KCBwcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5tdWwoIGNsaXBTcGFjZVBvc2l0aW9uICkgKTtcblxuXHRyZXR1cm4gdmlld1NwYWNlUG9zaXRpb24ueHl6LmRpdiggdmlld1NwYWNlUG9zaXRpb24udyApO1xuXG59ICk7XG5cbi8qKlxuKiBDb21wdXRlcyBhIHNjcmVlbiBwb3NpdGlvbiBleHByZXNzZWQgYXMgdXYgY29vcmRpbmF0ZXMgYmFzZWQgb24gYSBmcmFnbWVudCdzIHBvc2l0aW9uIGluIHZpZXcgc3BhY2VcbiogYW5kIHRoZSBjYW1lcmEncyBwcm9qZWN0aW9uIG1hdHJpeFxuKlxuKiBAcGFyYW0ge3ZlYzN9IHZpZXdQb3NpdGlvbiAtIFRoZSBmcmFnbWVudHMgcG9zaXRpb24gaW4gdmlldyBzcGFjZS5cbiogQHBhcmFtIHttYXQ0fSBwcm9qZWN0aW9uTWF0cml4IC0gVGhlIGNhbWVyYSdzIHByb2plY3Rpb24gbWF0cml4LlxuKiBAcmV0dXJuIHt2ZWMyfSBUaGUgZnJhZ21lbnQncyBzY3JlZW4gcG9zaXRpb24gZXhwcmVzc2VkIGFzIHV2IGNvb3JkaW5hdGVzLlxuKi9cbmV4cG9ydCBjb25zdCBnZXRTY3JlZW5Qb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB2aWV3UG9zaXRpb24sIHByb2plY3Rpb25NYXRyaXggXSApID0+IHtcblxuXHRjb25zdCBzYW1wbGVDbGlwUG9zID0gcHJvamVjdGlvbk1hdHJpeC5tdWwoIHZlYzQoIHZpZXdQb3NpdGlvbiwgMS4wICkgKTtcblx0Y29uc3Qgc2FtcGxlVXYgPSBzYW1wbGVDbGlwUG9zLnh5LmRpdiggc2FtcGxlQ2xpcFBvcy53ICkubXVsKCAwLjUgKS5hZGQoIDAuNSApLnRvVmFyKCk7XG5cdHJldHVybiB2ZWMyKCBzYW1wbGVVdi54LCBzYW1wbGVVdi55Lm9uZU1pbnVzKCkgKTtcblxufSApO1xuXG4vKipcbiogQ29tcHV0ZXMgYSBub3JtYWwgdmVjdG9yIGJhc2VkIG9uIGRlcHRoIGRhdGEuIENhbiBiZSB1c2VkIGFzIGEgZmFsbGJhY2sgd2hlbiBubyBub3JtYWwgcmVuZGVyXG4qIHRhcmdldCBpcyBhdmFpbGFibGUgb3IgaWYgZmxhdCBzdXJmYWNlIG5vcm1hbHMgYXJlIHJlcXVpcmVkLlxuKlxuKiBAcGFyYW0ge3ZlYzJ9IHV2IC0gVGhlIHRleHR1cmUgY29vcmRpbmF0ZS5cbiogQHBhcmFtIHtEZXB0aFRleHR1cmV9IGRlcHRoVGV4dHVyZSAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuKiBAcGFyYW0ge21hdDR9IHByb2plY3Rpb25NYXRyaXhJbnZlcnNlIC0gVGhlIGNhbWVyYSdzIGludmVyc2UgcHJvamVjdGlvbiBtYXRyaXguXG4qIEByZXR1cm4ge3ZlYzN9IFRoZSBjb21wdXRlZCBub3JtYWwgdmVjdG9yLlxuKi9cbmV4cG9ydCBjb25zdCBnZXROb3JtYWxGcm9tRGVwdGggPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdXYsIGRlcHRoVGV4dHVyZSwgcHJvamVjdGlvbk1hdHJpeEludmVyc2UgXSApID0+IHtcblxuXHRjb25zdCBzaXplID0gdGV4dHVyZVNpemUoIHRleHR1cmVMb2FkKCBkZXB0aFRleHR1cmUgKSApO1xuXHRjb25zdCBwID0gaXZlYzIoIHV2Lm11bCggc2l6ZSApICkudG9WYXIoKTtcblxuXHRjb25zdCBjMCA9IHRleHR1cmVMb2FkKCBkZXB0aFRleHR1cmUsIHAgKS50b1ZhcigpO1xuXG5cdGNvbnN0IGwyID0gdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSwgcC5zdWIoIGl2ZWMyKCAyLCAwICkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IGwxID0gdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSwgcC5zdWIoIGl2ZWMyKCAxLCAwICkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHIxID0gdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSwgcC5hZGQoIGl2ZWMyKCAxLCAwICkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHIyID0gdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSwgcC5hZGQoIGl2ZWMyKCAyLCAwICkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IGIyID0gdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSwgcC5hZGQoIGl2ZWMyKCAwLCAyICkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IGIxID0gdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSwgcC5hZGQoIGl2ZWMyKCAwLCAxICkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHQxID0gdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSwgcC5zdWIoIGl2ZWMyKCAwLCAxICkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHQyID0gdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSwgcC5zdWIoIGl2ZWMyKCAwLCAyICkgKSApLnRvVmFyKCk7XG5cblx0Y29uc3QgZGwgPSBhYnMoIHN1YiggZmxvYXQoIDIgKS5tdWwoIGwxICkuc3ViKCBsMiApLCBjMCApICkudG9WYXIoKTtcblx0Y29uc3QgZHIgPSBhYnMoIHN1YiggZmxvYXQoIDIgKS5tdWwoIHIxICkuc3ViKCByMiApLCBjMCApICkudG9WYXIoKTtcblx0Y29uc3QgZGIgPSBhYnMoIHN1YiggZmxvYXQoIDIgKS5tdWwoIGIxICkuc3ViKCBiMiApLCBjMCApICkudG9WYXIoKTtcblx0Y29uc3QgZHQgPSBhYnMoIHN1YiggZmxvYXQoIDIgKS5tdWwoIHQxICkuc3ViKCB0MiApLCBjMCApICkudG9WYXIoKTtcblxuXHRjb25zdCBjZSA9IGdldFZpZXdQb3NpdGlvbiggdXYsIGMwLCBwcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApLnRvVmFyKCk7XG5cblx0Y29uc3QgZHBkeCA9IGRsLmxlc3NUaGFuKCBkciApLnNlbGVjdCggY2Uuc3ViKCBnZXRWaWV3UG9zaXRpb24oIHV2LnN1YiggdmVjMiggZmxvYXQoIDEgKS5kaXYoIHNpemUueCApLCAwICkgKSwgbDEsIHByb2plY3Rpb25NYXRyaXhJbnZlcnNlICkgKSwgY2UubmVnYXRlKCkuYWRkKCBnZXRWaWV3UG9zaXRpb24oIHV2LmFkZCggdmVjMiggZmxvYXQoIDEgKS5kaXYoIHNpemUueCApLCAwICkgKSwgcjEsIHByb2plY3Rpb25NYXRyaXhJbnZlcnNlICkgKSApO1xuXHRjb25zdCBkcGR5ID0gZGIubGVzc1RoYW4oIGR0ICkuc2VsZWN0KCBjZS5zdWIoIGdldFZpZXdQb3NpdGlvbiggdXYuYWRkKCB2ZWMyKCAwLCBmbG9hdCggMSApLmRpdiggc2l6ZS55ICkgKSApLCBiMSwgcHJvamVjdGlvbk1hdHJpeEludmVyc2UgKSApLCBjZS5uZWdhdGUoKS5hZGQoIGdldFZpZXdQb3NpdGlvbiggdXYuc3ViKCB2ZWMyKCAwLCBmbG9hdCggMSApLmRpdiggc2l6ZS55ICkgKSApLCB0MSwgcHJvamVjdGlvbk1hdHJpeEludmVyc2UgKSApICk7XG5cblx0cmV0dXJuIG5vcm1hbGl6ZSggY3Jvc3MoIGRwZHgsIGRwZHkgKSApO1xuXG59ICk7XG4iLCJpbXBvcnQgeyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9jb3JlL0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qcyc7XG5cbmNsYXNzIFN0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIHR5cGVDbGFzcyA9IEZsb2F0MzJBcnJheSApIHtcblxuXHRcdGlmICggQXJyYXlCdWZmZXIuaXNWaWV3KCBhcnJheSApID09PSBmYWxzZSApIGFycmF5ID0gbmV3IHR5cGVDbGFzcyggYXJyYXkgKiBpdGVtU2l6ZSApO1xuXG5cdFx0c3VwZXIoIGFycmF5LCBpdGVtU2l6ZSApO1xuXG5cdFx0dGhpcy5pc1N0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTdG9yYWdlSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlO1xuIiwiaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuXG5jbGFzcyBTdG9yYWdlQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCB0eXBlQ2xhc3MgPSBGbG9hdDMyQXJyYXkgKSB7XG5cblx0XHRpZiAoIEFycmF5QnVmZmVyLmlzVmlldyggYXJyYXkgKSA9PT0gZmFsc2UgKSBhcnJheSA9IG5ldyB0eXBlQ2xhc3MoIGFycmF5ICogaXRlbVNpemUgKTtcblxuXHRcdHN1cGVyKCBhcnJheSwgaXRlbVNpemUgKTtcblxuXHRcdHRoaXMuaXNTdG9yYWdlQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZUJ1ZmZlckF0dHJpYnV0ZTtcbiIsImltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCBBcnJheUVsZW1lbnROb2RlIGZyb20gJy4vQXJyYXlFbGVtZW50Tm9kZS5qcyc7XG5cbmNsYXNzIFN0b3JhZ2VBcnJheUVsZW1lbnROb2RlIGV4dGVuZHMgQXJyYXlFbGVtZW50Tm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdTdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBzdG9yYWdlQnVmZmVyTm9kZSwgaW5kZXhOb2RlICkge1xuXG5cdFx0c3VwZXIoIHN0b3JhZ2VCdWZmZXJOb2RlLCBpbmRleE5vZGUgKTtcblxuXHRcdHRoaXMuaXNTdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSA9IHRydWU7XG5cblx0fVxuXG5cdHNldCBzdG9yYWdlQnVmZmVyTm9kZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLm5vZGUgPSB2YWx1ZTtcblxuXHR9XG5cblx0Z2V0IHN0b3JhZ2VCdWZmZXJOb2RlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9kZTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRpZiAoIGJ1aWxkZXIuaXNBdmFpbGFibGUoICdzdG9yYWdlQnVmZmVyJyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGUuaXNQQk8gPT09IHRydWUgKSB7XG5cblx0XHRcdFx0YnVpbGRlci5zZXR1cFBCTyggdGhpcy5ub2RlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBzdXBlci5zZXR1cCggYnVpbGRlciApO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xuXG5cdFx0bGV0IHNuaXBwZXQ7XG5cblx0XHRjb25zdCBpc0Fzc2lnbkNvbnRleHQgPSBidWlsZGVyLmNvbnRleHQuYXNzaWduO1xuXG5cdFx0Ly9cblxuXHRcdGlmICggYnVpbGRlci5pc0F2YWlsYWJsZSggJ3N0b3JhZ2VCdWZmZXInICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZS5pc1BCTyA9PT0gdHJ1ZSAmJiBpc0Fzc2lnbkNvbnRleHQgIT09IHRydWUgJiYgKCB0aGlzLm5vZGUudmFsdWUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgfHwgYnVpbGRlci5zaGFkZXJTdGFnZSAhPT0gJ2NvbXB1dGUnICkgKSB7XG5cblx0XHRcdFx0c25pcHBldCA9IGJ1aWxkZXIuZ2VuZXJhdGVQQk8oIHRoaXMgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzbmlwcGV0ID0gdGhpcy5ub2RlLmJ1aWxkKCBidWlsZGVyICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHNuaXBwZXQgPSBzdXBlci5nZW5lcmF0ZSggYnVpbGRlciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Fzc2lnbkNvbnRleHQgIT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0XHRcdHNuaXBwZXQgPSBidWlsZGVyLmZvcm1hdCggc25pcHBldCwgdHlwZSwgb3V0cHV0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc25pcHBldDtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZUFycmF5RWxlbWVudE5vZGU7XG5cbmV4cG9ydCBjb25zdCBzdG9yYWdlRWxlbWVudCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBTdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSApO1xuIiwiaW1wb3J0IEJ1ZmZlck5vZGUgZnJvbSAnLi9CdWZmZXJOb2RlLmpzJztcbmltcG9ydCB7IGJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4vQnVmZmVyQXR0cmlidXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlT2JqZWN0LCB2YXJ5aW5nIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgc3RvcmFnZUVsZW1lbnQgfSBmcm9tICcuLi91dGlscy9TdG9yYWdlQXJyYXlFbGVtZW50Tm9kZS5qcyc7XG5pbXBvcnQgeyBOb2RlQWNjZXNzIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2V0VHlwZUZyb21MZW5ndGggfSBmcm9tICcuLi9jb3JlL05vZGVVdGlscy5qcyc7XG5cbmNsYXNzIFN0b3JhZ2VCdWZmZXJOb2RlIGV4dGVuZHMgQnVmZmVyTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdTdG9yYWdlQnVmZmVyTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCB2YWx1ZSwgYnVmZmVyVHlwZSA9IG51bGwsIGJ1ZmZlckNvdW50ID0gMCApIHtcblxuXHRcdGlmICggYnVmZmVyVHlwZSA9PT0gbnVsbCAmJiAoIHZhbHVlLmlzU3RvcmFnZUJ1ZmZlckF0dHJpYnV0ZSB8fCB2YWx1ZS5pc1N0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSApIHtcblxuXHRcdFx0YnVmZmVyVHlwZSA9IGdldFR5cGVGcm9tTGVuZ3RoKCB2YWx1ZS5pdGVtU2l6ZSApO1xuXHRcdFx0YnVmZmVyQ291bnQgPSB2YWx1ZS5jb3VudDtcblxuXHRcdH1cblxuXHRcdHN1cGVyKCB2YWx1ZSwgYnVmZmVyVHlwZSwgYnVmZmVyQ291bnQgKTtcblxuXHRcdHRoaXMuaXNTdG9yYWdlQnVmZmVyTm9kZSA9IHRydWU7XG5cblx0XHR0aGlzLmFjY2VzcyA9IE5vZGVBY2Nlc3MuUkVBRF9XUklURTtcblx0XHR0aGlzLmlzQXRvbWljID0gZmFsc2U7XG5cdFx0dGhpcy5pc1BCTyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5idWZmZXJDb3VudCA9IGJ1ZmZlckNvdW50O1xuXG5cdFx0dGhpcy5fYXR0cmlidXRlID0gbnVsbDtcblx0XHR0aGlzLl92YXJ5aW5nID0gbnVsbDtcblxuXHRcdHRoaXMuZ2xvYmFsID0gdHJ1ZTtcblxuXHRcdGlmICggdmFsdWUuaXNTdG9yYWdlQnVmZmVyQXR0cmlidXRlICE9PSB0cnVlICYmIHZhbHVlLmlzU3RvcmFnZUluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0Ly8gVE9PRDogSW1wcm92ZSBpdCwgcG9zc2libHkgYWRkaW5nIGEgbmV3IHByb3BlcnR5IHRvIHRoZSBCdWZmZXJBdHRyaWJ1dGUgdG8gaWRlbnRpZnkgaXQgYXMgYSBzdG9yYWdlIGJ1ZmZlciByZWFkLW9ubHkgYXR0cmlidXRlIGluIFJlbmRlcmVyXG5cblx0XHRcdGlmICggdmFsdWUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB2YWx1ZS5pc1N0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXHRcdFx0ZWxzZSB2YWx1ZS5pc1N0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRnZXRIYXNoKCBidWlsZGVyICkge1xuXG5cdFx0aWYgKCB0aGlzLmJ1ZmZlckNvdW50ID09PSAwICkge1xuXG5cdFx0XHRsZXQgYnVmZmVyRGF0YSA9IGJ1aWxkZXIuZ2xvYmFsQ2FjaGUuZ2V0RGF0YSggdGhpcy52YWx1ZSApO1xuXG5cdFx0XHRpZiAoIGJ1ZmZlckRhdGEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRidWZmZXJEYXRhID0ge1xuXHRcdFx0XHRcdG5vZGU6IHRoaXNcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRidWlsZGVyLmdsb2JhbENhY2hlLnNldERhdGEoIHRoaXMudmFsdWUsIGJ1ZmZlckRhdGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVmZmVyRGF0YS5ub2RlLnV1aWQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy51dWlkO1xuXG5cdH1cblxuXHRnZXRJbnB1dFR5cGUoIC8qYnVpbGRlciovICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudmFsdWUuaXNJbmRpcmVjdFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgPyAnaW5kaXJlY3RTdG9yYWdlQnVmZmVyJyA6ICdzdG9yYWdlQnVmZmVyJztcblxuXHR9XG5cblx0ZWxlbWVudCggaW5kZXhOb2RlICkge1xuXG5cdFx0cmV0dXJuIHN0b3JhZ2VFbGVtZW50KCB0aGlzLCBpbmRleE5vZGUgKTtcblxuXHR9XG5cblx0c2V0UEJPKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuaXNQQk8gPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRQQk8oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pc1BCTztcblxuXHR9XG5cblx0c2V0QWNjZXNzKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuYWNjZXNzID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9SZWFkT25seSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEFjY2VzcyggTm9kZUFjY2Vzcy5SRUFEX09OTFkgKTtcblxuXHR9XG5cblx0c2V0QXRvbWljKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuaXNBdG9taWMgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0F0b21pYygpIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEF0b21pYyggdHJ1ZSApO1xuXG5cdH1cblxuXHRnZXRBdHRyaWJ1dGVEYXRhKCkge1xuXG5cdFx0aWYgKCB0aGlzLl9hdHRyaWJ1dGUgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2F0dHJpYnV0ZSA9IGJ1ZmZlckF0dHJpYnV0ZSggdGhpcy52YWx1ZSApO1xuXHRcdFx0dGhpcy5fdmFyeWluZyA9IHZhcnlpbmcoIHRoaXMuX2F0dHJpYnV0ZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGF0dHJpYnV0ZTogdGhpcy5fYXR0cmlidXRlLFxuXHRcdFx0dmFyeWluZzogdGhpcy5fdmFyeWluZ1xuXHRcdH07XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0aWYgKCBidWlsZGVyLmlzQXZhaWxhYmxlKCAnc3RvcmFnZUJ1ZmZlcicgKSB8fCBidWlsZGVyLmlzQXZhaWxhYmxlKCAnaW5kaXJlY3RTdG9yYWdlQnVmZmVyJyApICkge1xuXG5cdFx0XHRyZXR1cm4gc3VwZXIuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHsgYXR0cmlidXRlIH0gPSB0aGlzLmdldEF0dHJpYnV0ZURhdGEoKTtcblxuXHRcdHJldHVybiBhdHRyaWJ1dGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRpZiAoIGJ1aWxkZXIuaXNBdmFpbGFibGUoICdzdG9yYWdlQnVmZmVyJyApIHx8IGJ1aWxkZXIuaXNBdmFpbGFibGUoICdpbmRpcmVjdFN0b3JhZ2VCdWZmZXInICkgKSB7XG5cblx0XHRcdHJldHVybiBzdXBlci5nZW5lcmF0ZSggYnVpbGRlciApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgeyBhdHRyaWJ1dGUsIHZhcnlpbmcgfSA9IHRoaXMuZ2V0QXR0cmlidXRlRGF0YSgpO1xuXG5cdFx0Y29uc3Qgb3V0cHV0ID0gdmFyeWluZy5idWlsZCggYnVpbGRlciApO1xuXG5cdFx0YnVpbGRlci5yZWdpc3RlclRyYW5zZm9ybSggb3V0cHV0LCBhdHRyaWJ1dGUgKTtcblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0b3JhZ2VCdWZmZXJOb2RlO1xuXG5leHBvcnQgY29uc3Qgc3RvcmFnZSA9ICggdmFsdWUsIHR5cGUsIGNvdW50ICkgPT4gbm9kZU9iamVjdCggbmV3IFN0b3JhZ2VCdWZmZXJOb2RlKCB2YWx1ZSwgdHlwZSwgY291bnQgKSApO1xuXG5leHBvcnQgY29uc3Qgc3RvcmFnZU9iamVjdCA9ICggdmFsdWUsIHR5cGUsIGNvdW50ICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE3MVxuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlRTTDogXCJzdG9yYWdlT2JqZWN0KClcIiBpcyBkZXByZWNhdGVkLiBVc2UgXCJzdG9yYWdlKCkuc2V0UEJPKCB0cnVlIClcIiBpbnN0ZWFkLicgKTtcblxuXHRyZXR1cm4gc3RvcmFnZSggdmFsdWUsIHR5cGUsIGNvdW50ICkuc2V0UEJPKCB0cnVlICk7XG5cbn07XG4iLCJpbXBvcnQgU3RvcmFnZUluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvY29tbW9uL1N0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgZnJvbSAnLi4vLi4vcmVuZGVyZXJzL2NvbW1vbi9TdG9yYWdlQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IHN0b3JhZ2UgfSBmcm9tICcuL1N0b3JhZ2VCdWZmZXJOb2RlLmpzJztcbmltcG9ydCB7IGdldExlbmd0aEZyb21UeXBlIH0gZnJvbSAnLi4vY29yZS9Ob2RlVXRpbHMuanMnO1xuXG5leHBvcnQgY29uc3QgYXR0cmlidXRlQXJyYXkgPSAoIGNvdW50LCB0eXBlID0gJ2Zsb2F0JyApID0+IHtcblxuXHRjb25zdCBpdGVtU2l6ZSA9IGdldExlbmd0aEZyb21UeXBlKCB0eXBlICk7XG5cblx0Y29uc3QgYnVmZmVyID0gbmV3IFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUoIGNvdW50LCBpdGVtU2l6ZSApO1xuXHRjb25zdCBub2RlID0gc3RvcmFnZSggYnVmZmVyLCB0eXBlLCBjb3VudCApO1xuXG5cdHJldHVybiBub2RlO1xuXG59O1xuXG5cbmV4cG9ydCBjb25zdCBpbnN0YW5jZWRBcnJheSA9ICggY291bnQsIHR5cGUgPSAnZmxvYXQnICkgPT4ge1xuXG5cdGNvbnN0IGl0ZW1TaXplID0gZ2V0TGVuZ3RoRnJvbVR5cGUoIHR5cGUgKTtcblxuXHRjb25zdCBidWZmZXIgPSBuZXcgU3RvcmFnZUluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggY291bnQsIGl0ZW1TaXplICk7XG5cdGNvbnN0IG5vZGUgPSBzdG9yYWdlKCBidWZmZXIsIHR5cGUsIGNvdW50ICk7XG5cblx0cmV0dXJuIG5vZGU7XG5cbn07XG4iLCJpbXBvcnQgQXR0cmlidXRlTm9kZSBmcm9tICcuLi9jb3JlL0F0dHJpYnV0ZU5vZGUuanMnO1xuaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yNC5qcyc7XG5cbmNsYXNzIFZlcnRleENvbG9yTm9kZSBleHRlbmRzIEF0dHJpYnV0ZU5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnVmVydGV4Q29sb3JOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGluZGV4ID0gMCApIHtcblxuXHRcdHN1cGVyKCBudWxsLCAndmVjNCcgKTtcblxuXHRcdHRoaXMuaXNWZXJ0ZXhDb2xvck5vZGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5pbmRleCA9IGluZGV4O1xuXG5cdH1cblxuXHRnZXRBdHRyaWJ1dGVOYW1lKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcblxuXHRcdHJldHVybiAnY29sb3InICsgKCBpbmRleCA+IDAgPyBpbmRleCA6ICcnICk7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlTmFtZSggYnVpbGRlciApO1xuXHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlID0gYnVpbGRlci5oYXNHZW9tZXRyeUF0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSApO1xuXG5cdFx0bGV0IHJlc3VsdDtcblxuXHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgPT09IHRydWUgKSB7XG5cblx0XHRcdHJlc3VsdCA9IHN1cGVyLmdlbmVyYXRlKCBidWlsZGVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBWZXJ0ZXggY29sb3IgZmFsbGJhY2sgc2hvdWxkIGJlIHdoaXRlXG5cdFx0XHRyZXN1bHQgPSBidWlsZGVyLmdlbmVyYXRlQ29uc3QoIHRoaXMubm9kZVR5cGUsIG5ldyBWZWN0b3I0KCAxLCAxLCAxLCAxICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcblxuXHRcdHN1cGVyLnNlcmlhbGl6ZSggZGF0YSApO1xuXG5cdFx0ZGF0YS5pbmRleCA9IHRoaXMuaW5kZXg7XG5cblx0fVxuXG5cdGRlc2VyaWFsaXplKCBkYXRhICkge1xuXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcblxuXHRcdHRoaXMuaW5kZXggPSBkYXRhLmluZGV4O1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBWZXJ0ZXhDb2xvck5vZGU7XG5cbmV4cG9ydCBjb25zdCB2ZXJ0ZXhDb2xvciA9ICggLi4ucGFyYW1zICkgPT4gbm9kZU9iamVjdCggbmV3IFZlcnRleENvbG9yTm9kZSggLi4ucGFyYW1zICkgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlSW1tdXRhYmxlIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5jbGFzcyBQb2ludFVWTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnUG9pbnRVVk5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCAndmVjMicgKTtcblxuXHRcdHRoaXMuaXNQb2ludFVWTm9kZSA9IHRydWU7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdHJldHVybiAndmVjMiggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnkgKSc7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvaW50VVZOb2RlO1xuXG5leHBvcnQgY29uc3QgcG9pbnRVViA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUG9pbnRVVk5vZGUgKTtcbiIsImltcG9ydCB7IFVWTWFwcGluZyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBFdWxlciB9IGZyb20gJy4uLy4uL21hdGgvRXVsZXIuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xuaW1wb3J0IHsgcmVuZGVyR3JvdXAgfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Hcm91cE5vZGUuanMnO1xuaW1wb3J0IHsgbm9kZUltbXV0YWJsZSwgdW5pZm9ybSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IHJlZmVyZW5jZSB9IGZyb20gJy4vUmVmZXJlbmNlTm9kZS5qcyc7XG5cbmNvbnN0IF9lMSA9IC8qQF9fUFVSRV9fKi8gbmV3IEV1bGVyKCk7XG5jb25zdCBfbTEgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5cbmNsYXNzIFNjZW5lTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnU2NlbmVOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHNjb3BlID0gU2NlbmVOb2RlLkJBQ0tHUk9VTkRfQkxVUlJJTkVTUywgc2NlbmUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuc2NvcGUgPSBzY29wZTtcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xuXHRcdGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZSAhPT0gbnVsbCA/IHRoaXMuc2NlbmUgOiBidWlsZGVyLnNjZW5lO1xuXG5cdFx0bGV0IG91dHB1dDtcblxuXHRcdGlmICggc2NvcGUgPT09IFNjZW5lTm9kZS5CQUNLR1JPVU5EX0JMVVJSSU5FU1MgKSB7XG5cblx0XHRcdG91dHB1dCA9IHJlZmVyZW5jZSggJ2JhY2tncm91bmRCbHVycmluZXNzJywgJ2Zsb2F0Jywgc2NlbmUgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBTY2VuZU5vZGUuQkFDS0dST1VORF9JTlRFTlNJVFkgKSB7XG5cblx0XHRcdG91dHB1dCA9IHJlZmVyZW5jZSggJ2JhY2tncm91bmRJbnRlbnNpdHknLCAnZmxvYXQnLCBzY2VuZSApO1xuXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IFNjZW5lTm9kZS5CQUNLR1JPVU5EX1JPVEFUSU9OICkge1xuXG5cdFx0XHRvdXRwdXQgPSB1bmlmb3JtKCAnbWF0NCcgKS5sYWJlbCggJ2JhY2tncm91bmRSb3RhdGlvbicgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCkgPT4ge1xuXG5cdFx0XHRcdGNvbnN0IGJhY2tncm91bmQgPSBzY2VuZS5iYWNrZ3JvdW5kO1xuXG5cdFx0XHRcdGlmICggYmFja2dyb3VuZCAhPT0gbnVsbCAmJiBiYWNrZ3JvdW5kLmlzVGV4dHVyZSAmJiBiYWNrZ3JvdW5kLm1hcHBpbmcgIT09IFVWTWFwcGluZyApIHtcblxuXHRcdFx0XHRcdF9lMS5jb3B5KCBzY2VuZS5iYWNrZ3JvdW5kUm90YXRpb24gKTtcblxuXHRcdFx0XHRcdC8vIGFjY29tbW9kYXRlIGxlZnQtaGFuZGVkIGZyYW1lXG5cdFx0XHRcdFx0X2UxLnggKj0gLSAxOyBfZTEueSAqPSAtIDE7IF9lMS56ICo9IC0gMTtcblxuXHRcdFx0XHRcdF9tMS5tYWtlUm90YXRpb25Gcm9tRXVsZXIoIF9lMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRfbTEuaWRlbnRpdHkoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIF9tMTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNjZW5lTm9kZTogVW5rbm93biBzY29wZTonLCBzY29wZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHR9XG5cbn1cblxuU2NlbmVOb2RlLkJBQ0tHUk9VTkRfQkxVUlJJTkVTUyA9ICdiYWNrZ3JvdW5kQmx1cnJpbmVzcyc7XG5TY2VuZU5vZGUuQkFDS0dST1VORF9JTlRFTlNJVFkgPSAnYmFja2dyb3VuZEludGVuc2l0eSc7XG5TY2VuZU5vZGUuQkFDS0dST1VORF9ST1RBVElPTiA9ICdiYWNrZ3JvdW5kUm90YXRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBTY2VuZU5vZGU7XG5cbmV4cG9ydCBjb25zdCBiYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggU2NlbmVOb2RlLCBTY2VuZU5vZGUuQkFDS0dST1VORF9CTFVSUklORVNTICk7XG5leHBvcnQgY29uc3QgYmFja2dyb3VuZEludGVuc2l0eSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggU2NlbmVOb2RlLCBTY2VuZU5vZGUuQkFDS0dST1VORF9JTlRFTlNJVFkgKTtcbmV4cG9ydCBjb25zdCBiYWNrZ3JvdW5kUm90YXRpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFNjZW5lTm9kZSwgU2NlbmVOb2RlLkJBQ0tHUk9VTkRfUk9UQVRJT04gKTtcbiIsImltcG9ydCBUZXh0dXJlTm9kZSBmcm9tICcuL1RleHR1cmVOb2RlLmpzJztcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IE5vZGVBY2Nlc3MgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XG5cbmNsYXNzIFN0b3JhZ2VUZXh0dXJlTm9kZSBleHRlbmRzIFRleHR1cmVOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1N0b3JhZ2VUZXh0dXJlTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCB2YWx1ZSwgdXZOb2RlLCBzdG9yZU5vZGUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoIHZhbHVlLCB1dk5vZGUgKTtcblxuXHRcdHRoaXMuc3RvcmVOb2RlID0gc3RvcmVOb2RlO1xuXG5cdFx0dGhpcy5pc1N0b3JhZ2VUZXh0dXJlTm9kZSA9IHRydWU7XG5cblx0XHR0aGlzLmFjY2VzcyA9IE5vZGVBY2Nlc3MuV1JJVEVfT05MWTtcblxuXHR9XG5cblx0Z2V0SW5wdXRUeXBlKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdHJldHVybiAnc3RvcmFnZVRleHR1cmUnO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdHN1cGVyLnNldHVwKCBidWlsZGVyICk7XG5cblx0XHRjb25zdCBwcm9wZXJ0aWVzID0gYnVpbGRlci5nZXROb2RlUHJvcGVydGllcyggdGhpcyApO1xuXHRcdHByb3BlcnRpZXMuc3RvcmVOb2RlID0gdGhpcy5zdG9yZU5vZGU7XG5cblx0fVxuXG5cdHNldEFjY2VzcyggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmFjY2VzcyA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xuXG5cdFx0bGV0IHNuaXBwZXQ7XG5cblx0XHRpZiAoIHRoaXMuc3RvcmVOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRzbmlwcGV0ID0gdGhpcy5nZW5lcmF0ZVN0b3JlKCBidWlsZGVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzbmlwcGV0ID0gc3VwZXIuZ2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNuaXBwZXQ7XG5cblx0fVxuXG5cdHRvUmVhZFdyaXRlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWNjZXNzKCBOb2RlQWNjZXNzLlJFQURfV1JJVEUgKTtcblxuXHR9XG5cblx0dG9SZWFkT25seSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEFjY2VzcyggTm9kZUFjY2Vzcy5SRUFEX09OTFkgKTtcblxuXHR9XG5cblx0dG9Xcml0ZU9ubHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRBY2Nlc3MoIE5vZGVBY2Nlc3MuV1JJVEVfT05MWSApO1xuXG5cdH1cblxuXHRnZW5lcmF0ZVN0b3JlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgcHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcblxuXHRcdGNvbnN0IHsgdXZOb2RlLCBzdG9yZU5vZGUgfSA9IHByb3BlcnRpZXM7XG5cblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydHkgPSBzdXBlci5nZW5lcmF0ZSggYnVpbGRlciwgJ3Byb3BlcnR5JyApO1xuXHRcdGNvbnN0IHV2U25pcHBldCA9IHV2Tm9kZS5idWlsZCggYnVpbGRlciwgJ3V2ZWMyJyApO1xuXHRcdGNvbnN0IHN0b3JlU25pcHBldCA9IHN0b3JlTm9kZS5idWlsZCggYnVpbGRlciwgJ3ZlYzQnICk7XG5cblx0XHRjb25zdCBzbmlwcGV0ID0gYnVpbGRlci5nZW5lcmF0ZVRleHR1cmVTdG9yZSggYnVpbGRlciwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIHN0b3JlU25pcHBldCApO1xuXG5cdFx0YnVpbGRlci5hZGRMaW5lRmxvd0NvZGUoIHNuaXBwZXQsIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZVRleHR1cmVOb2RlO1xuXG5leHBvcnQgY29uc3Qgc3RvcmFnZVRleHR1cmUgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggU3RvcmFnZVRleHR1cmVOb2RlICk7XG5cbmV4cG9ydCBjb25zdCB0ZXh0dXJlU3RvcmUgPSAoIHZhbHVlLCB1dk5vZGUsIHN0b3JlTm9kZSApID0+IHtcblxuXHRjb25zdCBub2RlID0gc3RvcmFnZVRleHR1cmUoIHZhbHVlLCB1dk5vZGUsIHN0b3JlTm9kZSApO1xuXG5cdGlmICggc3RvcmVOb2RlICE9PSBudWxsICkgbm9kZS5hcHBlbmQoKTtcblxuXHRyZXR1cm4gbm9kZTtcblxufTtcbiIsImltcG9ydCBSZWZlcmVuY2VOb2RlIGZyb20gJy4vUmVmZXJlbmNlTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5jbGFzcyBVc2VyRGF0YU5vZGUgZXh0ZW5kcyBSZWZlcmVuY2VOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1VzZXJEYXRhTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBwcm9wZXJ0eSwgaW5wdXRUeXBlLCB1c2VyRGF0YSA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggcHJvcGVydHksIGlucHV0VHlwZSwgdXNlckRhdGEgKTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSB1c2VyRGF0YTtcblxuXHR9XG5cblx0dXBkYXRlUmVmZXJlbmNlKCBzdGF0ZSApIHtcblxuXHRcdHRoaXMucmVmZXJlbmNlID0gdGhpcy51c2VyRGF0YSAhPT0gbnVsbCA/IHRoaXMudXNlckRhdGEgOiBzdGF0ZS5vYmplY3QudXNlckRhdGE7XG5cblx0XHRyZXR1cm4gdGhpcy5yZWZlcmVuY2U7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFVzZXJEYXRhTm9kZTtcblxuZXhwb3J0IGNvbnN0IHVzZXJEYXRhID0gKCBuYW1lLCBpbnB1dFR5cGUsIHVzZXJEYXRhICkgPT4gbm9kZU9iamVjdCggbmV3IFVzZXJEYXRhTm9kZSggbmFtZSwgaW5wdXRUeXBlLCB1c2VyRGF0YSApICk7XG4iLCJpbXBvcnQgVGVtcE5vZGUgZnJvbSAnLi4vY29yZS9UZW1wTm9kZS5qcyc7XG5pbXBvcnQgeyBtb2RlbFZpZXdNYXRyaXggfSBmcm9tICcuL01vZGVsTm9kZS5qcyc7XG5pbXBvcnQgeyBwb3NpdGlvbkxvY2FsLCBwb3NpdGlvblByZXZpb3VzIH0gZnJvbSAnLi9Qb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBub2RlSW1tdXRhYmxlIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRyaXg0LmpzJztcbmltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcbmltcG9ydCB7IHN1YiB9IGZyb20gJy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJztcbmltcG9ydCB7IGNhbWVyYVByb2plY3Rpb25NYXRyaXggfSBmcm9tICcuL0NhbWVyYS5qcyc7XG5pbXBvcnQgeyByZW5kZXJHcm91cCB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybUdyb3VwTm9kZS5qcyc7XG5cbmNvbnN0IF9vYmplY3REYXRhID0gbmV3IFdlYWtNYXAoKTtcblxuY2xhc3MgVmVsb2NpdHlOb2RlIGV4dGVuZHMgVGVtcE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnVmVsb2NpdHlOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlciggJ3ZlYzInICk7XG5cblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXggPSBudWxsO1xuXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuT0JKRUNUO1xuXHRcdHRoaXMudXBkYXRlQWZ0ZXJUeXBlID0gTm9kZVVwZGF0ZVR5cGUuT0JKRUNUO1xuXG5cdFx0dGhpcy5wcmV2aW91c01vZGVsV29ybGRNYXRyaXggPSB1bmlmb3JtKCBuZXcgTWF0cml4NCgpICk7XG5cdFx0dGhpcy5wcmV2aW91c1Byb2plY3Rpb25NYXRyaXggPSB1bmlmb3JtKCBuZXcgTWF0cml4NCgpICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XG5cdFx0dGhpcy5wcmV2aW91c0NhbWVyYVZpZXdNYXRyaXggPSB1bmlmb3JtKCBuZXcgTWF0cml4NCgpICk7XG5cblx0fVxuXG5cdHNldFByb2plY3Rpb25NYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKSB7XG5cblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXggPSBwcm9qZWN0aW9uTWF0cml4O1xuXG5cdH1cblxuXHR1cGRhdGUoIHsgZnJhbWVJZCwgY2FtZXJhLCBvYmplY3QgfSApIHtcblxuXHRcdGNvbnN0IHByZXZpb3VzTW9kZWxNYXRyaXggPSBnZXRQcmV2aW91c01hdHJpeCggb2JqZWN0ICk7XG5cblx0XHR0aGlzLnByZXZpb3VzTW9kZWxXb3JsZE1hdHJpeC52YWx1ZS5jb3B5KCBwcmV2aW91c01vZGVsTWF0cml4ICk7XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgY2FtZXJhRGF0YSA9IGdldERhdGEoIGNhbWVyYSApO1xuXG5cdFx0aWYgKCBjYW1lcmFEYXRhLmZyYW1lSWQgIT09IGZyYW1lSWQgKSB7XG5cblx0XHRcdGNhbWVyYURhdGEuZnJhbWVJZCA9IGZyYW1lSWQ7XG5cblx0XHRcdGlmICggY2FtZXJhRGF0YS5wcmV2aW91c1Byb2plY3Rpb25NYXRyaXggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjYW1lcmFEYXRhLnByZXZpb3VzUHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0XHRcdGNhbWVyYURhdGEucHJldmlvdXNDYW1lcmFWaWV3TWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0XHRjYW1lcmFEYXRhLmN1cnJlbnRQcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdFx0Y2FtZXJhRGF0YS5jdXJyZW50Q2FtZXJhVmlld01hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdFx0Y2FtZXJhRGF0YS5wcmV2aW91c1Byb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5wcm9qZWN0aW9uTWF0cml4IHx8IGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0XHRcdGNhbWVyYURhdGEucHJldmlvdXNDYW1lcmFWaWV3TWF0cml4LmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjYW1lcmFEYXRhLnByZXZpb3VzUHJvamVjdGlvbk1hdHJpeC5jb3B5KCBjYW1lcmFEYXRhLmN1cnJlbnRQcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0XHRcdGNhbWVyYURhdGEucHJldmlvdXNDYW1lcmFWaWV3TWF0cml4LmNvcHkoIGNhbWVyYURhdGEuY3VycmVudENhbWVyYVZpZXdNYXRyaXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjYW1lcmFEYXRhLmN1cnJlbnRQcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMucHJvamVjdGlvbk1hdHJpeCB8fCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXHRcdFx0Y2FtZXJhRGF0YS5jdXJyZW50Q2FtZXJhVmlld01hdHJpeC5jb3B5KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0XHRcdHRoaXMucHJldmlvdXNQcm9qZWN0aW9uTWF0cml4LnZhbHVlLmNvcHkoIGNhbWVyYURhdGEucHJldmlvdXNQcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0XHR0aGlzLnByZXZpb3VzQ2FtZXJhVmlld01hdHJpeC52YWx1ZS5jb3B5KCBjYW1lcmFEYXRhLnByZXZpb3VzQ2FtZXJhVmlld01hdHJpeCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGVBZnRlciggeyBvYmplY3QgfSApIHtcblxuXHRcdGdldFByZXZpb3VzTWF0cml4KCBvYmplY3QgKS5jb3B5KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHR9XG5cblx0c2V0dXAoIC8qYnVpbGRlciovICkge1xuXG5cdFx0Y29uc3QgcHJvamVjdGlvbk1hdHJpeCA9ICggdGhpcy5wcm9qZWN0aW9uTWF0cml4ID09PSBudWxsICkgPyBjYW1lcmFQcm9qZWN0aW9uTWF0cml4IDogdW5pZm9ybSggdGhpcy5wcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHRjb25zdCBwcmV2aW91c01vZGVsVmlld01hdHJpeCA9IHRoaXMucHJldmlvdXNDYW1lcmFWaWV3TWF0cml4Lm11bCggdGhpcy5wcmV2aW91c01vZGVsV29ybGRNYXRyaXggKTtcblxuXHRcdGNvbnN0IGNsaXBQb3NpdGlvbkN1cnJlbnQgPSBwcm9qZWN0aW9uTWF0cml4Lm11bCggbW9kZWxWaWV3TWF0cml4ICkubXVsKCBwb3NpdGlvbkxvY2FsICk7XG5cdFx0Y29uc3QgY2xpcFBvc2l0aW9uUHJldmlvdXMgPSB0aGlzLnByZXZpb3VzUHJvamVjdGlvbk1hdHJpeC5tdWwoIHByZXZpb3VzTW9kZWxWaWV3TWF0cml4ICkubXVsKCBwb3NpdGlvblByZXZpb3VzICk7XG5cblx0XHRjb25zdCBuZGNQb3NpdGlvbkN1cnJlbnQgPSBjbGlwUG9zaXRpb25DdXJyZW50Lnh5LmRpdiggY2xpcFBvc2l0aW9uQ3VycmVudC53ICk7XG5cdFx0Y29uc3QgbmRjUG9zaXRpb25QcmV2aW91cyA9IGNsaXBQb3NpdGlvblByZXZpb3VzLnh5LmRpdiggY2xpcFBvc2l0aW9uUHJldmlvdXMudyApO1xuXG5cdFx0Y29uc3QgdmVsb2NpdHkgPSBzdWIoIG5kY1Bvc2l0aW9uQ3VycmVudCwgbmRjUG9zaXRpb25QcmV2aW91cyApO1xuXG5cdFx0cmV0dXJuIHZlbG9jaXR5O1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBnZXREYXRhKCBvYmplY3QgKSB7XG5cblx0bGV0IG9iamVjdERhdGEgPSBfb2JqZWN0RGF0YS5nZXQoIG9iamVjdCApO1xuXG5cdGlmICggb2JqZWN0RGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0b2JqZWN0RGF0YSA9IHt9O1xuXHRcdF9vYmplY3REYXRhLnNldCggb2JqZWN0LCBvYmplY3REYXRhICk7XG5cblx0fVxuXG5cdHJldHVybiBvYmplY3REYXRhO1xuXG59XG5cbmZ1bmN0aW9uIGdldFByZXZpb3VzTWF0cml4KCBvYmplY3QsIGluZGV4ID0gMCApIHtcblxuXHRjb25zdCBvYmplY3REYXRhID0gZ2V0RGF0YSggb2JqZWN0ICk7XG5cblx0bGV0IG1hdHJpeCA9IG9iamVjdERhdGFbIGluZGV4IF07XG5cblx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdG9iamVjdERhdGFbIGluZGV4IF0gPSBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5cdH1cblxuXHRyZXR1cm4gbWF0cml4O1xuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZlbG9jaXR5Tm9kZTtcblxuZXhwb3J0IGNvbnN0IHZlbG9jaXR5ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBWZWxvY2l0eU5vZGUgKTtcbiIsImltcG9ydCB7IEZuLCB2ZWM0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgbWl4LCBtaW4sIHN0ZXAgfSBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJztcblxuZXhwb3J0IGNvbnN0IGJsZW5kQnVybiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBiYXNlLCBibGVuZCBdICkgPT4ge1xuXG5cdHJldHVybiBtaW4oIDEuMCwgYmFzZS5vbmVNaW51cygpLmRpdiggYmxlbmQgKSApLm9uZU1pbnVzKCk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ2JsZW5kQnVybicsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnYmFzZScsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ2JsZW5kJywgdHlwZTogJ3ZlYzMnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgYmxlbmREb2RnZSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBiYXNlLCBibGVuZCBdICkgPT4ge1xuXG5cdHJldHVybiBtaW4oIGJhc2UuZGl2KCBibGVuZC5vbmVNaW51cygpICksIDEuMCApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdibGVuZERvZGdlJyxcblx0dHlwZTogJ3ZlYzMnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdiYXNlJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAnYmxlbmQnLCB0eXBlOiAndmVjMycgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBibGVuZFNjcmVlbiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBiYXNlLCBibGVuZCBdICkgPT4ge1xuXG5cdHJldHVybiBiYXNlLm9uZU1pbnVzKCkubXVsKCBibGVuZC5vbmVNaW51cygpICkub25lTWludXMoKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnYmxlbmRTY3JlZW4nLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ2Jhc2UnLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICdibGVuZCcsIHR5cGU6ICd2ZWMzJyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IGJsZW5kT3ZlcmxheSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBiYXNlLCBibGVuZCBdICkgPT4ge1xuXG5cdHJldHVybiBtaXgoIGJhc2UubXVsKCAyLjAgKS5tdWwoIGJsZW5kICksIGJhc2Uub25lTWludXMoKS5tdWwoIDIuMCApLm11bCggYmxlbmQub25lTWludXMoKSApLm9uZU1pbnVzKCksIHN0ZXAoIDAuNSwgYmFzZSApICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ2JsZW5kT3ZlcmxheScsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnYmFzZScsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ2JsZW5kJywgdHlwZTogJ3ZlYzMnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgYmxlbmRDb2xvciA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBiYXNlLCBibGVuZCBdICkgPT4ge1xuXG5cdGNvbnN0IG91dEFscGhhID0gYmxlbmQuYS5hZGQoIGJhc2UuYS5tdWwoIGJsZW5kLmEub25lTWludXMoKSApICk7XG5cblx0cmV0dXJuIHZlYzQoIGJsZW5kLnJnYi5tdWwoIGJsZW5kLmEgKS5hZGQoIGJhc2UucmdiLm11bCggYmFzZS5hICkubXVsKCBibGVuZC5hLm9uZU1pbnVzKCkgKSApLmRpdiggb3V0QWxwaGEgKSwgb3V0QWxwaGEgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnYmxlbmRDb2xvcicsXG5cdHR5cGU6ICd2ZWM0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnYmFzZScsIHR5cGU6ICd2ZWM0JyB9LFxuXHRcdHsgbmFtZTogJ2JsZW5kJywgdHlwZTogJ3ZlYzQnIH1cblx0XVxufSApO1xuXG4vLyBkZXByZWNhdGVkXG5cbmV4cG9ydCBjb25zdCBidXJuID0gKCAuLi5wYXJhbXMgKSA9PiB7IC8vIEBkZXByZWNhdGVkLCByMTcxXG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVFNMOiBcImJ1cm5cIiBoYXMgYmVlbiByZW5hbWVkLiBVc2UgXCJibGVuZEJ1cm5cIiBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIGJsZW5kQnVybiggcGFyYW1zICk7XG5cbn07XG5cbmV4cG9ydCBjb25zdCBkb2RnZSA9ICggLi4ucGFyYW1zICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE3MVxuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlRTTDogXCJkb2RnZVwiIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBcImJsZW5kRG9kZ2VcIiBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIGJsZW5kRG9kZ2UoIHBhcmFtcyApO1xuXG59O1xuXG5leHBvcnQgY29uc3Qgc2NyZWVuID0gKCAuLi5wYXJhbXMgKSA9PiB7IC8vIEBkZXByZWNhdGVkLCByMTcxXG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVFNMOiBcInNjcmVlblwiIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBcImJsZW5kU2NyZWVuXCIgaW5zdGVhZC4nICk7XG5cdHJldHVybiBibGVuZFNjcmVlbiggcGFyYW1zICk7XG5cbn07XG5cbmV4cG9ydCBjb25zdCBvdmVybGF5ID0gKCAuLi5wYXJhbXMgKSA9PiB7IC8vIEBkZXByZWNhdGVkLCByMTcxXG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVFNMOiBcIm92ZXJsYXlcIiBoYXMgYmVlbiByZW5hbWVkLiBVc2UgXCJibGVuZE92ZXJsYXlcIiBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIGJsZW5kT3ZlcmxheSggcGFyYW1zICk7XG5cbn07XG4iLCJpbXBvcnQgeyBkb3QsIG1heCwgbWl4IH0gZnJvbSAnLi4vbWF0aC9NYXRoTm9kZS5qcyc7XG5pbXBvcnQgeyBhZGQgfSBmcm9tICcuLi9tYXRoL09wZXJhdG9yTm9kZS5qcyc7XG5pbXBvcnQgeyBGbiwgSWYsIGZsb2F0LCB2ZWMzLCB2ZWM0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgQ29sb3JNYW5hZ2VtZW50IH0gZnJvbSAnLi4vLi4vbWF0aC9Db2xvck1hbmFnZW1lbnQuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBMaW5lYXJTUkdCQ29sb3JTcGFjZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbmV4cG9ydCBjb25zdCBncmF5c2NhbGUgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgY29sb3IgXSApID0+IHtcblxuXHRyZXR1cm4gbHVtaW5hbmNlKCBjb2xvci5yZ2IgKTtcblxufSApO1xuXG5leHBvcnQgY29uc3Qgc2F0dXJhdGlvbiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBjb2xvciwgYWRqdXN0bWVudCA9IGZsb2F0KCAxICkgXSApID0+IHtcblxuXHRyZXR1cm4gYWRqdXN0bWVudC5taXgoIGx1bWluYW5jZSggY29sb3IucmdiICksIGNvbG9yLnJnYiApO1xuXG59ICk7XG5cbmV4cG9ydCBjb25zdCB2aWJyYW5jZSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBjb2xvciwgYWRqdXN0bWVudCA9IGZsb2F0KCAxICkgXSApID0+IHtcblxuXHRjb25zdCBhdmVyYWdlID0gYWRkKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICkuZGl2KCAzLjAgKTtcblxuXHRjb25zdCBteCA9IGNvbG9yLnIubWF4KCBjb2xvci5nLm1heCggY29sb3IuYiApICk7XG5cdGNvbnN0IGFtdCA9IG14LnN1YiggYXZlcmFnZSApLm11bCggYWRqdXN0bWVudCApLm11bCggLSAzLjAgKTtcblxuXHRyZXR1cm4gbWl4KCBjb2xvci5yZ2IsIG14LCBhbXQgKTtcblxufSApO1xuXG5leHBvcnQgY29uc3QgaHVlID0gLypAX19QVVJFX18qLyBGbiggKCBbIGNvbG9yLCBhZGp1c3RtZW50ID0gZmxvYXQoIDEgKSBdICkgPT4ge1xuXG5cdGNvbnN0IGsgPSB2ZWMzKCAwLjU3NzM1LCAwLjU3NzM1LCAwLjU3NzM1ICk7XG5cblx0Y29uc3QgY29zQW5nbGUgPSBhZGp1c3RtZW50LmNvcygpO1xuXG5cdHJldHVybiB2ZWMzKCBjb2xvci5yZ2IubXVsKCBjb3NBbmdsZSApLmFkZCggay5jcm9zcyggY29sb3IucmdiICkubXVsKCBhZGp1c3RtZW50LnNpbigpICkuYWRkKCBrLm11bCggZG90KCBrLCBjb2xvci5yZ2IgKS5tdWwoIGNvc0FuZ2xlLm9uZU1pbnVzKCkgKSApICkgKSApO1xuXG59ICk7XG5cbmV4cG9ydCBjb25zdCBsdW1pbmFuY2UgPSAoXG5cdGNvbG9yLFxuXHRsdW1pbmFuY2VDb2VmZmljaWVudHMgPSB2ZWMzKCBDb2xvck1hbmFnZW1lbnQuZ2V0THVtaW5hbmNlQ29lZmZpY2llbnRzKCBuZXcgVmVjdG9yMygpICkgKVxuKSA9PiBkb3QoIGNvbG9yLCBsdW1pbmFuY2VDb2VmZmljaWVudHMgKTtcblxuZXhwb3J0IGNvbnN0IHRocmVzaG9sZCA9ICggY29sb3IsIHRocmVzaG9sZCApID0+IG1peCggdmVjMyggMC4wICksIGNvbG9yLCBsdW1pbmFuY2UoIGNvbG9yICkuc3ViKCB0aHJlc2hvbGQgKS5tYXgoIDAgKSApO1xuXG4vKipcbiAqIENvbG9yIERlY2lzaW9uIExpc3QgKENETCkgdjEuMlxuICpcbiAqIENvbXBhY3QgcmVwcmVzZW50YXRpb24gb2YgY29sb3IgZ3JhZGluZyBpbmZvcm1hdGlvbiwgZGVmaW5lZCBieSBzbG9wZSwgb2Zmc2V0LCBwb3dlciwgYW5kXG4gKiBzYXR1cmF0aW9uLiBUaGUgQ0RMIHNob3VsZCBiZSB0eXBpY2FsbHkgYmUgZ2l2ZW4gaW5wdXQgaW4gYSBsb2cgc3BhY2UgKHN1Y2ggYXMgTG9nQywgQUNFU2NjLFxuICogb3IgQWdYIExvZyksIGFuZCB3aWxsIHJldHVybiBvdXRwdXQgaW4gdGhlIHNhbWUgc3BhY2UuIE91dHB1dCBtYXkgcmVxdWlyZSBjbGFtcGluZyA+PTAuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBjb2xvciBJbnB1dCAoLUluZmluaXR5IDwgaW5wdXQgPCArSW5maW5pdHkpXG4gKiBAcGFyYW0ge251bWJlciB8IHZlYzN9IHNsb3BlIFNsb3BlICgwIOKJpCBzbG9wZSA8ICtJbmZpbml0eSlcbiAqIEBwYXJhbSB7bnVtYmVyIHwgdmVjM30gb2Zmc2V0IE9mZnNldCAoLUluZmluaXR5IDwgb2Zmc2V0IDwgK0luZmluaXR5OyB0eXBpY2FsbHkgLTEgPCBvZmZzZXQgPCAxKVxuICogQHBhcmFtIHtudW1iZXIgfCB2ZWMzfSBwb3dlciBQb3dlciAoMCA8IHBvd2VyIDwgK0luZmluaXR5KVxuICogQHBhcmFtIHtudW1iZXJ9IHNhdHVyYXRpb24gU2F0dXJhdGlvbiAoMCDiiaQgc2F0dXJhdGlvbiA8ICtJbmZpbml0eTsgdHlwaWNhbGx5IDAg4omkIHNhdHVyYXRpb24gPCA0KVxuICogQHBhcmFtIHt2ZWMzfSBsdW1pbmFuY2VDb2VmZmljaWVudHMgTHVtaW5hbmNlIGNvZWZmaWNpZW50cyBmb3Igc2F0dXJhdGlvbiB0ZXJtLCB0eXBpY2FsbHkgUmVjLiA3MDlcbiAqIEByZXR1cm4gT3V0cHV0LCAtSW5maW5pdHkgPCBvdXRwdXQgPCArSW5maW5pdHlcbiAqXG4gKiBSZWZlcmVuY2VzOlxuICogLSBBU0MgQ0RMIHYxLjJcbiAqIC0gaHR0cHM6Ly9ibGVuZGVyLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTUyMzkvNDM5MzBcbiAqIC0gaHR0cHM6Ly9kb2NzLmFjZXNjZW50cmFsLmNvbS9zcGVjaWZpY2F0aW9ucy9hY2VzY2MvXG4gKi9cbmV4cG9ydCBjb25zdCBjZGwgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFtcblx0Y29sb3IsXG5cdHNsb3BlID0gdmVjMyggMSApLFxuXHRvZmZzZXQgPSB2ZWMzKCAwICksXG5cdHBvd2VyID0gdmVjMyggMSApLFxuXHRzYXR1cmF0aW9uID0gZmxvYXQoIDEgKSxcblx0Ly8gQVNDIENETCB2MS4yIGV4cGxpY2l0bHkgcmVxdWlyZXMgUmVjLiA3MDkgbHVtaW5hbmNlIGNvZWZmaWNpZW50cy5cblx0bHVtaW5hbmNlQ29lZmZpY2llbnRzID0gdmVjMyggQ29sb3JNYW5hZ2VtZW50LmdldEx1bWluYW5jZUNvZWZmaWNpZW50cyggbmV3IFZlY3RvcjMoKSwgTGluZWFyU1JHQkNvbG9yU3BhY2UgKSApXG5dICkgPT4ge1xuXG5cdC8vIE5PVEU6IFRoZSBBU0MgQ0RMIHYxLjIgZGVmaW5lcyBhIFswLCAxXSBjbGFtcCBvbiB0aGUgc2xvcGUrb2Zmc2V0IHRlcm0sIGFuZCBhbm90aGVyIG9uIHRoZVxuXHQvLyBzYXR1cmF0aW9uIHRlcm0uIFBlciB0aGUgQUNFU2NjIHNwZWNpZmljYXRpb24gYW5kIEZpbGFtZW50LCBsaW1pdHMgbWF5IGJlIG9taXR0ZWQgdG8gc3VwcG9ydFxuXHQvLyB2YWx1ZXMgb3V0c2lkZSBbMCwgMV0sIHJlcXVpcmluZyBhIHdvcmthcm91bmQgZm9yIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGUgcG93ZXIgZXhwcmVzc2lvbi5cblxuXHRjb25zdCBsdW1hID0gY29sb3IucmdiLmRvdCggdmVjMyggbHVtaW5hbmNlQ29lZmZpY2llbnRzICkgKTtcblxuXHRjb25zdCB2ID0gbWF4KCBjb2xvci5yZ2IubXVsKCBzbG9wZSApLmFkZCggb2Zmc2V0ICksIDAuMCApLnRvVmFyKCk7XG5cdGNvbnN0IHB2ID0gdi5wb3coIHBvd2VyICkudG9WYXIoKTtcblxuXHRJZiggdi5yLmdyZWF0ZXJUaGFuKCAwLjAgKSwgKCkgPT4geyB2LnIuYXNzaWduKCBwdi5yICk7IH0gKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRJZiggdi5nLmdyZWF0ZXJUaGFuKCAwLjAgKSwgKCkgPT4geyB2LmcuYXNzaWduKCBwdi5nICk7IH0gKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRJZiggdi5iLmdyZWF0ZXJUaGFuKCAwLjAgKSwgKCkgPT4geyB2LmIuYXNzaWduKCBwdi5iICk7IH0gKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cdHYuYXNzaWduKCBsdW1hLmFkZCggdi5zdWIoIGx1bWEgKS5tdWwoIHNhdHVyYXRpb24gKSApICk7XG5cblx0cmV0dXJuIHZlYzQoIHYucmdiLCBjb2xvci5hICk7XG5cbn0gKTtcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY2xhc3MgUG9zdGVyaXplTm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1Bvc3Rlcml6ZU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3Rvciggc291cmNlTm9kZSwgc3RlcHNOb2RlICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuc291cmNlTm9kZSA9IHNvdXJjZU5vZGU7XG5cdFx0dGhpcy5zdGVwc05vZGUgPSBzdGVwc05vZGU7XG5cblx0fVxuXG5cdHNldHVwKCkge1xuXG5cdFx0Y29uc3QgeyBzb3VyY2VOb2RlLCBzdGVwc05vZGUgfSA9IHRoaXM7XG5cblx0XHRyZXR1cm4gc291cmNlTm9kZS5tdWwoIHN0ZXBzTm9kZSApLmZsb29yKCkuZGl2KCBzdGVwc05vZGUgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9zdGVyaXplTm9kZTtcblxuZXhwb3J0IGNvbnN0IHBvc3Rlcml6ZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBQb3N0ZXJpemVOb2RlICk7XG4iLCJpbXBvcnQgVGVtcE5vZGUgZnJvbSAnLi4vY29yZS9UZW1wTm9kZS5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0IGFzIFRleHR1cmVOb2RlLyosIHRleHR1cmUqLyB9IGZyb20gJy4uL2FjY2Vzc29ycy9UZXh0dXJlTm9kZS5qcyc7XG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XG5pbXBvcnQgeyB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgsIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaIH0gZnJvbSAnLi9WaWV3cG9ydERlcHRoTm9kZS5qcyc7XG5cbmltcG9ydCB7IEhhbGZGbG9hdFR5cGUvKiwgRmxvYXRUeXBlKi8gfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBEZXB0aFRleHR1cmUgfSBmcm9tICcuLi8uLi90ZXh0dXJlcy9EZXB0aFRleHR1cmUuanMnO1xuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi4vLi4vY29yZS9SZW5kZXJUYXJnZXQuanMnO1xuXG5jb25zdCBfc2l6ZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcblxuY2xhc3MgUGFzc1RleHR1cmVOb2RlIGV4dGVuZHMgVGV4dHVyZU5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnUGFzc1RleHR1cmVOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHBhc3NOb2RlLCB0ZXh0dXJlICkge1xuXG5cdFx0c3VwZXIoIHRleHR1cmUgKTtcblxuXHRcdHRoaXMucGFzc05vZGUgPSBwYXNzTm9kZTtcblxuXHRcdHRoaXMuc2V0VXBkYXRlTWF0cml4KCBmYWxzZSApO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdGlmICggYnVpbGRlci5vYmplY3QuaXNRdWFkTWVzaCApIHRoaXMucGFzc05vZGUuYnVpbGQoIGJ1aWxkZXIgKTtcblxuXHRcdHJldHVybiBzdXBlci5zZXR1cCggYnVpbGRlciApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5wYXNzTm9kZSwgdGhpcy52YWx1ZSApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBQYXNzTXVsdGlwbGVUZXh0dXJlTm9kZSBleHRlbmRzIFBhc3NUZXh0dXJlTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdQYXNzTXVsdGlwbGVUZXh0dXJlTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBwYXNzTm9kZSwgdGV4dHVyZU5hbWUsIHByZXZpb3VzVGV4dHVyZSA9IGZhbHNlICkge1xuXG5cdFx0c3VwZXIoIHBhc3NOb2RlLCBudWxsICk7XG5cblx0XHR0aGlzLnRleHR1cmVOYW1lID0gdGV4dHVyZU5hbWU7XG5cdFx0dGhpcy5wcmV2aW91c1RleHR1cmUgPSBwcmV2aW91c1RleHR1cmU7XG5cblx0fVxuXG5cdHVwZGF0ZVRleHR1cmUoKSB7XG5cblx0XHR0aGlzLnZhbHVlID0gdGhpcy5wcmV2aW91c1RleHR1cmUgPyB0aGlzLnBhc3NOb2RlLmdldFByZXZpb3VzVGV4dHVyZSggdGhpcy50ZXh0dXJlTmFtZSApIDogdGhpcy5wYXNzTm9kZS5nZXRUZXh0dXJlKCB0aGlzLnRleHR1cmVOYW1lICk7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0dGhpcy51cGRhdGVUZXh0dXJlKCk7XG5cblx0XHRyZXR1cm4gc3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMucGFzc05vZGUsIHRoaXMudGV4dHVyZU5hbWUsIHRoaXMucHJldmlvdXNUZXh0dXJlICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFBhc3NOb2RlIGV4dGVuZHMgVGVtcE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnUGFzc05vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3Rvciggc2NvcGUsIHNjZW5lLCBjYW1lcmEsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdHN1cGVyKCAndmVjNCcgKTtcblxuXHRcdHRoaXMuc2NvcGUgPSBzY29wZTtcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSAxO1xuXHRcdHRoaXMuX3dpZHRoID0gMTtcblx0XHR0aGlzLl9oZWlnaHQgPSAxO1xuXG5cdFx0Y29uc3QgZGVwdGhUZXh0dXJlID0gbmV3IERlcHRoVGV4dHVyZSgpO1xuXHRcdGRlcHRoVGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXHRcdC8vZGVwdGhUZXh0dXJlLnR5cGUgPSBGbG9hdFR5cGU7XG5cdFx0ZGVwdGhUZXh0dXJlLm5hbWUgPSAnZGVwdGgnO1xuXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gbmV3IFJlbmRlclRhcmdldCggdGhpcy5fd2lkdGggKiB0aGlzLl9waXhlbFJhdGlvLCB0aGlzLl9oZWlnaHQgKiB0aGlzLl9waXhlbFJhdGlvLCB7IHR5cGU6IEhhbGZGbG9hdFR5cGUsIC4uLm9wdGlvbnMsIH0gKTtcblx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gJ291dHB1dCc7XG5cdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSA9IGRlcHRoVGV4dHVyZTtcblxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuXG5cdFx0dGhpcy51cGRhdGVCZWZvcmVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuRlJBTUU7XG5cblx0XHR0aGlzLl90ZXh0dXJlcyA9IHtcblx0XHRcdG91dHB1dDogcmVuZGVyVGFyZ2V0LnRleHR1cmUsXG5cdFx0XHRkZXB0aDogZGVwdGhUZXh0dXJlXG5cdFx0fTtcblxuXHRcdHRoaXMuX3RleHR1cmVOb2RlcyA9IHt9O1xuXHRcdHRoaXMuX2xpbmVhckRlcHRoTm9kZXMgPSB7fTtcblx0XHR0aGlzLl92aWV3Wk5vZGVzID0ge307XG5cblx0XHR0aGlzLl9wcmV2aW91c1RleHR1cmVzID0ge307XG5cdFx0dGhpcy5fcHJldmlvdXNUZXh0dXJlTm9kZXMgPSB7fTtcblxuXHRcdHRoaXMuX2NhbWVyYU5lYXIgPSB1bmlmb3JtKCAwICk7XG5cdFx0dGhpcy5fY2FtZXJhRmFyID0gdW5pZm9ybSggMCApO1xuXG5cdFx0dGhpcy5fbXJ0ID0gbnVsbDtcblxuXHRcdHRoaXMuaXNQYXNzTm9kZSA9IHRydWU7XG5cblx0fVxuXG5cdHNldE1SVCggbXJ0ICkge1xuXG5cdFx0dGhpcy5fbXJ0ID0gbXJ0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE1SVCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9tcnQ7XG5cblx0fVxuXG5cdGlzR2xvYmFsKCkge1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdGdldFRleHR1cmUoIG5hbWUgKSB7XG5cblx0XHRsZXQgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmVzWyBuYW1lIF07XG5cblx0XHRpZiAoIHRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgcmVmVGV4dHVyZSA9IHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cblx0XHRcdHRleHR1cmUgPSByZWZUZXh0dXJlLmNsb25lKCk7XG5cdFx0XHR0ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG5cdFx0XHR0ZXh0dXJlLm5hbWUgPSBuYW1lO1xuXG5cdFx0XHR0aGlzLl90ZXh0dXJlc1sgbmFtZSBdID0gdGV4dHVyZTtcblxuXHRcdFx0dGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZXMucHVzaCggdGV4dHVyZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG5cdGdldFByZXZpb3VzVGV4dHVyZSggbmFtZSApIHtcblxuXHRcdGxldCB0ZXh0dXJlID0gdGhpcy5fcHJldmlvdXNUZXh0dXJlc1sgbmFtZSBdO1xuXG5cdFx0aWYgKCB0ZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRleHR1cmUgPSB0aGlzLmdldFRleHR1cmUoIG5hbWUgKS5jbG9uZSgpO1xuXHRcdFx0dGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLl9wcmV2aW91c1RleHR1cmVzWyBuYW1lIF0gPSB0ZXh0dXJlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG5cdHRvZ2dsZVRleHR1cmUoIG5hbWUgKSB7XG5cblx0XHRjb25zdCBwcmV2VGV4dHVyZSA9IHRoaXMuX3ByZXZpb3VzVGV4dHVyZXNbIG5hbWUgXTtcblxuXHRcdGlmICggcHJldlRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmVzWyBuYW1lIF07XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZXMuaW5kZXhPZiggdGV4dHVyZSApO1xuXHRcdFx0dGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZXNbIGluZGV4IF0gPSBwcmV2VGV4dHVyZTtcblxuXHRcdFx0dGhpcy5fdGV4dHVyZXNbIG5hbWUgXSA9IHByZXZUZXh0dXJlO1xuXHRcdFx0dGhpcy5fcHJldmlvdXNUZXh0dXJlc1sgbmFtZSBdID0gdGV4dHVyZTtcblxuXHRcdFx0dGhpcy5fdGV4dHVyZU5vZGVzWyBuYW1lIF0udXBkYXRlVGV4dHVyZSgpO1xuXHRcdFx0dGhpcy5fcHJldmlvdXNUZXh0dXJlTm9kZXNbIG5hbWUgXS51cGRhdGVUZXh0dXJlKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldFRleHR1cmVOb2RlKCBuYW1lID0gJ291dHB1dCcgKSB7XG5cblx0XHRsZXQgdGV4dHVyZU5vZGUgPSB0aGlzLl90ZXh0dXJlTm9kZXNbIG5hbWUgXTtcblxuXHRcdGlmICggdGV4dHVyZU5vZGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGV4dHVyZU5vZGUgPSBub2RlT2JqZWN0KCBuZXcgUGFzc011bHRpcGxlVGV4dHVyZU5vZGUoIHRoaXMsIG5hbWUgKSApO1xuXHRcdFx0dGV4dHVyZU5vZGUudXBkYXRlVGV4dHVyZSgpO1xuXHRcdFx0dGhpcy5fdGV4dHVyZU5vZGVzWyBuYW1lIF0gPSB0ZXh0dXJlTm9kZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0ZXh0dXJlTm9kZTtcblxuXHR9XG5cblx0Z2V0UHJldmlvdXNUZXh0dXJlTm9kZSggbmFtZSA9ICdvdXRwdXQnICkge1xuXG5cdFx0bGV0IHRleHR1cmVOb2RlID0gdGhpcy5fcHJldmlvdXNUZXh0dXJlTm9kZXNbIG5hbWUgXTtcblxuXHRcdGlmICggdGV4dHVyZU5vZGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCB0aGlzLl90ZXh0dXJlTm9kZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkgdGhpcy5nZXRUZXh0dXJlTm9kZSggbmFtZSApO1xuXG5cdFx0XHR0ZXh0dXJlTm9kZSA9IG5vZGVPYmplY3QoIG5ldyBQYXNzTXVsdGlwbGVUZXh0dXJlTm9kZSggdGhpcywgbmFtZSwgdHJ1ZSApICk7XG5cdFx0XHR0ZXh0dXJlTm9kZS51cGRhdGVUZXh0dXJlKCk7XG5cdFx0XHR0aGlzLl9wcmV2aW91c1RleHR1cmVOb2Rlc1sgbmFtZSBdID0gdGV4dHVyZU5vZGU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZU5vZGU7XG5cblx0fVxuXG5cdGdldFZpZXdaTm9kZSggbmFtZSA9ICdkZXB0aCcgKSB7XG5cblx0XHRsZXQgdmlld1pOb2RlID0gdGhpcy5fdmlld1pOb2Rlc1sgbmFtZSBdO1xuXG5cdFx0aWYgKCB2aWV3Wk5vZGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgY2FtZXJhTmVhciA9IHRoaXMuX2NhbWVyYU5lYXI7XG5cdFx0XHRjb25zdCBjYW1lcmFGYXIgPSB0aGlzLl9jYW1lcmFGYXI7XG5cblx0XHRcdHRoaXMuX3ZpZXdaTm9kZXNbIG5hbWUgXSA9IHZpZXdaTm9kZSA9IHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKCB0aGlzLmdldFRleHR1cmVOb2RlKCBuYW1lICksIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXdaTm9kZTtcblxuXHR9XG5cblx0Z2V0TGluZWFyRGVwdGhOb2RlKCBuYW1lID0gJ2RlcHRoJyApIHtcblxuXHRcdGxldCBsaW5lYXJEZXB0aE5vZGUgPSB0aGlzLl9saW5lYXJEZXB0aE5vZGVzWyBuYW1lIF07XG5cblx0XHRpZiAoIGxpbmVhckRlcHRoTm9kZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBjYW1lcmFOZWFyID0gdGhpcy5fY2FtZXJhTmVhcjtcblx0XHRcdGNvbnN0IGNhbWVyYUZhciA9IHRoaXMuX2NhbWVyYUZhcjtcblx0XHRcdGNvbnN0IHZpZXdaTm9kZSA9IHRoaXMuZ2V0Vmlld1pOb2RlKCBuYW1lICk7XG5cblx0XHRcdC8vIFRPRE86IGp1c3QgaWYgKCBidWlsZGVyLmNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhIClcblxuXHRcdFx0dGhpcy5fbGluZWFyRGVwdGhOb2Rlc1sgbmFtZSBdID0gbGluZWFyRGVwdGhOb2RlID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKCB2aWV3Wk5vZGUsIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxpbmVhckRlcHRoTm9kZTtcblxuXHR9XG5cblx0c2V0dXAoIHsgcmVuZGVyZXIgfSApIHtcblxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0LnNhbXBsZXMgPSB0aGlzLm9wdGlvbnMuc2FtcGxlcyA9PT0gdW5kZWZpbmVkID8gcmVuZGVyZXIuc2FtcGxlcyA6IHRoaXMub3B0aW9ucy5zYW1wbGVzO1xuXG5cdFx0Ly8gRGlzYWJsZSBNU0FBIGZvciBXZWJHTCBiYWNrZW5kIGZvciBub3dcblx0XHRpZiAoIHJlbmRlcmVyLmJhY2tlbmQuaXNXZWJHTEJhY2tlbmQgPT09IHRydWUgKSB7XG5cblx0XHRcdHRoaXMucmVuZGVyVGFyZ2V0LnNhbXBsZXMgPSAwO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmlzTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXRUZXh0dXJlID0gdGhpcy5yZW5kZXJUYXJnZXQuc2FtcGxlcyA+IDE7XG5cblx0XHRyZXR1cm4gdGhpcy5zY29wZSA9PT0gUGFzc05vZGUuQ09MT1IgPyB0aGlzLmdldFRleHR1cmVOb2RlKCkgOiB0aGlzLmdldExpbmVhckRlcHRoTm9kZSgpO1xuXG5cdH1cblxuXHR1cGRhdGVCZWZvcmUoIGZyYW1lICkge1xuXG5cdFx0Y29uc3QgeyByZW5kZXJlciB9ID0gZnJhbWU7XG5cdFx0Y29uc3QgeyBzY2VuZSwgY2FtZXJhIH0gPSB0aGlzO1xuXG5cdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IHJlbmRlcmVyLmdldFBpeGVsUmF0aW8oKTtcblxuXHRcdGNvbnN0IHNpemUgPSByZW5kZXJlci5nZXRTaXplKCBfc2l6ZSApO1xuXG5cdFx0dGhpcy5zZXRTaXplKCBzaXplLndpZHRoLCBzaXplLmhlaWdodCApO1xuXG5cdFx0Y29uc3QgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXHRcdGNvbnN0IGN1cnJlbnRNUlQgPSByZW5kZXJlci5nZXRNUlQoKTtcblxuXHRcdHRoaXMuX2NhbWVyYU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcblx0XHR0aGlzLl9jYW1lcmFGYXIudmFsdWUgPSBjYW1lcmEuZmFyO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiB0aGlzLl9wcmV2aW91c1RleHR1cmVzICkge1xuXG5cdFx0XHR0aGlzLnRvZ2dsZVRleHR1cmUoIG5hbWUgKTtcblxuXHRcdH1cblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggdGhpcy5yZW5kZXJUYXJnZXQgKTtcblx0XHRyZW5kZXJlci5zZXRNUlQoIHRoaXMuX21ydCApO1xuXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhICk7XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIGN1cnJlbnRSZW5kZXJUYXJnZXQgKTtcblx0XHRyZW5kZXJlci5zZXRNUlQoIGN1cnJlbnRNUlQgKTtcblxuXHR9XG5cblx0c2V0U2l6ZSggd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0Y29uc3QgZWZmZWN0aXZlV2lkdGggPSB0aGlzLl93aWR0aCAqIHRoaXMuX3BpeGVsUmF0aW87XG5cdFx0Y29uc3QgZWZmZWN0aXZlSGVpZ2h0ID0gdGhpcy5faGVpZ2h0ICogdGhpcy5fcGl4ZWxSYXRpbztcblxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUoIGVmZmVjdGl2ZVdpZHRoLCBlZmZlY3RpdmVIZWlnaHQgKTtcblxuXHR9XG5cblx0c2V0UGl4ZWxSYXRpbyggcGl4ZWxSYXRpbyApIHtcblxuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXG5cdFx0dGhpcy5zZXRTaXplKCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0ICk7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLnJlbmRlclRhcmdldC5kaXNwb3NlKCk7XG5cblx0fVxuXG5cbn1cblxuUGFzc05vZGUuQ09MT1IgPSAnY29sb3InO1xuUGFzc05vZGUuREVQVEggPSAnZGVwdGgnO1xuXG5leHBvcnQgZGVmYXVsdCBQYXNzTm9kZTtcblxuZXhwb3J0IGNvbnN0IHBhc3MgPSAoIHNjZW5lLCBjYW1lcmEsIG9wdGlvbnMgKSA9PiBub2RlT2JqZWN0KCBuZXcgUGFzc05vZGUoIFBhc3NOb2RlLkNPTE9SLCBzY2VuZSwgY2FtZXJhLCBvcHRpb25zICkgKTtcbmV4cG9ydCBjb25zdCBwYXNzVGV4dHVyZSA9ICggcGFzcywgdGV4dHVyZSApID0+IG5vZGVPYmplY3QoIG5ldyBQYXNzVGV4dHVyZU5vZGUoIHBhc3MsIHRleHR1cmUgKSApO1xuZXhwb3J0IGNvbnN0IGRlcHRoUGFzcyA9ICggc2NlbmUsIGNhbWVyYSApID0+IG5vZGVPYmplY3QoIG5ldyBQYXNzTm9kZSggUGFzc05vZGUuREVQVEgsIHNjZW5lLCBjYW1lcmEgKSApO1xuIiwiaW1wb3J0IHsgZmxvYXQsIG5vZGVPYmplY3QsIG5vcm1hbGl6ZSwgdmVjNCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vbWF0aC9Db2xvci5qcyc7XG5pbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4uLy4uL21hdGVyaWFscy9ub2Rlcy9Ob2RlTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgY2FtZXJhUHJvamVjdGlvbk1hdHJpeCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9DYW1lcmEuanMnO1xuaW1wb3J0IHsgbW9kZWxWaWV3TWF0cml4IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL01vZGVsTm9kZS5qcyc7XG5pbXBvcnQgeyBwb3NpdGlvbkxvY2FsIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IG5vcm1hbExvY2FsIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL05vcm1hbC5qcyc7XG5pbXBvcnQgeyBCYWNrU2lkZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgUGFzc05vZGUgZnJvbSAnLi9QYXNzTm9kZS5qcyc7XG5cbmNsYXNzIFRvb25PdXRsaW5lUGFzc05vZGUgZXh0ZW5kcyBQYXNzTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdUb29uT3V0bGluZVBhc3NOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIHNjZW5lLCBjYW1lcmEsIGNvbG9yTm9kZSwgdGhpY2tuZXNzTm9kZSwgYWxwaGFOb2RlICkge1xuXG5cdFx0c3VwZXIoIFBhc3NOb2RlLkNPTE9SLCBzY2VuZSwgY2FtZXJhICk7XG5cblx0XHR0aGlzLmNvbG9yTm9kZSA9IGNvbG9yTm9kZTtcblx0XHR0aGlzLnRoaWNrbmVzc05vZGUgPSB0aGlja25lc3NOb2RlO1xuXHRcdHRoaXMuYWxwaGFOb2RlID0gYWxwaGFOb2RlO1xuXG5cdFx0dGhpcy5fbWF0ZXJpYWxDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cblx0fVxuXG5cdHVwZGF0ZUJlZm9yZSggZnJhbWUgKSB7XG5cblx0XHRjb25zdCB7IHJlbmRlcmVyIH0gPSBmcmFtZTtcblxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJPYmplY3RGdW5jdGlvbiA9IHJlbmRlcmVyLmdldFJlbmRlck9iamVjdEZ1bmN0aW9uKCk7XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJPYmplY3RGdW5jdGlvbiggKCBvYmplY3QsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAsIGxpZ2h0c05vZGUsIGNsaXBwaW5nQ29udGV4dCApID0+IHtcblxuXHRcdFx0Ly8gb25seSByZW5kZXIgb3V0bGluZSBmb3Igc3VwcG9ydGVkIG1hdGVyaWFsc1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaFRvb25NYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hUb29uTm9kZU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG91dGxpbmVNYXRlcmlhbCA9IHRoaXMuX2dldE91dGxpbmVNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblx0XHRcdFx0XHRyZW5kZXJlci5yZW5kZXJPYmplY3QoIG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG91dGxpbmVNYXRlcmlhbCwgZ3JvdXAsIGxpZ2h0c05vZGUsIGNsaXBwaW5nQ29udGV4dCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZhdWx0XG5cblx0XHRcdHJlbmRlcmVyLnJlbmRlck9iamVjdCggb2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwLCBsaWdodHNOb2RlLCBjbGlwcGluZ0NvbnRleHQgKTtcblxuXHRcdH0gKTtcblxuXHRcdHN1cGVyLnVwZGF0ZUJlZm9yZSggZnJhbWUgKTtcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlck9iamVjdEZ1bmN0aW9uKCBjdXJyZW50UmVuZGVyT2JqZWN0RnVuY3Rpb24gKTtcblxuXHR9XG5cblx0X2NyZWF0ZU1hdGVyaWFsKCkge1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTm9kZU1hdGVyaWFsKCk7XG5cdFx0bWF0ZXJpYWwuaXNNZXNoVG9vbk91dGxpbmVNYXRlcmlhbCA9IHRydWU7XG5cdFx0bWF0ZXJpYWwubmFtZSA9ICdUb29uX091dGxpbmUnO1xuXHRcdG1hdGVyaWFsLnNpZGUgPSBCYWNrU2lkZTtcblxuXHRcdC8vIHZlcnRleCBub2RlXG5cblx0XHRjb25zdCBvdXRsaW5lTm9ybWFsID0gbm9ybWFsTG9jYWwubmVnYXRlKCk7XG5cdFx0Y29uc3QgbXZwID0gY2FtZXJhUHJvamVjdGlvbk1hdHJpeC5tdWwoIG1vZGVsVmlld01hdHJpeCApO1xuXG5cdFx0Y29uc3QgcmF0aW8gPSBmbG9hdCggMS4wICk7IC8vIFRPRE86IHN1cHBvcnQgb3V0bGluZSB0aGlja25lc3MgcmF0aW8gZm9yIGVhY2ggdmVydGV4XG5cdFx0Y29uc3QgcG9zID0gbXZwLm11bCggdmVjNCggcG9zaXRpb25Mb2NhbCwgMS4wICkgKTtcblx0XHRjb25zdCBwb3MyID0gbXZwLm11bCggdmVjNCggcG9zaXRpb25Mb2NhbC5hZGQoIG91dGxpbmVOb3JtYWwgKSwgMS4wICkgKTtcblx0XHRjb25zdCBub3JtID0gbm9ybWFsaXplKCBwb3Muc3ViKCBwb3MyICkgKTsgLy8gTk9URTogc3VidHJhY3QgcG9zMiBmcm9tIHBvcyBiZWNhdXNlIEJhY2tTaWRlIG9iamVjdE5vcm1hbCBpcyBuZWdhdGl2ZVxuXG5cdFx0bWF0ZXJpYWwudmVydGV4Tm9kZSA9IHBvcy5hZGQoIG5vcm0ubXVsKCB0aGlzLnRoaWNrbmVzc05vZGUgKS5tdWwoIHBvcy53ICkubXVsKCByYXRpbyApICk7XG5cblx0XHQvLyBjb2xvciBub2RlXG5cblx0XHRtYXRlcmlhbC5jb2xvck5vZGUgPSB2ZWM0KCB0aGlzLmNvbG9yTm9kZSwgdGhpcy5hbHBoYU5vZGUgKTtcblxuXHRcdHJldHVybiBtYXRlcmlhbDtcblxuXHR9XG5cblx0X2dldE91dGxpbmVNYXRlcmlhbCggb3JpZ2luYWxNYXRlcmlhbCApIHtcblxuXHRcdGxldCBvdXRsaW5lTWF0ZXJpYWwgPSB0aGlzLl9tYXRlcmlhbENhY2hlLmdldCggb3JpZ2luYWxNYXRlcmlhbCApO1xuXG5cdFx0aWYgKCBvdXRsaW5lTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0b3V0bGluZU1hdGVyaWFsID0gdGhpcy5fY3JlYXRlTWF0ZXJpYWwoKTtcblxuXHRcdFx0dGhpcy5fbWF0ZXJpYWxDYWNoZS5zZXQoIG9yaWdpbmFsTWF0ZXJpYWwsIG91dGxpbmVNYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dGxpbmVNYXRlcmlhbDtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9vbk91dGxpbmVQYXNzTm9kZTtcblxuZXhwb3J0IGNvbnN0IHRvb25PdXRsaW5lUGFzcyA9ICggc2NlbmUsIGNhbWVyYSwgY29sb3IgPSBuZXcgQ29sb3IoIDAsIDAsIDAgKSwgdGhpY2tuZXNzID0gMC4wMDMsIGFscGhhID0gMSApID0+IG5vZGVPYmplY3QoIG5ldyBUb29uT3V0bGluZVBhc3NOb2RlKCBzY2VuZSwgY2FtZXJhLCBub2RlT2JqZWN0KCBjb2xvciApLCBub2RlT2JqZWN0KCB0aGlja25lc3MgKSwgbm9kZU9iamVjdCggYWxwaGEgKSApICk7XG4iLCJpbXBvcnQgeyBGbiwgZmxvYXQsIG1hdDMsIHZlYzMsIElmIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnLi4vbWF0aC9Db25kaXRpb25hbE5vZGUuanMnO1xuaW1wb3J0IHsgY2xhbXAsIGxvZzIsIG1heCwgbWluLCBwb3csIG1peCB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xuaW1wb3J0IHsgbXVsLCBzdWIsIGRpdiB9IGZyb20gJy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJztcblxuLy8gZXhwb3N1cmUgb25seVxuXG5leHBvcnQgY29uc3QgbGluZWFyVG9uZU1hcHBpbmcgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgY29sb3IsIGV4cG9zdXJlIF0gKSA9PiB7XG5cblx0cmV0dXJuIGNvbG9yLm11bCggZXhwb3N1cmUgKS5jbGFtcCgpO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdsaW5lYXJUb25lTWFwcGluZycsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICdleHBvc3VyZScsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7XG5cbi8vIHNvdXJjZTogaHR0cHM6Ly93d3cuY3MudXRhaC5lZHUvZG9jcy90ZWNocmVwb3J0cy8yMDAyL3BkZi9VVUNTLTAyLTAwMS5wZGZcblxuZXhwb3J0IGNvbnN0IHJlaW5oYXJkVG9uZU1hcHBpbmcgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgY29sb3IsIGV4cG9zdXJlIF0gKSA9PiB7XG5cblx0Y29sb3IgPSBjb2xvci5tdWwoIGV4cG9zdXJlICk7XG5cblx0cmV0dXJuIGNvbG9yLmRpdiggY29sb3IuYWRkKCAxLjAgKSApLmNsYW1wKCk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ3JlaW5oYXJkVG9uZU1hcHBpbmcnLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAnZXhwb3N1cmUnLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG4vLyBzb3VyY2U6IGh0dHA6Ly9maWxtaWN3b3JsZHMuY29tL2Jsb2cvZmlsbWljLXRvbmVtYXBwaW5nLW9wZXJhdG9ycy9cblxuZXhwb3J0IGNvbnN0IGNpbmVvblRvbmVNYXBwaW5nID0gLypAX19QVVJFX18qLyBGbiggKCBbIGNvbG9yLCBleHBvc3VyZSBdICkgPT4ge1xuXG5cdC8vIGZpbG1pYyBvcGVyYXRvciBieSBKaW0gSGVqbCBhbmQgUmljaGFyZCBCdXJnZXNzLURhd3NvblxuXHRjb2xvciA9IGNvbG9yLm11bCggZXhwb3N1cmUgKTtcblx0Y29sb3IgPSBjb2xvci5zdWIoIDAuMDA0ICkubWF4KCAwLjAgKTtcblxuXHRjb25zdCBhID0gY29sb3IubXVsKCBjb2xvci5tdWwoIDYuMiApLmFkZCggMC41ICkgKTtcblx0Y29uc3QgYiA9IGNvbG9yLm11bCggY29sb3IubXVsKCA2LjIgKS5hZGQoIDEuNyApICkuYWRkKCAwLjA2ICk7XG5cblx0cmV0dXJuIGEuZGl2KCBiICkucG93KCAyLjIgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnY2luZW9uVG9uZU1hcHBpbmcnLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAnZXhwb3N1cmUnLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zZWxmc2hhZG93L2x0Y19jb2RlL2Jsb2IvbWFzdGVyL3dlYmdsL3NoYWRlcnMvbHRjL2x0Y19ibGl0LmZzXG5cbmNvbnN0IFJSVEFuZE9EVEZpdCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBjb2xvciBdICkgPT4ge1xuXG5cdGNvbnN0IGEgPSBjb2xvci5tdWwoIGNvbG9yLmFkZCggMC4wMjQ1Nzg2ICkgKS5zdWIoIDAuMDAwMDkwNTM3ICk7XG5cdGNvbnN0IGIgPSBjb2xvci5tdWwoIGNvbG9yLmFkZCggMC40MzI5NTEwICkubXVsKCAwLjk4MzcyOSApICkuYWRkKCAwLjIzODA4MSApO1xuXG5cdHJldHVybiBhLmRpdiggYiApO1xuXG59ICk7XG5cbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3NlbGZzaGFkb3cvbHRjX2NvZGUvYmxvYi9tYXN0ZXIvd2ViZ2wvc2hhZGVycy9sdGMvbHRjX2JsaXQuZnNcblxuZXhwb3J0IGNvbnN0IGFjZXNGaWxtaWNUb25lTWFwcGluZyA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBjb2xvciwgZXhwb3N1cmUgXSApID0+IHtcblxuXHQvLyBzUkdCID0+IFhZWiA9PiBENjVfMl9ENjAgPT4gQVAxID0+IFJSVF9TQVRcblx0Y29uc3QgQUNFU0lucHV0TWF0ID0gbWF0Myhcblx0XHQwLjU5NzE5LCAwLjM1NDU4LCAwLjA0ODIzLFxuXHRcdDAuMDc2MDAsIDAuOTA4MzQsIDAuMDE1NjYsXG5cdFx0MC4wMjg0MCwgMC4xMzM4MywgMC44Mzc3N1xuXHQpO1xuXG5cdC8vIE9EVF9TQVQgPT4gWFlaID0+IEQ2MF8yX0Q2NSA9PiBzUkdCXG5cdGNvbnN0IEFDRVNPdXRwdXRNYXQgPSBtYXQzKFxuXHRcdDEuNjA0NzUsIC0gMC41MzEwOCwgLSAwLjA3MzY3LFxuXHRcdC0gMC4xMDIwOCwgMS4xMDgxMywgLSAwLjAwNjA1LFxuXHRcdC0gMC4wMDMyNywgLSAwLjA3Mjc2LCAxLjA3NjAyXG5cdCk7XG5cblx0Y29sb3IgPSBjb2xvci5tdWwoIGV4cG9zdXJlICkuZGl2KCAwLjYgKTtcblxuXHRjb2xvciA9IEFDRVNJbnB1dE1hdC5tdWwoIGNvbG9yICk7XG5cblx0Ly8gQXBwbHkgUlJUIGFuZCBPRFRcblx0Y29sb3IgPSBSUlRBbmRPRFRGaXQoIGNvbG9yICk7XG5cblx0Y29sb3IgPSBBQ0VTT3V0cHV0TWF0Lm11bCggY29sb3IgKTtcblxuXHQvLyBDbGFtcCB0byBbMCwgMV1cblx0cmV0dXJuIGNvbG9yLmNsYW1wKCk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ2FjZXNGaWxtaWNUb25lTWFwcGluZycsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICdleHBvc3VyZScsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7XG5cbmNvbnN0IExJTkVBUl9SRUMyMDIwX1RPX0xJTkVBUl9TUkdCID0gLypAX19QVVJFX18qLyBtYXQzKCB2ZWMzKCAxLjY2MDUsIC0gMC4xMjQ2LCAtIDAuMDE4MiApLCB2ZWMzKCAtIDAuNTg3NiwgMS4xMzI5LCAtIDAuMTAwNiApLCB2ZWMzKCAtIDAuMDcyOCwgLSAwLjAwODMsIDEuMTE4NyApICk7XG5jb25zdCBMSU5FQVJfU1JHQl9UT19MSU5FQVJfUkVDMjAyMCA9IC8qQF9fUFVSRV9fKi8gbWF0MyggdmVjMyggMC42Mjc0LCAwLjA2OTEsIDAuMDE2NCApLCB2ZWMzKCAwLjMyOTMsIDAuOTE5NSwgMC4wODgwICksIHZlYzMoIDAuMDQzMywgMC4wMTEzLCAwLjg5NTYgKSApO1xuXG5jb25zdCBhZ3hEZWZhdWx0Q29udHJhc3RBcHByb3ggPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgeF9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCB4ID0gdmVjMyggeF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB4MiA9IHZlYzMoIHgubXVsKCB4ICkgKS50b1ZhcigpO1xuXHRjb25zdCB4NCA9IHZlYzMoIHgyLm11bCggeDIgKSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIGZsb2F0KCAxNS41ICkubXVsKCB4NC5tdWwoIHgyICkgKS5zdWIoIG11bCggNDAuMTQsIHg0Lm11bCggeCApICkgKS5hZGQoIG11bCggMzEuOTYsIHg0ICkuc3ViKCBtdWwoIDYuODY4LCB4Mi5tdWwoIHggKSApICkuYWRkKCBtdWwoIDAuNDI5OCwgeDIgKS5hZGQoIG11bCggMC4xMTkxLCB4ICkuc3ViKCAwLjAwMjMyICkgKSApICk7XG5cbn0gKTtcblxuZXhwb3J0IGNvbnN0IGFneFRvbmVNYXBwaW5nID0gLypAX19QVVJFX18qLyBGbiggKCBbIGNvbG9yLCBleHBvc3VyZSBdICkgPT4ge1xuXG5cdGNvbnN0IGNvbG9ydG9uZSA9IHZlYzMoIGNvbG9yICkudG9WYXIoKTtcblx0Y29uc3QgQWdYSW5zZXRNYXRyaXggPSBtYXQzKCB2ZWMzKCAwLjg1NjYyNzE1MzMxNTk4MywgMC4xMzczMTg5NzI5Mjk4NDcsIDAuMTExODk4MjEyOTk5OTUgKSwgdmVjMyggMC4wOTUxMjEyNDA1MzgxNTg4LCAwLjc2MTI0MTk5MDYwMjU5MSwgMC4wNzY3OTk0MTg2MDMxOTAzICksIHZlYzMoIDAuMDQ4MjUxNjA2MTQ1ODU4MywgMC4xMDE0MzkwMzY0Njc1NjIsIDAuODExMzAyMzY4Mzk2ODU5ICkgKTtcblx0Y29uc3QgQWdYT3V0c2V0TWF0cml4ID0gbWF0MyggdmVjMyggMS4xMjcxMDA1ODE4MTQ0MzY4LCAtIDAuMTQxMzI5NzYzNDk4NDM4MywgLSAwLjE0MTMyOTc2MzQ5ODQzODI2ICksIHZlYzMoIC0gMC4xMTA2MDY2NDMwOTY2MDMyMywgMS4xNTc4MjM3MDIyMTYyNzIsIC0gMC4xMTA2MDY2NDMwOTY2MDI5NCApLCB2ZWMzKCAtIDAuMDE2NDkzOTM4NzE3ODM0NTczLCAtIDAuMDE2NDkzOTM4NzE3ODM0MjU3LCAxLjI1MTkzNjQwNjU5NTA0MDUgKSApO1xuXHRjb25zdCBBZ3hNaW5FdiA9IGZsb2F0KCAtIDEyLjQ3MzkzICk7XG5cdGNvbnN0IEFneE1heEV2ID0gZmxvYXQoIDQuMDI2MDY5ICk7XG5cdGNvbG9ydG9uZS5tdWxBc3NpZ24oIGV4cG9zdXJlICk7XG5cdGNvbG9ydG9uZS5hc3NpZ24oIExJTkVBUl9TUkdCX1RPX0xJTkVBUl9SRUMyMDIwLm11bCggY29sb3J0b25lICkgKTtcblx0Y29sb3J0b25lLmFzc2lnbiggQWdYSW5zZXRNYXRyaXgubXVsKCBjb2xvcnRvbmUgKSApO1xuXHRjb2xvcnRvbmUuYXNzaWduKCBtYXgoIGNvbG9ydG9uZSwgMWUtMTAgKSApO1xuXHRjb2xvcnRvbmUuYXNzaWduKCBsb2cyKCBjb2xvcnRvbmUgKSApO1xuXHRjb2xvcnRvbmUuYXNzaWduKCBjb2xvcnRvbmUuc3ViKCBBZ3hNaW5FdiApLmRpdiggQWd4TWF4RXYuc3ViKCBBZ3hNaW5FdiApICkgKTtcblx0Y29sb3J0b25lLmFzc2lnbiggY2xhbXAoIGNvbG9ydG9uZSwgMC4wLCAxLjAgKSApO1xuXHRjb2xvcnRvbmUuYXNzaWduKCBhZ3hEZWZhdWx0Q29udHJhc3RBcHByb3goIGNvbG9ydG9uZSApICk7XG5cdGNvbG9ydG9uZS5hc3NpZ24oIEFnWE91dHNldE1hdHJpeC5tdWwoIGNvbG9ydG9uZSApICk7XG5cdGNvbG9ydG9uZS5hc3NpZ24oIHBvdyggbWF4KCB2ZWMzKCAwLjAgKSwgY29sb3J0b25lICksIHZlYzMoIDIuMiApICkgKTtcblx0Y29sb3J0b25lLmFzc2lnbiggTElORUFSX1JFQzIwMjBfVE9fTElORUFSX1NSR0IubXVsKCBjb2xvcnRvbmUgKSApO1xuXHRjb2xvcnRvbmUuYXNzaWduKCBjbGFtcCggY29sb3J0b25lLCAwLjAsIDEuMCApICk7XG5cblx0cmV0dXJuIGNvbG9ydG9uZTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnYWd4VG9uZU1hcHBpbmcnLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAnZXhwb3N1cmUnLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG4vLyBodHRwczovL21vZGVsdmlld2VyLmRldi9leGFtcGxlcy90b25lLW1hcHBpbmdcblxuZXhwb3J0IGNvbnN0IG5ldXRyYWxUb25lTWFwcGluZyA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBjb2xvciwgZXhwb3N1cmUgXSApID0+IHtcblxuXHRjb25zdCBTdGFydENvbXByZXNzaW9uID0gZmxvYXQoIDAuOCAtIDAuMDQgKTtcblx0Y29uc3QgRGVzYXR1cmF0aW9uID0gZmxvYXQoIDAuMTUgKTtcblxuXHRjb2xvciA9IGNvbG9yLm11bCggZXhwb3N1cmUgKTtcblxuXHRjb25zdCB4ID0gbWluKCBjb2xvci5yLCBtaW4oIGNvbG9yLmcsIGNvbG9yLmIgKSApO1xuXHRjb25zdCBvZmZzZXQgPSBzZWxlY3QoIHgubGVzc1RoYW4oIDAuMDggKSwgeC5zdWIoIG11bCggNi4yNSwgeC5tdWwoIHggKSApICksIDAuMDQgKTtcblxuXHRjb2xvci5zdWJBc3NpZ24oIG9mZnNldCApO1xuXG5cdGNvbnN0IHBlYWsgPSBtYXgoIGNvbG9yLnIsIG1heCggY29sb3IuZywgY29sb3IuYiApICk7XG5cblx0SWYoIHBlYWsubGVzc1RoYW4oIFN0YXJ0Q29tcHJlc3Npb24gKSwgKCkgPT4ge1xuXG5cdFx0cmV0dXJuIGNvbG9yO1xuXG5cdH0gKTtcblxuXHRjb25zdCBkID0gc3ViKCAxLCBTdGFydENvbXByZXNzaW9uICk7XG5cdGNvbnN0IG5ld1BlYWsgPSBzdWIoIDEsIGQubXVsKCBkICkuZGl2KCBwZWFrLmFkZCggZC5zdWIoIFN0YXJ0Q29tcHJlc3Npb24gKSApICkgKTtcblx0Y29sb3IubXVsQXNzaWduKCBuZXdQZWFrLmRpdiggcGVhayApICk7XG5cdGNvbnN0IGcgPSBzdWIoIDEsIGRpdiggMSwgRGVzYXR1cmF0aW9uLm11bCggcGVhay5zdWIoIG5ld1BlYWsgKSApLmFkZCggMSApICkgKTtcblxuXHRyZXR1cm4gbWl4KCBjb2xvciwgdmVjMyggbmV3UGVhayApLCBnICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ25ldXRyYWxUb25lTWFwcGluZycsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICdleHBvc3VyZScsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5jbGFzcyBDb2RlTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnQ29kZU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggY29kZSA9ICcnLCBpbmNsdWRlcyA9IFtdLCBsYW5ndWFnZSA9ICcnICkge1xuXG5cdFx0c3VwZXIoICdjb2RlJyApO1xuXG5cdFx0dGhpcy5pc0NvZGVOb2RlID0gdHJ1ZTtcblxuXHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cdFx0dGhpcy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuXG5cdFx0dGhpcy5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuXG5cdH1cblxuXHRpc0dsb2JhbCgpIHtcblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxuXHRzZXRJbmNsdWRlcyggaW5jbHVkZXMgKSB7XG5cblx0XHR0aGlzLmluY2x1ZGVzID0gaW5jbHVkZXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0SW5jbHVkZXMoIC8qYnVpbGRlciovICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaW5jbHVkZXM7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgaW5jbHVkZXMgPSB0aGlzLmdldEluY2x1ZGVzKCBidWlsZGVyICk7XG5cblx0XHRmb3IgKCBjb25zdCBpbmNsdWRlIG9mIGluY2x1ZGVzICkge1xuXG5cdFx0XHRpbmNsdWRlLmJ1aWxkKCBidWlsZGVyICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBub2RlQ29kZSA9IGJ1aWxkZXIuZ2V0Q29kZUZyb21Ob2RlKCB0aGlzLCB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICkgKTtcblx0XHRub2RlQ29kZS5jb2RlID0gdGhpcy5jb2RlO1xuXG5cdFx0cmV0dXJuIG5vZGVDb2RlLmNvZGU7XG5cblx0fVxuXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcblxuXHRcdHN1cGVyLnNlcmlhbGl6ZSggZGF0YSApO1xuXG5cdFx0ZGF0YS5jb2RlID0gdGhpcy5jb2RlO1xuXHRcdGRhdGEubGFuZ3VhZ2UgPSB0aGlzLmxhbmd1YWdlO1xuXG5cdH1cblxuXHRkZXNlcmlhbGl6ZSggZGF0YSApIHtcblxuXHRcdHN1cGVyLmRlc2VyaWFsaXplKCBkYXRhICk7XG5cblx0XHR0aGlzLmNvZGUgPSBkYXRhLmNvZGU7XG5cdFx0dGhpcy5sYW5ndWFnZSA9IGRhdGEubGFuZ3VhZ2U7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGVOb2RlO1xuXG5leHBvcnQgY29uc3QgY29kZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBDb2RlTm9kZSApO1xuXG5leHBvcnQgY29uc3QganMgPSAoIHNyYywgaW5jbHVkZXMgKSA9PiBjb2RlKCBzcmMsIGluY2x1ZGVzLCAnanMnICk7XG5leHBvcnQgY29uc3Qgd2dzbCA9ICggc3JjLCBpbmNsdWRlcyApID0+IGNvZGUoIHNyYywgaW5jbHVkZXMsICd3Z3NsJyApO1xuZXhwb3J0IGNvbnN0IGdsc2wgPSAoIHNyYywgaW5jbHVkZXMgKSA9PiBjb2RlKCBzcmMsIGluY2x1ZGVzLCAnZ2xzbCcgKTtcbiIsImltcG9ydCBDb2RlTm9kZSBmcm9tICcuL0NvZGVOb2RlLmpzJztcbmltcG9ydCB7IG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIEZ1bmN0aW9uTm9kZSBleHRlbmRzIENvZGVOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0Z1bmN0aW9uTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBjb2RlID0gJycsIGluY2x1ZGVzID0gW10sIGxhbmd1YWdlID0gJycgKSB7XG5cblx0XHRzdXBlciggY29kZSwgaW5jbHVkZXMsIGxhbmd1YWdlICk7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0Tm9kZUZ1bmN0aW9uKCBidWlsZGVyICkudHlwZTtcblxuXHR9XG5cblx0Z2V0SW5wdXRzKCBidWlsZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0Tm9kZUZ1bmN0aW9uKCBidWlsZGVyICkuaW5wdXRzO1xuXG5cdH1cblxuXHRnZXROb2RlRnVuY3Rpb24oIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBub2RlRGF0YSA9IGJ1aWxkZXIuZ2V0RGF0YUZyb21Ob2RlKCB0aGlzICk7XG5cblx0XHRsZXQgbm9kZUZ1bmN0aW9uID0gbm9kZURhdGEubm9kZUZ1bmN0aW9uO1xuXG5cdFx0aWYgKCBub2RlRnVuY3Rpb24gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bm9kZUZ1bmN0aW9uID0gYnVpbGRlci5wYXJzZXIucGFyc2VGdW5jdGlvbiggdGhpcy5jb2RlICk7XG5cblx0XHRcdG5vZGVEYXRhLm5vZGVGdW5jdGlvbiA9IG5vZGVGdW5jdGlvbjtcblxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlRnVuY3Rpb247XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XG5cblx0XHRzdXBlci5nZW5lcmF0ZSggYnVpbGRlciApO1xuXG5cdFx0Y29uc3Qgbm9kZUZ1bmN0aW9uID0gdGhpcy5nZXROb2RlRnVuY3Rpb24oIGJ1aWxkZXIgKTtcblxuXHRcdGNvbnN0IG5hbWUgPSBub2RlRnVuY3Rpb24ubmFtZTtcblx0XHRjb25zdCB0eXBlID0gbm9kZUZ1bmN0aW9uLnR5cGU7XG5cblx0XHRjb25zdCBub2RlQ29kZSA9IGJ1aWxkZXIuZ2V0Q29kZUZyb21Ob2RlKCB0aGlzLCB0eXBlICk7XG5cblx0XHRpZiAoIG5hbWUgIT09ICcnICkge1xuXG5cdFx0XHQvLyB1c2UgYSBjdXN0b20gcHJvcGVydHkgbmFtZVxuXG5cdFx0XHRub2RlQ29kZS5uYW1lID0gbmFtZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0UHJvcGVydHlOYW1lKCBub2RlQ29kZSApO1xuXG5cdFx0Y29uc3QgY29kZSA9IHRoaXMuZ2V0Tm9kZUZ1bmN0aW9uKCBidWlsZGVyICkuZ2V0Q29kZSggcHJvcGVydHlOYW1lICk7XG5cblx0XHRub2RlQ29kZS5jb2RlID0gY29kZSArICdcXG4nO1xuXG5cdFx0aWYgKCBvdXRwdXQgPT09ICdwcm9wZXJ0eScgKSB7XG5cblx0XHRcdHJldHVybiBwcm9wZXJ0eU5hbWU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIGAkeyBwcm9wZXJ0eU5hbWUgfSgpYCwgdHlwZSwgb3V0cHV0ICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEZ1bmN0aW9uTm9kZTtcblxuY29uc3QgbmF0aXZlRm4gPSAoIGNvZGUsIGluY2x1ZGVzID0gW10sIGxhbmd1YWdlID0gJycgKSA9PiB7XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0Y29uc3QgaW5jbHVkZSA9IGluY2x1ZGVzWyBpIF07XG5cblx0XHQvLyBUU0wgRnVuY3Rpb246IGdsc2xGbiwgd2dzbEZuXG5cblx0XHRpZiAoIHR5cGVvZiBpbmNsdWRlID09PSAnZnVuY3Rpb24nICkge1xuXG5cdFx0XHRpbmNsdWRlc1sgaSBdID0gaW5jbHVkZS5mdW5jdGlvbk5vZGU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IGZ1bmN0aW9uTm9kZSA9IG5vZGVPYmplY3QoIG5ldyBGdW5jdGlvbk5vZGUoIGNvZGUsIGluY2x1ZGVzLCBsYW5ndWFnZSApICk7XG5cblx0Y29uc3QgZm4gPSAoIC4uLnBhcmFtcyApID0+IGZ1bmN0aW9uTm9kZS5jYWxsKCAuLi5wYXJhbXMgKTtcblx0Zm4uZnVuY3Rpb25Ob2RlID0gZnVuY3Rpb25Ob2RlO1xuXG5cdHJldHVybiBmbjtcblxufTtcblxuZXhwb3J0IGNvbnN0IGdsc2xGbiA9ICggY29kZSwgaW5jbHVkZXMgKSA9PiBuYXRpdmVGbiggY29kZSwgaW5jbHVkZXMsICdnbHNsJyApO1xuZXhwb3J0IGNvbnN0IHdnc2xGbiA9ICggY29kZSwgaW5jbHVkZXMgKSA9PiBuYXRpdmVGbiggY29kZSwgaW5jbHVkZXMsICd3Z3NsJyApO1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcbmltcG9ydCB7IGFycmF5QnVmZmVyVG9CYXNlNjQsIGJhc2U2NFRvQXJyYXlCdWZmZXIgfSBmcm9tICcuLi9jb3JlL05vZGVVdGlscy5qcyc7XG5pbXBvcnQgeyBub2RlUHJveHksIGZsb2F0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuLi8uLi9jb3JlL0V2ZW50RGlzcGF0Y2hlci5qcyc7XG5cbmNsYXNzIFNjcmlwdGFibGVWYWx1ZU5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1NjcmlwdGFibGVWYWx1ZU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggdmFsdWUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cdFx0dGhpcy5fY2FjaGUgPSBudWxsO1xuXG5cdFx0dGhpcy5pbnB1dFR5cGUgPSBudWxsO1xuXHRcdHRoaXMub3V0cHVUeXBlID0gbnVsbDtcblxuXHRcdHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xuXG5cdFx0dGhpcy5pc1NjcmlwdGFibGVWYWx1ZU5vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRnZXQgaXNTY3JpcHRhYmxlT3V0cHV0Tm9kZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLm91dHB1dFR5cGUgIT09IG51bGw7XG5cblx0fVxuXG5cdHNldCB2YWx1ZSggdmFsICkge1xuXG5cdFx0aWYgKCB0aGlzLl92YWx1ZSA9PT0gdmFsICkgcmV0dXJuO1xuXG5cdFx0aWYgKCB0aGlzLl9jYWNoZSAmJiB0aGlzLmlucHV0VHlwZSA9PT0gJ1VSTCcgJiYgdGhpcy52YWx1ZS52YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICkge1xuXG5cdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKCB0aGlzLl9jYWNoZSApO1xuXG5cdFx0XHR0aGlzLl9jYWNoZSA9IG51bGw7XG5cblx0XHR9XG5cblx0XHR0aGlzLl92YWx1ZSA9IHZhbDtcblxuXHRcdHRoaXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2NoYW5nZScgfSApO1xuXG5cdFx0dGhpcy5yZWZyZXNoKCk7XG5cblx0fVxuXG5cdGdldCB2YWx1ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblxuXHR9XG5cblx0cmVmcmVzaCgpIHtcblxuXHRcdHRoaXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlZnJlc2gnIH0gKTtcblxuXHR9XG5cblx0Z2V0VmFsdWUoKSB7XG5cblx0XHRjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWU7XG5cblx0XHRpZiAoIHZhbHVlICYmIHRoaXMuX2NhY2hlID09PSBudWxsICYmIHRoaXMuaW5wdXRUeXBlID09PSAnVVJMJyAmJiB2YWx1ZS52YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICkge1xuXG5cdFx0XHR0aGlzLl9jYWNoZSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoIG5ldyBCbG9iKCBbIHZhbHVlLnZhbHVlIF0gKSApO1xuXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUudmFsdWUgIT09IG51bGwgJiYgdmFsdWUudmFsdWUgIT09IHVuZGVmaW5lZCAmJiAoXG5cdFx0XHQoICggdGhpcy5pbnB1dFR5cGUgPT09ICdVUkwnIHx8IHRoaXMuaW5wdXRUeXBlID09PSAnU3RyaW5nJyApICYmIHR5cGVvZiB2YWx1ZS52YWx1ZSA9PT0gJ3N0cmluZycgKSB8fFxuXHRcdFx0KCB0aGlzLmlucHV0VHlwZSA9PT0gJ051bWJlcicgJiYgdHlwZW9mIHZhbHVlLnZhbHVlID09PSAnbnVtYmVyJyApIHx8XG5cdFx0XHQoIHRoaXMuaW5wdXRUeXBlID09PSAnVmVjdG9yMicgJiYgdmFsdWUudmFsdWUuaXNWZWN0b3IyICkgfHxcblx0XHRcdCggdGhpcy5pbnB1dFR5cGUgPT09ICdWZWN0b3IzJyAmJiB2YWx1ZS52YWx1ZS5pc1ZlY3RvcjMgKSB8fFxuXHRcdFx0KCB0aGlzLmlucHV0VHlwZSA9PT0gJ1ZlY3RvcjQnICYmIHZhbHVlLnZhbHVlLmlzVmVjdG9yNCApIHx8XG5cdFx0XHQoIHRoaXMuaW5wdXRUeXBlID09PSAnQ29sb3InICYmIHZhbHVlLnZhbHVlLmlzQ29sb3IgKSB8fFxuXHRcdFx0KCB0aGlzLmlucHV0VHlwZSA9PT0gJ01hdHJpeDMnICYmIHZhbHVlLnZhbHVlLmlzTWF0cml4MyApIHx8XG5cdFx0XHQoIHRoaXMuaW5wdXRUeXBlID09PSAnTWF0cml4NCcgJiYgdmFsdWUudmFsdWUuaXNNYXRyaXg0IClcblx0XHQpICkge1xuXG5cdFx0XHRyZXR1cm4gdmFsdWUudmFsdWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fY2FjaGUgfHwgdmFsdWU7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5pc05vZGUgPyB0aGlzLnZhbHVlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgOiAnZmxvYXQnO1xuXG5cdH1cblxuXHRzZXR1cCgpIHtcblxuXHRcdHJldHVybiB0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUuaXNOb2RlID8gdGhpcy52YWx1ZSA6IGZsb2F0KCk7XG5cblx0fVxuXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcblxuXHRcdHN1cGVyLnNlcmlhbGl6ZSggZGF0YSApO1xuXG5cdFx0aWYgKCB0aGlzLnZhbHVlICE9PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuaW5wdXRUeXBlID09PSAnQXJyYXlCdWZmZXInICkge1xuXG5cdFx0XHRcdGRhdGEudmFsdWUgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KCB0aGlzLnZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZGF0YS52YWx1ZSA9IHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnRvSlNPTiggZGF0YS5tZXRhICkudXVpZCA6IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGRhdGEudmFsdWUgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0ZGF0YS5pbnB1dFR5cGUgPSB0aGlzLmlucHV0VHlwZTtcblx0XHRkYXRhLm91dHB1dFR5cGUgPSB0aGlzLm91dHB1dFR5cGU7XG5cblx0fVxuXG5cdGRlc2VyaWFsaXplKCBkYXRhICkge1xuXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcblxuXHRcdGxldCB2YWx1ZSA9IG51bGw7XG5cblx0XHRpZiAoIGRhdGEudmFsdWUgIT09IG51bGwgKSB7XG5cblx0XHRcdGlmICggZGF0YS5pbnB1dFR5cGUgPT09ICdBcnJheUJ1ZmZlcicgKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBiYXNlNjRUb0FycmF5QnVmZmVyKCBkYXRhLnZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGRhdGEuaW5wdXRUeXBlID09PSAnVGV4dHVyZScgKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBkYXRhLm1ldGEudGV4dHVyZXNbIGRhdGEudmFsdWUgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGRhdGEubWV0YS5ub2Rlc1sgZGF0YS52YWx1ZSBdIHx8IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuXHRcdHRoaXMuaW5wdXRUeXBlID0gZGF0YS5pbnB1dFR5cGU7XG5cdFx0dGhpcy5vdXRwdXRUeXBlID0gZGF0YS5vdXRwdXRUeXBlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTY3JpcHRhYmxlVmFsdWVOb2RlO1xuXG5leHBvcnQgY29uc3Qgc2NyaXB0YWJsZVZhbHVlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFNjcmlwdGFibGVWYWx1ZU5vZGUgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBzY3JpcHRhYmxlVmFsdWUgfSBmcm9tICcuL1NjcmlwdGFibGVWYWx1ZU5vZGUuanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5LCBmbG9hdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IGhhc2hBcnJheSwgaGFzaFN0cmluZyB9IGZyb20gJy4uL2NvcmUvTm9kZVV0aWxzLmpzJztcblxuY2xhc3MgUmVzb3VyY2VzIGV4dGVuZHMgTWFwIHtcblxuXHRnZXQoIGtleSwgY2FsbGJhY2sgPSBudWxsLCAuLi5wYXJhbXMgKSB7XG5cblx0XHRpZiAoIHRoaXMuaGFzKCBrZXkgKSApIHJldHVybiBzdXBlci5nZXQoIGtleSApO1xuXG5cdFx0aWYgKCBjYWxsYmFjayAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgdmFsdWUgPSBjYWxsYmFjayggLi4ucGFyYW1zICk7XG5cdFx0XHR0aGlzLnNldCgga2V5LCB2YWx1ZSApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5jbGFzcyBQYXJhbWV0ZXJzIHtcblxuXHRjb25zdHJ1Y3Rvciggc2NyaXB0YWJsZU5vZGUgKSB7XG5cblx0XHR0aGlzLnNjcmlwdGFibGVOb2RlID0gc2NyaXB0YWJsZU5vZGU7XG5cblx0fVxuXG5cdGdldCBwYXJhbWV0ZXJzKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2NyaXB0YWJsZU5vZGUucGFyYW1ldGVycztcblxuXHR9XG5cblx0Z2V0IGxheW91dCgpIHtcblxuXHRcdHJldHVybiB0aGlzLnNjcmlwdGFibGVOb2RlLmdldExheW91dCgpO1xuXG5cdH1cblxuXHRnZXRJbnB1dExheW91dCggaWQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zY3JpcHRhYmxlTm9kZS5nZXRJbnB1dExheW91dCggaWQgKTtcblxuXHR9XG5cblx0Z2V0KCBuYW1lICkge1xuXG5cdFx0Y29uc3QgcGFyYW0gPSB0aGlzLnBhcmFtZXRlcnNbIG5hbWUgXTtcblx0XHRjb25zdCB2YWx1ZSA9IHBhcmFtID8gcGFyYW0uZ2V0VmFsdWUoKSA6IG51bGw7XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBjb25zdCBTY3JpcHRhYmxlTm9kZVJlc291cmNlcyA9IG5ldyBSZXNvdXJjZXMoKTtcblxuY2xhc3MgU2NyaXB0YWJsZU5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1NjcmlwdGFibGVOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGNvZGVOb2RlID0gbnVsbCwgcGFyYW1ldGVycyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuY29kZU5vZGUgPSBjb2RlTm9kZTtcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuXG5cdFx0dGhpcy5fbG9jYWwgPSBuZXcgUmVzb3VyY2VzKCk7XG5cdFx0dGhpcy5fb3V0cHV0ID0gc2NyaXB0YWJsZVZhbHVlKCk7XG5cdFx0dGhpcy5fb3V0cHV0cyA9IHt9O1xuXHRcdHRoaXMuX3NvdXJjZSA9IHRoaXMuc291cmNlO1xuXHRcdHRoaXMuX21ldGhvZCA9IG51bGw7XG5cdFx0dGhpcy5fb2JqZWN0ID0gbnVsbDtcblx0XHR0aGlzLl92YWx1ZSA9IG51bGw7XG5cdFx0dGhpcy5fbmVlZHNPdXRwdXRVcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5vblJlZnJlc2ggPSB0aGlzLm9uUmVmcmVzaC5iaW5kKCB0aGlzICk7XG5cblx0XHR0aGlzLmlzU2NyaXB0YWJsZU5vZGUgPSB0cnVlO1xuXG5cdH1cblxuXHRnZXQgc291cmNlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29kZU5vZGUgPyB0aGlzLmNvZGVOb2RlLmNvZGUgOiAnJztcblxuXHR9XG5cblx0c2V0TG9jYWwoIG5hbWUsIHZhbHVlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2xvY2FsLnNldCggbmFtZSwgdmFsdWUgKTtcblxuXHR9XG5cblx0Z2V0TG9jYWwoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fbG9jYWwuZ2V0KCBuYW1lICk7XG5cblx0fVxuXG5cdG9uUmVmcmVzaCgpIHtcblxuXHRcdHRoaXMuX3JlZnJlc2goKTtcblxuXHR9XG5cblx0Z2V0SW5wdXRMYXlvdXQoIGlkICkge1xuXG5cdFx0Zm9yICggY29uc3QgZWxlbWVudCBvZiB0aGlzLmdldExheW91dCgpICkge1xuXG5cdFx0XHRpZiAoIGVsZW1lbnQuaW5wdXRUeXBlICYmICggZWxlbWVudC5pZCA9PT0gaWQgfHwgZWxlbWVudC5uYW1lID09PSBpZCApICkge1xuXG5cdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldE91dHB1dExheW91dCggaWQgKSB7XG5cblx0XHRmb3IgKCBjb25zdCBlbGVtZW50IG9mIHRoaXMuZ2V0TGF5b3V0KCkgKSB7XG5cblx0XHRcdGlmICggZWxlbWVudC5vdXRwdXRUeXBlICYmICggZWxlbWVudC5pZCA9PT0gaWQgfHwgZWxlbWVudC5uYW1lID09PSBpZCApICkge1xuXG5cdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldE91dHB1dCggbmFtZSwgdmFsdWUgKSB7XG5cblx0XHRjb25zdCBvdXRwdXRzID0gdGhpcy5fb3V0cHV0cztcblxuXHRcdGlmICggb3V0cHV0c1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG91dHB1dHNbIG5hbWUgXSA9IHNjcmlwdGFibGVWYWx1ZSggdmFsdWUgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG91dHB1dHNbIG5hbWUgXS52YWx1ZSA9IHZhbHVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE91dHB1dCggbmFtZSApIHtcblxuXHRcdHJldHVybiB0aGlzLl9vdXRwdXRzWyBuYW1lIF07XG5cblx0fVxuXG5cdGdldFBhcmFtZXRlciggbmFtZSApIHtcblxuXHRcdHJldHVybiB0aGlzLnBhcmFtZXRlcnNbIG5hbWUgXTtcblxuXHR9XG5cblx0c2V0UGFyYW1ldGVyKCBuYW1lLCB2YWx1ZSApIHtcblxuXHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRpZiAoIHZhbHVlICYmIHZhbHVlLmlzU2NyaXB0YWJsZU5vZGUgKSB7XG5cblx0XHRcdHRoaXMuZGVsZXRlUGFyYW1ldGVyKCBuYW1lICk7XG5cblx0XHRcdHBhcmFtZXRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0cGFyYW1ldGVyc1sgbmFtZSBdLmdldERlZmF1bHRPdXRwdXQoKS5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lciggJ3JlZnJlc2gnLCB0aGlzLm9uUmVmcmVzaCApO1xuXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNTY3JpcHRhYmxlVmFsdWVOb2RlICkge1xuXG5cdFx0XHR0aGlzLmRlbGV0ZVBhcmFtZXRlciggbmFtZSApO1xuXG5cdFx0XHRwYXJhbWV0ZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdHBhcmFtZXRlcnNbIG5hbWUgXS5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lciggJ3JlZnJlc2gnLCB0aGlzLm9uUmVmcmVzaCApO1xuXG5cdFx0fSBlbHNlIGlmICggcGFyYW1ldGVyc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBhcmFtZXRlcnNbIG5hbWUgXSA9IHNjcmlwdGFibGVWYWx1ZSggdmFsdWUgKTtcblx0XHRcdHBhcmFtZXRlcnNbIG5hbWUgXS5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lciggJ3JlZnJlc2gnLCB0aGlzLm9uUmVmcmVzaCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cGFyYW1ldGVyc1sgbmFtZSBdLnZhbHVlID0gdmFsdWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0VmFsdWUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXREZWZhdWx0T3V0cHV0KCkuZ2V0VmFsdWUoKTtcblxuXHR9XG5cblx0ZGVsZXRlUGFyYW1ldGVyKCBuYW1lICkge1xuXG5cdFx0bGV0IHZhbHVlTm9kZSA9IHRoaXMucGFyYW1ldGVyc1sgbmFtZSBdO1xuXG5cdFx0aWYgKCB2YWx1ZU5vZGUgKSB7XG5cblx0XHRcdGlmICggdmFsdWVOb2RlLmlzU2NyaXB0YWJsZU5vZGUgKSB2YWx1ZU5vZGUgPSB2YWx1ZU5vZGUuZ2V0RGVmYXVsdE91dHB1dCgpO1xuXG5cdFx0XHR2YWx1ZU5vZGUuZXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdyZWZyZXNoJywgdGhpcy5vblJlZnJlc2ggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGVhclBhcmFtZXRlcnMoKSB7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKCB0aGlzLnBhcmFtZXRlcnMgKSApIHtcblxuXHRcdFx0dGhpcy5kZWxldGVQYXJhbWV0ZXIoIG5hbWUgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNhbGwoIG5hbWUsIC4uLnBhcmFtcyApIHtcblxuXHRcdGNvbnN0IG9iamVjdCA9IHRoaXMuZ2V0T2JqZWN0KCk7XG5cdFx0Y29uc3QgbWV0aG9kID0gb2JqZWN0WyBuYW1lIF07XG5cblx0XHRpZiAoIHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicgKSB7XG5cblx0XHRcdHJldHVybiBtZXRob2QoIC4uLnBhcmFtcyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRhc3luYyBjYWxsQXN5bmMoIG5hbWUsIC4uLnBhcmFtcyApIHtcblxuXHRcdGNvbnN0IG9iamVjdCA9IHRoaXMuZ2V0T2JqZWN0KCk7XG5cdFx0Y29uc3QgbWV0aG9kID0gb2JqZWN0WyBuYW1lIF07XG5cblx0XHRpZiAoIHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicgKSB7XG5cblx0XHRcdHJldHVybiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FzeW5jRnVuY3Rpb24nID8gYXdhaXQgbWV0aG9kKCAuLi5wYXJhbXMgKSA6IG1ldGhvZCggLi4ucGFyYW1zICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGVmYXVsdE91dHB1dE5vZGUoKS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXG5cdH1cblxuXHRyZWZyZXNoKCBvdXRwdXQgPSBudWxsICkge1xuXG5cdFx0aWYgKCBvdXRwdXQgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuZ2V0T3V0cHV0KCBvdXRwdXQgKS5yZWZyZXNoKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldE9iamVjdCgpIHtcblxuXHRcdGlmICggdGhpcy5uZWVkc1VwZGF0ZSApIHRoaXMuZGlzcG9zZSgpO1xuXHRcdGlmICggdGhpcy5fb2JqZWN0ICE9PSBudWxsICkgcmV0dXJuIHRoaXMuX29iamVjdDtcblxuXHRcdC8vXG5cblx0XHRjb25zdCByZWZyZXNoID0gKCkgPT4gdGhpcy5yZWZyZXNoKCk7XG5cdFx0Y29uc3Qgc2V0T3V0cHV0ID0gKCBpZCwgdmFsdWUgKSA9PiB0aGlzLnNldE91dHB1dCggaWQsIHZhbHVlICk7XG5cblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gbmV3IFBhcmFtZXRlcnMoIHRoaXMgKTtcblxuXHRcdGNvbnN0IFRIUkVFID0gU2NyaXB0YWJsZU5vZGVSZXNvdXJjZXMuZ2V0KCAnVEhSRUUnICk7XG5cdFx0Y29uc3QgVFNMID0gU2NyaXB0YWJsZU5vZGVSZXNvdXJjZXMuZ2V0KCAnVFNMJyApO1xuXG5cdFx0Y29uc3QgbWV0aG9kID0gdGhpcy5nZXRNZXRob2QoIHRoaXMuY29kZU5vZGUgKTtcblx0XHRjb25zdCBwYXJhbXMgPSBbIHBhcmFtZXRlcnMsIHRoaXMuX2xvY2FsLCBTY3JpcHRhYmxlTm9kZVJlc291cmNlcywgcmVmcmVzaCwgc2V0T3V0cHV0LCBUSFJFRSwgVFNMIF07XG5cblx0XHR0aGlzLl9vYmplY3QgPSBtZXRob2QoIC4uLnBhcmFtcyApO1xuXG5cdFx0Y29uc3QgbGF5b3V0ID0gdGhpcy5fb2JqZWN0LmxheW91dDtcblxuXHRcdGlmICggbGF5b3V0ICkge1xuXG5cdFx0XHRpZiAoIGxheW91dC5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0dGhpcy5fbG9jYWwuY2xlYXIoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZhdWx0IG91dHB1dFxuXHRcdFx0dGhpcy5fb3V0cHV0Lm91dHB1dFR5cGUgPSBsYXlvdXQub3V0cHV0VHlwZSB8fCBudWxsO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGxheW91dC5lbGVtZW50cyApICkge1xuXG5cdFx0XHRcdGZvciAoIGNvbnN0IGVsZW1lbnQgb2YgbGF5b3V0LmVsZW1lbnRzICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgaWQgPSBlbGVtZW50LmlkIHx8IGVsZW1lbnQubmFtZTtcblxuXHRcdFx0XHRcdGlmICggZWxlbWVudC5pbnB1dFR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdGhpcy5nZXRQYXJhbWV0ZXIoIGlkICkgPT09IHVuZGVmaW5lZCApIHRoaXMuc2V0UGFyYW1ldGVyKCBpZCwgbnVsbCApO1xuXG5cdFx0XHRcdFx0XHR0aGlzLmdldFBhcmFtZXRlciggaWQgKS5pbnB1dFR5cGUgPSBlbGVtZW50LmlucHV0VHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZWxlbWVudC5vdXRwdXRUeXBlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuZ2V0T3V0cHV0KCBpZCApID09PSB1bmRlZmluZWQgKSB0aGlzLnNldE91dHB1dCggaWQsIG51bGwgKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5nZXRPdXRwdXQoIGlkICkub3V0cHV0VHlwZSA9IGVsZW1lbnQub3V0cHV0VHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9vYmplY3Q7XG5cblx0fVxuXG5cdGRlc2VyaWFsaXplKCBkYXRhICkge1xuXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gdGhpcy5wYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRsZXQgdmFsdWVOb2RlID0gdGhpcy5wYXJhbWV0ZXJzWyBuYW1lIF07XG5cblx0XHRcdGlmICggdmFsdWVOb2RlLmlzU2NyaXB0YWJsZU5vZGUgKSB2YWx1ZU5vZGUgPSB2YWx1ZU5vZGUuZ2V0RGVmYXVsdE91dHB1dCgpO1xuXG5cdFx0XHR2YWx1ZU5vZGUuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoICdyZWZyZXNoJywgdGhpcy5vblJlZnJlc2ggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2V0TGF5b3V0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0KCkubGF5b3V0O1xuXG5cdH1cblxuXHRnZXREZWZhdWx0T3V0cHV0Tm9kZSgpIHtcblxuXHRcdGNvbnN0IG91dHB1dCA9IHRoaXMuZ2V0RGVmYXVsdE91dHB1dCgpLnZhbHVlO1xuXG5cdFx0aWYgKCBvdXRwdXQgJiYgb3V0cHV0LmlzTm9kZSApIHtcblxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmbG9hdCgpO1xuXG5cdH1cblxuXHRnZXREZWZhdWx0T3V0cHV0KClcdHtcblxuXHRcdHJldHVybiB0aGlzLl9leGVjKCkuX291dHB1dDtcblxuXHR9XG5cblx0Z2V0TWV0aG9kKCkge1xuXG5cdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkgdGhpcy5kaXNwb3NlKCk7XG5cdFx0aWYgKCB0aGlzLl9tZXRob2QgIT09IG51bGwgKSByZXR1cm4gdGhpcy5fbWV0aG9kO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IHBhcmFtZXRlcnNQcm9wcyA9IFsgJ3BhcmFtZXRlcnMnLCAnbG9jYWwnLCAnZ2xvYmFsJywgJ3JlZnJlc2gnLCAnc2V0T3V0cHV0JywgJ1RIUkVFJywgJ1RTTCcgXTtcblx0XHRjb25zdCBpbnRlcmZhY2VQcm9wcyA9IFsgJ2xheW91dCcsICdpbml0JywgJ21haW4nLCAnZGlzcG9zZScgXTtcblxuXHRcdGNvbnN0IHByb3BlcnRpZXMgPSBpbnRlcmZhY2VQcm9wcy5qb2luKCAnLCAnICk7XG5cdFx0Y29uc3QgZGVjbGFyYXRpb25zID0gJ3ZhciAnICsgcHJvcGVydGllcyArICc7IHZhciBvdXRwdXQgPSB7fTtcXG4nO1xuXHRcdGNvbnN0IHJldHVybnMgPSAnXFxucmV0dXJuIHsgLi4ub3V0cHV0LCAnICsgcHJvcGVydGllcyArICcgfTsnO1xuXG5cdFx0Y29uc3QgY29kZSA9IGRlY2xhcmF0aW9ucyArIHRoaXMuY29kZU5vZGUuY29kZSArIHJldHVybnM7XG5cblx0XHQvL1xuXG5cdFx0dGhpcy5fbWV0aG9kID0gbmV3IEZ1bmN0aW9uKCAuLi5wYXJhbWV0ZXJzUHJvcHMsIGNvZGUgKTtcblxuXHRcdHJldHVybiB0aGlzLl9tZXRob2Q7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHRpZiAoIHRoaXMuX21ldGhvZCA9PT0gbnVsbCApIHJldHVybjtcblxuXHRcdGlmICggdGhpcy5fb2JqZWN0ICYmIHR5cGVvZiB0aGlzLl9vYmplY3QuZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblxuXHRcdFx0dGhpcy5fb2JqZWN0LmRpc3Bvc2UoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX21ldGhvZCA9IG51bGw7XG5cdFx0dGhpcy5fb2JqZWN0ID0gbnVsbDtcblx0XHR0aGlzLl9zb3VyY2UgPSBudWxsO1xuXHRcdHRoaXMuX3ZhbHVlID0gbnVsbDtcblx0XHR0aGlzLl9uZWVkc091dHB1dFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fb3V0cHV0LnZhbHVlID0gbnVsbDtcblx0XHR0aGlzLl9vdXRwdXRzID0ge307XG5cblx0fVxuXG5cdHNldHVwKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGVmYXVsdE91dHB1dE5vZGUoKTtcblxuXHR9XG5cblx0Z2V0Q2FjaGVLZXkoIGZvcmNlICkge1xuXG5cdFx0Y29uc3QgdmFsdWVzID0gWyBoYXNoU3RyaW5nKCB0aGlzLnNvdXJjZSApLCB0aGlzLmdldERlZmF1bHRPdXRwdXROb2RlKCkuZ2V0Q2FjaGVLZXkoIGZvcmNlICkgXTtcblxuXHRcdGZvciAoIGNvbnN0IHBhcmFtIGluIHRoaXMucGFyYW1ldGVycyApIHtcblxuXHRcdFx0dmFsdWVzLnB1c2goIHRoaXMucGFyYW1ldGVyc1sgcGFyYW0gXS5nZXRDYWNoZUtleSggZm9yY2UgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhc2hBcnJheSggdmFsdWVzICk7XG5cblx0fVxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy5kaXNwb3NlKCk7XG5cblx0fVxuXG5cdGdldCBuZWVkc1VwZGF0ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnNvdXJjZSAhPT0gdGhpcy5fc291cmNlO1xuXG5cdH1cblxuXHRfZXhlYygpXHR7XG5cblx0XHRpZiAoIHRoaXMuY29kZU5vZGUgPT09IG51bGwgKSByZXR1cm4gdGhpcztcblxuXHRcdGlmICggdGhpcy5fbmVlZHNPdXRwdXRVcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdHRoaXMuX3ZhbHVlID0gdGhpcy5jYWxsKCAnbWFpbicgKTtcblxuXHRcdFx0dGhpcy5fbmVlZHNPdXRwdXRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX291dHB1dC52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdF9yZWZyZXNoKCkge1xuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR0aGlzLl9leGVjKCk7XG5cblx0XHR0aGlzLl9vdXRwdXQucmVmcmVzaCgpO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTY3JpcHRhYmxlTm9kZTtcblxuZXhwb3J0IGNvbnN0IHNjcmlwdGFibGUgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggU2NyaXB0YWJsZU5vZGUgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBwb3NpdGlvblZpZXcgfSBmcm9tICcuLi9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5jbGFzcyBGb2dOb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdGb2dOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yTm9kZSwgZmFjdG9yTm9kZSApIHtcblxuXHRcdHN1cGVyKCAnZmxvYXQnICk7XG5cblx0XHR0aGlzLmlzRm9nTm9kZSA9IHRydWU7XG5cblx0XHR0aGlzLmNvbG9yTm9kZSA9IGNvbG9yTm9kZTtcblx0XHR0aGlzLmZhY3Rvck5vZGUgPSBmYWN0b3JOb2RlO1xuXG5cdH1cblxuXHRnZXRWaWV3Wk5vZGUoIGJ1aWxkZXIgKSB7XG5cblx0XHRsZXQgdmlld1o7XG5cblx0XHRjb25zdCBnZXRWaWV3WiA9IGJ1aWxkZXIuY29udGV4dC5nZXRWaWV3WjtcblxuXHRcdGlmICggZ2V0Vmlld1ogIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmlld1ogPSBnZXRWaWV3WiggdGhpcyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuICggdmlld1ogfHwgcG9zaXRpb25WaWV3LnogKS5uZWdhdGUoKTtcblxuXHR9XG5cblx0c2V0dXAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5mYWN0b3JOb2RlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBGb2dOb2RlO1xuXG5leHBvcnQgY29uc3QgZm9nID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEZvZ05vZGUgKTtcbiIsImltcG9ydCBGb2dOb2RlIGZyb20gJy4vRm9nTm9kZS5qcyc7XG5pbXBvcnQgeyBzbW9vdGhzdGVwIH0gZnJvbSAnLi4vbWF0aC9NYXRoTm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIEZvZ1JhbmdlTm9kZSBleHRlbmRzIEZvZ05vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnRm9nUmFuZ2VOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yTm9kZSwgbmVhck5vZGUsIGZhck5vZGUgKSB7XG5cblx0XHRzdXBlciggY29sb3JOb2RlICk7XG5cblx0XHR0aGlzLmlzRm9nUmFuZ2VOb2RlID0gdHJ1ZTtcblxuXHRcdHRoaXMubmVhck5vZGUgPSBuZWFyTm9kZTtcblx0XHR0aGlzLmZhck5vZGUgPSBmYXJOb2RlO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHZpZXdaID0gdGhpcy5nZXRWaWV3Wk5vZGUoIGJ1aWxkZXIgKTtcblxuXHRcdHJldHVybiBzbW9vdGhzdGVwKCB0aGlzLm5lYXJOb2RlLCB0aGlzLmZhck5vZGUsIHZpZXdaICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEZvZ1JhbmdlTm9kZTtcblxuZXhwb3J0IGNvbnN0IHJhbmdlRm9nID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEZvZ1JhbmdlTm9kZSApO1xuIiwiaW1wb3J0IEZvZ05vZGUgZnJvbSAnLi9Gb2dOb2RlLmpzJztcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY2xhc3MgRm9nRXhwMk5vZGUgZXh0ZW5kcyBGb2dOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0ZvZ0V4cDJOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGNvbG9yTm9kZSwgZGVuc2l0eU5vZGUgKSB7XG5cblx0XHRzdXBlciggY29sb3JOb2RlICk7XG5cblx0XHR0aGlzLmlzRm9nRXhwMk5vZGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5kZW5zaXR5Tm9kZSA9IGRlbnNpdHlOb2RlO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHZpZXdaID0gdGhpcy5nZXRWaWV3Wk5vZGUoIGJ1aWxkZXIgKTtcblx0XHRjb25zdCBkZW5zaXR5ID0gdGhpcy5kZW5zaXR5Tm9kZTtcblxuXHRcdHJldHVybiBkZW5zaXR5Lm11bCggZGVuc2l0eSwgdmlld1osIHZpZXdaICkubmVnYXRlKCkuZXhwKCkub25lTWludXMoKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRm9nRXhwMk5vZGU7XG5cbmV4cG9ydCBjb25zdCBkZW5zaXR5Rm9nID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEZvZ0V4cDJOb2RlICk7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xuaW1wb3J0IHsgZ2V0VmFsdWVUeXBlIH0gZnJvbSAnLi4vY29yZS9Ob2RlVXRpbHMuanMnO1xuaW1wb3J0IHsgYnVmZmVyIH0gZnJvbSAnLi4vYWNjZXNzb3JzL0J1ZmZlck5vZGUuanMnO1xuaW1wb3J0IHsgaW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vYWNjZXNzb3JzL0J1ZmZlckF0dHJpYnV0ZU5vZGUuanMnO1xuaW1wb3J0IHsgaW5zdGFuY2VJbmRleCB9IGZyb20gJy4uL2NvcmUvSW5kZXhOb2RlLmpzJztcbmltcG9ydCB7IG5vZGVQcm94eSwgZmxvYXQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xuaW1wb3J0IHsgTWF0aFV0aWxzIH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xuaW1wb3J0IHsgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vY29yZS9JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUuanMnO1xuXG5sZXQgbWluID0gbnVsbDtcbmxldCBtYXggPSBudWxsO1xuXG5jbGFzcyBSYW5nZU5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1JhbmdlTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBtaW5Ob2RlID0gZmxvYXQoKSwgbWF4Tm9kZSA9IGZsb2F0KCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5taW5Ob2RlID0gbWluTm9kZTtcblx0XHR0aGlzLm1heE5vZGUgPSBtYXhOb2RlO1xuXG5cdH1cblxuXHRnZXRWZWN0b3JMZW5ndGgoIGJ1aWxkZXIgKSB7XG5cblx0XHRjb25zdCBtaW5MZW5ndGggPSBidWlsZGVyLmdldFR5cGVMZW5ndGgoIGdldFZhbHVlVHlwZSggdGhpcy5taW5Ob2RlLnZhbHVlICkgKTtcblx0XHRjb25zdCBtYXhMZW5ndGggPSBidWlsZGVyLmdldFR5cGVMZW5ndGgoIGdldFZhbHVlVHlwZSggdGhpcy5tYXhOb2RlLnZhbHVlICkgKTtcblxuXHRcdHJldHVybiBtaW5MZW5ndGggPiBtYXhMZW5ndGggPyBtaW5MZW5ndGggOiBtYXhMZW5ndGg7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0cmV0dXJuIGJ1aWxkZXIub2JqZWN0LmNvdW50ID4gMSA/IGJ1aWxkZXIuZ2V0VHlwZUZyb21MZW5ndGgoIHRoaXMuZ2V0VmVjdG9yTGVuZ3RoKCBidWlsZGVyICkgKSA6ICdmbG9hdCc7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3Qgb2JqZWN0ID0gYnVpbGRlci5vYmplY3Q7XG5cblx0XHRsZXQgb3V0cHV0ID0gbnVsbDtcblxuXHRcdGlmICggb2JqZWN0LmNvdW50ID4gMSApIHtcblxuXHRcdFx0Y29uc3QgbWluVmFsdWUgPSB0aGlzLm1pbk5vZGUudmFsdWU7XG5cdFx0XHRjb25zdCBtYXhWYWx1ZSA9IHRoaXMubWF4Tm9kZS52YWx1ZTtcblxuXHRcdFx0Y29uc3QgbWluTGVuZ3RoID0gYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBnZXRWYWx1ZVR5cGUoIG1pblZhbHVlICkgKTtcblx0XHRcdGNvbnN0IG1heExlbmd0aCA9IGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggZ2V0VmFsdWVUeXBlKCBtYXhWYWx1ZSApICk7XG5cblx0XHRcdG1pbiA9IG1pbiB8fCBuZXcgVmVjdG9yNCgpO1xuXHRcdFx0bWF4ID0gbWF4IHx8IG5ldyBWZWN0b3I0KCk7XG5cblx0XHRcdG1pbi5zZXRTY2FsYXIoIDAgKTtcblx0XHRcdG1heC5zZXRTY2FsYXIoIDAgKTtcblxuXHRcdFx0aWYgKCBtaW5MZW5ndGggPT09IDEgKSBtaW4uc2V0U2NhbGFyKCBtaW5WYWx1ZSApO1xuXHRcdFx0ZWxzZSBpZiAoIG1pblZhbHVlLmlzQ29sb3IgKSBtaW4uc2V0KCBtaW5WYWx1ZS5yLCBtaW5WYWx1ZS5nLCBtaW5WYWx1ZS5iICk7XG5cdFx0XHRlbHNlIG1pbi5zZXQoIG1pblZhbHVlLngsIG1pblZhbHVlLnksIG1pblZhbHVlLnogfHwgMCwgbWluVmFsdWUudyB8fCAwICk7XG5cblx0XHRcdGlmICggbWF4TGVuZ3RoID09PSAxICkgbWF4LnNldFNjYWxhciggbWF4VmFsdWUgKTtcblx0XHRcdGVsc2UgaWYgKCBtYXhWYWx1ZS5pc0NvbG9yICkgbWF4LnNldCggbWF4VmFsdWUuciwgbWF4VmFsdWUuZywgbWF4VmFsdWUuYiApO1xuXHRcdFx0ZWxzZSBtYXguc2V0KCBtYXhWYWx1ZS54LCBtYXhWYWx1ZS55LCBtYXhWYWx1ZS56IHx8IDAsIG1heFZhbHVlLncgfHwgMCApO1xuXG5cdFx0XHRjb25zdCBzdHJpZGUgPSA0O1xuXG5cdFx0XHRjb25zdCBsZW5ndGggPSBzdHJpZGUgKiBvYmplY3QuY291bnQ7XG5cdFx0XHRjb25zdCBhcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIGxlbmd0aCApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICUgc3RyaWRlO1xuXG5cdFx0XHRcdGNvbnN0IG1pbkVsZW1lbnRWYWx1ZSA9IG1pbi5nZXRDb21wb25lbnQoIGluZGV4ICk7XG5cdFx0XHRcdGNvbnN0IG1heEVsZW1lbnRWYWx1ZSA9IG1heC5nZXRDb21wb25lbnQoIGluZGV4ICk7XG5cblx0XHRcdFx0YXJyYXlbIGkgXSA9IE1hdGhVdGlscy5sZXJwKCBtaW5FbGVtZW50VmFsdWUsIG1heEVsZW1lbnRWYWx1ZSwgTWF0aC5yYW5kb20oKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG5vZGVUeXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXG5cdFx0XHRpZiAoIG9iamVjdC5jb3VudCA8PSA0MDk2ICkge1xuXG5cdFx0XHRcdG91dHB1dCA9IGJ1ZmZlciggYXJyYXksICd2ZWM0Jywgb2JqZWN0LmNvdW50ICkuZWxlbWVudCggaW5zdGFuY2VJbmRleCApLmNvbnZlcnQoIG5vZGVUeXBlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gVE9ETzogSW1wcm92ZSBhbm9ueW1vdXMgYnVmZmVyIGF0dHJpYnV0ZSBjcmVhdGlvbiByZW1vdmluZyB0aGlzIHBhcnRcblx0XHRcdFx0Y29uc3QgYnVmZmVyQXR0cmlidXRlID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIDQgKTtcblx0XHRcdFx0YnVpbGRlci5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdfX3JhbmdlJyArIHRoaXMuaWQsIGJ1ZmZlckF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdG91dHB1dCA9IGluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVyQXR0cmlidXRlICkuY29udmVydCggbm9kZVR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0b3V0cHV0ID0gZmxvYXQoIDAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJhbmdlTm9kZTtcblxuZXhwb3J0IGNvbnN0IHJhbmdlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFJhbmdlTm9kZSApO1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcbmltcG9ydCB7IG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIENvbXB1dGVCdWlsdGluTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnQ29tcHV0ZUJ1aWx0aW5Ob2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGJ1aWx0aW5OYW1lLCBub2RlVHlwZSApIHtcblxuXHRcdHN1cGVyKCBub2RlVHlwZSApO1xuXG5cdFx0dGhpcy5fYnVpbHRpbk5hbWUgPSBidWlsdGluTmFtZTtcblxuXHR9XG5cblx0Z2V0SGFzaCggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLmdldEJ1aWx0aW5OYW1lKCBidWlsZGVyICk7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdHJldHVybiB0aGlzLm5vZGVUeXBlO1xuXG5cdH1cblxuXHRzZXRCdWlsdGluTmFtZSggYnVpbHRpbk5hbWUgKSB7XG5cblx0XHR0aGlzLl9idWlsdGluTmFtZSA9IGJ1aWx0aW5OYW1lO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldEJ1aWx0aW5OYW1lKCAvKmJ1aWxkZXIqLyApIHtcblxuXHRcdHJldHVybiB0aGlzLl9idWlsdGluTmFtZTtcblxuXHR9XG5cblx0aGFzQnVpbHRpbiggYnVpbGRlciApIHtcblxuXHRcdGJ1aWxkZXIuaGFzQnVpbHRpbiggdGhpcy5fYnVpbHRpbk5hbWUgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcblxuXHRcdGNvbnN0IGJ1aWx0aW5OYW1lID0gdGhpcy5nZXRCdWlsdGluTmFtZSggYnVpbGRlciApO1xuXHRcdGNvbnN0IG5vZGVUeXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXG5cdFx0aWYgKCBidWlsZGVyLnNoYWRlclN0YWdlID09PSAnY29tcHV0ZScgKSB7XG5cblx0XHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggYnVpbHRpbk5hbWUsIG5vZGVUeXBlLCBvdXRwdXQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggYENvbXB1dGVCdWlsdGluTm9kZTogQ29tcHV0ZSBidWlsdC1pbiB2YWx1ZSAke2J1aWx0aW5OYW1lfSBjYW4gbm90IGJlIGFjY2Vzc2VkIGluIHRoZSAke2J1aWxkZXIuc2hhZGVyU3RhZ2V9IHN0YWdlYCApO1xuXHRcdFx0cmV0dXJuIGJ1aWxkZXIuZ2VuZXJhdGVDb25zdCggbm9kZVR5cGUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2VyaWFsaXplKCBkYXRhICkge1xuXG5cdFx0c3VwZXIuc2VyaWFsaXplKCBkYXRhICk7XG5cblx0XHRkYXRhLmdsb2JhbCA9IHRoaXMuZ2xvYmFsO1xuXHRcdGRhdGEuX2J1aWx0aW5OYW1lID0gdGhpcy5fYnVpbHRpbk5hbWU7XG5cblx0fVxuXG5cdGRlc2VyaWFsaXplKCBkYXRhICkge1xuXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcblxuXHRcdHRoaXMuZ2xvYmFsID0gZGF0YS5nbG9iYWw7XG5cdFx0dGhpcy5fYnVpbHRpbk5hbWUgPSBkYXRhLl9idWlsdGluTmFtZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcHV0ZUJ1aWx0aW5Ob2RlO1xuXG5jb25zdCBjb21wdXRlQnVpbHRpbiA9ICggbmFtZSwgbm9kZVR5cGUgKSA9PiBub2RlT2JqZWN0KCBuZXcgQ29tcHV0ZUJ1aWx0aW5Ob2RlKCBuYW1lLCBub2RlVHlwZSApICk7XG5cbmV4cG9ydCBjb25zdCBudW1Xb3JrZ3JvdXBzID0gLypAX19QVVJFX18qLyBjb21wdXRlQnVpbHRpbiggJ251bVdvcmtncm91cHMnLCAndXZlYzMnICk7XG5leHBvcnQgY29uc3Qgd29ya2dyb3VwSWQgPSAvKkBfX1BVUkVfXyovIGNvbXB1dGVCdWlsdGluKCAnd29ya2dyb3VwSWQnLCAndXZlYzMnICk7XG5leHBvcnQgY29uc3QgbG9jYWxJZCA9IC8qQF9fUFVSRV9fKi8gY29tcHV0ZUJ1aWx0aW4oICdsb2NhbElkJywgJ3V2ZWMzJyApO1xuZXhwb3J0IGNvbnN0IHN1Ymdyb3VwU2l6ZSA9IC8qQF9fUFVSRV9fKi8gY29tcHV0ZUJ1aWx0aW4oICdzdWJncm91cFNpemUnLCAndWludCcgKTtcblxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcblxuY2xhc3MgQmFycmllck5vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRjb25zdHJ1Y3Rvciggc2NvcGUgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5zY29wZSA9IHNjb3BlO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHsgc2NvcGUgfSA9IHRoaXM7XG5cdFx0Y29uc3QgeyByZW5kZXJlciB9ID0gYnVpbGRlcjtcblxuXHRcdGlmICggcmVuZGVyZXIuYmFja2VuZC5pc1dlYkdMQmFja2VuZCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0YnVpbGRlci5hZGRGbG93Q29kZSggYFxcdC8vICR7c2NvcGV9QmFycmllciBcXG5gICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRidWlsZGVyLmFkZExpbmVGbG93Q29kZSggYCR7c2NvcGV9QmFycmllcigpYCwgdGhpcyApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXJyaWVyTm9kZTtcblxuY29uc3QgYmFycmllciA9IG5vZGVQcm94eSggQmFycmllck5vZGUgKTtcblxuZXhwb3J0IGNvbnN0IHdvcmtncm91cEJhcnJpZXIgPSAoKSA9PiBiYXJyaWVyKCAnd29ya2dyb3VwJyApLmFwcGVuZCgpO1xuZXhwb3J0IGNvbnN0IHN0b3JhZ2VCYXJyaWVyID0gKCkgPT4gYmFycmllciggJ3N0b3JhZ2UnICkuYXBwZW5kKCk7XG5leHBvcnQgY29uc3QgdGV4dHVyZUJhcnJpZXIgPSAoKSA9PiBiYXJyaWVyKCAndGV4dHVyZScgKS5hcHBlbmQoKTtcblxuIiwiaW1wb3J0IEFycmF5RWxlbWVudE5vZGUgZnJvbSAnLi4vdXRpbHMvQXJyYXlFbGVtZW50Tm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcblxuY2xhc3MgV29ya2dyb3VwSW5mb0VsZW1lbnROb2RlIGV4dGVuZHMgQXJyYXlFbGVtZW50Tm9kZSB7XG5cblx0Y29uc3RydWN0b3IoIHdvcmtncm91cEluZm9Ob2RlLCBpbmRleE5vZGUgKSB7XG5cblx0XHRzdXBlciggd29ya2dyb3VwSW5mb05vZGUsIGluZGV4Tm9kZSApO1xuXG5cdFx0dGhpcy5pc1dvcmtncm91cEluZm9FbGVtZW50Tm9kZSA9IHRydWU7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XG5cblx0XHRsZXQgc25pcHBldDtcblxuXHRcdGNvbnN0IGlzQXNzaWduQ29udGV4dCA9IGJ1aWxkZXIuY29udGV4dC5hc3NpZ247XG5cdFx0c25pcHBldCA9IHN1cGVyLmdlbmVyYXRlKCBidWlsZGVyICk7XG5cblx0XHRpZiAoIGlzQXNzaWduQ29udGV4dCAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcblxuXHRcdFx0c25pcHBldCA9IGJ1aWxkZXIuZm9ybWF0KCBzbmlwcGV0LCB0eXBlLCBvdXRwdXQgKTtcblxuXHRcdH1cblxuXHRcdC8vIFRPRE86IFBvc3NpYmx5IGFjdGl2YXRlIGNsaXAgZGlzdGFuY2UgaW5kZXggb24gaW5kZXggYWNjZXNzIHJhdGhlciB0aGFuIGZyb20gY2xpcHBpbmcgY29udGV4dFxuXG5cdFx0cmV0dXJuIHNuaXBwZXQ7XG5cblx0fVxuXG59XG5cblxuY2xhc3MgV29ya2dyb3VwSW5mb05vZGUgZXh0ZW5kcyBOb2RlIHtcblxuXHRjb25zdHJ1Y3Rvciggc2NvcGUsIGJ1ZmZlclR5cGUsIGJ1ZmZlckNvdW50ID0gMCApIHtcblxuXHRcdHN1cGVyKCBidWZmZXJUeXBlICk7XG5cblx0XHR0aGlzLmJ1ZmZlclR5cGUgPSBidWZmZXJUeXBlO1xuXHRcdHRoaXMuYnVmZmVyQ291bnQgPSBidWZmZXJDb3VudDtcblxuXHRcdHRoaXMuaXNXb3JrZ3JvdXBJbmZvTm9kZSA9IHRydWU7XG5cblx0XHR0aGlzLnNjb3BlID0gc2NvcGU7XG5cblx0fVxuXG5cdGxhYmVsKCBuYW1lICkge1xuXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRIYXNoKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudXVpZDtcblxuXHR9XG5cblx0c2V0U2NvcGUoIHNjb3BlICkge1xuXG5cdFx0dGhpcy5zY29wZSA9IHNjb3BlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldElucHV0VHlwZSggLypidWlsZGVyKi8gKSB7XG5cblx0XHRyZXR1cm4gYCR7dGhpcy5zY29wZX1BcnJheWA7XG5cblx0fVxuXG5cdGVsZW1lbnQoIGluZGV4Tm9kZSApIHtcblxuXHRcdHJldHVybiBub2RlT2JqZWN0KCBuZXcgV29ya2dyb3VwSW5mb0VsZW1lbnROb2RlKCB0aGlzLCBpbmRleE5vZGUgKSApO1xuXG5cdH1cblxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiBidWlsZGVyLmdldFNjb3BlZEFycmF5KCB0aGlzLm5hbWUgfHwgYCR7dGhpcy5zY29wZX1BcnJheV8ke3RoaXMuaWR9YCwgdGhpcy5zY29wZS50b0xvd2VyQ2FzZSgpLCB0aGlzLmJ1ZmZlclR5cGUsIHRoaXMuYnVmZmVyQ291bnQgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgV29ya2dyb3VwSW5mb05vZGU7XG5cbmV4cG9ydCBjb25zdCB3b3JrZ3JvdXBBcnJheSA9ICggdHlwZSwgY291bnQgKSA9PiBub2RlT2JqZWN0KCBuZXcgV29ya2dyb3VwSW5mb05vZGUoICdXb3JrZ3JvdXAnLCB0eXBlLCBjb3VudCApICk7XG5cblxuIiwiaW1wb3J0IFRlbXBOb2RlIGZyb20gJy4uL2NvcmUvVGVtcE5vZGUuanMnO1xuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuXG5jbGFzcyBBdG9taWNGdW5jdGlvbk5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdBdG9taWNGdW5jdGlvbk5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggbWV0aG9kLCBwb2ludGVyTm9kZSwgdmFsdWVOb2RlLCBzdG9yZU5vZGUgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoICd1aW50JyApO1xuXG5cdFx0dGhpcy5tZXRob2QgPSBtZXRob2Q7XG5cblx0XHR0aGlzLnBvaW50ZXJOb2RlID0gcG9pbnRlck5vZGU7XG5cdFx0dGhpcy52YWx1ZU5vZGUgPSB2YWx1ZU5vZGU7XG5cdFx0dGhpcy5zdG9yZU5vZGUgPSBzdG9yZU5vZGU7XG5cblx0fVxuXG5cdGdldElucHV0VHlwZSggYnVpbGRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLnBvaW50ZXJOb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XG5cblx0fVxuXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0SW5wdXRUeXBlKCBidWlsZGVyICk7XG5cblx0fVxuXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgbWV0aG9kID0gdGhpcy5tZXRob2Q7XG5cblx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xuXHRcdGNvbnN0IGlucHV0VHlwZSA9IHRoaXMuZ2V0SW5wdXRUeXBlKCBidWlsZGVyICk7XG5cblx0XHRjb25zdCBhID0gdGhpcy5wb2ludGVyTm9kZTtcblx0XHRjb25zdCBiID0gdGhpcy52YWx1ZU5vZGU7XG5cblx0XHRjb25zdCBwYXJhbXMgPSBbXTtcblxuXHRcdHBhcmFtcy5wdXNoKCBgJiR7IGEuYnVpbGQoIGJ1aWxkZXIsIGlucHV0VHlwZSApIH1gICk7XG5cdFx0cGFyYW1zLnB1c2goIGIuYnVpbGQoIGJ1aWxkZXIsIGlucHV0VHlwZSApICk7XG5cblx0XHRjb25zdCBtZXRob2RTbmlwcGV0ID0gYCR7IGJ1aWxkZXIuZ2V0TWV0aG9kKCBtZXRob2QsIHR5cGUgKSB9KCAke3BhcmFtcy5qb2luKCAnLCAnICl9IClgO1xuXG5cdFx0aWYgKCB0aGlzLnN0b3JlTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgdmFyU25pcHBldCA9IHRoaXMuc3RvcmVOb2RlLmJ1aWxkKCBidWlsZGVyLCBpbnB1dFR5cGUgKTtcblxuXHRcdFx0YnVpbGRlci5hZGRMaW5lRmxvd0NvZGUoIGAke3ZhclNuaXBwZXR9ID0gJHttZXRob2RTbmlwcGV0fWAsIHRoaXMgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGJ1aWxkZXIuYWRkTGluZUZsb3dDb2RlKCBtZXRob2RTbmlwcGV0LCB0aGlzICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbkF0b21pY0Z1bmN0aW9uTm9kZS5BVE9NSUNfTE9BRCA9ICdhdG9taWNMb2FkJztcbkF0b21pY0Z1bmN0aW9uTm9kZS5BVE9NSUNfU1RPUkUgPSAnYXRvbWljU3RvcmUnO1xuQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19BREQgPSAnYXRvbWljQWRkJztcbkF0b21pY0Z1bmN0aW9uTm9kZS5BVE9NSUNfU1VCID0gJ2F0b21pY1N1Yic7XG5BdG9taWNGdW5jdGlvbk5vZGUuQVRPTUlDX01BWCA9ICdhdG9taWNNYXgnO1xuQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19NSU4gPSAnYXRvbWljTWluJztcbkF0b21pY0Z1bmN0aW9uTm9kZS5BVE9NSUNfQU5EID0gJ2F0b21pY0FuZCc7XG5BdG9taWNGdW5jdGlvbk5vZGUuQVRPTUlDX09SID0gJ2F0b21pY09yJztcbkF0b21pY0Z1bmN0aW9uTm9kZS5BVE9NSUNfWE9SID0gJ2F0b21pY1hvcic7XG5cbmV4cG9ydCBkZWZhdWx0IEF0b21pY0Z1bmN0aW9uTm9kZTtcblxuY29uc3QgYXRvbWljTm9kZSA9IG5vZGVQcm94eSggQXRvbWljRnVuY3Rpb25Ob2RlICk7XG5cbmV4cG9ydCBjb25zdCBhdG9taWNGdW5jID0gKCBtZXRob2QsIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSApID0+IHtcblxuXHRjb25zdCBub2RlID0gYXRvbWljTm9kZSggbWV0aG9kLCBwb2ludGVyTm9kZSwgdmFsdWVOb2RlLCBzdG9yZU5vZGUgKTtcblx0bm9kZS5hcHBlbmQoKTtcblxuXHRyZXR1cm4gbm9kZTtcblxufTtcblxuZXhwb3J0IGNvbnN0IGF0b21pY1N0b3JlID0gKCBwb2ludGVyTm9kZSwgdmFsdWVOb2RlLCBzdG9yZU5vZGUgPSBudWxsICkgPT4gYXRvbWljRnVuYyggQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19TVE9SRSwgcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlICk7XG5leHBvcnQgY29uc3QgYXRvbWljQWRkID0gKCBwb2ludGVyTm9kZSwgdmFsdWVOb2RlLCBzdG9yZU5vZGUgPSBudWxsICkgPT4gYXRvbWljRnVuYyggQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19BREQsIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSApO1xuZXhwb3J0IGNvbnN0IGF0b21pY1N1YiA9ICggcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlID0gbnVsbCApID0+IGF0b21pY0Z1bmMoIEF0b21pY0Z1bmN0aW9uTm9kZS5BVE9NSUNfU1VCLCBwb2ludGVyTm9kZSwgdmFsdWVOb2RlLCBzdG9yZU5vZGUgKTtcbmV4cG9ydCBjb25zdCBhdG9taWNNYXggPSAoIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSA9IG51bGwgKSA9PiBhdG9taWNGdW5jKCBBdG9taWNGdW5jdGlvbk5vZGUuQVRPTUlDX01BWCwgcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlICk7XG5leHBvcnQgY29uc3QgYXRvbWljTWluID0gKCBwb2ludGVyTm9kZSwgdmFsdWVOb2RlLCBzdG9yZU5vZGUgPSBudWxsICkgPT4gYXRvbWljRnVuYyggQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19NSU4sIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSApO1xuZXhwb3J0IGNvbnN0IGF0b21pY0FuZCA9ICggcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlID0gbnVsbCApID0+IGF0b21pY0Z1bmMoIEF0b21pY0Z1bmN0aW9uTm9kZS5BVE9NSUNfQU5ELCBwb2ludGVyTm9kZSwgdmFsdWVOb2RlLCBzdG9yZU5vZGUgKTtcbmV4cG9ydCBjb25zdCBhdG9taWNPciA9ICggcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlID0gbnVsbCApID0+IGF0b21pY0Z1bmMoIEF0b21pY0Z1bmN0aW9uTm9kZS5BVE9NSUNfT1IsIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSApO1xuZXhwb3J0IGNvbnN0IGF0b21pY1hvciA9ICggcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlID0gbnVsbCApID0+IGF0b21pY0Z1bmMoIEF0b21pY0Z1bmN0aW9uTm9kZS5BVE9NSUNfWE9SLCBwb2ludGVyTm9kZSwgdmFsdWVOb2RlLCBzdG9yZU5vZGUgKTtcbiIsImltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcbmltcG9ydCB7IHJlbmRlckdyb3VwIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgY2FtZXJhVmlld01hdHJpeCB9IGZyb20gJy4vQ2FtZXJhLmpzJztcbmltcG9ydCB7IHBvc2l0aW9uV29ybGQgfSBmcm9tICcuL1Bvc2l0aW9uLmpzJztcblxubGV0IHVuaWZvcm1zTGliO1xuXG5mdW5jdGlvbiBnZXRMaWdodERhdGEoIGxpZ2h0ICkge1xuXG5cdHVuaWZvcm1zTGliID0gdW5pZm9ybXNMaWIgfHwgbmV3IFdlYWtNYXAoKTtcblxuXHRsZXQgdW5pZm9ybXMgPSB1bmlmb3Jtc0xpYi5nZXQoIGxpZ2h0ICk7XG5cblx0aWYgKCB1bmlmb3JtcyA9PT0gdW5kZWZpbmVkICkgdW5pZm9ybXNMaWIuc2V0KCBsaWdodCwgdW5pZm9ybXMgPSB7fSApO1xuXG5cdHJldHVybiB1bmlmb3JtcztcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlnaHRTaGFkb3dNYXRyaXgoIGxpZ2h0ICkge1xuXG5cdGNvbnN0IGRhdGEgPSBnZXRMaWdodERhdGEoIGxpZ2h0ICk7XG5cblx0cmV0dXJuIGRhdGEuc2hhZG93TWF0cml4IHx8ICggZGF0YS5zaGFkb3dNYXRyaXggPSB1bmlmb3JtKCAnbWF0NCcgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCkgPT4ge1xuXG5cdFx0bGlnaHQuc2hhZG93LnVwZGF0ZU1hdHJpY2VzKCBsaWdodCApO1xuXG5cdFx0cmV0dXJuIGxpZ2h0LnNoYWRvdy5tYXRyaXg7XG5cblx0fSApICk7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpZ2h0UHJvamVjdGlvblVWKCBsaWdodCApIHtcblxuXHRjb25zdCBkYXRhID0gZ2V0TGlnaHREYXRhKCBsaWdodCApO1xuXG5cdGlmICggZGF0YS5wcm9qZWN0aW9uVVYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGNvbnN0IHNwb3RMaWdodENvb3JkID0gbGlnaHRTaGFkb3dNYXRyaXgoIGxpZ2h0ICkubXVsKCBwb3NpdGlvbldvcmxkICk7XG5cblx0XHRkYXRhLnByb2plY3Rpb25VViA9IHNwb3RMaWdodENvb3JkLnh5ei5kaXYoIHNwb3RMaWdodENvb3JkLncgKTtcblxuXG5cdH1cblxuXHRyZXR1cm4gZGF0YS5wcm9qZWN0aW9uVVY7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpZ2h0UG9zaXRpb24oIGxpZ2h0ICkge1xuXG5cdGNvbnN0IGRhdGEgPSBnZXRMaWdodERhdGEoIGxpZ2h0ICk7XG5cblx0cmV0dXJuIGRhdGEucG9zaXRpb24gfHwgKCBkYXRhLnBvc2l0aW9uID0gdW5pZm9ybSggbmV3IFZlY3RvcjMoKSApLnNldEdyb3VwKCByZW5kZXJHcm91cCApLm9uUmVuZGVyVXBkYXRlKCAoIF8sIHNlbGYgKSA9PiBzZWxmLnZhbHVlLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKSApICk7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpZ2h0VGFyZ2V0UG9zaXRpb24oIGxpZ2h0ICkge1xuXG5cdGNvbnN0IGRhdGEgPSBnZXRMaWdodERhdGEoIGxpZ2h0ICk7XG5cblx0cmV0dXJuIGRhdGEudGFyZ2V0UG9zaXRpb24gfHwgKCBkYXRhLnRhcmdldFBvc2l0aW9uID0gdW5pZm9ybSggbmV3IFZlY3RvcjMoKSApLnNldEdyb3VwKCByZW5kZXJHcm91cCApLm9uUmVuZGVyVXBkYXRlKCAoIF8sIHNlbGYgKSA9PiBzZWxmLnZhbHVlLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICkgKSApO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaWdodFZpZXdQb3NpdGlvbiggbGlnaHQgKSB7XG5cblx0Y29uc3QgZGF0YSA9IGdldExpZ2h0RGF0YSggbGlnaHQgKTtcblxuXHRyZXR1cm4gZGF0YS52aWV3UG9zaXRpb24gfHwgKCBkYXRhLnZpZXdQb3NpdGlvbiA9IHVuaWZvcm0oIG5ldyBWZWN0b3IzKCkgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCB7IGNhbWVyYSB9LCBzZWxmICkgPT4ge1xuXG5cdFx0c2VsZi52YWx1ZSA9IHNlbGYudmFsdWUgfHwgbmV3IFZlY3RvcjMoKTtcblx0XHRzZWxmLnZhbHVlLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblxuXHRcdHNlbGYudmFsdWUuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0fSApICk7XG5cbn1cblxuZXhwb3J0IGNvbnN0IGxpZ2h0VGFyZ2V0RGlyZWN0aW9uID0gKCBsaWdodCApID0+IGNhbWVyYVZpZXdNYXRyaXgudHJhbnNmb3JtRGlyZWN0aW9uKCBsaWdodFBvc2l0aW9uKCBsaWdodCApLnN1YiggbGlnaHRUYXJnZXRQb3NpdGlvbiggbGlnaHQgKSApICk7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xuaW1wb3J0IHsgbm9kZU9iamVjdCwgdmVjMyB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuY29uc3Qgc29ydExpZ2h0cyA9ICggbGlnaHRzICkgPT4ge1xuXG5cdHJldHVybiBsaWdodHMuc29ydCggKCBhLCBiICkgPT4gYS5pZCAtIGIuaWQgKTtcblxufTtcblxuY29uc3QgZ2V0TGlnaHROb2RlQnlJZCA9ICggaWQsIGxpZ2h0Tm9kZXMgKSA9PiB7XG5cblx0Zm9yICggY29uc3QgbGlnaHROb2RlIG9mIGxpZ2h0Tm9kZXMgKSB7XG5cblx0XHRpZiAoIGxpZ2h0Tm9kZS5pc0FuYWx5dGljTGlnaHROb2RlICYmIGxpZ2h0Tm9kZS5saWdodC5pZCA9PT0gaWQgKSB7XG5cblx0XHRcdHJldHVybiBsaWdodE5vZGU7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBudWxsO1xuXG59O1xuXG5jb25zdCBfbGlnaHRzTm9kZVJlZiA9IC8qQF9fUFVSRV9fKi8gbmV3IFdlYWtNYXAoKTtcblxuY2xhc3MgTGlnaHRzTm9kZSBleHRlbmRzIE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnTGlnaHRzTm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoICd2ZWMzJyApO1xuXG5cdFx0dGhpcy50b3RhbERpZmZ1c2VOb2RlID0gdmVjMygpLnRvVmFyKCAndG90YWxEaWZmdXNlJyApO1xuXHRcdHRoaXMudG90YWxTcGVjdWxhck5vZGUgPSB2ZWMzKCkudG9WYXIoICd0b3RhbFNwZWN1bGFyJyApO1xuXG5cdFx0dGhpcy5vdXRnb2luZ0xpZ2h0Tm9kZSA9IHZlYzMoKS50b1ZhciggJ291dGdvaW5nTGlnaHQnICk7XG5cblx0XHR0aGlzLl9saWdodHMgPSBbXTtcblxuXHRcdHRoaXMuX2xpZ2h0Tm9kZXMgPSBudWxsO1xuXHRcdHRoaXMuX2xpZ2h0Tm9kZXNIYXNoID0gbnVsbDtcblxuXHRcdHRoaXMuZ2xvYmFsID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0SGFzaCggYnVpbGRlciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlnaHROb2Rlc0hhc2ggPT09IG51bGwgKSB7XG5cblx0XHRcdGlmICggdGhpcy5fbGlnaHROb2RlcyA9PT0gbnVsbCApIHRoaXMuc2V0dXBMaWdodHNOb2RlKCBidWlsZGVyICk7XG5cblx0XHRcdGNvbnN0IGhhc2ggPSBbXTtcblxuXHRcdFx0Zm9yICggY29uc3QgbGlnaHROb2RlIG9mIHRoaXMuX2xpZ2h0Tm9kZXMgKSB7XG5cblx0XHRcdFx0aGFzaC5wdXNoKCBsaWdodE5vZGUuZ2V0U2VsZigpLmdldEhhc2goKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xpZ2h0Tm9kZXNIYXNoID0gJ2xpZ2h0cy0nICsgaGFzaC5qb2luKCAnLCcgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9saWdodE5vZGVzSGFzaDtcblxuXHR9XG5cblx0YW5hbHl6ZSggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHByb3BlcnRpZXMgPSBidWlsZGVyLmdldERhdGFGcm9tTm9kZSggdGhpcyApO1xuXG5cdFx0Zm9yICggY29uc3Qgbm9kZSBvZiBwcm9wZXJ0aWVzLm5vZGVzICkge1xuXG5cdFx0XHRub2RlLmJ1aWxkKCBidWlsZGVyICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldHVwTGlnaHRzTm9kZSggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IGxpZ2h0Tm9kZXMgPSBbXTtcblxuXHRcdGNvbnN0IHByZXZpb3VzTGlnaHROb2RlcyA9IHRoaXMuX2xpZ2h0Tm9kZXM7XG5cblx0XHRjb25zdCBsaWdodHMgPSBzb3J0TGlnaHRzKCB0aGlzLl9saWdodHMgKTtcblx0XHRjb25zdCBub2RlTGlicmFyeSA9IGJ1aWxkZXIucmVuZGVyZXIubGlicmFyeTtcblxuXHRcdGZvciAoIGNvbnN0IGxpZ2h0IG9mIGxpZ2h0cyApIHtcblxuXHRcdFx0aWYgKCBsaWdodC5pc05vZGUgKSB7XG5cblx0XHRcdFx0bGlnaHROb2Rlcy5wdXNoKCBub2RlT2JqZWN0KCBsaWdodCApICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bGV0IGxpZ2h0Tm9kZSA9IG51bGw7XG5cblx0XHRcdFx0aWYgKCBwcmV2aW91c0xpZ2h0Tm9kZXMgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRsaWdodE5vZGUgPSBnZXRMaWdodE5vZGVCeUlkKCBsaWdodC5pZCwgcHJldmlvdXNMaWdodE5vZGVzICk7IC8vIHJlc3VzZSBleGlzdGluZyBsaWdodCBub2RlXG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbGlnaHROb2RlID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbGlnaHROb2RlQ2xhc3MgPSBub2RlTGlicmFyeS5nZXRMaWdodE5vZGVDbGFzcyggbGlnaHQuY29uc3RydWN0b3IgKTtcblxuXHRcdFx0XHRcdGlmICggbGlnaHROb2RlQ2xhc3MgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggYExpZ2h0c05vZGUuc2V0dXBOb2RlTGlnaHRzOiBMaWdodCBub2RlIG5vdCBmb3VuZCBmb3IgJHsgbGlnaHQuY29uc3RydWN0b3IubmFtZSB9YCApO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgbGlnaHROb2RlID0gbnVsbDtcblxuXHRcdFx0XHRcdGlmICggISBfbGlnaHRzTm9kZVJlZi5oYXMoIGxpZ2h0ICkgKSB7XG5cblx0XHRcdFx0XHRcdGxpZ2h0Tm9kZSA9IG5vZGVPYmplY3QoIG5ldyBsaWdodE5vZGVDbGFzcyggbGlnaHQgKSApO1xuXHRcdFx0XHRcdFx0X2xpZ2h0c05vZGVSZWYuc2V0KCBsaWdodCwgbGlnaHROb2RlICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRsaWdodE5vZGUgPSBfbGlnaHRzTm9kZVJlZi5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsaWdodE5vZGVzLnB1c2goIGxpZ2h0Tm9kZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5fbGlnaHROb2RlcyA9IGxpZ2h0Tm9kZXM7XG5cblx0fVxuXG5cdHNldHVwTGlnaHRzKCBidWlsZGVyLCBsaWdodE5vZGVzICkge1xuXG5cdFx0Zm9yICggY29uc3QgbGlnaHROb2RlIG9mIGxpZ2h0Tm9kZXMgKSB7XG5cblx0XHRcdGxpZ2h0Tm9kZS5idWlsZCggYnVpbGRlciApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlnaHROb2RlcyA9PT0gbnVsbCApIHRoaXMuc2V0dXBMaWdodHNOb2RlKCBidWlsZGVyICk7XG5cblx0XHRjb25zdCBjb250ZXh0ID0gYnVpbGRlci5jb250ZXh0O1xuXHRcdGNvbnN0IGxpZ2h0aW5nTW9kZWwgPSBjb250ZXh0LmxpZ2h0aW5nTW9kZWw7XG5cblx0XHRsZXQgb3V0Z29pbmdMaWdodE5vZGUgPSB0aGlzLm91dGdvaW5nTGlnaHROb2RlO1xuXG5cdFx0aWYgKCBsaWdodGluZ01vZGVsICkge1xuXG5cdFx0XHRjb25zdCB7IF9saWdodE5vZGVzLCB0b3RhbERpZmZ1c2VOb2RlLCB0b3RhbFNwZWN1bGFyTm9kZSB9ID0gdGhpcztcblxuXHRcdFx0Y29udGV4dC5vdXRnb2luZ0xpZ2h0ID0gb3V0Z29pbmdMaWdodE5vZGU7XG5cblx0XHRcdGNvbnN0IHN0YWNrID0gYnVpbGRlci5hZGRTdGFjaygpO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRjb25zdCBwcm9wZXJ0aWVzID0gYnVpbGRlci5nZXREYXRhRnJvbU5vZGUoIHRoaXMgKTtcblx0XHRcdHByb3BlcnRpZXMubm9kZXMgPSBzdGFjay5ub2RlcztcblxuXHRcdFx0Ly9cblxuXHRcdFx0bGlnaHRpbmdNb2RlbC5zdGFydCggY29udGV4dCwgc3RhY2ssIGJ1aWxkZXIgKTtcblxuXHRcdFx0Ly8gbGlnaHRzXG5cblx0XHRcdHRoaXMuc2V0dXBMaWdodHMoIGJ1aWxkZXIsIF9saWdodE5vZGVzICk7XG5cblx0XHRcdC8vXG5cblx0XHRcdGxpZ2h0aW5nTW9kZWwuaW5kaXJlY3QoIGNvbnRleHQsIHN0YWNrLCBidWlsZGVyICk7XG5cblx0XHRcdC8vXG5cblx0XHRcdGNvbnN0IHsgYmFja2Ryb3AsIGJhY2tkcm9wQWxwaGEgfSA9IGNvbnRleHQ7XG5cdFx0XHRjb25zdCB7IGRpcmVjdERpZmZ1c2UsIGRpcmVjdFNwZWN1bGFyLCBpbmRpcmVjdERpZmZ1c2UsIGluZGlyZWN0U3BlY3VsYXIgfSA9IGNvbnRleHQucmVmbGVjdGVkTGlnaHQ7XG5cblx0XHRcdGxldCB0b3RhbERpZmZ1c2UgPSBkaXJlY3REaWZmdXNlLmFkZCggaW5kaXJlY3REaWZmdXNlICk7XG5cblx0XHRcdGlmICggYmFja2Ryb3AgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCBiYWNrZHJvcEFscGhhICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0dG90YWxEaWZmdXNlID0gdmVjMyggYmFja2Ryb3BBbHBoYS5taXgoIHRvdGFsRGlmZnVzZSwgYmFja2Ryb3AgKSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0b3RhbERpZmZ1c2UgPSB2ZWMzKCBiYWNrZHJvcCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb250ZXh0Lm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0b3RhbERpZmZ1c2VOb2RlLmFzc2lnbiggdG90YWxEaWZmdXNlICk7XG5cdFx0XHR0b3RhbFNwZWN1bGFyTm9kZS5hc3NpZ24oIGRpcmVjdFNwZWN1bGFyLmFkZCggaW5kaXJlY3RTcGVjdWxhciApICk7XG5cblx0XHRcdG91dGdvaW5nTGlnaHROb2RlLmFzc2lnbiggdG90YWxEaWZmdXNlTm9kZS5hZGQoIHRvdGFsU3BlY3VsYXJOb2RlICkgKTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0bGlnaHRpbmdNb2RlbC5maW5pc2goIGNvbnRleHQsIHN0YWNrLCBidWlsZGVyICk7XG5cblx0XHRcdC8vXG5cblx0XHRcdG91dGdvaW5nTGlnaHROb2RlID0gb3V0Z29pbmdMaWdodE5vZGUuYnlwYXNzKCBidWlsZGVyLnJlbW92ZVN0YWNrKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvdXRnb2luZ0xpZ2h0Tm9kZTtcblxuXHR9XG5cblx0c2V0TGlnaHRzKCBsaWdodHMgKSB7XG5cblx0XHR0aGlzLl9saWdodHMgPSBsaWdodHM7XG5cblx0XHR0aGlzLl9saWdodE5vZGVzID0gbnVsbDtcblx0XHR0aGlzLl9saWdodE5vZGVzSGFzaCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0TGlnaHRzKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2xpZ2h0cztcblxuXHR9XG5cblx0Z2V0IGhhc0xpZ2h0cygpIHtcblxuXHRcdHJldHVybiB0aGlzLl9saWdodHMubGVuZ3RoID4gMDtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlnaHRzTm9kZTtcblxuZXhwb3J0IGNvbnN0IGxpZ2h0cyA9ICggbGlnaHRzID0gW10gKSA9PiBub2RlT2JqZWN0KCBuZXcgTGlnaHRzTm9kZSgpICkuc2V0TGlnaHRzKCBsaWdodHMgKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGZsb2F0LCB2ZWMyLCB2ZWMzLCB2ZWM0LCBJZiwgaW50LCBGbiwgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IHJlZmVyZW5jZSB9IGZyb20gJy4uL2FjY2Vzc29ycy9SZWZlcmVuY2VOb2RlLmpzJztcbmltcG9ydCB7IHRleHR1cmUgfSBmcm9tICcuLi9hY2Nlc3NvcnMvVGV4dHVyZU5vZGUuanMnO1xuaW1wb3J0IHsgcG9zaXRpb25Xb3JsZCB9IGZyb20gJy4uL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1lZE5vcm1hbFdvcmxkIH0gZnJvbSAnLi4vYWNjZXNzb3JzL05vcm1hbC5qcyc7XG5pbXBvcnQgeyBtaXgsIGZyYWN0LCBzdGVwLCBtYXgsIGNsYW1wLCBzcXJ0IH0gZnJvbSAnLi4vbWF0aC9NYXRoTm9kZS5qcyc7XG5pbXBvcnQgeyBhZGQsIHN1YiB9IGZyb20gJy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJztcbmltcG9ydCB7IERlcHRoVGV4dHVyZSB9IGZyb20gJy4uLy4uL3RleHR1cmVzL0RlcHRoVGV4dHVyZS5qcyc7XG5pbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4uLy4uL21hdGVyaWFscy9ub2Rlcy9Ob2RlTWF0ZXJpYWwuanMnO1xuaW1wb3J0IFF1YWRNZXNoIGZyb20gJy4uLy4uL3JlbmRlcmVycy9jb21tb24vUXVhZE1lc2guanMnO1xuaW1wb3J0IHsgTG9vcCB9IGZyb20gJy4uL3V0aWxzL0xvb3BOb2RlLmpzJztcbmltcG9ydCB7IHNjcmVlbkNvb3JkaW5hdGUgfSBmcm9tICcuLi9kaXNwbGF5L1NjcmVlbk5vZGUuanMnO1xuaW1wb3J0IHsgSGFsZkZsb2F0VHlwZSwgTGVzc0NvbXBhcmUsIE5vQmxlbmRpbmcsIFJHRm9ybWF0LCBWU01TaGFkb3dNYXAsIFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgcmVuZGVyR3JvdXAgfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Hcm91cE5vZGUuanMnO1xuaW1wb3J0IHsgdmlld1pUb0xvZ2FyaXRobWljRGVwdGggfSBmcm9tICcuLi9kaXNwbGF5L1ZpZXdwb3J0RGVwdGhOb2RlLmpzJztcbmltcG9ydCB7IG9iamVjdFBvc2l0aW9uIH0gZnJvbSAnLi4vYWNjZXNzb3JzL09iamVjdDNETm9kZS5qcyc7XG5pbXBvcnQgeyBsaWdodFNoYWRvd01hdHJpeCB9IGZyb20gJy4uL2FjY2Vzc29ycy9MaWdodHMuanMnO1xuXG5jb25zdCBzaGFkb3dNYXRlcmlhbExpYiA9IC8qQF9fUFVSRV9fKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWRvd1dvcmxkUG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIHZlYzMoKS50b1ZhciggJ3NoYWRvd1dvcmxkUG9zaXRpb24nICk7XG5cbmNvbnN0IGxpbmVhckRpc3RhbmNlID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBvc2l0aW9uLCBjYW1lcmFOZWFyLCBjYW1lcmFGYXIgXSApID0+IHtcblxuXHRsZXQgZGlzdCA9IHBvc2l0aW9uV29ybGQuc3ViKCBwb3NpdGlvbiApLmxlbmd0aCgpO1xuXHRkaXN0ID0gZGlzdC5zdWIoIGNhbWVyYU5lYXIgKS5kaXYoIGNhbWVyYUZhci5zdWIoIGNhbWVyYU5lYXIgKSApO1xuXHRkaXN0ID0gZGlzdC5zYXR1cmF0ZSgpOyAvLyBjbGFtcCB0byBbIDAsIDEgXVxuXG5cdHJldHVybiBkaXN0O1xuXG59ICk7XG5cbmNvbnN0IGxpbmVhclNoYWRvd0Rpc3RhbmNlID0gKCBsaWdodCApID0+IHtcblxuXHRjb25zdCBjYW1lcmEgPSBsaWdodC5zaGFkb3cuY2FtZXJhO1xuXG5cdGNvbnN0IG5lYXJEaXN0YW5jZSA9IHJlZmVyZW5jZSggJ25lYXInLCAnZmxvYXQnLCBjYW1lcmEgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcblx0Y29uc3QgZmFyRGlzdGFuY2UgPSByZWZlcmVuY2UoICdmYXInLCAnZmxvYXQnLCBjYW1lcmEgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcblxuXHRjb25zdCByZWZlcmVuY2VQb3NpdGlvbiA9IG9iamVjdFBvc2l0aW9uKCBsaWdodCApO1xuXG5cdHJldHVybiBsaW5lYXJEaXN0YW5jZSggcmVmZXJlbmNlUG9zaXRpb24sIG5lYXJEaXN0YW5jZSwgZmFyRGlzdGFuY2UgKTtcblxufTtcblxuY29uc3QgZ2V0U2hhZG93TWF0ZXJpYWwgPSAoIGxpZ2h0ICkgPT4ge1xuXG5cdGxldCBtYXRlcmlhbCA9IHNoYWRvd01hdGVyaWFsTGliLmdldCggbGlnaHQgKTtcblxuXHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRjb25zdCBkZXB0aE5vZGUgPSBsaWdodC5pc1BvaW50TGlnaHQgPyBsaW5lYXJTaGFkb3dEaXN0YW5jZSggbGlnaHQgKSA6IG51bGw7XG5cblx0XHRtYXRlcmlhbCA9IG5ldyBOb2RlTWF0ZXJpYWwoKTtcblx0XHRtYXRlcmlhbC5jb2xvck5vZGUgPSB2ZWM0KCAwLCAwLCAwLCAxICk7XG5cdFx0bWF0ZXJpYWwuZGVwdGhOb2RlID0gZGVwdGhOb2RlO1xuXHRcdG1hdGVyaWFsLmlzU2hhZG93Tm9kZU1hdGVyaWFsID0gdHJ1ZTsgLy8gVXNlIHRvIGF2b2lkIG90aGVyIG92ZXJyaWRlTWF0ZXJpYWwgb3ZlcnJpZGUgbWF0ZXJpYWwuY29sb3JOb2RlIHVuaW50ZW50aW9uYWxseSB3aGVuIHVzaW5nIG1hdGVyaWFsLnNoYWRvd05vZGVcblx0XHRtYXRlcmlhbC5ibGVuZGluZyA9IE5vQmxlbmRpbmc7XG5cdFx0bWF0ZXJpYWwubmFtZSA9ICdTaGFkb3dNYXRlcmlhbCc7XG5cblx0XHRzaGFkb3dNYXRlcmlhbExpYi5zZXQoIGxpZ2h0LCBtYXRlcmlhbCApO1xuXG5cdH1cblxuXHRyZXR1cm4gbWF0ZXJpYWw7XG5cbn07XG5cbmV4cG9ydCBjb25zdCBCYXNpY1NoYWRvd0ZpbHRlciA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBkZXB0aFRleHR1cmUsIHNoYWRvd0Nvb3JkIH0gKSA9PiB7XG5cblx0cmV0dXJuIHRleHR1cmUoIGRlcHRoVGV4dHVyZSwgc2hhZG93Q29vcmQueHkgKS5jb21wYXJlKCBzaGFkb3dDb29yZC56ICk7XG5cbn0gKTtcblxuZXhwb3J0IGNvbnN0IFBDRlNoYWRvd0ZpbHRlciA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBkZXB0aFRleHR1cmUsIHNoYWRvd0Nvb3JkLCBzaGFkb3cgfSApID0+IHtcblxuXHRjb25zdCBkZXB0aENvbXBhcmUgPSAoIHV2LCBjb21wYXJlICkgPT4gdGV4dHVyZSggZGVwdGhUZXh0dXJlLCB1diApLmNvbXBhcmUoIGNvbXBhcmUgKTtcblxuXHRjb25zdCBtYXBTaXplID0gcmVmZXJlbmNlKCAnbWFwU2l6ZScsICd2ZWMyJywgc2hhZG93ICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XG5cdGNvbnN0IHJhZGl1cyA9IHJlZmVyZW5jZSggJ3JhZGl1cycsICdmbG9hdCcsIHNoYWRvdyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xuXG5cdGNvbnN0IHRleGVsU2l6ZSA9IHZlYzIoIDEgKS5kaXYoIG1hcFNpemUgKTtcblx0Y29uc3QgZHgwID0gdGV4ZWxTaXplLngubmVnYXRlKCkubXVsKCByYWRpdXMgKTtcblx0Y29uc3QgZHkwID0gdGV4ZWxTaXplLnkubmVnYXRlKCkubXVsKCByYWRpdXMgKTtcblx0Y29uc3QgZHgxID0gdGV4ZWxTaXplLngubXVsKCByYWRpdXMgKTtcblx0Y29uc3QgZHkxID0gdGV4ZWxTaXplLnkubXVsKCByYWRpdXMgKTtcblx0Y29uc3QgZHgyID0gZHgwLmRpdiggMiApO1xuXHRjb25zdCBkeTIgPSBkeTAuZGl2KCAyICk7XG5cdGNvbnN0IGR4MyA9IGR4MS5kaXYoIDIgKTtcblx0Y29uc3QgZHkzID0gZHkxLmRpdiggMiApO1xuXG5cdHJldHVybiBhZGQoXG5cdFx0ZGVwdGhDb21wYXJlKCBzaGFkb3dDb29yZC54eS5hZGQoIHZlYzIoIGR4MCwgZHkwICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdGRlcHRoQ29tcGFyZSggc2hhZG93Q29vcmQueHkuYWRkKCB2ZWMyKCAwLCBkeTAgKSApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0ZGVwdGhDb21wYXJlKCBzaGFkb3dDb29yZC54eS5hZGQoIHZlYzIoIGR4MSwgZHkwICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdGRlcHRoQ29tcGFyZSggc2hhZG93Q29vcmQueHkuYWRkKCB2ZWMyKCBkeDIsIGR5MiApICksIHNoYWRvd0Nvb3JkLnogKSxcblx0XHRkZXB0aENvbXBhcmUoIHNoYWRvd0Nvb3JkLnh5LmFkZCggdmVjMiggMCwgZHkyICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdGRlcHRoQ29tcGFyZSggc2hhZG93Q29vcmQueHkuYWRkKCB2ZWMyKCBkeDMsIGR5MiApICksIHNoYWRvd0Nvb3JkLnogKSxcblx0XHRkZXB0aENvbXBhcmUoIHNoYWRvd0Nvb3JkLnh5LmFkZCggdmVjMiggZHgwLCAwICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdGRlcHRoQ29tcGFyZSggc2hhZG93Q29vcmQueHkuYWRkKCB2ZWMyKCBkeDIsIDAgKSApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0ZGVwdGhDb21wYXJlKCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApLFxuXHRcdGRlcHRoQ29tcGFyZSggc2hhZG93Q29vcmQueHkuYWRkKCB2ZWMyKCBkeDMsIDAgKSApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0ZGVwdGhDb21wYXJlKCBzaGFkb3dDb29yZC54eS5hZGQoIHZlYzIoIGR4MSwgMCApICksIHNoYWRvd0Nvb3JkLnogKSxcblx0XHRkZXB0aENvbXBhcmUoIHNoYWRvd0Nvb3JkLnh5LmFkZCggdmVjMiggZHgyLCBkeTMgKSApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0ZGVwdGhDb21wYXJlKCBzaGFkb3dDb29yZC54eS5hZGQoIHZlYzIoIDAsIGR5MyApICksIHNoYWRvd0Nvb3JkLnogKSxcblx0XHRkZXB0aENvbXBhcmUoIHNoYWRvd0Nvb3JkLnh5LmFkZCggdmVjMiggZHgzLCBkeTMgKSApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0ZGVwdGhDb21wYXJlKCBzaGFkb3dDb29yZC54eS5hZGQoIHZlYzIoIGR4MCwgZHkxICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdGRlcHRoQ29tcGFyZSggc2hhZG93Q29vcmQueHkuYWRkKCB2ZWMyKCAwLCBkeTEgKSApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0ZGVwdGhDb21wYXJlKCBzaGFkb3dDb29yZC54eS5hZGQoIHZlYzIoIGR4MSwgZHkxICkgKSwgc2hhZG93Q29vcmQueiApXG5cdCkubXVsKCAxIC8gMTcgKTtcblxufSApO1xuXG5leHBvcnQgY29uc3QgUENGU29mdFNoYWRvd0ZpbHRlciA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBkZXB0aFRleHR1cmUsIHNoYWRvd0Nvb3JkLCBzaGFkb3cgfSApID0+IHtcblxuXHRjb25zdCBkZXB0aENvbXBhcmUgPSAoIHV2LCBjb21wYXJlICkgPT4gdGV4dHVyZSggZGVwdGhUZXh0dXJlLCB1diApLmNvbXBhcmUoIGNvbXBhcmUgKTtcblxuXHRjb25zdCBtYXBTaXplID0gcmVmZXJlbmNlKCAnbWFwU2l6ZScsICd2ZWMyJywgc2hhZG93ICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XG5cblx0Y29uc3QgdGV4ZWxTaXplID0gdmVjMiggMSApLmRpdiggbWFwU2l6ZSApO1xuXHRjb25zdCBkeCA9IHRleGVsU2l6ZS54O1xuXHRjb25zdCBkeSA9IHRleGVsU2l6ZS55O1xuXG5cdGNvbnN0IHV2ID0gc2hhZG93Q29vcmQueHk7XG5cdGNvbnN0IGYgPSBmcmFjdCggdXYubXVsKCBtYXBTaXplICkuYWRkKCAwLjUgKSApO1xuXHR1di5zdWJBc3NpZ24oIGYubXVsKCB0ZXhlbFNpemUgKSApO1xuXG5cdHJldHVybiBhZGQoXG5cdFx0ZGVwdGhDb21wYXJlKCB1diwgc2hhZG93Q29vcmQueiApLFxuXHRcdGRlcHRoQ29tcGFyZSggdXYuYWRkKCB2ZWMyKCBkeCwgMCApICksIHNoYWRvd0Nvb3JkLnogKSxcblx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggMCwgZHkgKSApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0ZGVwdGhDb21wYXJlKCB1di5hZGQoIHRleGVsU2l6ZSApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0bWl4KFxuXHRcdFx0ZGVwdGhDb21wYXJlKCB1di5hZGQoIHZlYzIoIGR4Lm5lZ2F0ZSgpLCAwICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdFx0ZGVwdGhDb21wYXJlKCB1di5hZGQoIHZlYzIoIGR4Lm11bCggMiApLCAwICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdFx0Zi54XG5cdFx0KSxcblx0XHRtaXgoXG5cdFx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggZHgubmVnYXRlKCksIGR5ICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdFx0ZGVwdGhDb21wYXJlKCB1di5hZGQoIHZlYzIoIGR4Lm11bCggMiApLCBkeSApICksIHNoYWRvd0Nvb3JkLnogKSxcblx0XHRcdGYueFxuXHRcdCksXG5cdFx0bWl4KFxuXHRcdFx0ZGVwdGhDb21wYXJlKCB1di5hZGQoIHZlYzIoIDAsIGR5Lm5lZ2F0ZSgpICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdFx0ZGVwdGhDb21wYXJlKCB1di5hZGQoIHZlYzIoIDAsIGR5Lm11bCggMiApICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdFx0Zi55XG5cdFx0KSxcblx0XHRtaXgoXG5cdFx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggZHgsIGR5Lm5lZ2F0ZSgpICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdFx0ZGVwdGhDb21wYXJlKCB1di5hZGQoIHZlYzIoIGR4LCBkeS5tdWwoIDIgKSApICksIHNoYWRvd0Nvb3JkLnogKSxcblx0XHRcdGYueVxuXHRcdCksXG5cdFx0bWl4KFxuXHRcdFx0bWl4KFxuXHRcdFx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggZHgubmVnYXRlKCksIGR5Lm5lZ2F0ZSgpICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdFx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggZHgubXVsKCAyICksIGR5Lm5lZ2F0ZSgpICkgKSwgc2hhZG93Q29vcmQueiApLFxuXHRcdFx0XHRmLnhcblx0XHRcdCksXG5cdFx0XHRtaXgoXG5cdFx0XHRcdGRlcHRoQ29tcGFyZSggdXYuYWRkKCB2ZWMyKCBkeC5uZWdhdGUoKSwgZHkubXVsKCAyICkgKSApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0XHRcdGRlcHRoQ29tcGFyZSggdXYuYWRkKCB2ZWMyKCBkeC5tdWwoIDIgKSwgZHkubXVsKCAyICkgKSApLCBzaGFkb3dDb29yZC56ICksXG5cdFx0XHRcdGYueFxuXHRcdFx0KSxcblx0XHRcdGYueVxuXHRcdClcblx0KS5tdWwoIDEgLyA5ICk7XG5cbn0gKTtcblxuLy8gVlNNXG5cbmV4cG9ydCBjb25zdCBWU01TaGFkb3dGaWx0ZXIgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgZGVwdGhUZXh0dXJlLCBzaGFkb3dDb29yZCB9ICkgPT4ge1xuXG5cdGNvbnN0IG9jY2x1c2lvbiA9IGZsb2F0KCAxICkudG9WYXIoKTtcblxuXHRjb25zdCBkaXN0cmlidXRpb24gPSB0ZXh0dXJlKCBkZXB0aFRleHR1cmUgKS51diggc2hhZG93Q29vcmQueHkgKS5yZztcblxuXHRjb25zdCBoYXJkU2hhZG93ID0gc3RlcCggc2hhZG93Q29vcmQueiwgZGlzdHJpYnV0aW9uLnggKTtcblxuXHRJZiggaGFyZFNoYWRvdy5ub3RFcXVhbCggZmxvYXQoIDEuMCApICksICgpID0+IHtcblxuXHRcdGNvbnN0IGRpc3RhbmNlID0gc2hhZG93Q29vcmQuei5zdWIoIGRpc3RyaWJ1dGlvbi54ICk7XG5cdFx0Y29uc3QgdmFyaWFuY2UgPSBtYXgoIDAsIGRpc3RyaWJ1dGlvbi55Lm11bCggZGlzdHJpYnV0aW9uLnkgKSApO1xuXHRcdGxldCBzb2Z0bmVzc1Byb2JhYmlsaXR5ID0gdmFyaWFuY2UuZGl2KCB2YXJpYW5jZS5hZGQoIGRpc3RhbmNlLm11bCggZGlzdGFuY2UgKSApICk7IC8vIENoZWJleXNoZXZzIGluZXF1YWxpdHlcblx0XHRzb2Z0bmVzc1Byb2JhYmlsaXR5ID0gY2xhbXAoIHN1Yiggc29mdG5lc3NQcm9iYWJpbGl0eSwgMC4zICkuZGl2KCAwLjk1IC0gMC4zICkgKTtcblx0XHRvY2NsdXNpb24uYXNzaWduKCBjbGFtcCggbWF4KCBoYXJkU2hhZG93LCBzb2Z0bmVzc1Byb2JhYmlsaXR5ICkgKSApO1xuXG5cdH0gKTtcblxuXHRyZXR1cm4gb2NjbHVzaW9uO1xuXG59ICk7XG5cbmNvbnN0IFZTTVBhc3NWZXJ0aWNhbCA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBzYW1wbGVzLCByYWRpdXMsIHNpemUsIHNoYWRvd1Bhc3MgfSApID0+IHtcblxuXHRjb25zdCBtZWFuID0gZmxvYXQoIDAgKS50b1ZhcigpO1xuXHRjb25zdCBzcXVhcmVkTWVhbiA9IGZsb2F0KCAwICkudG9WYXIoKTtcblxuXHRjb25zdCB1dlN0cmlkZSA9IHNhbXBsZXMubGVzc1RoYW5FcXVhbCggZmxvYXQoIDEgKSApLnNlbGVjdCggZmxvYXQoIDAgKSwgZmxvYXQoIDIgKS5kaXYoIHNhbXBsZXMuc3ViKCAxICkgKSApO1xuXHRjb25zdCB1dlN0YXJ0ID0gc2FtcGxlcy5sZXNzVGhhbkVxdWFsKCBmbG9hdCggMSApICkuc2VsZWN0KCBmbG9hdCggMCApLCBmbG9hdCggLSAxICkgKTtcblxuXHRMb29wKCB7IHN0YXJ0OiBpbnQoIDAgKSwgZW5kOiBpbnQoIHNhbXBsZXMgKSwgdHlwZTogJ2ludCcsIGNvbmRpdGlvbjogJzwnIH0sICggeyBpIH0gKSA9PiB7XG5cblx0XHRjb25zdCB1dk9mZnNldCA9IHV2U3RhcnQuYWRkKCBmbG9hdCggaSApLm11bCggdXZTdHJpZGUgKSApO1xuXG5cdFx0Y29uc3QgZGVwdGggPSBzaGFkb3dQYXNzLnV2KCBhZGQoIHNjcmVlbkNvb3JkaW5hdGUueHksIHZlYzIoIDAsIHV2T2Zmc2V0ICkubXVsKCByYWRpdXMgKSApLmRpdiggc2l6ZSApICkueDtcblx0XHRtZWFuLmFkZEFzc2lnbiggZGVwdGggKTtcblx0XHRzcXVhcmVkTWVhbi5hZGRBc3NpZ24oIGRlcHRoLm11bCggZGVwdGggKSApO1xuXG5cdH0gKTtcblxuXHRtZWFuLmRpdkFzc2lnbiggc2FtcGxlcyApO1xuXHRzcXVhcmVkTWVhbi5kaXZBc3NpZ24oIHNhbXBsZXMgKTtcblxuXHRjb25zdCBzdGRfZGV2ID0gc3FydCggc3F1YXJlZE1lYW4uc3ViKCBtZWFuLm11bCggbWVhbiApICkgKTtcblx0cmV0dXJuIHZlYzIoIG1lYW4sIHN0ZF9kZXYgKTtcblxufSApO1xuXG5jb25zdCBWU01QYXNzSG9yaXpvbnRhbCA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBzYW1wbGVzLCByYWRpdXMsIHNpemUsIHNoYWRvd1Bhc3MgfSApID0+IHtcblxuXHRjb25zdCBtZWFuID0gZmxvYXQoIDAgKS50b1ZhcigpO1xuXHRjb25zdCBzcXVhcmVkTWVhbiA9IGZsb2F0KCAwICkudG9WYXIoKTtcblxuXHRjb25zdCB1dlN0cmlkZSA9IHNhbXBsZXMubGVzc1RoYW5FcXVhbCggZmxvYXQoIDEgKSApLnNlbGVjdCggZmxvYXQoIDAgKSwgZmxvYXQoIDIgKS5kaXYoIHNhbXBsZXMuc3ViKCAxICkgKSApO1xuXHRjb25zdCB1dlN0YXJ0ID0gc2FtcGxlcy5sZXNzVGhhbkVxdWFsKCBmbG9hdCggMSApICkuc2VsZWN0KCBmbG9hdCggMCApLCBmbG9hdCggLSAxICkgKTtcblxuXHRMb29wKCB7IHN0YXJ0OiBpbnQoIDAgKSwgZW5kOiBpbnQoIHNhbXBsZXMgKSwgdHlwZTogJ2ludCcsIGNvbmRpdGlvbjogJzwnIH0sICggeyBpIH0gKSA9PiB7XG5cblx0XHRjb25zdCB1dk9mZnNldCA9IHV2U3RhcnQuYWRkKCBmbG9hdCggaSApLm11bCggdXZTdHJpZGUgKSApO1xuXG5cdFx0Y29uc3QgZGlzdHJpYnV0aW9uID0gc2hhZG93UGFzcy51diggYWRkKCBzY3JlZW5Db29yZGluYXRlLnh5LCB2ZWMyKCB1dk9mZnNldCwgMCApLm11bCggcmFkaXVzICkgKS5kaXYoIHNpemUgKSApO1xuXHRcdG1lYW4uYWRkQXNzaWduKCBkaXN0cmlidXRpb24ueCApO1xuXHRcdHNxdWFyZWRNZWFuLmFkZEFzc2lnbiggYWRkKCBkaXN0cmlidXRpb24ueS5tdWwoIGRpc3RyaWJ1dGlvbi55ICksIGRpc3RyaWJ1dGlvbi54Lm11bCggZGlzdHJpYnV0aW9uLnggKSApICk7XG5cblx0fSApO1xuXG5cdG1lYW4uZGl2QXNzaWduKCBzYW1wbGVzICk7XG5cdHNxdWFyZWRNZWFuLmRpdkFzc2lnbiggc2FtcGxlcyApO1xuXG5cdGNvbnN0IHN0ZF9kZXYgPSBzcXJ0KCBzcXVhcmVkTWVhbi5zdWIoIG1lYW4ubXVsKCBtZWFuICkgKSApO1xuXHRyZXR1cm4gdmVjMiggbWVhbiwgc3RkX2RldiApO1xuXG59ICk7XG5cbmNvbnN0IF9zaGFkb3dGaWx0ZXJMaWIgPSBbIEJhc2ljU2hhZG93RmlsdGVyLCBQQ0ZTaGFkb3dGaWx0ZXIsIFBDRlNvZnRTaGFkb3dGaWx0ZXIsIFZTTVNoYWRvd0ZpbHRlciBdO1xuXG4vL1xuXG5jb25zdCBfcXVhZE1lc2ggPSAvKkBfX1BVUkVfXyovIG5ldyBRdWFkTWVzaCgpO1xuXG5jbGFzcyBTaGFkb3dOb2RlIGV4dGVuZHMgTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdTaGFkb3dOb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGxpZ2h0LCBzaGFkb3cgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMubGlnaHQgPSBsaWdodDtcblx0XHR0aGlzLnNoYWRvdyA9IHNoYWRvdyB8fCBsaWdodC5zaGFkb3c7XG5cblx0XHR0aGlzLnNoYWRvd01hcCA9IG51bGw7XG5cblx0XHR0aGlzLnZzbVNoYWRvd01hcFZlcnRpY2FsID0gbnVsbDtcblx0XHR0aGlzLnZzbVNoYWRvd01hcEhvcml6b250YWwgPSBudWxsO1xuXG5cdFx0dGhpcy52c21NYXRlcmlhbFZlcnRpY2FsID0gbnVsbDtcblx0XHR0aGlzLnZzbU1hdGVyaWFsSG9yaXpvbnRhbCA9IG51bGw7XG5cblx0XHR0aGlzLnVwZGF0ZUJlZm9yZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5SRU5ERVI7XG5cdFx0dGhpcy5fbm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLmlzU2hhZG93Tm9kZSA9IHRydWU7XG5cblx0fVxuXG5cdHNldHVwU2hhZG93RmlsdGVyKCBidWlsZGVyLCB7IGZpbHRlckZuLCBkZXB0aFRleHR1cmUsIHNoYWRvd0Nvb3JkLCBzaGFkb3cgfSApIHtcblxuXHRcdGNvbnN0IGZydXN0dW1UZXN0ID0gc2hhZG93Q29vcmQueC5ncmVhdGVyVGhhbkVxdWFsKCAwIClcblx0XHRcdC5hbmQoIHNoYWRvd0Nvb3JkLngubGVzc1RoYW5FcXVhbCggMSApIClcblx0XHRcdC5hbmQoIHNoYWRvd0Nvb3JkLnkuZ3JlYXRlclRoYW5FcXVhbCggMCApIClcblx0XHRcdC5hbmQoIHNoYWRvd0Nvb3JkLnkubGVzc1RoYW5FcXVhbCggMSApIClcblx0XHRcdC5hbmQoIHNoYWRvd0Nvb3JkLnoubGVzc1RoYW5FcXVhbCggMSApICk7XG5cblx0XHRjb25zdCBzaGFkb3dOb2RlID0gZmlsdGVyRm4oIHsgZGVwdGhUZXh0dXJlLCBzaGFkb3dDb29yZCwgc2hhZG93IH0gKTtcblxuXHRcdHJldHVybiBmcnVzdHVtVGVzdC5zZWxlY3QoIHNoYWRvd05vZGUsIGZsb2F0KCAxICkgKTtcblxuXHR9XG5cblx0c2V0dXBTaGFkb3dDb29yZCggYnVpbGRlciwgc2hhZG93UG9zaXRpb24gKSB7XG5cblx0XHRjb25zdCB7IHNoYWRvdyB9ID0gdGhpcztcblx0XHRjb25zdCB7IHJlbmRlcmVyIH0gPSBidWlsZGVyO1xuXG5cdFx0Y29uc3QgYmlhcyA9IHJlZmVyZW5jZSggJ2JpYXMnLCAnZmxvYXQnLCBzaGFkb3cgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcblxuXHRcdGxldCBzaGFkb3dDb29yZCA9IHNoYWRvd1Bvc2l0aW9uO1xuXHRcdGxldCBjb29yZFo7XG5cblx0XHRpZiAoIHNoYWRvdy5jYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEgfHwgcmVuZGVyZXIubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0c2hhZG93Q29vcmQgPSBzaGFkb3dDb29yZC54eXouZGl2KCBzaGFkb3dDb29yZC53ICk7XG5cblx0XHRcdGNvb3JkWiA9IHNoYWRvd0Nvb3JkLno7XG5cblx0XHRcdGlmICggcmVuZGVyZXIuY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0XHRjb29yZFogPSBjb29yZFoubXVsKCAyICkuc3ViKCAxICk7IC8vIFdlYkdQVTogQ29udmVyc2lvbiBbIDAsIDEgXSB0byBbIC0gMSwgMSBdXG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHcgPSBzaGFkb3dDb29yZC53O1xuXHRcdFx0c2hhZG93Q29vcmQgPSBzaGFkb3dDb29yZC54eS5kaXYoIHcgKTsgLy8gPC0tIE9ubHkgZGl2aWRlIFgvWSBjb29yZHMgc2luY2Ugd2UgZG9uJ3QgbmVlZCBaXG5cblx0XHRcdC8vIFRoZSBub3JtYWxseSBhdmFpbGFibGUgXCJjYW1lcmFOZWFyXCIgYW5kIFwiY2FtZXJhRmFyXCIgbm9kZXMgY2Fubm90IGJlIHVzZWQgaGVyZSBiZWNhdXNlIHRoZXkgZG8gbm90IGdldFxuXHRcdFx0Ly8gdXBkYXRlZCB0byB1c2UgdGhlIHNoYWRvdyBjYW1lcmEuIFNvLCB3ZSBoYXZlIHRvIGRlY2xhcmUgb3VyIG93biBcImxvY2FsXCIgb25lcyBoZXJlLlxuXHRcdFx0Ly8gVE9ETzogSG93IGRvIHdlIGdldCB0aGUgY2FtZXJhTmVhci9jYW1lcmFGYXIgbm9kZXMgdG8gdXNlIHRoZSBzaGFkb3cgY2FtZXJhIHNvIHdlIGRvbid0IGhhdmUgdG8gZGVjbGFyZSBsb2NhbCBvbmVzIGhlcmU/XG5cdFx0XHRjb25zdCBjYW1lcmFOZWFyTG9jYWwgPSByZWZlcmVuY2UoICduZWFyJywgJ2Zsb2F0Jywgc2hhZG93LmNhbWVyYSApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xuXHRcdFx0Y29uc3QgY2FtZXJhRmFyTG9jYWwgPSByZWZlcmVuY2UoICdmYXInLCAnZmxvYXQnLCBzaGFkb3cuY2FtZXJhICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XG5cblx0XHRcdGNvb3JkWiA9IHZpZXdaVG9Mb2dhcml0aG1pY0RlcHRoKCB3Lm5lZ2F0ZSgpLCBjYW1lcmFOZWFyTG9jYWwsIGNhbWVyYUZhckxvY2FsICk7XG5cblx0XHR9XG5cblx0XHRzaGFkb3dDb29yZCA9IHZlYzMoXG5cdFx0XHRzaGFkb3dDb29yZC54LFxuXHRcdFx0c2hhZG93Q29vcmQueS5vbmVNaW51cygpLCAvLyBmb2xsb3cgd2ViZ3B1IHN0YW5kYXJkc1xuXHRcdFx0Y29vcmRaLmFkZCggYmlhcyApXG5cdFx0KTtcblxuXHRcdHJldHVybiBzaGFkb3dDb29yZDtcblxuXHR9XG5cblx0Z2V0U2hhZG93RmlsdGVyRm4oIHR5cGUgKSB7XG5cblx0XHRyZXR1cm4gX3NoYWRvd0ZpbHRlckxpYlsgdHlwZSBdO1xuXG5cdH1cblxuXHRzZXR1cFNoYWRvdyggYnVpbGRlciApIHtcblxuXHRcdGNvbnN0IHsgcmVuZGVyZXIgfSA9IGJ1aWxkZXI7XG5cblx0XHRjb25zdCB7IGxpZ2h0LCBzaGFkb3cgfSA9IHRoaXM7XG5cblx0XHRjb25zdCBzaGFkb3dNYXBUeXBlID0gcmVuZGVyZXIuc2hhZG93TWFwLnR5cGU7XG5cblx0XHRjb25zdCBkZXB0aFRleHR1cmUgPSBuZXcgRGVwdGhUZXh0dXJlKCBzaGFkb3cubWFwU2l6ZS53aWR0aCwgc2hhZG93Lm1hcFNpemUuaGVpZ2h0ICk7XG5cdFx0ZGVwdGhUZXh0dXJlLmNvbXBhcmVGdW5jdGlvbiA9IExlc3NDb21wYXJlO1xuXG5cdFx0Y29uc3Qgc2hhZG93TWFwID0gYnVpbGRlci5jcmVhdGVSZW5kZXJUYXJnZXQoIHNoYWRvdy5tYXBTaXplLndpZHRoLCBzaGFkb3cubWFwU2l6ZS5oZWlnaHQgKTtcblx0XHRzaGFkb3dNYXAuZGVwdGhUZXh0dXJlID0gZGVwdGhUZXh0dXJlO1xuXG5cdFx0c2hhZG93LmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHQvLyBWU01cblxuXHRcdGlmICggc2hhZG93TWFwVHlwZSA9PT0gVlNNU2hhZG93TWFwICkge1xuXG5cdFx0XHRkZXB0aFRleHR1cmUuY29tcGFyZUZ1bmN0aW9uID0gbnVsbDsgLy8gVlNNIGRvZXMgbm90IHVzZSB0ZXh0dXJlU2FtcGxlQ29tcGFyZSgpL3RleHR1cmUyRENvbXBhcmUoKVxuXG5cdFx0XHR0aGlzLnZzbVNoYWRvd01hcFZlcnRpY2FsID0gYnVpbGRlci5jcmVhdGVSZW5kZXJUYXJnZXQoIHNoYWRvdy5tYXBTaXplLndpZHRoLCBzaGFkb3cubWFwU2l6ZS5oZWlnaHQsIHsgZm9ybWF0OiBSR0Zvcm1hdCwgdHlwZTogSGFsZkZsb2F0VHlwZSB9ICk7XG5cdFx0XHR0aGlzLnZzbVNoYWRvd01hcEhvcml6b250YWwgPSBidWlsZGVyLmNyZWF0ZVJlbmRlclRhcmdldCggc2hhZG93Lm1hcFNpemUud2lkdGgsIHNoYWRvdy5tYXBTaXplLmhlaWdodCwgeyBmb3JtYXQ6IFJHRm9ybWF0LCB0eXBlOiBIYWxmRmxvYXRUeXBlIH0gKTtcblxuXHRcdFx0Y29uc3Qgc2hhZG93UGFzc1ZlcnRpY2FsID0gdGV4dHVyZSggZGVwdGhUZXh0dXJlICk7XG5cdFx0XHRjb25zdCBzaGFkb3dQYXNzSG9yaXpvbnRhbCA9IHRleHR1cmUoIHRoaXMudnNtU2hhZG93TWFwVmVydGljYWwudGV4dHVyZSApO1xuXG5cdFx0XHRjb25zdCBzYW1wbGVzID0gcmVmZXJlbmNlKCAnYmx1clNhbXBsZXMnLCAnZmxvYXQnLCBzaGFkb3cgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcblx0XHRcdGNvbnN0IHJhZGl1cyA9IHJlZmVyZW5jZSggJ3JhZGl1cycsICdmbG9hdCcsIHNoYWRvdyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xuXHRcdFx0Y29uc3Qgc2l6ZSA9IHJlZmVyZW5jZSggJ21hcFNpemUnLCAndmVjMicsIHNoYWRvdyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xuXG5cdFx0XHRsZXQgbWF0ZXJpYWwgPSB0aGlzLnZzbU1hdGVyaWFsVmVydGljYWwgfHwgKCB0aGlzLnZzbU1hdGVyaWFsVmVydGljYWwgPSBuZXcgTm9kZU1hdGVyaWFsKCkgKTtcblx0XHRcdG1hdGVyaWFsLmZyYWdtZW50Tm9kZSA9IFZTTVBhc3NWZXJ0aWNhbCggeyBzYW1wbGVzLCByYWRpdXMsIHNpemUsIHNoYWRvd1Bhc3M6IHNoYWRvd1Bhc3NWZXJ0aWNhbCB9ICkuY29udGV4dCggYnVpbGRlci5nZXRTaGFyZWRDb250ZXh0KCkgKTtcblx0XHRcdG1hdGVyaWFsLm5hbWUgPSAnVlNNVmVydGljYWwnO1xuXG5cdFx0XHRtYXRlcmlhbCA9IHRoaXMudnNtTWF0ZXJpYWxIb3Jpem9udGFsIHx8ICggdGhpcy52c21NYXRlcmlhbEhvcml6b250YWwgPSBuZXcgTm9kZU1hdGVyaWFsKCkgKTtcblx0XHRcdG1hdGVyaWFsLmZyYWdtZW50Tm9kZSA9IFZTTVBhc3NIb3Jpem9udGFsKCB7IHNhbXBsZXMsIHJhZGl1cywgc2l6ZSwgc2hhZG93UGFzczogc2hhZG93UGFzc0hvcml6b250YWwgfSApLmNvbnRleHQoIGJ1aWxkZXIuZ2V0U2hhcmVkQ29udGV4dCgpICk7XG5cdFx0XHRtYXRlcmlhbC5uYW1lID0gJ1ZTTUhvcml6b250YWwnO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IHNoYWRvd0ludGVuc2l0eSA9IHJlZmVyZW5jZSggJ2ludGVuc2l0eScsICdmbG9hdCcsIHNoYWRvdyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xuXHRcdGNvbnN0IG5vcm1hbEJpYXMgPSByZWZlcmVuY2UoICdub3JtYWxCaWFzJywgJ2Zsb2F0Jywgc2hhZG93ICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XG5cblx0XHRjb25zdCBzaGFkb3dQb3NpdGlvbiA9IGxpZ2h0U2hhZG93TWF0cml4KCBsaWdodCApLm11bCggc2hhZG93V29ybGRQb3NpdGlvbi5hZGQoIHRyYW5zZm9ybWVkTm9ybWFsV29ybGQubXVsKCBub3JtYWxCaWFzICkgKSApO1xuXHRcdGNvbnN0IHNoYWRvd0Nvb3JkID0gdGhpcy5zZXR1cFNoYWRvd0Nvb3JkKCBidWlsZGVyLCBzaGFkb3dQb3NpdGlvbiApO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGZpbHRlckZuID0gc2hhZG93LmZpbHRlck5vZGUgfHwgdGhpcy5nZXRTaGFkb3dGaWx0ZXJGbiggcmVuZGVyZXIuc2hhZG93TWFwLnR5cGUgKSB8fCBudWxsO1xuXG5cdFx0aWYgKCBmaWx0ZXJGbiA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuV2ViR1BVUmVuZGVyZXI6IFNoYWRvdyBtYXAgdHlwZSBub3Qgc3VwcG9ydGVkIHlldC4nICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBzaGFkb3dEZXB0aFRleHR1cmUgPSAoIHNoYWRvd01hcFR5cGUgPT09IFZTTVNoYWRvd01hcCApID8gdGhpcy52c21TaGFkb3dNYXBIb3Jpem9udGFsLnRleHR1cmUgOiBkZXB0aFRleHR1cmU7XG5cblx0XHRjb25zdCBzaGFkb3dOb2RlID0gdGhpcy5zZXR1cFNoYWRvd0ZpbHRlciggYnVpbGRlciwgeyBmaWx0ZXJGbiwgc2hhZG93VGV4dHVyZTogc2hhZG93TWFwLnRleHR1cmUsIGRlcHRoVGV4dHVyZTogc2hhZG93RGVwdGhUZXh0dXJlLCBzaGFkb3dDb29yZCwgc2hhZG93IH0gKTtcblxuXHRcdGNvbnN0IHNoYWRvd0NvbG9yID0gdGV4dHVyZSggc2hhZG93TWFwLnRleHR1cmUsIHNoYWRvd0Nvb3JkICk7XG5cdFx0Y29uc3Qgc2hhZG93T3V0cHV0ID0gbWl4KCAxLCBzaGFkb3dOb2RlLnJnYi5taXgoIHNoYWRvd0NvbG9yLCAxICksIHNoYWRvd0ludGVuc2l0eS5tdWwoIHNoYWRvd0NvbG9yLmEgKSApLnRvVmFyKCk7XG5cblx0XHR0aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcblx0XHR0aGlzLnNoYWRvdy5tYXAgPSBzaGFkb3dNYXA7XG5cblx0XHRyZXR1cm4gc2hhZG93T3V0cHV0O1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdGlmICggYnVpbGRlci5yZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRyZXR1cm4gRm4oICggeyBtYXRlcmlhbCB9ICkgPT4ge1xuXG5cdFx0XHRzaGFkb3dXb3JsZFBvc2l0aW9uLmFzc2lnbiggbWF0ZXJpYWwuc2hhZG93UG9zaXRpb25Ob2RlIHx8IHBvc2l0aW9uV29ybGQgKTtcblxuXHRcdFx0bGV0IG5vZGUgPSB0aGlzLl9ub2RlO1xuXG5cdFx0XHRpZiAoIG5vZGUgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5fbm9kZSA9IG5vZGUgPSB0aGlzLnNldHVwU2hhZG93KCBidWlsZGVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidWlsZGVyLm1hdGVyaWFsLnNoYWRvd05vZGUgKSB7IC8vIEBkZXByZWNhdGVkLCByMTcxXG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTm9kZU1hdGVyaWFsOiBcIi5zaGFkb3dOb2RlXCIgaXMgZGVwcmVjYXRlZC4gVXNlIFwiLmNhc3RTaGFkb3dOb2RlXCIgaW5zdGVhZC4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidWlsZGVyLm1hdGVyaWFsLnJlY2VpdmVkU2hhZG93Tm9kZSApIHtcblxuXHRcdFx0XHRub2RlID0gYnVpbGRlci5tYXRlcmlhbC5yZWNlaXZlZFNoYWRvd05vZGUoIG5vZGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbm9kZTtcblxuXHRcdH0gKSgpO1xuXG5cdH1cblxuXHRyZW5kZXJTaGFkb3coIGZyYW1lICkge1xuXG5cdFx0Y29uc3QgeyBzaGFkb3csIHNoYWRvd01hcCB9ID0gdGhpcztcblx0XHRjb25zdCB7IHJlbmRlcmVyLCBzY2VuZSB9ID0gZnJhbWU7XG5cblx0XHRzaGFkb3dNYXAuc2V0U2l6ZSggc2hhZG93Lm1hcFNpemUud2lkdGgsIHNoYWRvdy5tYXBTaXplLmhlaWdodCApO1xuXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgc2hhZG93LmNhbWVyYSApO1xuXG5cdH1cblxuXHR1cGRhdGVTaGFkb3coIGZyYW1lICkge1xuXG5cdFx0Y29uc3QgeyBzaGFkb3dNYXAsIGxpZ2h0LCBzaGFkb3cgfSA9IHRoaXM7XG5cdFx0Y29uc3QgeyByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSB9ID0gZnJhbWU7XG5cblx0XHRjb25zdCBzaGFkb3dUeXBlID0gcmVuZGVyZXIuc2hhZG93TWFwLnR5cGU7XG5cblx0XHRjb25zdCBkZXB0aFZlcnNpb24gPSBzaGFkb3dNYXAuZGVwdGhUZXh0dXJlLnZlcnNpb247XG5cdFx0dGhpcy5fZGVwdGhWZXJzaW9uQ2FjaGVkID0gZGVwdGhWZXJzaW9uO1xuXG5cdFx0Y29uc3QgY3VycmVudE92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xuXG5cdFx0c2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IGdldFNoYWRvd01hdGVyaWFsKCBsaWdodCApO1xuXG5cdFx0c2hhZG93LmNhbWVyYS5sYXllcnMubWFzayA9IGNhbWVyYS5sYXllcnMubWFzaztcblxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRjb25zdCBjdXJyZW50UmVuZGVyT2JqZWN0RnVuY3Rpb24gPSByZW5kZXJlci5nZXRSZW5kZXJPYmplY3RGdW5jdGlvbigpO1xuXHRcdGNvbnN0IGN1cnJlbnRNUlQgPSByZW5kZXJlci5nZXRNUlQoKTtcblxuXHRcdHJlbmRlcmVyLnNldE1SVCggbnVsbCApO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyT2JqZWN0RnVuY3Rpb24oICggb2JqZWN0LCAuLi5wYXJhbXMgKSA9PiB7XG5cblx0XHRcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgPT09IHRydWUgfHwgKCBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBzaGFkb3dUeXBlID09PSBWU01TaGFkb3dNYXAgKSApIHtcblxuXHRcdFx0XHRyZW5kZXJlci5yZW5kZXJPYmplY3QoIG9iamVjdCwgLi4ucGFyYW1zICk7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc2hhZG93TWFwICk7XG5cblx0XHR0aGlzLnJlbmRlclNoYWRvdyggZnJhbWUgKTtcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlck9iamVjdEZ1bmN0aW9uKCBjdXJyZW50UmVuZGVyT2JqZWN0RnVuY3Rpb24gKTtcblxuXHRcdC8vIHZzbSBibHVyIHBhc3NcblxuXHRcdGlmICggbGlnaHQuaXNQb2ludExpZ2h0ICE9PSB0cnVlICYmIHNoYWRvd1R5cGUgPT09IFZTTVNoYWRvd01hcCApIHtcblxuXHRcdFx0dGhpcy52c21QYXNzKCByZW5kZXJlciApO1xuXG5cdFx0fVxuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdXJyZW50UmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRyZW5kZXJlci5zZXRNUlQoIGN1cnJlbnRNUlQgKTtcblxuXHRcdHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgPSBjdXJyZW50T3ZlcnJpZGVNYXRlcmlhbDtcblxuXHR9XG5cblx0dnNtUGFzcyggcmVuZGVyZXIgKSB7XG5cblx0XHRjb25zdCB7IHNoYWRvdyB9ID0gdGhpcztcblxuXHRcdHRoaXMudnNtU2hhZG93TWFwVmVydGljYWwuc2V0U2l6ZSggc2hhZG93Lm1hcFNpemUud2lkdGgsIHNoYWRvdy5tYXBTaXplLmhlaWdodCApO1xuXHRcdHRoaXMudnNtU2hhZG93TWFwSG9yaXpvbnRhbC5zZXRTaXplKCBzaGFkb3cubWFwU2l6ZS53aWR0aCwgc2hhZG93Lm1hcFNpemUuaGVpZ2h0ICk7XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHRoaXMudnNtU2hhZG93TWFwVmVydGljYWwgKTtcblx0XHRfcXVhZE1lc2gubWF0ZXJpYWwgPSB0aGlzLnZzbU1hdGVyaWFsVmVydGljYWw7XG5cdFx0X3F1YWRNZXNoLnJlbmRlciggcmVuZGVyZXIgKTtcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggdGhpcy52c21TaGFkb3dNYXBIb3Jpem9udGFsICk7XG5cdFx0X3F1YWRNZXNoLm1hdGVyaWFsID0gdGhpcy52c21NYXRlcmlhbEhvcml6b250YWw7XG5cdFx0X3F1YWRNZXNoLnJlbmRlciggcmVuZGVyZXIgKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuc2hhZG93TWFwLmRpc3Bvc2UoKTtcblx0XHR0aGlzLnNoYWRvd01hcCA9IG51bGw7XG5cblx0XHRpZiAoIHRoaXMudnNtU2hhZG93TWFwVmVydGljYWwgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMudnNtU2hhZG93TWFwVmVydGljYWwuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy52c21TaGFkb3dNYXBWZXJ0aWNhbCA9IG51bGw7XG5cblx0XHRcdHRoaXMudnNtTWF0ZXJpYWxWZXJ0aWNhbC5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLnZzbU1hdGVyaWFsVmVydGljYWwgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnZzbVNoYWRvd01hcEhvcml6b250YWwgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMudnNtU2hhZG93TWFwSG9yaXpvbnRhbC5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLnZzbVNoYWRvd01hcEhvcml6b250YWwgPSBudWxsO1xuXG5cdFx0XHR0aGlzLnZzbU1hdGVyaWFsSG9yaXpvbnRhbC5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLnZzbU1hdGVyaWFsSG9yaXpvbnRhbCA9IG51bGw7XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZUJlZm9yZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5OT05FO1xuXG5cdH1cblxuXHR1cGRhdGVCZWZvcmUoIGZyYW1lICkge1xuXG5cdFx0Y29uc3QgeyBzaGFkb3cgfSA9IHRoaXM7XG5cblx0XHRjb25zdCBuZWVkc1VwZGF0ZSA9IHNoYWRvdy5uZWVkc1VwZGF0ZSB8fCBzaGFkb3cuYXV0b1VwZGF0ZTtcblxuXHRcdGlmICggbmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdHRoaXMudXBkYXRlU2hhZG93KCBmcmFtZSApO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2hhZG93TWFwLmRlcHRoVGV4dHVyZS52ZXJzaW9uID09PSB0aGlzLl9kZXB0aFZlcnNpb25DYWNoZWQgKSB7XG5cblx0XHRcdFx0c2hhZG93Lm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2hhZG93Tm9kZTtcblxuZXhwb3J0IGNvbnN0IHNoYWRvdyA9ICggbGlnaHQsIHNoYWRvdyApID0+IG5vZGVPYmplY3QoIG5ldyBTaGFkb3dOb2RlKCBsaWdodCwgc2hhZG93ICkgKTtcbiIsImltcG9ydCBMaWdodGluZ05vZGUgZnJvbSAnLi9MaWdodGluZ05vZGUuanMnO1xuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL21hdGgvQ29sb3IuanMnO1xuaW1wb3J0IHsgcmVuZGVyR3JvdXAgfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Hcm91cE5vZGUuanMnO1xuaW1wb3J0IHsgaGFzaCB9IGZyb20gJy4uL2NvcmUvTm9kZVV0aWxzLmpzJztcbmltcG9ydCB7IHNoYWRvdyB9IGZyb20gJy4vU2hhZG93Tm9kZS5qcyc7XG5pbXBvcnQgeyBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xuXG5jbGFzcyBBbmFseXRpY0xpZ2h0Tm9kZSBleHRlbmRzIExpZ2h0aW5nTm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdBbmFseXRpY0xpZ2h0Tm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBsaWdodCA9IG51bGwgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvcigpO1xuXHRcdHRoaXMuY29sb3JOb2RlID0gKCBsaWdodCAmJiBsaWdodC5jb2xvck5vZGUgKSB8fCB1bmlmb3JtKCB0aGlzLmNvbG9yICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XG5cblx0XHR0aGlzLmJhc2VDb2xvck5vZGUgPSBudWxsO1xuXG5cdFx0dGhpcy5zaGFkb3dOb2RlID0gbnVsbDtcblx0XHR0aGlzLnNoYWRvd0NvbG9yTm9kZSA9IG51bGw7XG5cblx0XHR0aGlzLmlzQW5hbHl0aWNMaWdodE5vZGUgPSB0cnVlO1xuXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuRlJBTUU7XG5cblx0fVxuXG5cdGdldENhY2hlS2V5KCkge1xuXG5cdFx0cmV0dXJuIGhhc2goIHN1cGVyLmdldENhY2hlS2V5KCksIHRoaXMubGlnaHQuaWQsIHRoaXMubGlnaHQuY2FzdFNoYWRvdyA/IDEgOiAwICk7XG5cblx0fVxuXG5cdGdldEhhc2goKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5saWdodC51dWlkO1xuXG5cdH1cblxuXHRzZXR1cFNoYWRvd05vZGUoKSB7XG5cblx0XHRyZXR1cm4gc2hhZG93KCB0aGlzLmxpZ2h0ICk7XG5cblx0fVxuXG5cdHNldHVwU2hhZG93KCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgeyByZW5kZXJlciB9ID0gYnVpbGRlcjtcblxuXHRcdGlmICggcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0bGV0IHNoYWRvd0NvbG9yTm9kZSA9IHRoaXMuc2hhZG93Q29sb3JOb2RlO1xuXG5cdFx0aWYgKCBzaGFkb3dDb2xvck5vZGUgPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IGN1c3RvbVNoYWRvd05vZGUgPSB0aGlzLmxpZ2h0LnNoYWRvdy5zaGFkb3dOb2RlO1xuXG5cdFx0XHRsZXQgc2hhZG93Tm9kZTtcblxuXHRcdFx0aWYgKCBjdXN0b21TaGFkb3dOb2RlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c2hhZG93Tm9kZSA9IG5vZGVPYmplY3QoIGN1c3RvbVNoYWRvd05vZGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzaGFkb3dOb2RlID0gdGhpcy5zZXR1cFNoYWRvd05vZGUoIGJ1aWxkZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNoYWRvd05vZGUgPSBzaGFkb3dOb2RlO1xuXG5cdFx0XHR0aGlzLnNoYWRvd0NvbG9yTm9kZSA9IHNoYWRvd0NvbG9yTm9kZSA9IHRoaXMuY29sb3JOb2RlLm11bCggc2hhZG93Tm9kZSApO1xuXG5cdFx0XHR0aGlzLmJhc2VDb2xvck5vZGUgPSB0aGlzLmNvbG9yTm9kZTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR0aGlzLmNvbG9yTm9kZSA9IHNoYWRvd0NvbG9yTm9kZTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHR0aGlzLmNvbG9yTm9kZSA9IHRoaXMuYmFzZUNvbG9yTm9kZSB8fCB0aGlzLmNvbG9yTm9kZTtcblxuXHRcdGlmICggdGhpcy5saWdodC5jYXN0U2hhZG93ICkge1xuXG5cdFx0XHRpZiAoIGJ1aWxkZXIub2JqZWN0LnJlY2VpdmVTaGFkb3cgKSB7XG5cblx0XHRcdFx0dGhpcy5zZXR1cFNoYWRvdyggYnVpbGRlciApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLnNoYWRvd05vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuc2hhZG93Tm9kZS5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLnNoYWRvd05vZGUgPSBudWxsO1xuXHRcdFx0dGhpcy5zaGFkb3dDb2xvck5vZGUgPSBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGUoIC8qZnJhbWUqLyApIHtcblxuXHRcdGNvbnN0IHsgbGlnaHQgfSA9IHRoaXM7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGxpZ2h0LmludGVuc2l0eSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBbmFseXRpY0xpZ2h0Tm9kZTtcbiIsImltcG9ydCB7IEZuIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5leHBvcnQgY29uc3QgZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiA9IC8qQF9fUFVSRV9fKi8gRm4oICggaW5wdXRzICkgPT4ge1xuXG5cdGNvbnN0IHsgbGlnaHREaXN0YW5jZSwgY3V0b2ZmRGlzdGFuY2UsIGRlY2F5RXhwb25lbnQgfSA9IGlucHV0cztcblxuXHQvLyBiYXNlZCB1cG9uIEZyb3N0Yml0ZSAzIE1vdmluZyB0byBQaHlzaWNhbGx5LWJhc2VkIFJlbmRlcmluZ1xuXHQvLyBwYWdlIDMyLCBlcXVhdGlvbiAyNjogRVt3aW5kb3cxXVxuXHQvLyBodHRwczovL3NlYmxhZ2FyZGUuZmlsZXMud29yZHByZXNzLmNvbS8yMDE1LzA3L2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bicl92MzIucGRmXG5cdGNvbnN0IGRpc3RhbmNlRmFsbG9mZiA9IGxpZ2h0RGlzdGFuY2UucG93KCBkZWNheUV4cG9uZW50ICkubWF4KCAwLjAxICkucmVjaXByb2NhbCgpO1xuXG5cdHJldHVybiBjdXRvZmZEaXN0YW5jZS5ncmVhdGVyVGhhbiggMCApLnNlbGVjdChcblx0XHRkaXN0YW5jZUZhbGxvZmYubXVsKCBsaWdodERpc3RhbmNlLmRpdiggY3V0b2ZmRGlzdGFuY2UgKS5wb3c0KCkub25lTWludXMoKS5jbGFtcCgpLnBvdzIoKSApLFxuXHRcdGRpc3RhbmNlRmFsbG9mZlxuXHQpO1xuXG59ICk7IC8vIHZhbGlkYXRlZFxuIiwiaW1wb3J0IFNoYWRvd05vZGUgZnJvbSAnLi9TaGFkb3dOb2RlLmpzJztcbmltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcbmltcG9ydCB7IGZsb2F0LCB2ZWMyLCBJZiwgRm4sIG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5pbXBvcnQgeyByZWZlcmVuY2UgfSBmcm9tICcuLi9hY2Nlc3NvcnMvUmVmZXJlbmNlTm9kZS5qcyc7XG5pbXBvcnQgeyB0ZXh0dXJlIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcbmltcG9ydCB7IG1heCwgYWJzLCBzaWduIH0gZnJvbSAnLi4vbWF0aC9NYXRoTm9kZS5qcyc7XG5pbXBvcnQgeyBzdWIsIGRpdiB9IGZyb20gJy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJztcbmltcG9ydCB7IHJlbmRlckdyb3VwIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yNC5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL21hdGgvQ29sb3IuanMnO1xuaW1wb3J0IHsgQmFzaWNTaGFkb3dNYXAgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuXG5jb25zdCBfY2xlYXJDb2xvciA9IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCk7XG5cbi8vIGN1YmVUb1VWKCkgbWFwcyBhIDNEIGRpcmVjdGlvbiB2ZWN0b3Igc3VpdGFibGUgZm9yIGN1YmUgdGV4dHVyZSBtYXBwaW5nIHRvIGEgMkRcbi8vIHZlY3RvciBzdWl0YWJsZSBmb3IgMkQgdGV4dHVyZSBtYXBwaW5nLiBUaGlzIGNvZGUgdXNlcyB0aGUgZm9sbG93aW5nIGxheW91dCBmb3IgdGhlXG4vLyAyRCB0ZXh0dXJlOlxuLy9cbi8vIHh6WFpcbi8vICB5IFlcbi8vXG4vLyBZIC0gUG9zaXRpdmUgeSBkaXJlY3Rpb25cbi8vIHkgLSBOZWdhdGl2ZSB5IGRpcmVjdGlvblxuLy8gWCAtIFBvc2l0aXZlIHggZGlyZWN0aW9uXG4vLyB4IC0gTmVnYXRpdmUgeCBkaXJlY3Rpb25cbi8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxuLy8geiAtIE5lZ2F0aXZlIHogZGlyZWN0aW9uXG4vL1xuLy8gU291cmNlIGFuZCB0ZXN0IGJlZDpcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3RzY2h3L2RhMTBjNDNjNDY3Y2U4YWZkMGM0XG5cbmV4cG9ydCBjb25zdCBjdWJlVG9VViA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwb3MsIHRleGVsU2l6ZVkgXSApID0+IHtcblxuXHRjb25zdCB2ID0gcG9zLnRvVmFyKCk7XG5cblx0Ly8gTnVtYmVyIG9mIHRleGVscyB0byBhdm9pZCBhdCB0aGUgZWRnZSBvZiBlYWNoIHNxdWFyZVxuXG5cdGNvbnN0IGFic1YgPSBhYnMoIHYgKTtcblxuXHQvLyBJbnRlcnNlY3QgdW5pdCBjdWJlXG5cblx0Y29uc3Qgc2NhbGVUb0N1YmUgPSBkaXYoIDEuMCwgbWF4KCBhYnNWLngsIG1heCggYWJzVi55LCBhYnNWLnogKSApICk7XG5cdGFic1YubXVsQXNzaWduKCBzY2FsZVRvQ3ViZSApO1xuXG5cdC8vIEFwcGx5IHNjYWxlIHRvIGF2b2lkIHNlYW1zXG5cblx0Ly8gdHdvIHRleGVscyBsZXNzIHBlciBzcXVhcmUgKG9uZSB0ZXhlbCB3aWxsIGRvIGZvciBORUFSRVNUKVxuXHR2Lm11bEFzc2lnbiggc2NhbGVUb0N1YmUubXVsKCB0ZXhlbFNpemVZLm11bCggMiApLm9uZU1pbnVzKCkgKSApO1xuXG5cdC8vIFVud3JhcFxuXG5cdC8vIHNwYWNlOiAtMSAuLi4gMSByYW5nZSBmb3IgZWFjaCBzcXVhcmVcblx0Ly9cblx0Ly8gI1gjI1x0XHRkaW0gICAgOj0gKCA0ICwgMiApXG5cdC8vICAjICNcdFx0Y2VudGVyIDo9ICggMSAsIDEgKVxuXG5cdGNvbnN0IHBsYW5hciA9IHZlYzIoIHYueHkgKS50b1ZhcigpO1xuXG5cdGNvbnN0IGFsbW9zdEFUZXhlbCA9IHRleGVsU2l6ZVkubXVsKCAxLjUgKTtcblx0Y29uc3QgYWxtb3N0T25lID0gYWxtb3N0QVRleGVsLm9uZU1pbnVzKCk7XG5cblx0SWYoIGFic1Yuei5ncmVhdGVyVGhhbkVxdWFsKCBhbG1vc3RPbmUgKSwgKCkgPT4ge1xuXG5cdFx0SWYoIHYuei5ncmVhdGVyVGhhbiggMC4wICksICgpID0+IHtcblxuXHRcdFx0cGxhbmFyLnguYXNzaWduKCBzdWIoIDQuMCwgdi54ICkgKTtcblxuXHRcdH0gKTtcblxuXHR9ICkuRWxzZUlmKCBhYnNWLnguZ3JlYXRlclRoYW5FcXVhbCggYWxtb3N0T25lICksICgpID0+IHtcblxuXHRcdGNvbnN0IHNpZ25YID0gc2lnbiggdi54ICk7XG5cdFx0cGxhbmFyLnguYXNzaWduKCB2LnoubXVsKCBzaWduWCApLmFkZCggc2lnblgubXVsKCAyLjAgKSApICk7XG5cblx0fSApLkVsc2VJZiggYWJzVi55LmdyZWF0ZXJUaGFuRXF1YWwoIGFsbW9zdE9uZSApLCAoKSA9PiB7XG5cblx0XHRjb25zdCBzaWduWSA9IHNpZ24oIHYueSApO1xuXHRcdHBsYW5hci54LmFzc2lnbiggdi54LmFkZCggc2lnblkubXVsKCAyLjAgKSApLmFkZCggMi4wICkgKTtcblx0XHRwbGFuYXIueS5hc3NpZ24oIHYuei5tdWwoIHNpZ25ZICkuc3ViKCAyLjAgKSApO1xuXG5cdH0gKTtcblxuXHQvLyBUcmFuc2Zvcm0gdG8gVVYgc3BhY2VcblxuXHQvLyBzY2FsZSA6PSAwLjUgLyBkaW1cblx0Ly8gdHJhbnNsYXRlIDo9ICggY2VudGVyICsgMC41ICkgLyBkaW1cblx0cmV0dXJuIHZlYzIoIDAuMTI1LCAwLjI1ICkubXVsKCBwbGFuYXIgKS5hZGQoIHZlYzIoIDAuMzc1LCAwLjc1ICkgKS5mbGlwWSgpO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdjdWJlVG9VVicsXG5cdHR5cGU6ICd2ZWMyJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncG9zJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAndGV4ZWxTaXplWScsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBCYXNpY1BvaW50U2hhZG93RmlsdGVyID0gLypAX19QVVJFX18qLyBGbiggKCB7IGRlcHRoVGV4dHVyZSwgYmQzRCwgZHAsIHRleGVsU2l6ZSB9ICkgPT4ge1xuXG5cdHJldHVybiB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKTtcblxufSApO1xuXG5leHBvcnQgY29uc3QgUG9pbnRTaGFkb3dGaWx0ZXIgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgZGVwdGhUZXh0dXJlLCBiZDNELCBkcCwgdGV4ZWxTaXplLCBzaGFkb3cgfSApID0+IHtcblxuXHRjb25zdCByYWRpdXMgPSByZWZlcmVuY2UoICdyYWRpdXMnLCAnZmxvYXQnLCBzaGFkb3cgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcblx0Y29uc3Qgb2Zmc2V0ID0gdmVjMiggLSAxLjAsIDEuMCApLm11bCggcmFkaXVzICkubXVsKCB0ZXhlbFNpemUueSApO1xuXG5cdHJldHVybiB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELmFkZCggb2Zmc2V0Lnh5eSApLCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKVxuXHRcdC5hZGQoIHRleHR1cmUoIGRlcHRoVGV4dHVyZSwgY3ViZVRvVVYoIGJkM0QuYWRkKCBvZmZzZXQueXl5ICksIHRleGVsU2l6ZS55ICkgKS5jb21wYXJlKCBkcCApIClcblx0XHQuYWRkKCB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELmFkZCggb2Zmc2V0Lnh5eCApLCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKSApXG5cdFx0LmFkZCggdGV4dHVyZSggZGVwdGhUZXh0dXJlLCBjdWJlVG9VViggYmQzRC5hZGQoIG9mZnNldC55eXggKSwgdGV4ZWxTaXplLnkgKSApLmNvbXBhcmUoIGRwICkgKVxuXHRcdC5hZGQoIHRleHR1cmUoIGRlcHRoVGV4dHVyZSwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICkgKS5jb21wYXJlKCBkcCApIClcblx0XHQuYWRkKCB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELmFkZCggb2Zmc2V0Lnh4eSApLCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKSApXG5cdFx0LmFkZCggdGV4dHVyZSggZGVwdGhUZXh0dXJlLCBjdWJlVG9VViggYmQzRC5hZGQoIG9mZnNldC55eHkgKSwgdGV4ZWxTaXplLnkgKSApLmNvbXBhcmUoIGRwICkgKVxuXHRcdC5hZGQoIHRleHR1cmUoIGRlcHRoVGV4dHVyZSwgY3ViZVRvVVYoIGJkM0QuYWRkKCBvZmZzZXQueHh4ICksIHRleGVsU2l6ZS55ICkgKS5jb21wYXJlKCBkcCApIClcblx0XHQuYWRkKCB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELmFkZCggb2Zmc2V0Lnl4eCApLCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKSApXG5cdFx0Lm11bCggMS4wIC8gOS4wICk7XG5cbn0gKTtcblxuY29uc3QgcG9pbnRTaGFkb3dGaWx0ZXIgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgZmlsdGVyRm4sIGRlcHRoVGV4dHVyZSwgc2hhZG93Q29vcmQsIHNoYWRvdyB9ICkgPT4ge1xuXG5cdC8vIGZvciBwb2ludCBsaWdodHMsIHRoZSB1bmlmb3JtIEB2U2hhZG93Q29vcmQgaXMgcmUtcHVycG9zZWQgdG8gaG9sZFxuXHQvLyB0aGUgdmVjdG9yIGZyb20gdGhlIGxpZ2h0IHRvIHRoZSB3b3JsZC1zcGFjZSBwb3NpdGlvbiBvZiB0aGUgZnJhZ21lbnQuXG5cdGNvbnN0IGxpZ2h0VG9Qb3NpdGlvbiA9IHNoYWRvd0Nvb3JkLnh5ei50b1ZhcigpO1xuXHRjb25zdCBsaWdodFRvUG9zaXRpb25MZW5ndGggPSBsaWdodFRvUG9zaXRpb24ubGVuZ3RoKCk7XG5cblx0Y29uc3QgY2FtZXJhTmVhckxvY2FsID0gdW5pZm9ybSggJ2Zsb2F0JyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApLm9uUmVuZGVyVXBkYXRlKCAoKSA9PiBzaGFkb3cuY2FtZXJhLm5lYXIgKTtcblx0Y29uc3QgY2FtZXJhRmFyTG9jYWwgPSB1bmlmb3JtKCAnZmxvYXQnICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICkub25SZW5kZXJVcGRhdGUoICgpID0+IHNoYWRvdy5jYW1lcmEuZmFyICk7XG5cdGNvbnN0IGJpYXMgPSByZWZlcmVuY2UoICdiaWFzJywgJ2Zsb2F0Jywgc2hhZG93ICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XG5cdGNvbnN0IG1hcFNpemUgPSB1bmlmb3JtKCBzaGFkb3cubWFwU2l6ZSApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xuXG5cdGNvbnN0IHJlc3VsdCA9IGZsb2F0KCAxLjAgKS50b1ZhcigpO1xuXG5cdElmKCBsaWdodFRvUG9zaXRpb25MZW5ndGguc3ViKCBjYW1lcmFGYXJMb2NhbCApLmxlc3NUaGFuRXF1YWwoIDAuMCApLmFuZCggbGlnaHRUb1Bvc2l0aW9uTGVuZ3RoLnN1YiggY2FtZXJhTmVhckxvY2FsICkuZ3JlYXRlclRoYW5FcXVhbCggMC4wICkgKSwgKCkgPT4ge1xuXG5cdFx0Ly8gZHAgPSBub3JtYWxpemVkIGRpc3RhbmNlIGZyb20gbGlnaHQgdG8gZnJhZ21lbnQgcG9zaXRpb25cblx0XHRjb25zdCBkcCA9IGxpZ2h0VG9Qb3NpdGlvbkxlbmd0aC5zdWIoIGNhbWVyYU5lYXJMb2NhbCApLmRpdiggY2FtZXJhRmFyTG9jYWwuc3ViKCBjYW1lcmFOZWFyTG9jYWwgKSApLnRvVmFyKCk7IC8vIG5lZWQgdG8gY2xhbXA/XG5cdFx0ZHAuYWRkQXNzaWduKCBiaWFzICk7XG5cblx0XHQvLyBiZDNEID0gYmFzZSBkaXJlY3Rpb24gM0Rcblx0XHRjb25zdCBiZDNEID0gbGlnaHRUb1Bvc2l0aW9uLm5vcm1hbGl6ZSgpO1xuXHRcdGNvbnN0IHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApLmRpdiggbWFwU2l6ZS5tdWwoIHZlYzIoIDQuMCwgMi4wICkgKSApO1xuXG5cdFx0Ly8gcGVyY2VudGFnZS1jbG9zZXIgZmlsdGVyaW5nXG5cdFx0cmVzdWx0LmFzc2lnbiggZmlsdGVyRm4oIHsgZGVwdGhUZXh0dXJlLCBiZDNELCBkcCwgdGV4ZWxTaXplLCBzaGFkb3cgfSApICk7XG5cblx0fSApO1xuXG5cdHJldHVybiByZXN1bHQ7XG5cbn0gKTtcblxuY29uc3QgX3ZpZXdwb3J0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yNCgpO1xuY29uc3QgX3ZpZXdwb3J0U2l6ZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF9zaGFkb3dNYXBTaXplID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xuXG4vL1xuXG5jbGFzcyBQb2ludFNoYWRvd05vZGUgZXh0ZW5kcyBTaGFkb3dOb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ1BvaW50U2hhZG93Tm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBsaWdodCwgc2hhZG93ID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCBsaWdodCwgc2hhZG93ICk7XG5cblx0fVxuXG5cdGdldFNoYWRvd0ZpbHRlckZuKCB0eXBlICkge1xuXG5cdFx0cmV0dXJuIHR5cGUgPT09IEJhc2ljU2hhZG93TWFwID8gQmFzaWNQb2ludFNoYWRvd0ZpbHRlciA6IFBvaW50U2hhZG93RmlsdGVyO1xuXG5cdH1cblxuXHRzZXR1cFNoYWRvd0Nvb3JkKCBidWlsZGVyLCBzaGFkb3dQb3NpdGlvbiApIHtcblxuXHRcdHJldHVybiBzaGFkb3dQb3NpdGlvbjtcblxuXHR9XG5cblx0c2V0dXBTaGFkb3dGaWx0ZXIoIGJ1aWxkZXIsIHsgZmlsdGVyRm4sIHNoYWRvd1RleHR1cmUsIGRlcHRoVGV4dHVyZSwgc2hhZG93Q29vcmQsIHNoYWRvdyB9ICkge1xuXG5cdFx0cmV0dXJuIHBvaW50U2hhZG93RmlsdGVyKCB7IGZpbHRlckZuLCBzaGFkb3dUZXh0dXJlLCBkZXB0aFRleHR1cmUsIHNoYWRvd0Nvb3JkLCBzaGFkb3cgfSApO1xuXG5cdH1cblxuXHRyZW5kZXJTaGFkb3coIGZyYW1lICkge1xuXG5cdFx0Y29uc3QgeyBzaGFkb3csIHNoYWRvd01hcCwgbGlnaHQgfSA9IHRoaXM7XG5cdFx0Y29uc3QgeyByZW5kZXJlciwgc2NlbmUgfSA9IGZyYW1lO1xuXG5cdFx0Y29uc3Qgc2hhZG93RnJhbWVFeHRlbnRzID0gc2hhZG93LmdldEZyYW1lRXh0ZW50cygpO1xuXG5cdFx0X3NoYWRvd01hcFNpemUuY29weSggc2hhZG93Lm1hcFNpemUgKTtcblx0XHRfc2hhZG93TWFwU2l6ZS5tdWx0aXBseSggc2hhZG93RnJhbWVFeHRlbnRzICk7XG5cblx0XHRzaGFkb3dNYXAuc2V0U2l6ZSggX3NoYWRvd01hcFNpemUud2lkdGgsIF9zaGFkb3dNYXBTaXplLmhlaWdodCApO1xuXG5cdFx0X3ZpZXdwb3J0U2l6ZS5jb3B5KCBzaGFkb3cubWFwU2l6ZSApO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IHByZXZpb3VzQXV0b0NsZWFyID0gcmVuZGVyZXIuYXV0b0NsZWFyO1xuXG5cdFx0Y29uc3QgcHJldmlvdXNDbGVhckNvbG9yID0gcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvciggX2NsZWFyQ29sb3IgKTtcblx0XHRjb25zdCBwcmV2aW91c0NsZWFyQWxwaGEgPSByZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG5cblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBmYWxzZTtcblx0XHRyZW5kZXJlci5zZXRDbGVhckNvbG9yKCBzaGFkb3cuY2xlYXJDb2xvciwgc2hhZG93LmNsZWFyQWxwaGEgKTtcblx0XHRyZW5kZXJlci5jbGVhcigpO1xuXG5cdFx0Y29uc3Qgdmlld3BvcnRDb3VudCA9IHNoYWRvdy5nZXRWaWV3cG9ydENvdW50KCk7XG5cblx0XHRmb3IgKCBsZXQgdnAgPSAwOyB2cCA8IHZpZXdwb3J0Q291bnQ7IHZwICsrICkge1xuXG5cdFx0XHRjb25zdCB2aWV3cG9ydCA9IHNoYWRvdy5nZXRWaWV3cG9ydCggdnAgKTtcblxuXHRcdFx0Y29uc3QgeCA9IF92aWV3cG9ydFNpemUueCAqIHZpZXdwb3J0Lng7XG5cdFx0XHRjb25zdCB5ID0gX3NoYWRvd01hcFNpemUueSAtIF92aWV3cG9ydFNpemUueSAtICggX3ZpZXdwb3J0U2l6ZS55ICogdmlld3BvcnQueSApO1xuXG5cdFx0XHRfdmlld3BvcnQuc2V0KFxuXHRcdFx0XHR4LFxuXHRcdFx0XHR5LFxuXHRcdFx0XHRfdmlld3BvcnRTaXplLnggKiB2aWV3cG9ydC56LFxuXHRcdFx0XHRfdmlld3BvcnRTaXplLnkgKiB2aWV3cG9ydC53XG5cdFx0XHQpO1xuXG5cdFx0XHRzaGFkb3dNYXAudmlld3BvcnQuY29weSggX3ZpZXdwb3J0ICk7XG5cblx0XHRcdHNoYWRvdy51cGRhdGVNYXRyaWNlcyggbGlnaHQsIHZwICk7XG5cblx0XHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIHNoYWRvdy5jYW1lcmEgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBwcmV2aW91c0F1dG9DbGVhcjtcblx0XHRyZW5kZXJlci5zZXRDbGVhckNvbG9yKCBwcmV2aW91c0NsZWFyQ29sb3IsIHByZXZpb3VzQ2xlYXJBbHBoYSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQb2ludFNoYWRvd05vZGU7XG5cbmV4cG9ydCBjb25zdCBwb2ludFNoYWRvdyA9ICggbGlnaHQsIHNoYWRvdyApID0+IG5vZGVPYmplY3QoIG5ldyBQb2ludFNoYWRvd05vZGUoIGxpZ2h0LCBzaGFkb3cgKSApO1xuIiwiaW1wb3J0IEFuYWx5dGljTGlnaHROb2RlIGZyb20gJy4vQW5hbHl0aWNMaWdodE5vZGUuanMnO1xuaW1wb3J0IHsgZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiB9IGZyb20gJy4vTGlnaHRVdGlscy5qcyc7XG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XG5pbXBvcnQgeyBsaWdodFZpZXdQb3NpdGlvbiB9IGZyb20gJy4uL2FjY2Vzc29ycy9MaWdodHMuanMnO1xuaW1wb3J0IHsgcG9zaXRpb25WaWV3IH0gZnJvbSAnLi4vYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IEZuIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgcmVuZGVyR3JvdXAgfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Hcm91cE5vZGUuanMnO1xuaW1wb3J0IHsgcG9pbnRTaGFkb3cgfSBmcm9tICcuL1BvaW50U2hhZG93Tm9kZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBkaXJlY3RQb2ludExpZ2h0ID0gRm4oICggeyBjb2xvciwgbGlnaHRWaWV3UG9zaXRpb24sIGN1dG9mZkRpc3RhbmNlLCBkZWNheUV4cG9uZW50IH0sIGJ1aWxkZXIgKSA9PiB7XG5cblx0Y29uc3QgbGlnaHRpbmdNb2RlbCA9IGJ1aWxkZXIuY29udGV4dC5saWdodGluZ01vZGVsO1xuXG5cdGNvbnN0IGxWZWN0b3IgPSBsaWdodFZpZXdQb3NpdGlvbi5zdWIoIHBvc2l0aW9uVmlldyApOyAvLyBAVE9ETzogQWRkIGl0IGludG8gTGlnaHROb2RlXG5cblx0Y29uc3QgbGlnaHREaXJlY3Rpb24gPSBsVmVjdG9yLm5vcm1hbGl6ZSgpO1xuXHRjb25zdCBsaWdodERpc3RhbmNlID0gbFZlY3Rvci5sZW5ndGgoKTtcblxuXHRjb25zdCBsaWdodEF0dGVudWF0aW9uID0gZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbigge1xuXHRcdGxpZ2h0RGlzdGFuY2UsXG5cdFx0Y3V0b2ZmRGlzdGFuY2UsXG5cdFx0ZGVjYXlFeHBvbmVudFxuXHR9ICk7XG5cblx0Y29uc3QgbGlnaHRDb2xvciA9IGNvbG9yLm11bCggbGlnaHRBdHRlbnVhdGlvbiApO1xuXG5cdGNvbnN0IHJlZmxlY3RlZExpZ2h0ID0gYnVpbGRlci5jb250ZXh0LnJlZmxlY3RlZExpZ2h0O1xuXG5cdGxpZ2h0aW5nTW9kZWwuZGlyZWN0KCB7XG5cdFx0bGlnaHREaXJlY3Rpb24sXG5cdFx0bGlnaHRDb2xvcixcblx0XHRyZWZsZWN0ZWRMaWdodFxuXHR9LCBidWlsZGVyLnN0YWNrLCBidWlsZGVyICk7XG5cbn0gKTtcblxuY2xhc3MgUG9pbnRMaWdodE5vZGUgZXh0ZW5kcyBBbmFseXRpY0xpZ2h0Tm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdQb2ludExpZ2h0Tm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBsaWdodCA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggbGlnaHQgKTtcblxuXHRcdHRoaXMuY3V0b2ZmRGlzdGFuY2VOb2RlID0gdW5pZm9ybSggMCApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xuXHRcdHRoaXMuZGVjYXlFeHBvbmVudE5vZGUgPSB1bmlmb3JtKCAwICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XG5cblx0fVxuXG5cdHVwZGF0ZSggZnJhbWUgKSB7XG5cblx0XHRjb25zdCB7IGxpZ2h0IH0gPSB0aGlzO1xuXG5cdFx0c3VwZXIudXBkYXRlKCBmcmFtZSApO1xuXG5cdFx0dGhpcy5jdXRvZmZEaXN0YW5jZU5vZGUudmFsdWUgPSBsaWdodC5kaXN0YW5jZTtcblx0XHR0aGlzLmRlY2F5RXhwb25lbnROb2RlLnZhbHVlID0gbGlnaHQuZGVjYXk7XG5cblx0fVxuXG5cdHNldHVwU2hhZG93Tm9kZSgpIHtcblxuXHRcdHJldHVybiBwb2ludFNoYWRvdyggdGhpcy5saWdodCApO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdHN1cGVyLnNldHVwKCBidWlsZGVyICk7XG5cblx0XHRkaXJlY3RQb2ludExpZ2h0KCB7XG5cdFx0XHRjb2xvcjogdGhpcy5jb2xvck5vZGUsXG5cdFx0XHRsaWdodFZpZXdQb3NpdGlvbjogbGlnaHRWaWV3UG9zaXRpb24oIHRoaXMubGlnaHQgKSxcblx0XHRcdGN1dG9mZkRpc3RhbmNlOiB0aGlzLmN1dG9mZkRpc3RhbmNlTm9kZSxcblx0XHRcdGRlY2F5RXhwb25lbnQ6IHRoaXMuZGVjYXlFeHBvbmVudE5vZGVcblx0XHR9ICkuYXBwZW5kKCk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvaW50TGlnaHROb2RlO1xuIiwiaW1wb3J0IHsgdXYgfSBmcm9tICcuLi9hY2Nlc3NvcnMvVVYuanMnO1xuaW1wb3J0IHsgRm4gfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBjaGVja2VyID0gLypAX19QVVJFX18qLyBGbiggKCBbIGNvb3JkID0gdXYoKSBdICkgPT4ge1xuXG5cdGNvbnN0IHV2ID0gY29vcmQubXVsKCAyLjAgKTtcblxuXHRjb25zdCBjeCA9IHV2LnguZmxvb3IoKTtcblx0Y29uc3QgY3kgPSB1di55LmZsb29yKCk7XG5cdGNvbnN0IHJlc3VsdCA9IGN4LmFkZCggY3kgKS5tb2QoIDIuMCApO1xuXG5cdHJldHVybiByZXN1bHQuc2lnbigpO1xuXG59ICk7XG4iLCIvLyBUaHJlZS5qcyBUcmFuc3BpbGVyXG4vLyBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vQWNhZGVteVNvZnR3YXJlRm91bmRhdGlvbi9NYXRlcmlhbFgvbWFpbi9saWJyYXJpZXMvc3RkbGliL2dlbmdsc2wvbGliL214X25vaXNlLmdsc2xcblxuaW1wb3J0IHsgaW50LCB1aW50LCBmbG9hdCwgdmVjMywgYm9vbCwgdXZlYzMsIHZlYzIsIHZlYzQsIElmLCBGbiB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJy4uLy4uL21hdGgvQ29uZGl0aW9uYWxOb2RlLmpzJztcbmltcG9ydCB7IHN1YiwgbXVsIH0gZnJvbSAnLi4vLi4vbWF0aC9PcGVyYXRvck5vZGUuanMnO1xuaW1wb3J0IHsgZmxvb3IsIGFicywgbWF4LCBkb3QsIG1pbiwgc3FydCB9IGZyb20gJy4uLy4uL21hdGgvTWF0aE5vZGUuanMnO1xuaW1wb3J0IHsgb3ZlcmxvYWRpbmdGbiB9IGZyb20gJy4uLy4uL3V0aWxzL0Z1bmN0aW9uT3ZlcmxvYWRpbmdOb2RlLmpzJztcbmltcG9ydCB7IExvb3AgfSBmcm9tICcuLi8uLi91dGlscy9Mb29wTm9kZS5qcyc7XG5cblxuZXhwb3J0IGNvbnN0IG14X3NlbGVjdCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBiX2ltbXV0YWJsZSwgdF9pbW11dGFibGUsIGZfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgZiA9IGZsb2F0KCBmX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHQgPSBmbG9hdCggdF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBiID0gYm9vbCggYl9pbW11dGFibGUgKS50b1ZhcigpO1xuXG5cdHJldHVybiBzZWxlY3QoIGIsIHQsIGYgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfc2VsZWN0Jyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnYicsIHR5cGU6ICdib29sJyB9LFxuXHRcdHsgbmFtZTogJ3QnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAnZicsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9uZWdhdGVfaWYgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdmFsX2ltbXV0YWJsZSwgYl9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCBiID0gYm9vbCggYl9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB2YWwgPSBmbG9hdCggdmFsX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIHNlbGVjdCggYiwgdmFsLm5lZ2F0ZSgpLCB2YWwgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfbmVnYXRlX2lmJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAndmFsJywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ2InLCB0eXBlOiAnYm9vbCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9mbG9vciA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB4X2ltbXV0YWJsZSBdICkgPT4ge1xuXG5cdGNvbnN0IHggPSBmbG9hdCggeF9pbW11dGFibGUgKS50b1ZhcigpO1xuXG5cdHJldHVybiBpbnQoIGZsb29yKCB4ICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfZmxvb3InLFxuXHR0eXBlOiAnaW50Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAneCcsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9mbG9vcmZyYWMgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgeF9pbW11dGFibGUsIGkgXSApID0+IHtcblxuXHRjb25zdCB4ID0gZmxvYXQoIHhfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0aS5hc3NpZ24oIG14X2Zsb29yKCB4ICkgKTtcblxuXHRyZXR1cm4geC5zdWIoIGZsb2F0KCBpICkgKTtcblxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfYmlsZXJwXzAgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdjBfaW1tdXRhYmxlLCB2MV9pbW11dGFibGUsIHYyX2ltbXV0YWJsZSwgdjNfaW1tdXRhYmxlLCBzX2ltbXV0YWJsZSwgdF9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCB0ID0gZmxvYXQoIHRfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgcyA9IGZsb2F0KCBzX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHYzID0gZmxvYXQoIHYzX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHYyID0gZmxvYXQoIHYyX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHYxID0gZmxvYXQoIHYxX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHYwID0gZmxvYXQoIHYwX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHMxID0gZmxvYXQoIHN1YiggMS4wLCBzICkgKS50b1ZhcigpO1xuXG5cdHJldHVybiBzdWIoIDEuMCwgdCApLm11bCggdjAubXVsKCBzMSApLmFkZCggdjEubXVsKCBzICkgKSApLmFkZCggdC5tdWwoIHYyLm11bCggczEgKS5hZGQoIHYzLm11bCggcyApICkgKSApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9iaWxlcnBfMCcsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3YwJywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ3YxJywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ3YyJywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ3YzJywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ3MnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAndCcsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9iaWxlcnBfMSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB2MF9pbW11dGFibGUsIHYxX2ltbXV0YWJsZSwgdjJfaW1tdXRhYmxlLCB2M19pbW11dGFibGUsIHNfaW1tdXRhYmxlLCB0X2ltbXV0YWJsZSBdICkgPT4ge1xuXG5cdGNvbnN0IHQgPSBmbG9hdCggdF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBzID0gZmxvYXQoIHNfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjMgPSB2ZWMzKCB2M19pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB2MiA9IHZlYzMoIHYyX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHYxID0gdmVjMyggdjFfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjAgPSB2ZWMzKCB2MF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBzMSA9IGZsb2F0KCBzdWIoIDEuMCwgcyApICkudG9WYXIoKTtcblxuXHRyZXR1cm4gc3ViKCAxLjAsIHQgKS5tdWwoIHYwLm11bCggczEgKS5hZGQoIHYxLm11bCggcyApICkgKS5hZGQoIHQubXVsKCB2Mi5tdWwoIHMxICkuYWRkKCB2My5tdWwoIHMgKSApICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfYmlsZXJwXzEnLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3YwJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAndjEnLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICd2MicsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ3YzJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAncycsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICd0JywgdHlwZTogJ2Zsb2F0JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X2JpbGVycCA9IC8qQF9fUFVSRV9fKi8gb3ZlcmxvYWRpbmdGbiggWyBteF9iaWxlcnBfMCwgbXhfYmlsZXJwXzEgXSApO1xuXG5leHBvcnQgY29uc3QgbXhfdHJpbGVycF8wID0gLypAX19QVVJFX18qLyBGbiggKCBbIHYwX2ltbXV0YWJsZSwgdjFfaW1tdXRhYmxlLCB2Ml9pbW11dGFibGUsIHYzX2ltbXV0YWJsZSwgdjRfaW1tdXRhYmxlLCB2NV9pbW11dGFibGUsIHY2X2ltbXV0YWJsZSwgdjdfaW1tdXRhYmxlLCBzX2ltbXV0YWJsZSwgdF9pbW11dGFibGUsIHJfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgciA9IGZsb2F0KCByX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHQgPSBmbG9hdCggdF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBzID0gZmxvYXQoIHNfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjcgPSBmbG9hdCggdjdfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjYgPSBmbG9hdCggdjZfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjUgPSBmbG9hdCggdjVfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjQgPSBmbG9hdCggdjRfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjMgPSBmbG9hdCggdjNfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjIgPSBmbG9hdCggdjJfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjEgPSBmbG9hdCggdjFfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjAgPSBmbG9hdCggdjBfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgczEgPSBmbG9hdCggc3ViKCAxLjAsIHMgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHQxID0gZmxvYXQoIHN1YiggMS4wLCB0ICkgKS50b1ZhcigpO1xuXHRjb25zdCByMSA9IGZsb2F0KCBzdWIoIDEuMCwgciApICkudG9WYXIoKTtcblxuXHRyZXR1cm4gcjEubXVsKCB0MS5tdWwoIHYwLm11bCggczEgKS5hZGQoIHYxLm11bCggcyApICkgKS5hZGQoIHQubXVsKCB2Mi5tdWwoIHMxICkuYWRkKCB2My5tdWwoIHMgKSApICkgKSApLmFkZCggci5tdWwoIHQxLm11bCggdjQubXVsKCBzMSApLmFkZCggdjUubXVsKCBzICkgKSApLmFkZCggdC5tdWwoIHY2Lm11bCggczEgKS5hZGQoIHY3Lm11bCggcyApICkgKSApICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfdHJpbGVycF8wJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAndjAnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAndjEnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAndjInLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAndjMnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAndjQnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAndjUnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAndjYnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAndjcnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAncycsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICd0JywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ3InLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfdHJpbGVycF8xID0gLypAX19QVVJFX18qLyBGbiggKCBbIHYwX2ltbXV0YWJsZSwgdjFfaW1tdXRhYmxlLCB2Ml9pbW11dGFibGUsIHYzX2ltbXV0YWJsZSwgdjRfaW1tdXRhYmxlLCB2NV9pbW11dGFibGUsIHY2X2ltbXV0YWJsZSwgdjdfaW1tdXRhYmxlLCBzX2ltbXV0YWJsZSwgdF9pbW11dGFibGUsIHJfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgciA9IGZsb2F0KCByX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHQgPSBmbG9hdCggdF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBzID0gZmxvYXQoIHNfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjcgPSB2ZWMzKCB2N19pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB2NiA9IHZlYzMoIHY2X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHY1ID0gdmVjMyggdjVfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjQgPSB2ZWMzKCB2NF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB2MyA9IHZlYzMoIHYzX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHYyID0gdmVjMyggdjJfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdjEgPSB2ZWMzKCB2MV9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB2MCA9IHZlYzMoIHYwX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHMxID0gZmxvYXQoIHN1YiggMS4wLCBzICkgKS50b1ZhcigpO1xuXHRjb25zdCB0MSA9IGZsb2F0KCBzdWIoIDEuMCwgdCApICkudG9WYXIoKTtcblx0Y29uc3QgcjEgPSBmbG9hdCggc3ViKCAxLjAsIHIgKSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIHIxLm11bCggdDEubXVsKCB2MC5tdWwoIHMxICkuYWRkKCB2MS5tdWwoIHMgKSApICkuYWRkKCB0Lm11bCggdjIubXVsKCBzMSApLmFkZCggdjMubXVsKCBzICkgKSApICkgKS5hZGQoIHIubXVsKCB0MS5tdWwoIHY0Lm11bCggczEgKS5hZGQoIHY1Lm11bCggcyApICkgKS5hZGQoIHQubXVsKCB2Ni5tdWwoIHMxICkuYWRkKCB2Ny5tdWwoIHMgKSApICkgKSApICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X3RyaWxlcnBfMScsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAndjAnLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICd2MScsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ3YyJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAndjMnLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICd2NCcsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ3Y1JywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAndjYnLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICd2NycsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ3MnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAndCcsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICdyJywgdHlwZTogJ2Zsb2F0JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X3RyaWxlcnAgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfdHJpbGVycF8wLCBteF90cmlsZXJwXzEgXSApO1xuXG5leHBvcnQgY29uc3QgbXhfZ3JhZGllbnRfZmxvYXRfMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBoYXNoX2ltbXV0YWJsZSwgeF9pbW11dGFibGUsIHlfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgeSA9IGZsb2F0KCB5X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHggPSBmbG9hdCggeF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBoYXNoID0gdWludCggaGFzaF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBoID0gdWludCggaGFzaC5iaXRBbmQoIHVpbnQoIDcgKSApICkudG9WYXIoKTtcblx0Y29uc3QgdSA9IGZsb2F0KCBteF9zZWxlY3QoIGgubGVzc1RoYW4oIHVpbnQoIDQgKSApLCB4LCB5ICkgKS50b1ZhcigpO1xuXHRjb25zdCB2ID0gZmxvYXQoIG11bCggMi4wLCBteF9zZWxlY3QoIGgubGVzc1RoYW4oIHVpbnQoIDQgKSApLCB5LCB4ICkgKSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIG14X25lZ2F0ZV9pZiggdSwgYm9vbCggaC5iaXRBbmQoIHVpbnQoIDEgKSApICkgKS5hZGQoIG14X25lZ2F0ZV9pZiggdiwgYm9vbCggaC5iaXRBbmQoIHVpbnQoIDIgKSApICkgKSApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9ncmFkaWVudF9mbG9hdF8wJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnaGFzaCcsIHR5cGU6ICd1aW50JyB9LFxuXHRcdHsgbmFtZTogJ3gnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAneScsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9ncmFkaWVudF9mbG9hdF8xID0gLypAX19QVVJFX18qLyBGbiggKCBbIGhhc2hfaW1tdXRhYmxlLCB4X2ltbXV0YWJsZSwgeV9pbW11dGFibGUsIHpfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgeiA9IGZsb2F0KCB6X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHkgPSBmbG9hdCggeV9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB4ID0gZmxvYXQoIHhfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgaGFzaCA9IHVpbnQoIGhhc2hfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgaCA9IHVpbnQoIGhhc2guYml0QW5kKCB1aW50KCAxNSApICkgKS50b1ZhcigpO1xuXHRjb25zdCB1ID0gZmxvYXQoIG14X3NlbGVjdCggaC5sZXNzVGhhbiggdWludCggOCApICksIHgsIHkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHYgPSBmbG9hdCggbXhfc2VsZWN0KCBoLmxlc3NUaGFuKCB1aW50KCA0ICkgKSwgeSwgbXhfc2VsZWN0KCBoLmVxdWFsKCB1aW50KCAxMiApICkub3IoIGguZXF1YWwoIHVpbnQoIDE0ICkgKSApLCB4LCB6ICkgKSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIG14X25lZ2F0ZV9pZiggdSwgYm9vbCggaC5iaXRBbmQoIHVpbnQoIDEgKSApICkgKS5hZGQoIG14X25lZ2F0ZV9pZiggdiwgYm9vbCggaC5iaXRBbmQoIHVpbnQoIDIgKSApICkgKSApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9ncmFkaWVudF9mbG9hdF8xJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnaGFzaCcsIHR5cGU6ICd1aW50JyB9LFxuXHRcdHsgbmFtZTogJ3gnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAneScsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICd6JywgdHlwZTogJ2Zsb2F0JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X2dyYWRpZW50X2Zsb2F0ID0gLypAX19QVVJFX18qLyBvdmVybG9hZGluZ0ZuKCBbIG14X2dyYWRpZW50X2Zsb2F0XzAsIG14X2dyYWRpZW50X2Zsb2F0XzEgXSApO1xuXG5leHBvcnQgY29uc3QgbXhfZ3JhZGllbnRfdmVjM18wID0gLypAX19QVVJFX18qLyBGbiggKCBbIGhhc2hfaW1tdXRhYmxlLCB4X2ltbXV0YWJsZSwgeV9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCB5ID0gZmxvYXQoIHlfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgeCA9IGZsb2F0KCB4X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IGhhc2ggPSB1dmVjMyggaGFzaF9pbW11dGFibGUgKS50b1ZhcigpO1xuXG5cdHJldHVybiB2ZWMzKCBteF9ncmFkaWVudF9mbG9hdCggaGFzaC54LCB4LCB5ICksIG14X2dyYWRpZW50X2Zsb2F0KCBoYXNoLnksIHgsIHkgKSwgbXhfZ3JhZGllbnRfZmxvYXQoIGhhc2gueiwgeCwgeSApICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X2dyYWRpZW50X3ZlYzNfMCcsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnaGFzaCcsIHR5cGU6ICd1dmVjMycgfSxcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ3knLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfZ3JhZGllbnRfdmVjM18xID0gLypAX19QVVJFX18qLyBGbiggKCBbIGhhc2hfaW1tdXRhYmxlLCB4X2ltbXV0YWJsZSwgeV9pbW11dGFibGUsIHpfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgeiA9IGZsb2F0KCB6X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHkgPSBmbG9hdCggeV9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB4ID0gZmxvYXQoIHhfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgaGFzaCA9IHV2ZWMzKCBoYXNoX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIHZlYzMoIG14X2dyYWRpZW50X2Zsb2F0KCBoYXNoLngsIHgsIHksIHogKSwgbXhfZ3JhZGllbnRfZmxvYXQoIGhhc2gueSwgeCwgeSwgeiApLCBteF9ncmFkaWVudF9mbG9hdCggaGFzaC56LCB4LCB5LCB6ICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfZ3JhZGllbnRfdmVjM18xJyxcblx0dHlwZTogJ3ZlYzMnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdoYXNoJywgdHlwZTogJ3V2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ3gnLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAneScsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICd6JywgdHlwZTogJ2Zsb2F0JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X2dyYWRpZW50X3ZlYzMgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfZ3JhZGllbnRfdmVjM18wLCBteF9ncmFkaWVudF92ZWMzXzEgXSApO1xuXG5leHBvcnQgY29uc3QgbXhfZ3JhZGllbnRfc2NhbGUyZF8wID0gLypAX19QVVJFX18qLyBGbiggKCBbIHZfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgdiA9IGZsb2F0KCB2X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIG11bCggMC42NjE2LCB2ICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X2dyYWRpZW50X3NjYWxlMmRfMCcsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3YnLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfZ3JhZGllbnRfc2NhbGUzZF8wID0gLypAX19QVVJFX18qLyBGbiggKCBbIHZfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgdiA9IGZsb2F0KCB2X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIG11bCggMC45ODIwLCB2ICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X2dyYWRpZW50X3NjYWxlM2RfMCcsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3YnLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfZ3JhZGllbnRfc2NhbGUyZF8xID0gLypAX19QVVJFX18qLyBGbiggKCBbIHZfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgdiA9IHZlYzMoIHZfaW1tdXRhYmxlICkudG9WYXIoKTtcblxuXHRyZXR1cm4gbXVsKCAwLjY2MTYsIHYgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfZ3JhZGllbnRfc2NhbGUyZF8xJyxcblx0dHlwZTogJ3ZlYzMnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICd2JywgdHlwZTogJ3ZlYzMnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfZ3JhZGllbnRfc2NhbGUyZCA9IC8qQF9fUFVSRV9fKi8gb3ZlcmxvYWRpbmdGbiggWyBteF9ncmFkaWVudF9zY2FsZTJkXzAsIG14X2dyYWRpZW50X3NjYWxlMmRfMSBdICk7XG5cbmV4cG9ydCBjb25zdCBteF9ncmFkaWVudF9zY2FsZTNkXzEgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdl9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCB2ID0gdmVjMyggdl9pbW11dGFibGUgKS50b1ZhcigpO1xuXG5cdHJldHVybiBtdWwoIDAuOTgyMCwgdiApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9ncmFkaWVudF9zY2FsZTNkXzEnLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3YnLCB0eXBlOiAndmVjMycgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9ncmFkaWVudF9zY2FsZTNkID0gLypAX19QVVJFX18qLyBvdmVybG9hZGluZ0ZuKCBbIG14X2dyYWRpZW50X3NjYWxlM2RfMCwgbXhfZ3JhZGllbnRfc2NhbGUzZF8xIF0gKTtcblxuZXhwb3J0IGNvbnN0IG14X3JvdGwzMiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB4X2ltbXV0YWJsZSwga19pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCBrID0gaW50KCBrX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHggPSB1aW50KCB4X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIHguc2hpZnRMZWZ0KCBrICkuYml0T3IoIHguc2hpZnRSaWdodCggaW50KCAzMiApLnN1YiggayApICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfcm90bDMyJyxcblx0dHlwZTogJ3VpbnQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ3VpbnQnIH0sXG5cdFx0eyBuYW1lOiAnaycsIHR5cGU6ICdpbnQnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfYmptaXggPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgYSwgYiwgYyBdICkgPT4ge1xuXG5cdGEuc3ViQXNzaWduKCBjICk7XG5cdGEuYml0WG9yQXNzaWduKCBteF9yb3RsMzIoIGMsIGludCggNCApICkgKTtcblx0Yy5hZGRBc3NpZ24oIGIgKTtcblx0Yi5zdWJBc3NpZ24oIGEgKTtcblx0Yi5iaXRYb3JBc3NpZ24oIG14X3JvdGwzMiggYSwgaW50KCA2ICkgKSApO1xuXHRhLmFkZEFzc2lnbiggYyApO1xuXHRjLnN1YkFzc2lnbiggYiApO1xuXHRjLmJpdFhvckFzc2lnbiggbXhfcm90bDMyKCBiLCBpbnQoIDggKSApICk7XG5cdGIuYWRkQXNzaWduKCBhICk7XG5cdGEuc3ViQXNzaWduKCBjICk7XG5cdGEuYml0WG9yQXNzaWduKCBteF9yb3RsMzIoIGMsIGludCggMTYgKSApICk7XG5cdGMuYWRkQXNzaWduKCBiICk7XG5cdGIuc3ViQXNzaWduKCBhICk7XG5cdGIuYml0WG9yQXNzaWduKCBteF9yb3RsMzIoIGEsIGludCggMTkgKSApICk7XG5cdGEuYWRkQXNzaWduKCBjICk7XG5cdGMuc3ViQXNzaWduKCBiICk7XG5cdGMuYml0WG9yQXNzaWduKCBteF9yb3RsMzIoIGIsIGludCggNCApICkgKTtcblx0Yi5hZGRBc3NpZ24oIGEgKTtcblxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfYmpmaW5hbCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBhX2ltbXV0YWJsZSwgYl9pbW11dGFibGUsIGNfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgYyA9IHVpbnQoIGNfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgYiA9IHVpbnQoIGJfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgYSA9IHVpbnQoIGFfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Yy5iaXRYb3JBc3NpZ24oIGIgKTtcblx0Yy5zdWJBc3NpZ24oIG14X3JvdGwzMiggYiwgaW50KCAxNCApICkgKTtcblx0YS5iaXRYb3JBc3NpZ24oIGMgKTtcblx0YS5zdWJBc3NpZ24oIG14X3JvdGwzMiggYywgaW50KCAxMSApICkgKTtcblx0Yi5iaXRYb3JBc3NpZ24oIGEgKTtcblx0Yi5zdWJBc3NpZ24oIG14X3JvdGwzMiggYSwgaW50KCAyNSApICkgKTtcblx0Yy5iaXRYb3JBc3NpZ24oIGIgKTtcblx0Yy5zdWJBc3NpZ24oIG14X3JvdGwzMiggYiwgaW50KCAxNiApICkgKTtcblx0YS5iaXRYb3JBc3NpZ24oIGMgKTtcblx0YS5zdWJBc3NpZ24oIG14X3JvdGwzMiggYywgaW50KCA0ICkgKSApO1xuXHRiLmJpdFhvckFzc2lnbiggYSApO1xuXHRiLnN1YkFzc2lnbiggbXhfcm90bDMyKCBhLCBpbnQoIDE0ICkgKSApO1xuXHRjLmJpdFhvckFzc2lnbiggYiApO1xuXHRjLnN1YkFzc2lnbiggbXhfcm90bDMyKCBiLCBpbnQoIDI0ICkgKSApO1xuXG5cdHJldHVybiBjO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9iamZpbmFsJyxcblx0dHlwZTogJ3VpbnQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdhJywgdHlwZTogJ3VpbnQnIH0sXG5cdFx0eyBuYW1lOiAnYicsIHR5cGU6ICd1aW50JyB9LFxuXHRcdHsgbmFtZTogJ2MnLCB0eXBlOiAndWludCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9iaXRzX3RvXzAxID0gLypAX19QVVJFX18qLyBGbiggKCBbIGJpdHNfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgYml0cyA9IHVpbnQoIGJpdHNfaW1tdXRhYmxlICkudG9WYXIoKTtcblxuXHRyZXR1cm4gZmxvYXQoIGJpdHMgKS5kaXYoIGZsb2F0KCB1aW50KCBpbnQoIDB4ZmZmZmZmZmYgKSApICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfYml0c190b18wMScsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ2JpdHMnLCB0eXBlOiAndWludCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9mYWRlID0gLypAX19QVVJFX18qLyBGbiggKCBbIHRfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgdCA9IGZsb2F0KCB0X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIHQubXVsKCB0ICkubXVsKCB0ICkubXVsKCB0Lm11bCggdC5tdWwoIDYuMCApLnN1YiggMTUuMCApICkuYWRkKCAxMC4wICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfZmFkZScsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3QnLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfaGFzaF9pbnRfMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB4X2ltbXV0YWJsZSBdICkgPT4ge1xuXG5cdGNvbnN0IHggPSBpbnQoIHhfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgbGVuID0gdWludCggdWludCggMSApICkudG9WYXIoKTtcblx0Y29uc3Qgc2VlZCA9IHVpbnQoIHVpbnQoIGludCggMHhkZWFkYmVlZiApICkuYWRkKCBsZW4uc2hpZnRMZWZ0KCB1aW50KCAyICkgKSApLmFkZCggdWludCggMTMgKSApICkudG9WYXIoKTtcblxuXHRyZXR1cm4gbXhfYmpmaW5hbCggc2VlZC5hZGQoIHVpbnQoIHggKSApLCBzZWVkLCBzZWVkICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X2hhc2hfaW50XzAnLFxuXHR0eXBlOiAndWludCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3gnLCB0eXBlOiAnaW50JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X2hhc2hfaW50XzEgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgeF9pbW11dGFibGUsIHlfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgeSA9IGludCggeV9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB4ID0gaW50KCB4X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IGxlbiA9IHVpbnQoIHVpbnQoIDIgKSApLnRvVmFyKCk7XG5cdGNvbnN0IGEgPSB1aW50KCkudG9WYXIoKSwgYiA9IHVpbnQoKS50b1ZhcigpLCBjID0gdWludCgpLnRvVmFyKCk7XG5cdGEuYXNzaWduKCBiLmFzc2lnbiggYy5hc3NpZ24oIHVpbnQoIGludCggMHhkZWFkYmVlZiApICkuYWRkKCBsZW4uc2hpZnRMZWZ0KCB1aW50KCAyICkgKSApLmFkZCggdWludCggMTMgKSApICkgKSApO1xuXHRhLmFkZEFzc2lnbiggdWludCggeCApICk7XG5cdGIuYWRkQXNzaWduKCB1aW50KCB5ICkgKTtcblxuXHRyZXR1cm4gbXhfYmpmaW5hbCggYSwgYiwgYyApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9oYXNoX2ludF8xJyxcblx0dHlwZTogJ3VpbnQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ2ludCcgfSxcblx0XHR7IG5hbWU6ICd5JywgdHlwZTogJ2ludCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9oYXNoX2ludF8yID0gLypAX19QVVJFX18qLyBGbiggKCBbIHhfaW1tdXRhYmxlLCB5X2ltbXV0YWJsZSwgel9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCB6ID0gaW50KCB6X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHkgPSBpbnQoIHlfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgeCA9IGludCggeF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBsZW4gPSB1aW50KCB1aW50KCAzICkgKS50b1ZhcigpO1xuXHRjb25zdCBhID0gdWludCgpLnRvVmFyKCksIGIgPSB1aW50KCkudG9WYXIoKSwgYyA9IHVpbnQoKS50b1ZhcigpO1xuXHRhLmFzc2lnbiggYi5hc3NpZ24oIGMuYXNzaWduKCB1aW50KCBpbnQoIDB4ZGVhZGJlZWYgKSApLmFkZCggbGVuLnNoaWZ0TGVmdCggdWludCggMiApICkgKS5hZGQoIHVpbnQoIDEzICkgKSApICkgKTtcblx0YS5hZGRBc3NpZ24oIHVpbnQoIHggKSApO1xuXHRiLmFkZEFzc2lnbiggdWludCggeSApICk7XG5cdGMuYWRkQXNzaWduKCB1aW50KCB6ICkgKTtcblxuXHRyZXR1cm4gbXhfYmpmaW5hbCggYSwgYiwgYyApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9oYXNoX2ludF8yJyxcblx0dHlwZTogJ3VpbnQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ2ludCcgfSxcblx0XHR7IG5hbWU6ICd5JywgdHlwZTogJ2ludCcgfSxcblx0XHR7IG5hbWU6ICd6JywgdHlwZTogJ2ludCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9oYXNoX2ludF8zID0gLypAX19QVVJFX18qLyBGbiggKCBbIHhfaW1tdXRhYmxlLCB5X2ltbXV0YWJsZSwgel9pbW11dGFibGUsIHh4X2ltbXV0YWJsZSBdICkgPT4ge1xuXG5cdGNvbnN0IHh4ID0gaW50KCB4eF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB6ID0gaW50KCB6X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHkgPSBpbnQoIHlfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgeCA9IGludCggeF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBsZW4gPSB1aW50KCB1aW50KCA0ICkgKS50b1ZhcigpO1xuXHRjb25zdCBhID0gdWludCgpLnRvVmFyKCksIGIgPSB1aW50KCkudG9WYXIoKSwgYyA9IHVpbnQoKS50b1ZhcigpO1xuXHRhLmFzc2lnbiggYi5hc3NpZ24oIGMuYXNzaWduKCB1aW50KCBpbnQoIDB4ZGVhZGJlZWYgKSApLmFkZCggbGVuLnNoaWZ0TGVmdCggdWludCggMiApICkgKS5hZGQoIHVpbnQoIDEzICkgKSApICkgKTtcblx0YS5hZGRBc3NpZ24oIHVpbnQoIHggKSApO1xuXHRiLmFkZEFzc2lnbiggdWludCggeSApICk7XG5cdGMuYWRkQXNzaWduKCB1aW50KCB6ICkgKTtcblx0bXhfYmptaXgoIGEsIGIsIGMgKTtcblx0YS5hZGRBc3NpZ24oIHVpbnQoIHh4ICkgKTtcblxuXHRyZXR1cm4gbXhfYmpmaW5hbCggYSwgYiwgYyApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9oYXNoX2ludF8zJyxcblx0dHlwZTogJ3VpbnQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ2ludCcgfSxcblx0XHR7IG5hbWU6ICd5JywgdHlwZTogJ2ludCcgfSxcblx0XHR7IG5hbWU6ICd6JywgdHlwZTogJ2ludCcgfSxcblx0XHR7IG5hbWU6ICd4eCcsIHR5cGU6ICdpbnQnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfaGFzaF9pbnRfNCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB4X2ltbXV0YWJsZSwgeV9pbW11dGFibGUsIHpfaW1tdXRhYmxlLCB4eF9pbW11dGFibGUsIHl5X2ltbXV0YWJsZSBdICkgPT4ge1xuXG5cdGNvbnN0IHl5ID0gaW50KCB5eV9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB4eCA9IGludCggeHhfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgeiA9IGludCggel9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB5ID0gaW50KCB5X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHggPSBpbnQoIHhfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgbGVuID0gdWludCggdWludCggNSApICkudG9WYXIoKTtcblx0Y29uc3QgYSA9IHVpbnQoKS50b1ZhcigpLCBiID0gdWludCgpLnRvVmFyKCksIGMgPSB1aW50KCkudG9WYXIoKTtcblx0YS5hc3NpZ24oIGIuYXNzaWduKCBjLmFzc2lnbiggdWludCggaW50KCAweGRlYWRiZWVmICkgKS5hZGQoIGxlbi5zaGlmdExlZnQoIHVpbnQoIDIgKSApICkuYWRkKCB1aW50KCAxMyApICkgKSApICk7XG5cdGEuYWRkQXNzaWduKCB1aW50KCB4ICkgKTtcblx0Yi5hZGRBc3NpZ24oIHVpbnQoIHkgKSApO1xuXHRjLmFkZEFzc2lnbiggdWludCggeiApICk7XG5cdG14X2JqbWl4KCBhLCBiLCBjICk7XG5cdGEuYWRkQXNzaWduKCB1aW50KCB4eCApICk7XG5cdGIuYWRkQXNzaWduKCB1aW50KCB5eSApICk7XG5cblx0cmV0dXJuIG14X2JqZmluYWwoIGEsIGIsIGMgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfaGFzaF9pbnRfNCcsXG5cdHR5cGU6ICd1aW50Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAneCcsIHR5cGU6ICdpbnQnIH0sXG5cdFx0eyBuYW1lOiAneScsIHR5cGU6ICdpbnQnIH0sXG5cdFx0eyBuYW1lOiAneicsIHR5cGU6ICdpbnQnIH0sXG5cdFx0eyBuYW1lOiAneHgnLCB0eXBlOiAnaW50JyB9LFxuXHRcdHsgbmFtZTogJ3l5JywgdHlwZTogJ2ludCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9oYXNoX2ludCA9IC8qQF9fUFVSRV9fKi8gb3ZlcmxvYWRpbmdGbiggWyBteF9oYXNoX2ludF8wLCBteF9oYXNoX2ludF8xLCBteF9oYXNoX2ludF8yLCBteF9oYXNoX2ludF8zLCBteF9oYXNoX2ludF80IF0gKTtcblxuZXhwb3J0IGNvbnN0IG14X2hhc2hfdmVjM18wID0gLypAX19QVVJFX18qLyBGbiggKCBbIHhfaW1tdXRhYmxlLCB5X2ltbXV0YWJsZSBdICkgPT4ge1xuXG5cdGNvbnN0IHkgPSBpbnQoIHlfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgeCA9IGludCggeF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBoID0gdWludCggbXhfaGFzaF9pbnQoIHgsIHkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHJlc3VsdCA9IHV2ZWMzKCkudG9WYXIoKTtcblx0cmVzdWx0LnguYXNzaWduKCBoLmJpdEFuZCggaW50KCAweEZGICkgKSApO1xuXHRyZXN1bHQueS5hc3NpZ24oIGguc2hpZnRSaWdodCggaW50KCA4ICkgKS5iaXRBbmQoIGludCggMHhGRiApICkgKTtcblx0cmVzdWx0LnouYXNzaWduKCBoLnNoaWZ0UmlnaHQoIGludCggMTYgKSApLmJpdEFuZCggaW50KCAweEZGICkgKSApO1xuXG5cdHJldHVybiByZXN1bHQ7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X2hhc2hfdmVjM18wJyxcblx0dHlwZTogJ3V2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAneCcsIHR5cGU6ICdpbnQnIH0sXG5cdFx0eyBuYW1lOiAneScsIHR5cGU6ICdpbnQnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfaGFzaF92ZWMzXzEgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgeF9pbW11dGFibGUsIHlfaW1tdXRhYmxlLCB6X2ltbXV0YWJsZSBdICkgPT4ge1xuXG5cdGNvbnN0IHogPSBpbnQoIHpfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgeSA9IGludCggeV9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB4ID0gaW50KCB4X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IGggPSB1aW50KCBteF9oYXNoX2ludCggeCwgeSwgeiApICkudG9WYXIoKTtcblx0Y29uc3QgcmVzdWx0ID0gdXZlYzMoKS50b1ZhcigpO1xuXHRyZXN1bHQueC5hc3NpZ24oIGguYml0QW5kKCBpbnQoIDB4RkYgKSApICk7XG5cdHJlc3VsdC55LmFzc2lnbiggaC5zaGlmdFJpZ2h0KCBpbnQoIDggKSApLmJpdEFuZCggaW50KCAweEZGICkgKSApO1xuXHRyZXN1bHQuei5hc3NpZ24oIGguc2hpZnRSaWdodCggaW50KCAxNiApICkuYml0QW5kKCBpbnQoIDB4RkYgKSApICk7XG5cblx0cmV0dXJuIHJlc3VsdDtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfaGFzaF92ZWMzXzEnLFxuXHR0eXBlOiAndXZlYzMnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ2ludCcgfSxcblx0XHR7IG5hbWU6ICd5JywgdHlwZTogJ2ludCcgfSxcblx0XHR7IG5hbWU6ICd6JywgdHlwZTogJ2ludCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9oYXNoX3ZlYzMgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfaGFzaF92ZWMzXzAsIG14X2hhc2hfdmVjM18xIF0gKTtcblxuZXhwb3J0IGNvbnN0IG14X3Blcmxpbl9ub2lzZV9mbG9hdF8wID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgcCA9IHZlYzIoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgWCA9IGludCgpLnRvVmFyKCksIFkgPSBpbnQoKS50b1ZhcigpO1xuXHRjb25zdCBmeCA9IGZsb2F0KCBteF9mbG9vcmZyYWMoIHAueCwgWCApICkudG9WYXIoKTtcblx0Y29uc3QgZnkgPSBmbG9hdCggbXhfZmxvb3JmcmFjKCBwLnksIFkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHUgPSBmbG9hdCggbXhfZmFkZSggZnggKSApLnRvVmFyKCk7XG5cdGNvbnN0IHYgPSBmbG9hdCggbXhfZmFkZSggZnkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHJlc3VsdCA9IGZsb2F0KCBteF9iaWxlcnAoIG14X2dyYWRpZW50X2Zsb2F0KCBteF9oYXNoX2ludCggWCwgWSApLCBmeCwgZnkgKSwgbXhfZ3JhZGllbnRfZmxvYXQoIG14X2hhc2hfaW50KCBYLmFkZCggaW50KCAxICkgKSwgWSApLCBmeC5zdWIoIDEuMCApLCBmeSApLCBteF9ncmFkaWVudF9mbG9hdCggbXhfaGFzaF9pbnQoIFgsIFkuYWRkKCBpbnQoIDEgKSApICksIGZ4LCBmeS5zdWIoIDEuMCApICksIG14X2dyYWRpZW50X2Zsb2F0KCBteF9oYXNoX2ludCggWC5hZGQoIGludCggMSApICksIFkuYWRkKCBpbnQoIDEgKSApICksIGZ4LnN1YiggMS4wICksIGZ5LnN1YiggMS4wICkgKSwgdSwgdiApICkudG9WYXIoKTtcblxuXHRyZXR1cm4gbXhfZ3JhZGllbnRfc2NhbGUyZCggcmVzdWx0ICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X3Blcmxpbl9ub2lzZV9mbG9hdF8wJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMyJyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X3Blcmxpbl9ub2lzZV9mbG9hdF8xID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgcCA9IHZlYzMoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgWCA9IGludCgpLnRvVmFyKCksIFkgPSBpbnQoKS50b1ZhcigpLCBaID0gaW50KCkudG9WYXIoKTtcblx0Y29uc3QgZnggPSBmbG9hdCggbXhfZmxvb3JmcmFjKCBwLngsIFggKSApLnRvVmFyKCk7XG5cdGNvbnN0IGZ5ID0gZmxvYXQoIG14X2Zsb29yZnJhYyggcC55LCBZICkgKS50b1ZhcigpO1xuXHRjb25zdCBmeiA9IGZsb2F0KCBteF9mbG9vcmZyYWMoIHAueiwgWiApICkudG9WYXIoKTtcblx0Y29uc3QgdSA9IGZsb2F0KCBteF9mYWRlKCBmeCApICkudG9WYXIoKTtcblx0Y29uc3QgdiA9IGZsb2F0KCBteF9mYWRlKCBmeSApICkudG9WYXIoKTtcblx0Y29uc3QgdyA9IGZsb2F0KCBteF9mYWRlKCBmeiApICkudG9WYXIoKTtcblx0Y29uc3QgcmVzdWx0ID0gZmxvYXQoIG14X3RyaWxlcnAoIG14X2dyYWRpZW50X2Zsb2F0KCBteF9oYXNoX2ludCggWCwgWSwgWiApLCBmeCwgZnksIGZ6ICksIG14X2dyYWRpZW50X2Zsb2F0KCBteF9oYXNoX2ludCggWC5hZGQoIGludCggMSApICksIFksIFogKSwgZnguc3ViKCAxLjAgKSwgZnksIGZ6ICksIG14X2dyYWRpZW50X2Zsb2F0KCBteF9oYXNoX2ludCggWCwgWS5hZGQoIGludCggMSApICksIFogKSwgZngsIGZ5LnN1YiggMS4wICksIGZ6ICksIG14X2dyYWRpZW50X2Zsb2F0KCBteF9oYXNoX2ludCggWC5hZGQoIGludCggMSApICksIFkuYWRkKCBpbnQoIDEgKSApLCBaICksIGZ4LnN1YiggMS4wICksIGZ5LnN1YiggMS4wICksIGZ6ICksIG14X2dyYWRpZW50X2Zsb2F0KCBteF9oYXNoX2ludCggWCwgWSwgWi5hZGQoIGludCggMSApICkgKSwgZngsIGZ5LCBmei5zdWIoIDEuMCApICksIG14X2dyYWRpZW50X2Zsb2F0KCBteF9oYXNoX2ludCggWC5hZGQoIGludCggMSApICksIFksIFouYWRkKCBpbnQoIDEgKSApICksIGZ4LnN1YiggMS4wICksIGZ5LCBmei5zdWIoIDEuMCApICksIG14X2dyYWRpZW50X2Zsb2F0KCBteF9oYXNoX2ludCggWCwgWS5hZGQoIGludCggMSApICksIFouYWRkKCBpbnQoIDEgKSApICksIGZ4LCBmeS5zdWIoIDEuMCApLCBmei5zdWIoIDEuMCApICksIG14X2dyYWRpZW50X2Zsb2F0KCBteF9oYXNoX2ludCggWC5hZGQoIGludCggMSApICksIFkuYWRkKCBpbnQoIDEgKSApLCBaLmFkZCggaW50KCAxICkgKSApLCBmeC5zdWIoIDEuMCApLCBmeS5zdWIoIDEuMCApLCBmei5zdWIoIDEuMCApICksIHUsIHYsIHcgKSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIG14X2dyYWRpZW50X3NjYWxlM2QoIHJlc3VsdCApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9wZXJsaW5fbm9pc2VfZmxvYXRfMScsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjMycgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9wZXJsaW5fbm9pc2VfZmxvYXQgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfcGVybGluX25vaXNlX2Zsb2F0XzAsIG14X3Blcmxpbl9ub2lzZV9mbG9hdF8xIF0gKTtcblxuZXhwb3J0IGNvbnN0IG14X3Blcmxpbl9ub2lzZV92ZWMzXzAgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCBwID0gdmVjMiggcF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBYID0gaW50KCkudG9WYXIoKSwgWSA9IGludCgpLnRvVmFyKCk7XG5cdGNvbnN0IGZ4ID0gZmxvYXQoIG14X2Zsb29yZnJhYyggcC54LCBYICkgKS50b1ZhcigpO1xuXHRjb25zdCBmeSA9IGZsb2F0KCBteF9mbG9vcmZyYWMoIHAueSwgWSApICkudG9WYXIoKTtcblx0Y29uc3QgdSA9IGZsb2F0KCBteF9mYWRlKCBmeCApICkudG9WYXIoKTtcblx0Y29uc3QgdiA9IGZsb2F0KCBteF9mYWRlKCBmeSApICkudG9WYXIoKTtcblx0Y29uc3QgcmVzdWx0ID0gdmVjMyggbXhfYmlsZXJwKCBteF9ncmFkaWVudF92ZWMzKCBteF9oYXNoX3ZlYzMoIFgsIFkgKSwgZngsIGZ5ICksIG14X2dyYWRpZW50X3ZlYzMoIG14X2hhc2hfdmVjMyggWC5hZGQoIGludCggMSApICksIFkgKSwgZnguc3ViKCAxLjAgKSwgZnkgKSwgbXhfZ3JhZGllbnRfdmVjMyggbXhfaGFzaF92ZWMzKCBYLCBZLmFkZCggaW50KCAxICkgKSApLCBmeCwgZnkuc3ViKCAxLjAgKSApLCBteF9ncmFkaWVudF92ZWMzKCBteF9oYXNoX3ZlYzMoIFguYWRkKCBpbnQoIDEgKSApLCBZLmFkZCggaW50KCAxICkgKSApLCBmeC5zdWIoIDEuMCApLCBmeS5zdWIoIDEuMCApICksIHUsIHYgKSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIG14X2dyYWRpZW50X3NjYWxlMmQoIHJlc3VsdCApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9wZXJsaW5fbm9pc2VfdmVjM18wJyxcblx0dHlwZTogJ3ZlYzMnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzInIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfcGVybGluX25vaXNlX3ZlYzNfMSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSBdICkgPT4ge1xuXG5cdGNvbnN0IHAgPSB2ZWMzKCBwX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IFggPSBpbnQoKS50b1ZhcigpLCBZID0gaW50KCkudG9WYXIoKSwgWiA9IGludCgpLnRvVmFyKCk7XG5cdGNvbnN0IGZ4ID0gZmxvYXQoIG14X2Zsb29yZnJhYyggcC54LCBYICkgKS50b1ZhcigpO1xuXHRjb25zdCBmeSA9IGZsb2F0KCBteF9mbG9vcmZyYWMoIHAueSwgWSApICkudG9WYXIoKTtcblx0Y29uc3QgZnogPSBmbG9hdCggbXhfZmxvb3JmcmFjKCBwLnosIFogKSApLnRvVmFyKCk7XG5cdGNvbnN0IHUgPSBmbG9hdCggbXhfZmFkZSggZnggKSApLnRvVmFyKCk7XG5cdGNvbnN0IHYgPSBmbG9hdCggbXhfZmFkZSggZnkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHcgPSBmbG9hdCggbXhfZmFkZSggZnogKSApLnRvVmFyKCk7XG5cdGNvbnN0IHJlc3VsdCA9IHZlYzMoIG14X3RyaWxlcnAoIG14X2dyYWRpZW50X3ZlYzMoIG14X2hhc2hfdmVjMyggWCwgWSwgWiApLCBmeCwgZnksIGZ6ICksIG14X2dyYWRpZW50X3ZlYzMoIG14X2hhc2hfdmVjMyggWC5hZGQoIGludCggMSApICksIFksIFogKSwgZnguc3ViKCAxLjAgKSwgZnksIGZ6ICksIG14X2dyYWRpZW50X3ZlYzMoIG14X2hhc2hfdmVjMyggWCwgWS5hZGQoIGludCggMSApICksIFogKSwgZngsIGZ5LnN1YiggMS4wICksIGZ6ICksIG14X2dyYWRpZW50X3ZlYzMoIG14X2hhc2hfdmVjMyggWC5hZGQoIGludCggMSApICksIFkuYWRkKCBpbnQoIDEgKSApLCBaICksIGZ4LnN1YiggMS4wICksIGZ5LnN1YiggMS4wICksIGZ6ICksIG14X2dyYWRpZW50X3ZlYzMoIG14X2hhc2hfdmVjMyggWCwgWSwgWi5hZGQoIGludCggMSApICkgKSwgZngsIGZ5LCBmei5zdWIoIDEuMCApICksIG14X2dyYWRpZW50X3ZlYzMoIG14X2hhc2hfdmVjMyggWC5hZGQoIGludCggMSApICksIFksIFouYWRkKCBpbnQoIDEgKSApICksIGZ4LnN1YiggMS4wICksIGZ5LCBmei5zdWIoIDEuMCApICksIG14X2dyYWRpZW50X3ZlYzMoIG14X2hhc2hfdmVjMyggWCwgWS5hZGQoIGludCggMSApICksIFouYWRkKCBpbnQoIDEgKSApICksIGZ4LCBmeS5zdWIoIDEuMCApLCBmei5zdWIoIDEuMCApICksIG14X2dyYWRpZW50X3ZlYzMoIG14X2hhc2hfdmVjMyggWC5hZGQoIGludCggMSApICksIFkuYWRkKCBpbnQoIDEgKSApLCBaLmFkZCggaW50KCAxICkgKSApLCBmeC5zdWIoIDEuMCApLCBmeS5zdWIoIDEuMCApLCBmei5zdWIoIDEuMCApICksIHUsIHYsIHcgKSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIG14X2dyYWRpZW50X3NjYWxlM2QoIHJlc3VsdCApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9wZXJsaW5fbm9pc2VfdmVjM18xJyxcblx0dHlwZTogJ3ZlYzMnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzMnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfcGVybGluX25vaXNlX3ZlYzMgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfcGVybGluX25vaXNlX3ZlYzNfMCwgbXhfcGVybGluX25vaXNlX3ZlYzNfMSBdICk7XG5cbmV4cG9ydCBjb25zdCBteF9jZWxsX25vaXNlX2Zsb2F0XzAgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCBwID0gZmxvYXQoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgaXggPSBpbnQoIG14X2Zsb29yKCBwICkgKS50b1ZhcigpO1xuXG5cdHJldHVybiBteF9iaXRzX3RvXzAxKCBteF9oYXNoX2ludCggaXggKSApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9jZWxsX25vaXNlX2Zsb2F0XzAnLFxuXHR0eXBlOiAnZmxvYXQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ2Zsb2F0JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X2NlbGxfbm9pc2VfZmxvYXRfMSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSBdICkgPT4ge1xuXG5cdGNvbnN0IHAgPSB2ZWMyKCBwX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IGl4ID0gaW50KCBteF9mbG9vciggcC54ICkgKS50b1ZhcigpO1xuXHRjb25zdCBpeSA9IGludCggbXhfZmxvb3IoIHAueSApICkudG9WYXIoKTtcblxuXHRyZXR1cm4gbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpeSApICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X2NlbGxfbm9pc2VfZmxvYXRfMScsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjMicgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9jZWxsX25vaXNlX2Zsb2F0XzIgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBpeCA9IGludCggbXhfZmxvb3IoIHAueCApICkudG9WYXIoKTtcblx0Y29uc3QgaXkgPSBpbnQoIG14X2Zsb29yKCBwLnkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IGl6ID0gaW50KCBteF9mbG9vciggcC56ICkgKS50b1ZhcigpO1xuXG5cdHJldHVybiBteF9iaXRzX3RvXzAxKCBteF9oYXNoX2ludCggaXgsIGl5LCBpeiApICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X2NlbGxfbm9pc2VfZmxvYXRfMicsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjMycgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9jZWxsX25vaXNlX2Zsb2F0XzMgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCBwID0gdmVjNCggcF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBpeCA9IGludCggbXhfZmxvb3IoIHAueCApICkudG9WYXIoKTtcblx0Y29uc3QgaXkgPSBpbnQoIG14X2Zsb29yKCBwLnkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IGl6ID0gaW50KCBteF9mbG9vciggcC56ICkgKS50b1ZhcigpO1xuXHRjb25zdCBpdyA9IGludCggbXhfZmxvb3IoIHAudyApICkudG9WYXIoKTtcblxuXHRyZXR1cm4gbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpeSwgaXosIGl3ICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfY2VsbF9ub2lzZV9mbG9hdF8zJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWM0JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X2NlbGxfbm9pc2VfZmxvYXQgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfY2VsbF9ub2lzZV9mbG9hdF8wLCBteF9jZWxsX25vaXNlX2Zsb2F0XzEsIG14X2NlbGxfbm9pc2VfZmxvYXRfMiwgbXhfY2VsbF9ub2lzZV9mbG9hdF8zIF0gKTtcblxuZXhwb3J0IGNvbnN0IG14X2NlbGxfbm9pc2VfdmVjM18wID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgcCA9IGZsb2F0KCBwX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IGl4ID0gaW50KCBteF9mbG9vciggcCApICkudG9WYXIoKTtcblxuXHRyZXR1cm4gdmVjMyggbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpbnQoIDAgKSApICksIG14X2JpdHNfdG9fMDEoIG14X2hhc2hfaW50KCBpeCwgaW50KCAxICkgKSApLCBteF9iaXRzX3RvXzAxKCBteF9oYXNoX2ludCggaXgsIGludCggMiApICkgKSApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9jZWxsX25vaXNlX3ZlYzNfMCcsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9jZWxsX25vaXNlX3ZlYzNfMSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSBdICkgPT4ge1xuXG5cdGNvbnN0IHAgPSB2ZWMyKCBwX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IGl4ID0gaW50KCBteF9mbG9vciggcC54ICkgKS50b1ZhcigpO1xuXHRjb25zdCBpeSA9IGludCggbXhfZmxvb3IoIHAueSApICkudG9WYXIoKTtcblxuXHRyZXR1cm4gdmVjMyggbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpeSwgaW50KCAwICkgKSApLCBteF9iaXRzX3RvXzAxKCBteF9oYXNoX2ludCggaXgsIGl5LCBpbnQoIDEgKSApICksIG14X2JpdHNfdG9fMDEoIG14X2hhc2hfaW50KCBpeCwgaXksIGludCggMiApICkgKSApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9jZWxsX25vaXNlX3ZlYzNfMScsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMyJyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X2NlbGxfbm9pc2VfdmVjM18yID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgcCA9IHZlYzMoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgaXggPSBpbnQoIG14X2Zsb29yKCBwLnggKSApLnRvVmFyKCk7XG5cdGNvbnN0IGl5ID0gaW50KCBteF9mbG9vciggcC55ICkgKS50b1ZhcigpO1xuXHRjb25zdCBpeiA9IGludCggbXhfZmxvb3IoIHAueiApICkudG9WYXIoKTtcblxuXHRyZXR1cm4gdmVjMyggbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpeSwgaXosIGludCggMCApICkgKSwgbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpeSwgaXosIGludCggMSApICkgKSwgbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpeSwgaXosIGludCggMiApICkgKSApO1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9jZWxsX25vaXNlX3ZlYzNfMicsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMzJyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X2NlbGxfbm9pc2VfdmVjM18zID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgcCA9IHZlYzQoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgaXggPSBpbnQoIG14X2Zsb29yKCBwLnggKSApLnRvVmFyKCk7XG5cdGNvbnN0IGl5ID0gaW50KCBteF9mbG9vciggcC55ICkgKS50b1ZhcigpO1xuXHRjb25zdCBpeiA9IGludCggbXhfZmxvb3IoIHAueiApICkudG9WYXIoKTtcblx0Y29uc3QgaXcgPSBpbnQoIG14X2Zsb29yKCBwLncgKSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIHZlYzMoIG14X2JpdHNfdG9fMDEoIG14X2hhc2hfaW50KCBpeCwgaXksIGl6LCBpdywgaW50KCAwICkgKSApLCBteF9iaXRzX3RvXzAxKCBteF9oYXNoX2ludCggaXgsIGl5LCBpeiwgaXcsIGludCggMSApICkgKSwgbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpeSwgaXosIGl3LCBpbnQoIDIgKSApICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfY2VsbF9ub2lzZV92ZWMzXzMnLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjNCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9jZWxsX25vaXNlX3ZlYzMgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfY2VsbF9ub2lzZV92ZWMzXzAsIG14X2NlbGxfbm9pc2VfdmVjM18xLCBteF9jZWxsX25vaXNlX3ZlYzNfMiwgbXhfY2VsbF9ub2lzZV92ZWMzXzMgXSApO1xuXG5leHBvcnQgY29uc3QgbXhfZnJhY3RhbF9ub2lzZV9mbG9hdCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSwgb2N0YXZlc19pbW11dGFibGUsIGxhY3VuYXJpdHlfaW1tdXRhYmxlLCBkaW1pbmlzaF9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCBkaW1pbmlzaCA9IGZsb2F0KCBkaW1pbmlzaF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBsYWN1bmFyaXR5ID0gZmxvYXQoIGxhY3VuYXJpdHlfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3Qgb2N0YXZlcyA9IGludCggb2N0YXZlc19pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCByZXN1bHQgPSBmbG9hdCggMC4wICkudG9WYXIoKTtcblx0Y29uc3QgYW1wbGl0dWRlID0gZmxvYXQoIDEuMCApLnRvVmFyKCk7XG5cblx0TG9vcCggb2N0YXZlcywgKCkgPT4ge1xuXG5cdFx0cmVzdWx0LmFkZEFzc2lnbiggYW1wbGl0dWRlLm11bCggbXhfcGVybGluX25vaXNlX2Zsb2F0KCBwICkgKSApO1xuXHRcdGFtcGxpdHVkZS5tdWxBc3NpZ24oIGRpbWluaXNoICk7XG5cdFx0cC5tdWxBc3NpZ24oIGxhY3VuYXJpdHkgKTtcblxuXHR9ICk7XG5cblx0cmV0dXJuIHJlc3VsdDtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfZnJhY3RhbF9ub2lzZV9mbG9hdCcsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjMycgfSxcblx0XHR7IG5hbWU6ICdvY3RhdmVzJywgdHlwZTogJ2ludCcgfSxcblx0XHR7IG5hbWU6ICdsYWN1bmFyaXR5JywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ2RpbWluaXNoJywgdHlwZTogJ2Zsb2F0JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X2ZyYWN0YWxfbm9pc2VfdmVjMyA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSwgb2N0YXZlc19pbW11dGFibGUsIGxhY3VuYXJpdHlfaW1tdXRhYmxlLCBkaW1pbmlzaF9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCBkaW1pbmlzaCA9IGZsb2F0KCBkaW1pbmlzaF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBsYWN1bmFyaXR5ID0gZmxvYXQoIGxhY3VuYXJpdHlfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3Qgb2N0YXZlcyA9IGludCggb2N0YXZlc19pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCByZXN1bHQgPSB2ZWMzKCAwLjAgKS50b1ZhcigpO1xuXHRjb25zdCBhbXBsaXR1ZGUgPSBmbG9hdCggMS4wICkudG9WYXIoKTtcblxuXHRMb29wKCBvY3RhdmVzLCAoKSA9PiB7XG5cblx0XHRyZXN1bHQuYWRkQXNzaWduKCBhbXBsaXR1ZGUubXVsKCBteF9wZXJsaW5fbm9pc2VfdmVjMyggcCApICkgKTtcblx0XHRhbXBsaXR1ZGUubXVsQXNzaWduKCBkaW1pbmlzaCApO1xuXHRcdHAubXVsQXNzaWduKCBsYWN1bmFyaXR5ICk7XG5cblx0fSApO1xuXG5cdHJldHVybiByZXN1bHQ7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X2ZyYWN0YWxfbm9pc2VfdmVjMycsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ29jdGF2ZXMnLCB0eXBlOiAnaW50JyB9LFxuXHRcdHsgbmFtZTogJ2xhY3VuYXJpdHknLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAnZGltaW5pc2gnLCB0eXBlOiAnZmxvYXQnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfZnJhY3RhbF9ub2lzZV92ZWMyID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlLCBvY3RhdmVzX2ltbXV0YWJsZSwgbGFjdW5hcml0eV9pbW11dGFibGUsIGRpbWluaXNoX2ltbXV0YWJsZSBdICkgPT4ge1xuXG5cdGNvbnN0IGRpbWluaXNoID0gZmxvYXQoIGRpbWluaXNoX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IGxhY3VuYXJpdHkgPSBmbG9hdCggbGFjdW5hcml0eV9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBvY3RhdmVzID0gaW50KCBvY3RhdmVzX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHAgPSB2ZWMzKCBwX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIHZlYzIoIG14X2ZyYWN0YWxfbm9pc2VfZmxvYXQoIHAsIG9jdGF2ZXMsIGxhY3VuYXJpdHksIGRpbWluaXNoICksIG14X2ZyYWN0YWxfbm9pc2VfZmxvYXQoIHAuYWRkKCB2ZWMzKCBpbnQoIDE5ICksIGludCggMTkzICksIGludCggMTcgKSApICksIG9jdGF2ZXMsIGxhY3VuYXJpdHksIGRpbWluaXNoICkgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfZnJhY3RhbF9ub2lzZV92ZWMyJyxcblx0dHlwZTogJ3ZlYzInLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAnb2N0YXZlcycsIHR5cGU6ICdpbnQnIH0sXG5cdFx0eyBuYW1lOiAnbGFjdW5hcml0eScsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICdkaW1pbmlzaCcsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF9mcmFjdGFsX25vaXNlX3ZlYzQgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUsIG9jdGF2ZXNfaW1tdXRhYmxlLCBsYWN1bmFyaXR5X2ltbXV0YWJsZSwgZGltaW5pc2hfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgZGltaW5pc2ggPSBmbG9hdCggZGltaW5pc2hfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgbGFjdW5hcml0eSA9IGZsb2F0KCBsYWN1bmFyaXR5X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IG9jdGF2ZXMgPSBpbnQoIG9jdGF2ZXNfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgcCA9IHZlYzMoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgYyA9IHZlYzMoIG14X2ZyYWN0YWxfbm9pc2VfdmVjMyggcCwgb2N0YXZlcywgbGFjdW5hcml0eSwgZGltaW5pc2ggKSApLnRvVmFyKCk7XG5cdGNvbnN0IGYgPSBmbG9hdCggbXhfZnJhY3RhbF9ub2lzZV9mbG9hdCggcC5hZGQoIHZlYzMoIGludCggMTkgKSwgaW50KCAxOTMgKSwgaW50KCAxNyApICkgKSwgb2N0YXZlcywgbGFjdW5hcml0eSwgZGltaW5pc2ggKSApLnRvVmFyKCk7XG5cblx0cmV0dXJuIHZlYzQoIGMsIGYgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfZnJhY3RhbF9ub2lzZV92ZWM0Jyxcblx0dHlwZTogJ3ZlYzQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAnb2N0YXZlcycsIHR5cGU6ICdpbnQnIH0sXG5cdFx0eyBuYW1lOiAnbGFjdW5hcml0eScsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICdkaW1pbmlzaCcsIHR5cGU6ICdmbG9hdCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF93b3JsZXlfZGlzdGFuY2VfMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSwgeF9pbW11dGFibGUsIHlfaW1tdXRhYmxlLCB4b2ZmX2ltbXV0YWJsZSwgeW9mZl9pbW11dGFibGUsIGppdHRlcl9pbW11dGFibGUsIG1ldHJpY19pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCBtZXRyaWMgPSBpbnQoIG1ldHJpY19pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBqaXR0ZXIgPSBmbG9hdCggaml0dGVyX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHlvZmYgPSBpbnQoIHlvZmZfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgeG9mZiA9IGludCggeG9mZl9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB5ID0gaW50KCB5X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHggPSBpbnQoIHhfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgcCA9IHZlYzIoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgdG1wID0gdmVjMyggbXhfY2VsbF9ub2lzZV92ZWMzKCB2ZWMyKCB4LmFkZCggeG9mZiApLCB5LmFkZCggeW9mZiApICkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IG9mZiA9IHZlYzIoIHRtcC54LCB0bXAueSApLnRvVmFyKCk7XG5cdG9mZi5zdWJBc3NpZ24oIDAuNSApO1xuXHRvZmYubXVsQXNzaWduKCBqaXR0ZXIgKTtcblx0b2ZmLmFkZEFzc2lnbiggMC41ICk7XG5cdGNvbnN0IGNlbGxwb3MgPSB2ZWMyKCB2ZWMyKCBmbG9hdCggeCApLCBmbG9hdCggeSApICkuYWRkKCBvZmYgKSApLnRvVmFyKCk7XG5cdGNvbnN0IGRpZmYgPSB2ZWMyKCBjZWxscG9zLnN1YiggcCApICkudG9WYXIoKTtcblxuXHRJZiggbWV0cmljLmVxdWFsKCBpbnQoIDIgKSApLCAoKSA9PiB7XG5cblx0XHRyZXR1cm4gYWJzKCBkaWZmLnggKS5hZGQoIGFicyggZGlmZi55ICkgKTtcblxuXHR9ICk7XG5cblx0SWYoIG1ldHJpYy5lcXVhbCggaW50KCAzICkgKSwgKCkgPT4ge1xuXG5cdFx0cmV0dXJuIG1heCggYWJzKCBkaWZmLnggKSwgYWJzKCBkaWZmLnkgKSApO1xuXG5cdH0gKTtcblxuXHRyZXR1cm4gZG90KCBkaWZmLCBkaWZmICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X3dvcmxleV9kaXN0YW5jZV8wJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMyJyB9LFxuXHRcdHsgbmFtZTogJ3gnLCB0eXBlOiAnaW50JyB9LFxuXHRcdHsgbmFtZTogJ3knLCB0eXBlOiAnaW50JyB9LFxuXHRcdHsgbmFtZTogJ3hvZmYnLCB0eXBlOiAnaW50JyB9LFxuXHRcdHsgbmFtZTogJ3lvZmYnLCB0eXBlOiAnaW50JyB9LFxuXHRcdHsgbmFtZTogJ2ppdHRlcicsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICdtZXRyaWMnLCB0eXBlOiAnaW50JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X3dvcmxleV9kaXN0YW5jZV8xID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlLCB4X2ltbXV0YWJsZSwgeV9pbW11dGFibGUsIHpfaW1tdXRhYmxlLCB4b2ZmX2ltbXV0YWJsZSwgeW9mZl9pbW11dGFibGUsIHpvZmZfaW1tdXRhYmxlLCBqaXR0ZXJfaW1tdXRhYmxlLCBtZXRyaWNfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgbWV0cmljID0gaW50KCBtZXRyaWNfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3Qgaml0dGVyID0gZmxvYXQoIGppdHRlcl9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB6b2ZmID0gaW50KCB6b2ZmX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHlvZmYgPSBpbnQoIHlvZmZfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgeG9mZiA9IGludCggeG9mZl9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCB6ID0gaW50KCB6X2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHkgPSBpbnQoIHlfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3QgeCA9IGludCggeF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBvZmYgPSB2ZWMzKCBteF9jZWxsX25vaXNlX3ZlYzMoIHZlYzMoIHguYWRkKCB4b2ZmICksIHkuYWRkKCB5b2ZmICksIHouYWRkKCB6b2ZmICkgKSApICkudG9WYXIoKTtcblx0b2ZmLnN1YkFzc2lnbiggMC41ICk7XG5cdG9mZi5tdWxBc3NpZ24oIGppdHRlciApO1xuXHRvZmYuYWRkQXNzaWduKCAwLjUgKTtcblx0Y29uc3QgY2VsbHBvcyA9IHZlYzMoIHZlYzMoIGZsb2F0KCB4ICksIGZsb2F0KCB5ICksIGZsb2F0KCB6ICkgKS5hZGQoIG9mZiApICkudG9WYXIoKTtcblx0Y29uc3QgZGlmZiA9IHZlYzMoIGNlbGxwb3Muc3ViKCBwICkgKS50b1ZhcigpO1xuXG5cdElmKCBtZXRyaWMuZXF1YWwoIGludCggMiApICksICgpID0+IHtcblxuXHRcdHJldHVybiBhYnMoIGRpZmYueCApLmFkZCggYWJzKCBkaWZmLnkgKSApLmFkZCggYWJzKCBkaWZmLnogKSApO1xuXG5cdH0gKTtcblxuXHRJZiggbWV0cmljLmVxdWFsKCBpbnQoIDMgKSApLCAoKSA9PiB7XG5cblx0XHRyZXR1cm4gbWF4KCBtYXgoIGFicyggZGlmZi54ICksIGFicyggZGlmZi55ICkgKSwgYWJzKCBkaWZmLnogKSApO1xuXG5cdH0gKTtcblxuXHRyZXR1cm4gZG90KCBkaWZmLCBkaWZmICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X3dvcmxleV9kaXN0YW5jZV8xJyxcblx0dHlwZTogJ2Zsb2F0Jyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ3gnLCB0eXBlOiAnaW50JyB9LFxuXHRcdHsgbmFtZTogJ3knLCB0eXBlOiAnaW50JyB9LFxuXHRcdHsgbmFtZTogJ3onLCB0eXBlOiAnaW50JyB9LFxuXHRcdHsgbmFtZTogJ3hvZmYnLCB0eXBlOiAnaW50JyB9LFxuXHRcdHsgbmFtZTogJ3lvZmYnLCB0eXBlOiAnaW50JyB9LFxuXHRcdHsgbmFtZTogJ3pvZmYnLCB0eXBlOiAnaW50JyB9LFxuXHRcdHsgbmFtZTogJ2ppdHRlcicsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICdtZXRyaWMnLCB0eXBlOiAnaW50JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X3dvcmxleV9kaXN0YW5jZSA9IC8qQF9fUFVSRV9fKi8gb3ZlcmxvYWRpbmdGbiggWyBteF93b3JsZXlfZGlzdGFuY2VfMCwgbXhfd29ybGV5X2Rpc3RhbmNlXzEgXSApO1xuXG5leHBvcnQgY29uc3QgbXhfd29ybGV5X25vaXNlX2Zsb2F0XzAgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUsIGppdHRlcl9pbW11dGFibGUsIG1ldHJpY19pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCBtZXRyaWMgPSBpbnQoIG1ldHJpY19pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBqaXR0ZXIgPSBmbG9hdCggaml0dGVyX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IHAgPSB2ZWMyKCBwX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IFggPSBpbnQoKS50b1ZhcigpLCBZID0gaW50KCkudG9WYXIoKTtcblx0Y29uc3QgbG9jYWxwb3MgPSB2ZWMyKCBteF9mbG9vcmZyYWMoIHAueCwgWCApLCBteF9mbG9vcmZyYWMoIHAueSwgWSApICkudG9WYXIoKTtcblx0Y29uc3Qgc3FkaXN0ID0gZmxvYXQoIDFlNiApLnRvVmFyKCk7XG5cblx0TG9vcCggeyBzdGFydDogLSAxLCBlbmQ6IGludCggMSApLCBuYW1lOiAneCcsIGNvbmRpdGlvbjogJzw9JyB9LCAoIHsgeCB9ICkgPT4ge1xuXG5cdFx0TG9vcCggeyBzdGFydDogLSAxLCBlbmQ6IGludCggMSApLCBuYW1lOiAneScsIGNvbmRpdGlvbjogJzw9JyB9LCAoIHsgeSB9ICkgPT4ge1xuXG5cdFx0XHRjb25zdCBkaXN0ID0gZmxvYXQoIG14X3dvcmxleV9kaXN0YW5jZSggbG9jYWxwb3MsIHgsIHksIFgsIFksIGppdHRlciwgbWV0cmljICkgKS50b1ZhcigpO1xuXHRcdFx0c3FkaXN0LmFzc2lnbiggbWluKCBzcWRpc3QsIGRpc3QgKSApO1xuXG5cdFx0fSApO1xuXG5cdH0gKTtcblxuXHRJZiggbWV0cmljLmVxdWFsKCBpbnQoIDAgKSApLCAoKSA9PiB7XG5cblx0XHRzcWRpc3QuYXNzaWduKCBzcXJ0KCBzcWRpc3QgKSApO1xuXG5cdH0gKTtcblxuXHRyZXR1cm4gc3FkaXN0O1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF93b3JsZXlfbm9pc2VfZmxvYXRfMCcsXG5cdHR5cGU6ICdmbG9hdCcsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjMicgfSxcblx0XHR7IG5hbWU6ICdqaXR0ZXInLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAnbWV0cmljJywgdHlwZTogJ2ludCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF93b3JsZXlfbm9pc2VfdmVjMl8wID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlLCBqaXR0ZXJfaW1tdXRhYmxlLCBtZXRyaWNfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgbWV0cmljID0gaW50KCBtZXRyaWNfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3Qgaml0dGVyID0gZmxvYXQoIGppdHRlcl9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBwID0gdmVjMiggcF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBYID0gaW50KCkudG9WYXIoKSwgWSA9IGludCgpLnRvVmFyKCk7XG5cdGNvbnN0IGxvY2FscG9zID0gdmVjMiggbXhfZmxvb3JmcmFjKCBwLngsIFggKSwgbXhfZmxvb3JmcmFjKCBwLnksIFkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHNxZGlzdCA9IHZlYzIoIDFlNiwgMWU2ICkudG9WYXIoKTtcblxuXHRMb29wKCB7IHN0YXJ0OiAtIDEsIGVuZDogaW50KCAxICksIG5hbWU6ICd4JywgY29uZGl0aW9uOiAnPD0nIH0sICggeyB4IH0gKSA9PiB7XG5cblx0XHRMb29wKCB7IHN0YXJ0OiAtIDEsIGVuZDogaW50KCAxICksIG5hbWU6ICd5JywgY29uZGl0aW9uOiAnPD0nIH0sICggeyB5IH0gKSA9PiB7XG5cblx0XHRcdGNvbnN0IGRpc3QgPSBmbG9hdCggbXhfd29ybGV5X2Rpc3RhbmNlKCBsb2NhbHBvcywgeCwgeSwgWCwgWSwgaml0dGVyLCBtZXRyaWMgKSApLnRvVmFyKCk7XG5cblx0XHRcdElmKCBkaXN0Lmxlc3NUaGFuKCBzcWRpc3QueCApLCAoKSA9PiB7XG5cblx0XHRcdFx0c3FkaXN0LnkuYXNzaWduKCBzcWRpc3QueCApO1xuXHRcdFx0XHRzcWRpc3QueC5hc3NpZ24oIGRpc3QgKTtcblxuXHRcdFx0fSApLkVsc2VJZiggZGlzdC5sZXNzVGhhbiggc3FkaXN0LnkgKSwgKCkgPT4ge1xuXG5cdFx0XHRcdHNxZGlzdC55LmFzc2lnbiggZGlzdCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9ICk7XG5cblx0fSApO1xuXG5cdElmKCBtZXRyaWMuZXF1YWwoIGludCggMCApICksICgpID0+IHtcblxuXHRcdHNxZGlzdC5hc3NpZ24oIHNxcnQoIHNxZGlzdCApICk7XG5cblx0fSApO1xuXG5cdHJldHVybiBzcWRpc3Q7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X3dvcmxleV9ub2lzZV92ZWMyXzAnLFxuXHR0eXBlOiAndmVjMicsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjMicgfSxcblx0XHR7IG5hbWU6ICdqaXR0ZXInLCB0eXBlOiAnZmxvYXQnIH0sXG5cdFx0eyBuYW1lOiAnbWV0cmljJywgdHlwZTogJ2ludCcgfVxuXHRdXG59ICk7XG5cbmV4cG9ydCBjb25zdCBteF93b3JsZXlfbm9pc2VfdmVjM18wID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlLCBqaXR0ZXJfaW1tdXRhYmxlLCBtZXRyaWNfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgbWV0cmljID0gaW50KCBtZXRyaWNfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3Qgaml0dGVyID0gZmxvYXQoIGppdHRlcl9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBwID0gdmVjMiggcF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBYID0gaW50KCkudG9WYXIoKSwgWSA9IGludCgpLnRvVmFyKCk7XG5cdGNvbnN0IGxvY2FscG9zID0gdmVjMiggbXhfZmxvb3JmcmFjKCBwLngsIFggKSwgbXhfZmxvb3JmcmFjKCBwLnksIFkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHNxZGlzdCA9IHZlYzMoIDFlNiwgMWU2LCAxZTYgKS50b1ZhcigpO1xuXG5cdExvb3AoIHsgc3RhcnQ6IC0gMSwgZW5kOiBpbnQoIDEgKSwgbmFtZTogJ3gnLCBjb25kaXRpb246ICc8PScgfSwgKCB7IHggfSApID0+IHtcblxuXHRcdExvb3AoIHsgc3RhcnQ6IC0gMSwgZW5kOiBpbnQoIDEgKSwgbmFtZTogJ3knLCBjb25kaXRpb246ICc8PScgfSwgKCB7IHkgfSApID0+IHtcblxuXHRcdFx0Y29uc3QgZGlzdCA9IGZsb2F0KCBteF93b3JsZXlfZGlzdGFuY2UoIGxvY2FscG9zLCB4LCB5LCBYLCBZLCBqaXR0ZXIsIG1ldHJpYyApICkudG9WYXIoKTtcblxuXHRcdFx0SWYoIGRpc3QubGVzc1RoYW4oIHNxZGlzdC54ICksICgpID0+IHtcblxuXHRcdFx0XHRzcWRpc3Quei5hc3NpZ24oIHNxZGlzdC55ICk7XG5cdFx0XHRcdHNxZGlzdC55LmFzc2lnbiggc3FkaXN0LnggKTtcblx0XHRcdFx0c3FkaXN0LnguYXNzaWduKCBkaXN0ICk7XG5cblx0XHRcdH0gKS5FbHNlSWYoIGRpc3QubGVzc1RoYW4oIHNxZGlzdC55ICksICgpID0+IHtcblxuXHRcdFx0XHRzcWRpc3Quei5hc3NpZ24oIHNxZGlzdC55ICk7XG5cdFx0XHRcdHNxZGlzdC55LmFzc2lnbiggZGlzdCApO1xuXG5cdFx0XHR9ICkuRWxzZUlmKCBkaXN0Lmxlc3NUaGFuKCBzcWRpc3QueiApLCAoKSA9PiB7XG5cblx0XHRcdFx0c3FkaXN0LnouYXNzaWduKCBkaXN0ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHR9ICk7XG5cblx0SWYoIG1ldHJpYy5lcXVhbCggaW50KCAwICkgKSwgKCkgPT4ge1xuXG5cdFx0c3FkaXN0LmFzc2lnbiggc3FydCggc3FkaXN0ICkgKTtcblxuXHR9ICk7XG5cblx0cmV0dXJuIHNxZGlzdDtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfd29ybGV5X25vaXNlX3ZlYzNfMCcsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMyJyB9LFxuXHRcdHsgbmFtZTogJ2ppdHRlcicsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICdtZXRyaWMnLCB0eXBlOiAnaW50JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X3dvcmxleV9ub2lzZV9mbG9hdF8xID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlLCBqaXR0ZXJfaW1tdXRhYmxlLCBtZXRyaWNfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgbWV0cmljID0gaW50KCBtZXRyaWNfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3Qgaml0dGVyID0gZmxvYXQoIGppdHRlcl9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBYID0gaW50KCkudG9WYXIoKSwgWSA9IGludCgpLnRvVmFyKCksIFogPSBpbnQoKS50b1ZhcigpO1xuXHRjb25zdCBsb2NhbHBvcyA9IHZlYzMoIG14X2Zsb29yZnJhYyggcC54LCBYICksIG14X2Zsb29yZnJhYyggcC55LCBZICksIG14X2Zsb29yZnJhYyggcC56LCBaICkgKS50b1ZhcigpO1xuXHRjb25zdCBzcWRpc3QgPSBmbG9hdCggMWU2ICkudG9WYXIoKTtcblxuXHRMb29wKCB7IHN0YXJ0OiAtIDEsIGVuZDogaW50KCAxICksIG5hbWU6ICd4JywgY29uZGl0aW9uOiAnPD0nIH0sICggeyB4IH0gKSA9PiB7XG5cblx0XHRMb29wKCB7IHN0YXJ0OiAtIDEsIGVuZDogaW50KCAxICksIG5hbWU6ICd5JywgY29uZGl0aW9uOiAnPD0nIH0sICggeyB5IH0gKSA9PiB7XG5cblx0XHRcdExvb3AoIHsgc3RhcnQ6IC0gMSwgZW5kOiBpbnQoIDEgKSwgbmFtZTogJ3onLCBjb25kaXRpb246ICc8PScgfSwgKCB7IHogfSApID0+IHtcblxuXHRcdFx0XHRjb25zdCBkaXN0ID0gZmxvYXQoIG14X3dvcmxleV9kaXN0YW5jZSggbG9jYWxwb3MsIHgsIHksIHosIFgsIFksIFosIGppdHRlciwgbWV0cmljICkgKS50b1ZhcigpO1xuXHRcdFx0XHRzcWRpc3QuYXNzaWduKCBtaW4oIHNxZGlzdCwgZGlzdCApICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHR9ICk7XG5cblx0SWYoIG1ldHJpYy5lcXVhbCggaW50KCAwICkgKSwgKCkgPT4ge1xuXG5cdFx0c3FkaXN0LmFzc2lnbiggc3FydCggc3FkaXN0ICkgKTtcblxuXHR9ICk7XG5cblx0cmV0dXJuIHNxZGlzdDtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfd29ybGV5X25vaXNlX2Zsb2F0XzEnLFxuXHR0eXBlOiAnZmxvYXQnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAnaml0dGVyJywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ21ldHJpYycsIHR5cGU6ICdpbnQnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfd29ybGV5X25vaXNlX2Zsb2F0ID0gLypAX19QVVJFX18qLyBvdmVybG9hZGluZ0ZuKCBbIG14X3dvcmxleV9ub2lzZV9mbG9hdF8wLCBteF93b3JsZXlfbm9pc2VfZmxvYXRfMSBdICk7XG5cbmV4cG9ydCBjb25zdCBteF93b3JsZXlfbm9pc2VfdmVjMl8xID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlLCBqaXR0ZXJfaW1tdXRhYmxlLCBtZXRyaWNfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgbWV0cmljID0gaW50KCBtZXRyaWNfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3Qgaml0dGVyID0gZmxvYXQoIGppdHRlcl9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBYID0gaW50KCkudG9WYXIoKSwgWSA9IGludCgpLnRvVmFyKCksIFogPSBpbnQoKS50b1ZhcigpO1xuXHRjb25zdCBsb2NhbHBvcyA9IHZlYzMoIG14X2Zsb29yZnJhYyggcC54LCBYICksIG14X2Zsb29yZnJhYyggcC55LCBZICksIG14X2Zsb29yZnJhYyggcC56LCBaICkgKS50b1ZhcigpO1xuXHRjb25zdCBzcWRpc3QgPSB2ZWMyKCAxZTYsIDFlNiApLnRvVmFyKCk7XG5cblx0TG9vcCggeyBzdGFydDogLSAxLCBlbmQ6IGludCggMSApLCBuYW1lOiAneCcsIGNvbmRpdGlvbjogJzw9JyB9LCAoIHsgeCB9ICkgPT4ge1xuXG5cdFx0TG9vcCggeyBzdGFydDogLSAxLCBlbmQ6IGludCggMSApLCBuYW1lOiAneScsIGNvbmRpdGlvbjogJzw9JyB9LCAoIHsgeSB9ICkgPT4ge1xuXG5cdFx0XHRMb29wKCB7IHN0YXJ0OiAtIDEsIGVuZDogaW50KCAxICksIG5hbWU6ICd6JywgY29uZGl0aW9uOiAnPD0nIH0sICggeyB6IH0gKSA9PiB7XG5cblx0XHRcdFx0Y29uc3QgZGlzdCA9IGZsb2F0KCBteF93b3JsZXlfZGlzdGFuY2UoIGxvY2FscG9zLCB4LCB5LCB6LCBYLCBZLCBaLCBqaXR0ZXIsIG1ldHJpYyApICkudG9WYXIoKTtcblxuXHRcdFx0XHRJZiggZGlzdC5sZXNzVGhhbiggc3FkaXN0LnggKSwgKCkgPT4ge1xuXG5cdFx0XHRcdFx0c3FkaXN0LnkuYXNzaWduKCBzcWRpc3QueCApO1xuXHRcdFx0XHRcdHNxZGlzdC54LmFzc2lnbiggZGlzdCApO1xuXG5cdFx0XHRcdH0gKS5FbHNlSWYoIGRpc3QubGVzc1RoYW4oIHNxZGlzdC55ICksICgpID0+IHtcblxuXHRcdFx0XHRcdHNxZGlzdC55LmFzc2lnbiggZGlzdCApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdH0gKTtcblxuXHRJZiggbWV0cmljLmVxdWFsKCBpbnQoIDAgKSApLCAoKSA9PiB7XG5cblx0XHRzcWRpc3QuYXNzaWduKCBzcXJ0KCBzcWRpc3QgKSApO1xuXG5cdH0gKTtcblxuXHRyZXR1cm4gc3FkaXN0O1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF93b3JsZXlfbm9pc2VfdmVjMl8xJyxcblx0dHlwZTogJ3ZlYzInLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzMnIH0sXG5cdFx0eyBuYW1lOiAnaml0dGVyJywgdHlwZTogJ2Zsb2F0JyB9LFxuXHRcdHsgbmFtZTogJ21ldHJpYycsIHR5cGU6ICdpbnQnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfd29ybGV5X25vaXNlX3ZlYzIgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfd29ybGV5X25vaXNlX3ZlYzJfMCwgbXhfd29ybGV5X25vaXNlX3ZlYzJfMSBdICk7XG5cbmV4cG9ydCBjb25zdCBteF93b3JsZXlfbm9pc2VfdmVjM18xID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlLCBqaXR0ZXJfaW1tdXRhYmxlLCBtZXRyaWNfaW1tdXRhYmxlIF0gKSA9PiB7XG5cblx0Y29uc3QgbWV0cmljID0gaW50KCBtZXRyaWNfaW1tdXRhYmxlICkudG9WYXIoKTtcblx0Y29uc3Qgaml0dGVyID0gZmxvYXQoIGppdHRlcl9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCBYID0gaW50KCkudG9WYXIoKSwgWSA9IGludCgpLnRvVmFyKCksIFogPSBpbnQoKS50b1ZhcigpO1xuXHRjb25zdCBsb2NhbHBvcyA9IHZlYzMoIG14X2Zsb29yZnJhYyggcC54LCBYICksIG14X2Zsb29yZnJhYyggcC55LCBZICksIG14X2Zsb29yZnJhYyggcC56LCBaICkgKS50b1ZhcigpO1xuXHRjb25zdCBzcWRpc3QgPSB2ZWMzKCAxZTYsIDFlNiwgMWU2ICkudG9WYXIoKTtcblxuXHRMb29wKCB7IHN0YXJ0OiAtIDEsIGVuZDogaW50KCAxICksIG5hbWU6ICd4JywgY29uZGl0aW9uOiAnPD0nIH0sICggeyB4IH0gKSA9PiB7XG5cblx0XHRMb29wKCB7IHN0YXJ0OiAtIDEsIGVuZDogaW50KCAxICksIG5hbWU6ICd5JywgY29uZGl0aW9uOiAnPD0nIH0sICggeyB5IH0gKSA9PiB7XG5cblx0XHRcdExvb3AoIHsgc3RhcnQ6IC0gMSwgZW5kOiBpbnQoIDEgKSwgbmFtZTogJ3onLCBjb25kaXRpb246ICc8PScgfSwgKCB7IHogfSApID0+IHtcblxuXHRcdFx0XHRjb25zdCBkaXN0ID0gZmxvYXQoIG14X3dvcmxleV9kaXN0YW5jZSggbG9jYWxwb3MsIHgsIHksIHosIFgsIFksIFosIGppdHRlciwgbWV0cmljICkgKS50b1ZhcigpO1xuXG5cdFx0XHRcdElmKCBkaXN0Lmxlc3NUaGFuKCBzcWRpc3QueCApLCAoKSA9PiB7XG5cblx0XHRcdFx0XHRzcWRpc3Quei5hc3NpZ24oIHNxZGlzdC55ICk7XG5cdFx0XHRcdFx0c3FkaXN0LnkuYXNzaWduKCBzcWRpc3QueCApO1xuXHRcdFx0XHRcdHNxZGlzdC54LmFzc2lnbiggZGlzdCApO1xuXG5cdFx0XHRcdH0gKS5FbHNlSWYoIGRpc3QubGVzc1RoYW4oIHNxZGlzdC55ICksICgpID0+IHtcblxuXHRcdFx0XHRcdHNxZGlzdC56LmFzc2lnbiggc3FkaXN0LnkgKTtcblx0XHRcdFx0XHRzcWRpc3QueS5hc3NpZ24oIGRpc3QgKTtcblxuXHRcdFx0XHR9ICkuRWxzZUlmKCBkaXN0Lmxlc3NUaGFuKCBzcWRpc3QueiApLCAoKSA9PiB7XG5cblx0XHRcdFx0XHRzcWRpc3Quei5hc3NpZ24oIGRpc3QgKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHR9ICk7XG5cblx0SWYoIG1ldHJpYy5lcXVhbCggaW50KCAwICkgKSwgKCkgPT4ge1xuXG5cdFx0c3FkaXN0LmFzc2lnbiggc3FydCggc3FkaXN0ICkgKTtcblxuXHR9ICk7XG5cblx0cmV0dXJuIHNxZGlzdDtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfd29ybGV5X25vaXNlX3ZlYzNfMScsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMzJyB9LFxuXHRcdHsgbmFtZTogJ2ppdHRlcicsIHR5cGU6ICdmbG9hdCcgfSxcblx0XHR7IG5hbWU6ICdtZXRyaWMnLCB0eXBlOiAnaW50JyB9XG5cdF1cbn0gKTtcblxuZXhwb3J0IGNvbnN0IG14X3dvcmxleV9ub2lzZV92ZWMzID0gLypAX19QVVJFX18qLyBvdmVybG9hZGluZ0ZuKCBbIG14X3dvcmxleV9ub2lzZV92ZWMzXzAsIG14X3dvcmxleV9ub2lzZV92ZWMzXzEgXSApO1xuIiwiLy8gVGhyZWUuanMgVHJhbnNwaWxlclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0FjYWRlbXlTb2Z0d2FyZUZvdW5kYXRpb24vTWF0ZXJpYWxYL2Jsb2IvbWFpbi9saWJyYXJpZXMvc3RkbGliL2dlbmdsc2wvbGliL214X2hzdi5nbHNsXG5cbmltcG9ydCB7IGludCwgZmxvYXQsIHZlYzMsIElmLCBGbiB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IGFkZCB9IGZyb20gJy4uLy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJztcbmltcG9ydCB7IGZsb29yLCB0cnVuYywgbWF4LCBtaW4gfSBmcm9tICcuLi8uLi9tYXRoL01hdGhOb2RlLmpzJztcblxuZXhwb3J0IGNvbnN0IG14X2hzdnRvcmdiID0gLypAX19QVVJFX18qLyBGbiggKCBbIGhzdiBdICkgPT4ge1xuXG5cdGNvbnN0IHMgPSBoc3YueTtcblx0Y29uc3QgdiA9IGhzdi56O1xuXG5cdGNvbnN0IHJlc3VsdCA9IHZlYzMoKS50b1ZhcigpO1xuXG5cdElmKCBzLmxlc3NUaGFuKCAwLjAwMDEgKSwgKCkgPT4ge1xuXG5cdFx0cmVzdWx0LmFzc2lnbiggdmVjMyggdiwgdiwgdiApICk7XG5cblx0fSApLkVsc2UoICgpID0+IHtcblxuXHRcdGxldCBoID0gaHN2Lng7XG5cdFx0aCA9IGguc3ViKCBmbG9vciggaCApICkubXVsKCA2LjAgKS50b1ZhcigpOyAvLyBUT0RPOiBjaGVjayB3aGF0IC50b1ZhcigpIGlzIG5lZWRlZCBpbiBub2RlIHN5c3RlbSBjYWNoZVxuXHRcdGNvbnN0IGhpID0gaW50KCB0cnVuYyggaCApICk7XG5cdFx0Y29uc3QgZiA9IGguc3ViKCBmbG9hdCggaGkgKSApO1xuXHRcdGNvbnN0IHAgPSB2Lm11bCggcy5vbmVNaW51cygpICk7XG5cdFx0Y29uc3QgcSA9IHYubXVsKCBzLm11bCggZiApLm9uZU1pbnVzKCkgKTtcblx0XHRjb25zdCB0ID0gdi5tdWwoIHMubXVsKCBmLm9uZU1pbnVzKCkgKS5vbmVNaW51cygpICk7XG5cblx0XHRJZiggaGkuZXF1YWwoIGludCggMCApICksICgpID0+IHtcblxuXHRcdFx0cmVzdWx0LmFzc2lnbiggdmVjMyggdiwgdCwgcCApICk7XG5cblx0XHR9ICkuRWxzZUlmKCBoaS5lcXVhbCggaW50KCAxICkgKSwgKCkgPT4ge1xuXG5cdFx0XHRyZXN1bHQuYXNzaWduKCB2ZWMzKCBxLCB2LCBwICkgKTtcblxuXHRcdH0gKS5FbHNlSWYoIGhpLmVxdWFsKCBpbnQoIDIgKSApLCAoKSA9PiB7XG5cblx0XHRcdHJlc3VsdC5hc3NpZ24oIHZlYzMoIHAsIHYsIHQgKSApO1xuXG5cdFx0fSApLkVsc2VJZiggaGkuZXF1YWwoIGludCggMyApICksICgpID0+IHtcblxuXHRcdFx0cmVzdWx0LmFzc2lnbiggdmVjMyggcCwgcSwgdiApICk7XG5cblx0XHR9ICkuRWxzZUlmKCBoaS5lcXVhbCggaW50KCA0ICkgKSwgKCkgPT4ge1xuXG5cdFx0XHRyZXN1bHQuYXNzaWduKCB2ZWMzKCB0LCBwLCB2ICkgKTtcblxuXHRcdH0gKS5FbHNlKCAoKSA9PiB7XG5cblx0XHRcdHJlc3VsdC5hc3NpZ24oIHZlYzMoIHYsIHAsIHEgKSApO1xuXG5cdFx0fSApO1xuXG5cdH0gKTtcblxuXHRyZXR1cm4gcmVzdWx0O1xuXG59ICkuc2V0TGF5b3V0KCB7XG5cdG5hbWU6ICdteF9oc3Z0b3JnYicsXG5cdHR5cGU6ICd2ZWMzJyxcblx0aW5wdXRzOiBbXG5cdFx0eyBuYW1lOiAnaHN2JywgdHlwZTogJ3ZlYzMnIH1cblx0XVxufSApO1xuXG5leHBvcnQgY29uc3QgbXhfcmdidG9oc3YgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgY19pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCBjID0gdmVjMyggY19pbW11dGFibGUgKS50b1ZhcigpO1xuXHRjb25zdCByID0gZmxvYXQoIGMueCApLnRvVmFyKCk7XG5cdGNvbnN0IGcgPSBmbG9hdCggYy55ICkudG9WYXIoKTtcblx0Y29uc3QgYiA9IGZsb2F0KCBjLnogKS50b1ZhcigpO1xuXHRjb25zdCBtaW5jb21wID0gZmxvYXQoIG1pbiggciwgbWluKCBnLCBiICkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IG1heGNvbXAgPSBmbG9hdCggbWF4KCByLCBtYXgoIGcsIGIgKSApICkudG9WYXIoKTtcblx0Y29uc3QgZGVsdGEgPSBmbG9hdCggbWF4Y29tcC5zdWIoIG1pbmNvbXAgKSApLnRvVmFyKCk7XG5cdGNvbnN0IGggPSBmbG9hdCgpLnRvVmFyKCksIHMgPSBmbG9hdCgpLnRvVmFyKCksIHYgPSBmbG9hdCgpLnRvVmFyKCk7XG5cdHYuYXNzaWduKCBtYXhjb21wICk7XG5cblx0SWYoIG1heGNvbXAuZ3JlYXRlclRoYW4oIDAuMCApLCAoKSA9PiB7XG5cblx0XHRzLmFzc2lnbiggZGVsdGEuZGl2KCBtYXhjb21wICkgKTtcblxuXHR9ICkuRWxzZSggKCkgPT4ge1xuXG5cdFx0cy5hc3NpZ24oIDAuMCApO1xuXG5cdH0gKTtcblxuXHRJZiggcy5sZXNzVGhhbkVxdWFsKCAwLjAgKSwgKCkgPT4ge1xuXG5cdFx0aC5hc3NpZ24oIDAuMCApO1xuXG5cdH0gKS5FbHNlKCAoKSA9PiB7XG5cblx0XHRJZiggci5ncmVhdGVyVGhhbkVxdWFsKCBtYXhjb21wICksICgpID0+IHtcblxuXHRcdFx0aC5hc3NpZ24oIGcuc3ViKCBiICkuZGl2KCBkZWx0YSApICk7XG5cblx0XHR9ICkuRWxzZUlmKCBnLmdyZWF0ZXJUaGFuRXF1YWwoIG1heGNvbXAgKSwgKCkgPT4ge1xuXG5cdFx0XHRoLmFzc2lnbiggYWRkKCAyLjAsIGIuc3ViKCByICkuZGl2KCBkZWx0YSApICkgKTtcblxuXHRcdH0gKS5FbHNlKCAoKSA9PiB7XG5cblx0XHRcdGguYXNzaWduKCBhZGQoIDQuMCwgci5zdWIoIGcgKS5kaXYoIGRlbHRhICkgKSApO1xuXG5cdFx0fSApO1xuXG5cdFx0aC5tdWxBc3NpZ24oIDEuMCAvIDYuMCApO1xuXG5cdFx0SWYoIGgubGVzc1RoYW4oIDAuMCApLCAoKSA9PiB7XG5cblx0XHRcdGguYWRkQXNzaWduKCAxLjAgKTtcblxuXHRcdH0gKTtcblxuXHR9ICk7XG5cblx0cmV0dXJuIHZlYzMoIGgsIHMsIHYgKTtcblxufSApLnNldExheW91dCgge1xuXHRuYW1lOiAnbXhfcmdidG9oc3YnLFxuXHR0eXBlOiAndmVjMycsXG5cdGlucHV0czogW1xuXHRcdHsgbmFtZTogJ2MnLCB0eXBlOiAndmVjMycgfVxuXHRdXG59ICk7XG4iLCIvLyBUaHJlZS5qcyBUcmFuc3BpbGVyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vQWNhZGVteVNvZnR3YXJlRm91bmRhdGlvbi9NYXRlcmlhbFgvYmxvYi9tYWluL2xpYnJhcmllcy9zdGRsaWIvZ2VuZ2xzbC9saWIvbXhfdHJhbnNmb3JtX2NvbG9yLmdsc2xcblxuaW1wb3J0IHsgYnZlYzMsIHZlYzMsIEZuIH0gZnJvbSAnLi4vLi4vdHNsL1RTTEJhc2UuanMnO1xuaW1wb3J0IHsgZ3JlYXRlclRoYW4gfSBmcm9tICcuLi8uLi9tYXRoL09wZXJhdG9yTm9kZS5qcyc7XG5pbXBvcnQgeyBtYXgsIHBvdywgbWl4IH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRoTm9kZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBteF9zcmdiX3RleHR1cmVfdG9fbGluX3JlYzcwOSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBjb2xvcl9pbW11dGFibGUgXSApID0+IHtcblxuXHRjb25zdCBjb2xvciA9IHZlYzMoIGNvbG9yX2ltbXV0YWJsZSApLnRvVmFyKCk7XG5cdGNvbnN0IGlzQWJvdmUgPSBidmVjMyggZ3JlYXRlclRoYW4oIGNvbG9yLCB2ZWMzKCAwLjA0MDQ1ICkgKSApLnRvVmFyKCk7XG5cdGNvbnN0IGxpblNlZyA9IHZlYzMoIGNvbG9yLmRpdiggMTIuOTIgKSApLnRvVmFyKCk7XG5cdGNvbnN0IHBvd1NlZyA9IHZlYzMoIHBvdyggbWF4KCBjb2xvci5hZGQoIHZlYzMoIDAuMDU1ICkgKSwgdmVjMyggMC4wICkgKS5kaXYoIDEuMDU1ICksIHZlYzMoIDIuNCApICkgKS50b1ZhcigpO1xuXG5cdHJldHVybiBtaXgoIGxpblNlZywgcG93U2VnLCBpc0Fib3ZlICk7XG5cbn0gKS5zZXRMYXlvdXQoIHtcblx0bmFtZTogJ214X3NyZ2JfdGV4dHVyZV90b19saW5fcmVjNzA5Jyxcblx0dHlwZTogJ3ZlYzMnLFxuXHRpbnB1dHM6IFtcblx0XHR7IG5hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWMzJyB9XG5cdF1cbn0gKTtcbiIsImltcG9ydCB7XG5cdG14X3Blcmxpbl9ub2lzZV9mbG9hdCwgbXhfcGVybGluX25vaXNlX3ZlYzMsXG5cdG14X3dvcmxleV9ub2lzZV9mbG9hdCBhcyB3b3JsZXlfbm9pc2VfZmxvYXQsIG14X3dvcmxleV9ub2lzZV92ZWMyIGFzIHdvcmxleV9ub2lzZV92ZWMyLCBteF93b3JsZXlfbm9pc2VfdmVjMyBhcyB3b3JsZXlfbm9pc2VfdmVjMyxcblx0bXhfY2VsbF9ub2lzZV9mbG9hdCBhcyBjZWxsX25vaXNlX2Zsb2F0LFxuXHRteF9mcmFjdGFsX25vaXNlX2Zsb2F0IGFzIGZyYWN0YWxfbm9pc2VfZmxvYXQsIG14X2ZyYWN0YWxfbm9pc2VfdmVjMiBhcyBmcmFjdGFsX25vaXNlX3ZlYzIsIG14X2ZyYWN0YWxfbm9pc2VfdmVjMyBhcyBmcmFjdGFsX25vaXNlX3ZlYzMsIG14X2ZyYWN0YWxfbm9pc2VfdmVjNCBhcyBmcmFjdGFsX25vaXNlX3ZlYzRcbn0gZnJvbSAnLi9saWIvbXhfbm9pc2UuanMnO1xuaW1wb3J0IHsgbXhfaHN2dG9yZ2IsIG14X3JnYnRvaHN2IH0gZnJvbSAnLi9saWIvbXhfaHN2LmpzJztcbmltcG9ydCB7IG14X3NyZ2JfdGV4dHVyZV90b19saW5fcmVjNzA5IH0gZnJvbSAnLi9saWIvbXhfdHJhbnNmb3JtX2NvbG9yLmpzJztcbmltcG9ydCB7IG1peCwgc21vb3Roc3RlcCB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xuaW1wb3J0IHsgdXYgfSBmcm9tICcuLi9hY2Nlc3NvcnMvVVYuanMnO1xuaW1wb3J0IHsgZmxvYXQsIHZlYzIsIHZlYzQsIGludCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcblxuZXhwb3J0IGNvbnN0IG14X2Fhc3RlcCA9ICggdGhyZXNob2xkLCB2YWx1ZSApID0+IHtcblxuXHR0aHJlc2hvbGQgPSBmbG9hdCggdGhyZXNob2xkICk7XG5cdHZhbHVlID0gZmxvYXQoIHZhbHVlICk7XG5cblx0Y29uc3QgYWZ3aWR0aCA9IHZlYzIoIHZhbHVlLmRGZHgoKSwgdmFsdWUuZEZkeSgpICkubGVuZ3RoKCkubXVsKCAwLjcwNzEwNjc4MTE4NjU0NzU3ICk7XG5cblx0cmV0dXJuIHNtb290aHN0ZXAoIHRocmVzaG9sZC5zdWIoIGFmd2lkdGggKSwgdGhyZXNob2xkLmFkZCggYWZ3aWR0aCApLCB2YWx1ZSApO1xuXG59O1xuXG5jb25zdCBfcmFtcCA9ICggYSwgYiwgdXYsIHAgKSA9PiBtaXgoIGEsIGIsIHV2WyBwIF0uY2xhbXAoKSApO1xuZXhwb3J0IGNvbnN0IG14X3JhbXBsciA9ICggdmFsdWVsLCB2YWx1ZXIsIHRleGNvb3JkID0gdXYoKSApID0+IF9yYW1wKCB2YWx1ZWwsIHZhbHVlciwgdGV4Y29vcmQsICd4JyApO1xuZXhwb3J0IGNvbnN0IG14X3JhbXB0YiA9ICggdmFsdWV0LCB2YWx1ZWIsIHRleGNvb3JkID0gdXYoKSApID0+IF9yYW1wKCB2YWx1ZXQsIHZhbHVlYiwgdGV4Y29vcmQsICd5JyApO1xuXG5jb25zdCBfc3BsaXQgPSAoIGEsIGIsIGNlbnRlciwgdXYsIHAgKSA9PiBtaXgoIGEsIGIsIG14X2Fhc3RlcCggY2VudGVyLCB1dlsgcCBdICkgKTtcbmV4cG9ydCBjb25zdCBteF9zcGxpdGxyID0gKCB2YWx1ZWwsIHZhbHVlciwgY2VudGVyLCB0ZXhjb29yZCA9IHV2KCkgKSA9PiBfc3BsaXQoIHZhbHVlbCwgdmFsdWVyLCBjZW50ZXIsIHRleGNvb3JkLCAneCcgKTtcbmV4cG9ydCBjb25zdCBteF9zcGxpdHRiID0gKCB2YWx1ZXQsIHZhbHVlYiwgY2VudGVyLCB0ZXhjb29yZCA9IHV2KCkgKSA9PiBfc3BsaXQoIHZhbHVldCwgdmFsdWViLCBjZW50ZXIsIHRleGNvb3JkLCAneScgKTtcblxuZXhwb3J0IGNvbnN0IG14X3RyYW5zZm9ybV91diA9ICggdXZfc2NhbGUgPSAxLCB1dl9vZmZzZXQgPSAwLCB1dl9nZW8gPSB1digpICkgPT4gdXZfZ2VvLm11bCggdXZfc2NhbGUgKS5hZGQoIHV2X29mZnNldCApO1xuXG5leHBvcnQgY29uc3QgbXhfc2FmZXBvd2VyID0gKCBpbjEsIGluMiA9IDEgKSA9PiB7XG5cblx0aW4xID0gZmxvYXQoIGluMSApO1xuXG5cdHJldHVybiBpbjEuYWJzKCkucG93KCBpbjIgKS5tdWwoIGluMS5zaWduKCkgKTtcblxufTtcblxuZXhwb3J0IGNvbnN0IG14X2NvbnRyYXN0ID0gKCBpbnB1dCwgYW1vdW50ID0gMSwgcGl2b3QgPSAuNSApID0+IGZsb2F0KCBpbnB1dCApLnN1YiggcGl2b3QgKS5tdWwoIGFtb3VudCApLmFkZCggcGl2b3QgKTtcblxuZXhwb3J0IGNvbnN0IG14X25vaXNlX2Zsb2F0ID0gKCB0ZXhjb29yZCA9IHV2KCksIGFtcGxpdHVkZSA9IDEsIHBpdm90ID0gMCApID0+IG14X3Blcmxpbl9ub2lzZV9mbG9hdCggdGV4Y29vcmQuY29udmVydCggJ3ZlYzJ8dmVjMycgKSApLm11bCggYW1wbGl0dWRlICkuYWRkKCBwaXZvdCApO1xuLy9leHBvcnQgY29uc3QgbXhfbm9pc2VfdmVjMiA9ICggdGV4Y29vcmQgPSB1digpLCBhbXBsaXR1ZGUgPSAxLCBwaXZvdCA9IDAgKSA9PiBteF9wZXJsaW5fbm9pc2VfdmVjMyggdGV4Y29vcmQuY29udmVydCggJ3ZlYzJ8dmVjMycgKSApLm11bCggYW1wbGl0dWRlICkuYWRkKCBwaXZvdCApO1xuZXhwb3J0IGNvbnN0IG14X25vaXNlX3ZlYzMgPSAoIHRleGNvb3JkID0gdXYoKSwgYW1wbGl0dWRlID0gMSwgcGl2b3QgPSAwICkgPT4gbXhfcGVybGluX25vaXNlX3ZlYzMoIHRleGNvb3JkLmNvbnZlcnQoICd2ZWMyfHZlYzMnICkgKS5tdWwoIGFtcGxpdHVkZSApLmFkZCggcGl2b3QgKTtcbmV4cG9ydCBjb25zdCBteF9ub2lzZV92ZWM0ID0gKCB0ZXhjb29yZCA9IHV2KCksIGFtcGxpdHVkZSA9IDEsIHBpdm90ID0gMCApID0+IHtcblxuXHR0ZXhjb29yZCA9IHRleGNvb3JkLmNvbnZlcnQoICd2ZWMyfHZlYzMnICk7IC8vIG92ZXJsb2FkaW5nIHR5cGVcblxuXHRjb25zdCBub2lzZV92ZWM0ID0gdmVjNCggbXhfcGVybGluX25vaXNlX3ZlYzMoIHRleGNvb3JkICksIG14X3Blcmxpbl9ub2lzZV9mbG9hdCggdGV4Y29vcmQuYWRkKCB2ZWMyKCAxOSwgNzMgKSApICkgKTtcblxuXHRyZXR1cm4gbm9pc2VfdmVjNC5tdWwoIGFtcGxpdHVkZSApLmFkZCggcGl2b3QgKTtcblxufTtcblxuZXhwb3J0IGNvbnN0IG14X3dvcmxleV9ub2lzZV9mbG9hdCA9ICggdGV4Y29vcmQgPSB1digpLCBqaXR0ZXIgPSAxICkgPT4gd29ybGV5X25vaXNlX2Zsb2F0KCB0ZXhjb29yZC5jb252ZXJ0KCAndmVjMnx2ZWMzJyApLCBqaXR0ZXIsIGludCggMSApICk7XG5leHBvcnQgY29uc3QgbXhfd29ybGV5X25vaXNlX3ZlYzIgPSAoIHRleGNvb3JkID0gdXYoKSwgaml0dGVyID0gMSApID0+IHdvcmxleV9ub2lzZV92ZWMyKCB0ZXhjb29yZC5jb252ZXJ0KCAndmVjMnx2ZWMzJyApLCBqaXR0ZXIsIGludCggMSApICk7XG5leHBvcnQgY29uc3QgbXhfd29ybGV5X25vaXNlX3ZlYzMgPSAoIHRleGNvb3JkID0gdXYoKSwgaml0dGVyID0gMSApID0+IHdvcmxleV9ub2lzZV92ZWMzKCB0ZXhjb29yZC5jb252ZXJ0KCAndmVjMnx2ZWMzJyApLCBqaXR0ZXIsIGludCggMSApICk7XG5cbmV4cG9ydCBjb25zdCBteF9jZWxsX25vaXNlX2Zsb2F0ID0gKCB0ZXhjb29yZCA9IHV2KCkgKSA9PiBjZWxsX25vaXNlX2Zsb2F0KCB0ZXhjb29yZC5jb252ZXJ0KCAndmVjMnx2ZWMzJyApICk7XG5cbmV4cG9ydCBjb25zdCBteF9mcmFjdGFsX25vaXNlX2Zsb2F0ID0gKCBwb3NpdGlvbiA9IHV2KCksIG9jdGF2ZXMgPSAzLCBsYWN1bmFyaXR5ID0gMiwgZGltaW5pc2ggPSAuNSwgYW1wbGl0dWRlID0gMSApID0+IGZyYWN0YWxfbm9pc2VfZmxvYXQoIHBvc2l0aW9uLCBpbnQoIG9jdGF2ZXMgKSwgbGFjdW5hcml0eSwgZGltaW5pc2ggKS5tdWwoIGFtcGxpdHVkZSApO1xuZXhwb3J0IGNvbnN0IG14X2ZyYWN0YWxfbm9pc2VfdmVjMiA9ICggcG9zaXRpb24gPSB1digpLCBvY3RhdmVzID0gMywgbGFjdW5hcml0eSA9IDIsIGRpbWluaXNoID0gLjUsIGFtcGxpdHVkZSA9IDEgKSA9PiBmcmFjdGFsX25vaXNlX3ZlYzIoIHBvc2l0aW9uLCBpbnQoIG9jdGF2ZXMgKSwgbGFjdW5hcml0eSwgZGltaW5pc2ggKS5tdWwoIGFtcGxpdHVkZSApO1xuZXhwb3J0IGNvbnN0IG14X2ZyYWN0YWxfbm9pc2VfdmVjMyA9ICggcG9zaXRpb24gPSB1digpLCBvY3RhdmVzID0gMywgbGFjdW5hcml0eSA9IDIsIGRpbWluaXNoID0gLjUsIGFtcGxpdHVkZSA9IDEgKSA9PiBmcmFjdGFsX25vaXNlX3ZlYzMoIHBvc2l0aW9uLCBpbnQoIG9jdGF2ZXMgKSwgbGFjdW5hcml0eSwgZGltaW5pc2ggKS5tdWwoIGFtcGxpdHVkZSApO1xuZXhwb3J0IGNvbnN0IG14X2ZyYWN0YWxfbm9pc2VfdmVjNCA9ICggcG9zaXRpb24gPSB1digpLCBvY3RhdmVzID0gMywgbGFjdW5hcml0eSA9IDIsIGRpbWluaXNoID0gLjUsIGFtcGxpdHVkZSA9IDEgKSA9PiBmcmFjdGFsX25vaXNlX3ZlYzQoIHBvc2l0aW9uLCBpbnQoIG9jdGF2ZXMgKSwgbGFjdW5hcml0eSwgZGltaW5pc2ggKS5tdWwoIGFtcGxpdHVkZSApO1xuXG5leHBvcnQgeyBteF9oc3Z0b3JnYiwgbXhfcmdidG9oc3YsIG14X3NyZ2JfdGV4dHVyZV90b19saW5fcmVjNzA5IH07XG4iLCJpbXBvcnQgeyBwb3NpdGlvbldvcmxkIH0gZnJvbSAnLi4vLi4vYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IGZsb2F0LCBGbiwgbWluLCBub3JtYWxpemUsIHN1YiwgdmVjMyB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcblxuLy8gaHR0cHM6Ly9kZXZsb2ctbWFydGluc2guYmxvZ3Nwb3QuY29tLzIwMTEvMDkvYm94LXByb2plY3RlZC1jdWJlLWVudmlyb25tZW50LW1hcHBpbmcuaHRtbFxuXG5jb25zdCBnZXRQYXJhbGxheENvcnJlY3ROb3JtYWwgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgbm9ybWFsLCBjdWJlU2l6ZSwgY3ViZVBvcyBdICkgPT4ge1xuXG5cdGNvbnN0IG5EaXIgPSBub3JtYWxpemUoIG5vcm1hbCApLnRvVmFyKCAnbkRpcicgKTtcblx0Y29uc3QgcmJtYXggPSBzdWIoIGZsb2F0KCAwLjUgKS5tdWwoIGN1YmVTaXplLnN1YiggY3ViZVBvcyApICksIHBvc2l0aW9uV29ybGQgKS5kaXYoIG5EaXIgKS50b1ZhciggJ3JibWF4JyApO1xuXHRjb25zdCByYm1pbiA9IHN1YiggZmxvYXQoIC0gMC41ICkubXVsKCBjdWJlU2l6ZS5zdWIoIGN1YmVQb3MgKSApLCBwb3NpdGlvbldvcmxkICkuZGl2KCBuRGlyICkudG9WYXIoICdyYm1pbicgKTtcblx0Y29uc3QgcmJtaW5tYXggPSB2ZWMzKCkudG9WYXIoICdyYm1pbm1heCcgKTtcblx0cmJtaW5tYXgueCA9IG5EaXIueC5ncmVhdGVyVGhhbiggZmxvYXQoIDAgKSApLnNlbGVjdCggcmJtYXgueCwgcmJtaW4ueCApO1xuXHRyYm1pbm1heC55ID0gbkRpci55LmdyZWF0ZXJUaGFuKCBmbG9hdCggMCApICkuc2VsZWN0KCByYm1heC55LCByYm1pbi55ICk7XG5cdHJibWlubWF4LnogPSBuRGlyLnouZ3JlYXRlclRoYW4oIGZsb2F0KCAwICkgKS5zZWxlY3QoIHJibWF4LnosIHJibWluLnogKTtcblxuXHRjb25zdCBjb3JyZWN0aW9uID0gbWluKCBtaW4oIHJibWlubWF4LngsIHJibWlubWF4LnkgKSwgcmJtaW5tYXgueiApLnRvVmFyKCAnY29ycmVjdGlvbicgKTtcblx0Y29uc3QgYm94SW50ZXJzZWN0aW9uID0gcG9zaXRpb25Xb3JsZC5hZGQoIG5EaXIubXVsKCBjb3JyZWN0aW9uICkgKS50b1ZhciggJ2JveEludGVyc2VjdGlvbicgKTtcblx0cmV0dXJuIGJveEludGVyc2VjdGlvbi5zdWIoIGN1YmVQb3MgKTtcblxufSApO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRQYXJhbGxheENvcnJlY3ROb3JtYWw7XG4iLCJpbXBvcnQgeyBGbiwgbXVsIH0gZnJvbSAnLi4vLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5jb25zdCBnZXRTaElycmFkaWFuY2VBdCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBub3JtYWwsIHNoQ29lZmZpY2llbnRzIF0gKSA9PiB7XG5cblx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdGNvbnN0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XG5cblx0Ly8gYmFuZCAwXG5cdGxldCByZXN1bHQgPSBzaENvZWZmaWNpZW50cy5lbGVtZW50KCAwICkubXVsKCAwLjg4NjIyNyApO1xuXG5cdC8vIGJhbmQgMVxuXHRyZXN1bHQgPSByZXN1bHQuYWRkKCBzaENvZWZmaWNpZW50cy5lbGVtZW50KCAxICkubXVsKCAyLjAgKiAwLjUxMTY2NCApLm11bCggeSApICk7XG5cdHJlc3VsdCA9IHJlc3VsdC5hZGQoIHNoQ29lZmZpY2llbnRzLmVsZW1lbnQoIDIgKS5tdWwoIDIuMCAqIDAuNTExNjY0ICkubXVsKCB6ICkgKTtcblx0cmVzdWx0ID0gcmVzdWx0LmFkZCggc2hDb2VmZmljaWVudHMuZWxlbWVudCggMyApLm11bCggMi4wICogMC41MTE2NjQgKS5tdWwoIHggKSApO1xuXG5cdC8vIGJhbmQgMlxuXHRyZXN1bHQgPSByZXN1bHQuYWRkKCBzaENvZWZmaWNpZW50cy5lbGVtZW50KCA0ICkubXVsKCAyLjAgKiAwLjQyOTA0MyApLm11bCggeCApLm11bCggeSApICk7XG5cdHJlc3VsdCA9IHJlc3VsdC5hZGQoIHNoQ29lZmZpY2llbnRzLmVsZW1lbnQoIDUgKS5tdWwoIDIuMCAqIDAuNDI5MDQzICkubXVsKCB5ICkubXVsKCB6ICkgKTtcblx0cmVzdWx0ID0gcmVzdWx0LmFkZCggc2hDb2VmZmljaWVudHMuZWxlbWVudCggNiApLm11bCggei5tdWwoIHogKS5tdWwoIDAuNzQzMTI1ICkuc3ViKCAwLjI0NzcwOCApICkgKTtcblx0cmVzdWx0ID0gcmVzdWx0LmFkZCggc2hDb2VmZmljaWVudHMuZWxlbWVudCggNyApLm11bCggMi4wICogMC40MjkwNDMgKS5tdWwoIHggKS5tdWwoIHogKSApO1xuXHRyZXN1bHQgPSByZXN1bHQuYWRkKCBzaENvZWZmaWNpZW50cy5lbGVtZW50KCA4ICkubXVsKCAwLjQyOTA0MyApLm11bCggbXVsKCB4LCB4ICkuc3ViKCBtdWwoIHksIHkgKSApICkgKTtcblxuXHRyZXR1cm4gcmVzdWx0O1xuXG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFNoSXJyYWRpYW5jZUF0O1xuIiwiLy8gY29uc3RhbnRzXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvY29uc3RhbnRzLmpzJztcblxuLy8gY29yZVxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL0Fzc2lnbk5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL0F0dHJpYnV0ZU5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL0J5cGFzc05vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL0NhY2hlTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvQ29udGV4dE5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL0luZGV4Tm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvUGFyYW1ldGVyTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9TdGFja05vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL1VuaWZvcm1Hcm91cE5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9WYXJ5aW5nTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvT3V0cHV0U3RydWN0Tm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvTVJUTm9kZS5qcyc7XG5cbi8vIG1hdGhcbmV4cG9ydCAqIGZyb20gJy4vbWF0aC9IYXNoLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbWF0aC9NYXRoVXRpbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9tYXRoL1RyaU5vaXNlM0QuanMnO1xuXG4vLyB1dGlsc1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9FcXVpcmVjdFVWTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL0Z1bmN0aW9uT3ZlcmxvYWRpbmdOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvTG9vcE5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9NYXRjYXBVVk5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9NYXhNaXBMZXZlbE5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9Pc2NpbGxhdG9ycy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL1BhY2tpbmcuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9SZW1hcE5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9VVlV0aWxzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvU3ByaXRlVXRpbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9WaWV3cG9ydFV0aWxzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvUm90YXRlTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL1Nwcml0ZVNoZWV0VVZOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvVGltZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9UcmlwbGFuYXJUZXh0dXJlc05vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9SZWZsZWN0b3JOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvUlRUTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL1Bvc3RQcm9jZXNzaW5nVXRpbHMuanMnO1xuXG4vLyB0aHJlZS5qcyBzaGFkaW5nIGxhbmd1YWdlXG5leHBvcnQgKiBmcm9tICcuL3RzbC9UU0xCYXNlLmpzJztcblxuLy8gYWNjZXNzb3JzXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9BY2Nlc3NvcnNVdGlscy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9BcnJheXMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvVW5pZm9ybUFycmF5Tm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9CaXRhbmdlbnQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvQnVmZmVyQXR0cmlidXRlTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9CdWZmZXJOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL0NhbWVyYS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9WZXJ0ZXhDb2xvck5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvQ3ViZVRleHR1cmVOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL0luc3RhbmNlTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9JbnN0YW5jZWRNZXNoTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9CYXRjaE5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvTWF0ZXJpYWxOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL01hdGVyaWFsUHJvcGVydGllcy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9NYXRlcmlhbFJlZmVyZW5jZU5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvUmVuZGVyZXJSZWZlcmVuY2VOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL01vcnBoTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9UZXh0dXJlQmljdWJpYy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9Nb2RlbE5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvTW9kZWxWaWV3UHJvamVjdGlvbk5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL09iamVjdDNETm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9Qb2ludFVWTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9SZWZlcmVuY2VOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL1JlZmxlY3RWZWN0b3IuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvU2tpbm5pbmdOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL1NjZW5lTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9TdG9yYWdlQnVmZmVyTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9UYW5nZW50LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL1RleHR1cmVTaXplTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9TdG9yYWdlVGV4dHVyZU5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvVGV4dHVyZTNETm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9VVi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9Vc2VyRGF0YU5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvVmVsb2NpdHlOb2RlLmpzJztcblxuLy8gZGlzcGxheVxuZXhwb3J0ICogZnJvbSAnLi9kaXNwbGF5L0JsZW5kTW9kZXMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9kaXNwbGF5L0J1bXBNYXBOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZGlzcGxheS9Db2xvckFkanVzdG1lbnQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9kaXNwbGF5L0NvbG9yU3BhY2VOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZGlzcGxheS9Gcm9udEZhY2luZ05vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9kaXNwbGF5L05vcm1hbE1hcE5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9kaXNwbGF5L1Bvc3Rlcml6ZU5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9kaXNwbGF5L1RvbmVNYXBwaW5nTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvU2NyZWVuTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvVmlld3BvcnRUZXh0dXJlTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvVmlld3BvcnRTaGFyZWRUZXh0dXJlTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvVmlld3BvcnREZXB0aFRleHR1cmVOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZGlzcGxheS9WaWV3cG9ydERlcHRoTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvUmVuZGVyT3V0cHV0Tm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvVG9vbk91dGxpbmVQYXNzTm9kZS5qcyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vZGlzcGxheS9QYXNzTm9kZS5qcyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vZGlzcGxheS9Db2xvclNwYWNlRnVuY3Rpb25zLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZGlzcGxheS9Ub25lTWFwcGluZ0Z1bmN0aW9ucy5qcyc7XG5cbi8vIGNvZGVcbmV4cG9ydCAqIGZyb20gJy4vY29kZS9FeHByZXNzaW9uTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvZGUvQ29kZU5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb2RlL0Z1bmN0aW9uQ2FsbE5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb2RlL0Z1bmN0aW9uTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvZGUvU2NyaXB0YWJsZU5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb2RlL1NjcmlwdGFibGVWYWx1ZU5vZGUuanMnO1xuXG4vLyBmb2dcbmV4cG9ydCAqIGZyb20gJy4vZm9nL0ZvZ05vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9mb2cvRm9nUmFuZ2VOb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZm9nL0ZvZ0V4cDJOb2RlLmpzJztcblxuLy8gZ2VvbWV0cnlcbmV4cG9ydCAqIGZyb20gJy4vZ2VvbWV0cnkvUmFuZ2VOb2RlLmpzJztcblxuLy8gZ3BncHVcbmV4cG9ydCAqIGZyb20gJy4vZ3BncHUvQ29tcHV0ZU5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9ncGdwdS9Db21wdXRlQnVpbHRpbk5vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9ncGdwdS9CYXJyaWVyTm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2dwZ3B1L1dvcmtncm91cEluZm9Ob2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZ3BncHUvQXRvbWljRnVuY3Rpb25Ob2RlLmpzJztcblxuLy8gbGlnaHRpbmdcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL0xpZ2h0cy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpZ2h0aW5nL0xpZ2h0c05vZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWdodGluZy9MaWdodGluZ0NvbnRleHROb2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbGlnaHRpbmcvU2hhZG93Tm9kZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpZ2h0aW5nL1BvaW50TGlnaHROb2RlLmpzJztcblxuLy8gcG1yZW1cbmV4cG9ydCAqIGZyb20gJy4vcG1yZW0vUE1SRU1Ob2RlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcG1yZW0vUE1SRU1VdGlscy5qcyc7XG5cbi8vIHByb2NlZHVyYWxcbmV4cG9ydCAqIGZyb20gJy4vcHJvY2VkdXJhbC9DaGVja2VyLmpzJztcblxuLy8gbWF0ZXJpYWxYXG5leHBvcnQgKiBmcm9tICcuL21hdGVyaWFseC9NYXRlcmlhbFhOb2Rlcy5qcyc7XG5cbi8vIGZ1bmN0aW9uc1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCUkRGX0dHWCB9IGZyb20gJy4vZnVuY3Rpb25zL0JTREYvQlJERl9HR1guanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCUkRGX0xhbWJlcnQgfSBmcm9tICcuL2Z1bmN0aW9ucy9CU0RGL0JSREZfTGFtYmVydC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERfR0dYIH0gZnJvbSAnLi9mdW5jdGlvbnMvQlNERi9EX0dHWC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERGR0FwcHJveCB9IGZyb20gJy4vZnVuY3Rpb25zL0JTREYvREZHQXBwcm94LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRl9TY2hsaWNrIH0gZnJvbSAnLi9mdW5jdGlvbnMvQlNERi9GX1NjaGxpY2suanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTY2hsaWNrX3RvX0YwIH0gZnJvbSAnLi9mdW5jdGlvbnMvQlNERi9TY2hsaWNrX3RvX0YwLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVl9HR1hfU21pdGhDb3JyZWxhdGVkIH0gZnJvbSAnLi9mdW5jdGlvbnMvQlNERi9WX0dHWF9TbWl0aENvcnJlbGF0ZWQuanMnO1xuXG5leHBvcnQgKiBmcm9tICcuL2xpZ2h0aW5nL0xpZ2h0VXRpbHMuanMnO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIGdldEdlb21ldHJ5Um91Z2huZXNzIH0gZnJvbSAnLi9mdW5jdGlvbnMvbWF0ZXJpYWwvZ2V0R2VvbWV0cnlSb3VnaG5lc3MuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBnZXRQYXJhbGxheENvcnJlY3ROb3JtYWwgfSBmcm9tICcuL2Z1bmN0aW9ucy9tYXRlcmlhbC9nZXRQYXJhbGxheENvcnJlY3ROb3JtYWwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBnZXRSb3VnaG5lc3MgfSBmcm9tICcuL2Z1bmN0aW9ucy9tYXRlcmlhbC9nZXRSb3VnaG5lc3MuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBnZXRTaElycmFkaWFuY2VBdCB9IGZyb20gJy4vZnVuY3Rpb25zL21hdGVyaWFsL2dldFNoSXJyYWRpYW5jZUF0LmpzJztcbiIsImltcG9ydCBEYXRhTWFwIGZyb20gJy4vRGF0YU1hcC5qcyc7XG5pbXBvcnQgQ29sb3I0IGZyb20gJy4vQ29sb3I0LmpzJztcbmltcG9ydCB7IHZlYzQsIGNvbnRleHQsIG5vcm1hbFdvcmxkLCBiYWNrZ3JvdW5kQmx1cnJpbmVzcywgYmFja2dyb3VuZEludGVuc2l0eSwgYmFja2dyb3VuZFJvdGF0aW9uLCBtb2RlbFZpZXdQcm9qZWN0aW9uIH0gZnJvbSAnLi4vLi4vbm9kZXMvVFNMLmpzJztcbmltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi4vLi4vbWF0ZXJpYWxzL25vZGVzL05vZGVNYXRlcmlhbC5qcyc7XG5cbmltcG9ydCB7IE1lc2ggfSBmcm9tICcuLi8uLi9vYmplY3RzL01lc2guanMnO1xuaW1wb3J0IHsgU3BoZXJlR2VvbWV0cnkgfSBmcm9tICcuLi8uLi9nZW9tZXRyaWVzL1NwaGVyZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEJhY2tTaWRlLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IF9jbGVhckNvbG9yID0gLypAX19QVVJFX18qLyBuZXcgQ29sb3I0KCk7XG5cbmNsYXNzIEJhY2tncm91bmQgZXh0ZW5kcyBEYXRhTWFwIHtcblxuXHRjb25zdHJ1Y3RvciggcmVuZGVyZXIsIG5vZGVzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblx0XHR0aGlzLm5vZGVzID0gbm9kZXM7XG5cblx0fVxuXG5cdHVwZGF0ZSggc2NlbmUsIHJlbmRlckxpc3QsIHJlbmRlckNvbnRleHQgKSB7XG5cblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cdFx0Y29uc3QgYmFja2dyb3VuZCA9IHRoaXMubm9kZXMuZ2V0QmFja2dyb3VuZE5vZGUoIHNjZW5lICkgfHwgc2NlbmUuYmFja2dyb3VuZDtcblxuXHRcdGxldCBmb3JjZUNsZWFyID0gZmFsc2U7XG5cblx0XHRpZiAoIGJhY2tncm91bmQgPT09IG51bGwgKSB7XG5cblx0XHRcdC8vIG5vIGJhY2tncm91bmQgc2V0dGluZ3MsIHVzZSBjbGVhciBjb2xvciBjb25maWd1cmF0aW9uIGZyb20gdGhlIHJlbmRlcmVyXG5cblx0XHRcdHJlbmRlcmVyLl9jbGVhckNvbG9yLmdldFJHQiggX2NsZWFyQ29sb3IsIExpbmVhclNSR0JDb2xvclNwYWNlICk7XG5cdFx0XHRfY2xlYXJDb2xvci5hID0gcmVuZGVyZXIuX2NsZWFyQ29sb3IuYTtcblxuXHRcdH0gZWxzZSBpZiAoIGJhY2tncm91bmQuaXNDb2xvciA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Ly8gYmFja2dyb3VuZCBpcyBhbiBvcGFxdWUgY29sb3JcblxuXHRcdFx0YmFja2dyb3VuZC5nZXRSR0IoIF9jbGVhckNvbG9yLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSApO1xuXHRcdFx0X2NsZWFyQ29sb3IuYSA9IDE7XG5cblx0XHRcdGZvcmNlQ2xlYXIgPSB0cnVlO1xuXG5cdFx0fSBlbHNlIGlmICggYmFja2dyb3VuZC5pc05vZGUgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IHNjZW5lRGF0YSA9IHRoaXMuZ2V0KCBzY2VuZSApO1xuXHRcdFx0Y29uc3QgYmFja2dyb3VuZE5vZGUgPSBiYWNrZ3JvdW5kO1xuXG5cdFx0XHRfY2xlYXJDb2xvci5jb3B5KCByZW5kZXJlci5fY2xlYXJDb2xvciApO1xuXG5cdFx0XHRsZXQgYmFja2dyb3VuZE1lc2ggPSBzY2VuZURhdGEuYmFja2dyb3VuZE1lc2g7XG5cblx0XHRcdGlmICggYmFja2dyb3VuZE1lc2ggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zdCBiYWNrZ3JvdW5kTWVzaE5vZGUgPSBjb250ZXh0KCB2ZWM0KCBiYWNrZ3JvdW5kTm9kZSApLm11bCggYmFja2dyb3VuZEludGVuc2l0eSApLCB7XG5cdFx0XHRcdFx0Ly8gQFRPRE86IEFkZCBUZXh0dXJlMkQgc3VwcG9ydCB1c2luZyBub2RlIGNvbnRleHRcblx0XHRcdFx0XHRnZXRVVjogKCkgPT4gYmFja2dyb3VuZFJvdGF0aW9uLm11bCggbm9ybWFsV29ybGQgKSxcblx0XHRcdFx0XHRnZXRUZXh0dXJlTGV2ZWw6ICgpID0+IGJhY2tncm91bmRCbHVycmluZXNzXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRsZXQgdmlld1Byb2ogPSBtb2RlbFZpZXdQcm9qZWN0aW9uKCk7XG5cdFx0XHRcdHZpZXdQcm9qID0gdmlld1Byb2ouc2V0Wiggdmlld1Byb2oudyApO1xuXG5cdFx0XHRcdGNvbnN0IG5vZGVNYXRlcmlhbCA9IG5ldyBOb2RlTWF0ZXJpYWwoKTtcblx0XHRcdFx0bm9kZU1hdGVyaWFsLm5hbWUgPSAnQmFja2dyb3VuZC5tYXRlcmlhbCc7XG5cdFx0XHRcdG5vZGVNYXRlcmlhbC5zaWRlID0gQmFja1NpZGU7XG5cdFx0XHRcdG5vZGVNYXRlcmlhbC5kZXB0aFRlc3QgPSBmYWxzZTtcblx0XHRcdFx0bm9kZU1hdGVyaWFsLmRlcHRoV3JpdGUgPSBmYWxzZTtcblx0XHRcdFx0bm9kZU1hdGVyaWFsLmZvZyA9IGZhbHNlO1xuXHRcdFx0XHRub2RlTWF0ZXJpYWwubGlnaHRzID0gZmFsc2U7XG5cdFx0XHRcdG5vZGVNYXRlcmlhbC52ZXJ0ZXhOb2RlID0gdmlld1Byb2o7XG5cdFx0XHRcdG5vZGVNYXRlcmlhbC5jb2xvck5vZGUgPSBiYWNrZ3JvdW5kTWVzaE5vZGU7XG5cblx0XHRcdFx0c2NlbmVEYXRhLmJhY2tncm91bmRNZXNoTm9kZSA9IGJhY2tncm91bmRNZXNoTm9kZTtcblx0XHRcdFx0c2NlbmVEYXRhLmJhY2tncm91bmRNZXNoID0gYmFja2dyb3VuZE1lc2ggPSBuZXcgTWVzaCggbmV3IFNwaGVyZUdlb21ldHJ5KCAxLCAzMiwgMzIgKSwgbm9kZU1hdGVyaWFsICk7XG5cdFx0XHRcdGJhY2tncm91bmRNZXNoLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcblx0XHRcdFx0YmFja2dyb3VuZE1lc2gubmFtZSA9ICdCYWNrZ3JvdW5kLm1lc2gnO1xuXG5cdFx0XHRcdGJhY2tncm91bmRNZXNoLm9uQmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSApIHtcblxuXHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weVBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGJhY2tncm91bmRDYWNoZUtleSA9IGJhY2tncm91bmROb2RlLmdldENhY2hlS2V5KCk7XG5cblx0XHRcdGlmICggc2NlbmVEYXRhLmJhY2tncm91bmRDYWNoZUtleSAhPT0gYmFja2dyb3VuZENhY2hlS2V5ICkge1xuXG5cdFx0XHRcdHNjZW5lRGF0YS5iYWNrZ3JvdW5kTWVzaE5vZGUubm9kZSA9IHZlYzQoIGJhY2tncm91bmROb2RlICkubXVsKCBiYWNrZ3JvdW5kSW50ZW5zaXR5ICk7XG5cdFx0XHRcdHNjZW5lRGF0YS5iYWNrZ3JvdW5kTWVzaE5vZGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdGJhY2tncm91bmRNZXNoLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRzY2VuZURhdGEuYmFja2dyb3VuZENhY2hlS2V5ID0gYmFja2dyb3VuZENhY2hlS2V5O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJlbmRlckxpc3QudW5zaGlmdCggYmFja2dyb3VuZE1lc2gsIGJhY2tncm91bmRNZXNoLmdlb21ldHJ5LCBiYWNrZ3JvdW5kTWVzaC5tYXRlcmlhbCwgMCwgMCwgbnVsbCwgbnVsbCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlJlbmRlcmVyOiBVbnN1cHBvcnRlZCBiYWNrZ3JvdW5kIGNvbmZpZ3VyYXRpb24uJywgYmFja2dyb3VuZCApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGlmICggcmVuZGVyZXIuYXV0b0NsZWFyID09PSB0cnVlIHx8IGZvcmNlQ2xlYXIgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IGNsZWFyQ29sb3JWYWx1ZSA9IHJlbmRlckNvbnRleHQuY2xlYXJDb2xvclZhbHVlO1xuXG5cdFx0XHRjbGVhckNvbG9yVmFsdWUuciA9IF9jbGVhckNvbG9yLnI7XG5cdFx0XHRjbGVhckNvbG9yVmFsdWUuZyA9IF9jbGVhckNvbG9yLmc7XG5cdFx0XHRjbGVhckNvbG9yVmFsdWUuYiA9IF9jbGVhckNvbG9yLmI7XG5cdFx0XHRjbGVhckNvbG9yVmFsdWUuYSA9IF9jbGVhckNvbG9yLmE7XG5cblx0XHRcdC8vIHByZW11bHRpcGx5IGFscGhhXG5cblx0XHRcdGlmICggcmVuZGVyZXIuYmFja2VuZC5pc1dlYkdMQmFja2VuZCA9PT0gdHJ1ZSB8fCByZW5kZXJlci5hbHBoYSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRjbGVhckNvbG9yVmFsdWUuciAqPSBjbGVhckNvbG9yVmFsdWUuYTtcblx0XHRcdFx0Y2xlYXJDb2xvclZhbHVlLmcgKj0gY2xlYXJDb2xvclZhbHVlLmE7XG5cdFx0XHRcdGNsZWFyQ29sb3JWYWx1ZS5iICo9IGNsZWFyQ29sb3JWYWx1ZS5hO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdHJlbmRlckNvbnRleHQuZGVwdGhDbGVhclZhbHVlID0gcmVuZGVyZXIuX2NsZWFyRGVwdGg7XG5cdFx0XHRyZW5kZXJDb250ZXh0LnN0ZW5jaWxDbGVhclZhbHVlID0gcmVuZGVyZXIuX2NsZWFyU3RlbmNpbDtcblxuXHRcdFx0cmVuZGVyQ29udGV4dC5jbGVhckNvbG9yID0gcmVuZGVyZXIuYXV0b0NsZWFyQ29sb3IgPT09IHRydWU7XG5cdFx0XHRyZW5kZXJDb250ZXh0LmNsZWFyRGVwdGggPSByZW5kZXJlci5hdXRvQ2xlYXJEZXB0aCA9PT0gdHJ1ZTtcblx0XHRcdHJlbmRlckNvbnRleHQuY2xlYXJTdGVuY2lsID0gcmVuZGVyZXIuYXV0b0NsZWFyU3RlbmNpbCA9PT0gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlbmRlckNvbnRleHQuY2xlYXJDb2xvciA9IGZhbHNlO1xuXHRcdFx0cmVuZGVyQ29udGV4dC5jbGVhckRlcHRoID0gZmFsc2U7XG5cdFx0XHRyZW5kZXJDb250ZXh0LmNsZWFyU3RlbmNpbCA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCYWNrZ3JvdW5kO1xuIiwibGV0IF9pZCA9IDA7XG5cbmNsYXNzIEJpbmRHcm91cCB7XG5cblx0Y29uc3RydWN0b3IoIG5hbWUgPSAnJywgYmluZGluZ3MgPSBbXSwgaW5kZXggPSAwLCBiaW5kaW5nc1JlZmVyZW5jZSA9IFtdICkge1xuXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR0aGlzLmJpbmRpbmdzID0gYmluZGluZ3M7XG5cdFx0dGhpcy5pbmRleCA9IGluZGV4O1xuXHRcdHRoaXMuYmluZGluZ3NSZWZlcmVuY2UgPSBiaW5kaW5nc1JlZmVyZW5jZTtcblxuXHRcdHRoaXMuaWQgPSBfaWQgKys7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJpbmRHcm91cDtcbiIsImltcG9ydCBCaW5kR3JvdXAgZnJvbSAnLi4vQmluZEdyb3VwLmpzJztcblxuY2xhc3MgTm9kZUJ1aWxkZXJTdGF0ZSB7XG5cblx0Y29uc3RydWN0b3IoIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIGNvbXB1dGVTaGFkZXIsIG5vZGVBdHRyaWJ1dGVzLCBiaW5kaW5ncywgdXBkYXRlTm9kZXMsIHVwZGF0ZUJlZm9yZU5vZGVzLCB1cGRhdGVBZnRlck5vZGVzLCBtb25pdG9yLCB0cmFuc2Zvcm1zID0gW10gKSB7XG5cblx0XHR0aGlzLnZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlcjtcblx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXI7XG5cdFx0dGhpcy5jb21wdXRlU2hhZGVyID0gY29tcHV0ZVNoYWRlcjtcblx0XHR0aGlzLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zO1xuXG5cdFx0dGhpcy5ub2RlQXR0cmlidXRlcyA9IG5vZGVBdHRyaWJ1dGVzO1xuXHRcdHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcblxuXHRcdHRoaXMudXBkYXRlTm9kZXMgPSB1cGRhdGVOb2Rlcztcblx0XHR0aGlzLnVwZGF0ZUJlZm9yZU5vZGVzID0gdXBkYXRlQmVmb3JlTm9kZXM7XG5cdFx0dGhpcy51cGRhdGVBZnRlck5vZGVzID0gdXBkYXRlQWZ0ZXJOb2RlcztcblxuXHRcdHRoaXMubW9uaXRvciA9IG1vbml0b3I7XG5cblx0XHR0aGlzLnVzZWRUaW1lcyA9IDA7XG5cblx0fVxuXG5cdGNyZWF0ZUJpbmRpbmdzKCkge1xuXG5cdFx0Y29uc3QgYmluZGluZ3MgPSBbXTtcblxuXHRcdGZvciAoIGNvbnN0IGluc3RhbmNlR3JvdXAgb2YgdGhpcy5iaW5kaW5ncyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcmVkID0gaW5zdGFuY2VHcm91cC5iaW5kaW5nc1sgMCBdLmdyb3VwTm9kZS5zaGFyZWQ7XG5cblx0XHRcdGlmICggc2hhcmVkICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdGNvbnN0IGJpbmRpbmdzR3JvdXAgPSBuZXcgQmluZEdyb3VwKCBpbnN0YW5jZUdyb3VwLm5hbWUsIFtdLCBpbnN0YW5jZUdyb3VwLmluZGV4LCBpbnN0YW5jZUdyb3VwICk7XG5cdFx0XHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmdzR3JvdXAgKTtcblxuXHRcdFx0XHRmb3IgKCBjb25zdCBpbnN0YW5jZUJpbmRpbmcgb2YgaW5zdGFuY2VHcm91cC5iaW5kaW5ncyApIHtcblxuXHRcdFx0XHRcdGJpbmRpbmdzR3JvdXAuYmluZGluZ3MucHVzaCggaW5zdGFuY2VCaW5kaW5nLmNsb25lKCkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YmluZGluZ3MucHVzaCggaW5zdGFuY2VHcm91cCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYmluZGluZ3M7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVCdWlsZGVyU3RhdGU7XG4iLCJjbGFzcyBOb2RlQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdHlwZSwgbm9kZSA9IG51bGwgKSB7XG5cblx0XHR0aGlzLmlzTm9kZUF0dHJpYnV0ZSA9IHRydWU7XG5cblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTm9kZUF0dHJpYnV0ZTtcbiIsImNsYXNzIE5vZGVVbmlmb3JtIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdHlwZSwgbm9kZSApIHtcblxuXHRcdHRoaXMuaXNOb2RlVW5pZm9ybSA9IHRydWU7XG5cblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5ub2RlID0gbm9kZS5nZXRTZWxmKCk7XG5cblx0fVxuXG5cdGdldCB2YWx1ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLm5vZGUudmFsdWU7XG5cblx0fVxuXG5cdHNldCB2YWx1ZSggdmFsICkge1xuXG5cdFx0dGhpcy5ub2RlLnZhbHVlID0gdmFsO1xuXG5cdH1cblxuXHRnZXQgaWQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlLmlkO1xuXG5cdH1cblxuXHRnZXQgZ3JvdXBOb2RlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9kZS5ncm91cE5vZGU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVVbmlmb3JtO1xuIiwiY2xhc3MgTm9kZVZhciB7XG5cblx0Y29uc3RydWN0b3IoIG5hbWUsIHR5cGUgKSB7XG5cblx0XHR0aGlzLmlzTm9kZVZhciA9IHRydWU7XG5cblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVWYXI7XG4iLCJpbXBvcnQgTm9kZVZhciBmcm9tICcuL05vZGVWYXIuanMnO1xuXG5jbGFzcyBOb2RlVmFyeWluZyBleHRlbmRzIE5vZGVWYXIge1xuXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0eXBlICkge1xuXG5cdFx0c3VwZXIoIG5hbWUsIHR5cGUgKTtcblxuXHRcdHRoaXMubmVlZHNJbnRlcnBvbGF0aW9uID0gZmFsc2U7XG5cblx0XHR0aGlzLmlzTm9kZVZhcnlpbmcgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlVmFyeWluZztcbiIsImNsYXNzIE5vZGVDb2RlIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdHlwZSwgY29kZSA9ICcnICkge1xuXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpc05vZGVDb2RlJywgeyB2YWx1ZTogdHJ1ZSB9ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVDb2RlO1xuIiwibGV0IGlkID0gMDtcblxuY2xhc3MgTm9kZUNhY2hlIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50ID0gbnVsbCApIHtcblxuXHRcdHRoaXMuaWQgPSBpZCArKztcblx0XHR0aGlzLm5vZGVzRGF0YSA9IG5ldyBXZWFrTWFwKCk7XG5cblx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuXHR9XG5cblx0Z2V0RGF0YSggbm9kZSApIHtcblxuXHRcdGxldCBkYXRhID0gdGhpcy5ub2Rlc0RhdGEuZ2V0KCBub2RlICk7XG5cblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0ZGF0YSA9IHRoaXMucGFyZW50LmdldERhdGEoIG5vZGUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRzZXREYXRhKCBub2RlLCBkYXRhICkge1xuXG5cdFx0dGhpcy5ub2Rlc0RhdGEuc2V0KCBub2RlLCBkYXRhICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVDYWNoZTtcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vbWF0aC9Db2xvci5qcyc7XG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRyaXgzLmpzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi8uLi9tYXRoL01hdHJpeDQuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xuXG5jbGFzcyBVbmlmb3JtIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdmFsdWUgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuXHRcdHRoaXMuYm91bmRhcnkgPSAwOyAvLyB1c2VkIHRvIGJ1aWxkIHRoZSB1bmlmb3JtIGJ1ZmZlciBhY2NvcmRpbmcgdG8gdGhlIFNURDE0MCBsYXlvdXRcblx0XHR0aGlzLml0ZW1TaXplID0gMDtcblxuXHRcdHRoaXMub2Zmc2V0ID0gMDsgLy8gdGhpcyBwcm9wZXJ0eSBpcyBzZXQgYnkgV2ViR1BVVW5pZm9ybXNHcm91cCBhbmQgbWFya3MgdGhlIHN0YXJ0IHBvc2l0aW9uIGluIHRoZSB1bmlmb3JtIGJ1ZmZlclxuXG5cdH1cblxuXHRzZXRWYWx1ZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cblx0fVxuXG5cdGdldFZhbHVlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cblx0fVxuXG59XG5cbmNsYXNzIE51bWJlclVuaWZvcm0gZXh0ZW5kcyBVbmlmb3JtIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdmFsdWUgPSAwICkge1xuXG5cdFx0c3VwZXIoIG5hbWUsIHZhbHVlICk7XG5cblx0XHR0aGlzLmlzTnVtYmVyVW5pZm9ybSA9IHRydWU7XG5cblx0XHR0aGlzLmJvdW5kYXJ5ID0gNDtcblx0XHR0aGlzLml0ZW1TaXplID0gMTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVmVjdG9yMlVuaWZvcm0gZXh0ZW5kcyBVbmlmb3JtIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdmFsdWUgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0c3VwZXIoIG5hbWUsIHZhbHVlICk7XG5cblx0XHR0aGlzLmlzVmVjdG9yMlVuaWZvcm0gPSB0cnVlO1xuXG5cdFx0dGhpcy5ib3VuZGFyeSA9IDg7XG5cdFx0dGhpcy5pdGVtU2l6ZSA9IDI7XG5cblx0fVxuXG59XG5cbmNsYXNzIFZlY3RvcjNVbmlmb3JtIGV4dGVuZHMgVW5pZm9ybSB7XG5cblx0Y29uc3RydWN0b3IoIG5hbWUsIHZhbHVlID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdHN1cGVyKCBuYW1lLCB2YWx1ZSApO1xuXG5cdFx0dGhpcy5pc1ZlY3RvcjNVbmlmb3JtID0gdHJ1ZTtcblxuXHRcdHRoaXMuYm91bmRhcnkgPSAxNjtcblx0XHR0aGlzLml0ZW1TaXplID0gMztcblxuXHR9XG5cbn1cblxuY2xhc3MgVmVjdG9yNFVuaWZvcm0gZXh0ZW5kcyBVbmlmb3JtIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdmFsdWUgPSBuZXcgVmVjdG9yNCgpICkge1xuXG5cdFx0c3VwZXIoIG5hbWUsIHZhbHVlICk7XG5cblx0XHR0aGlzLmlzVmVjdG9yNFVuaWZvcm0gPSB0cnVlO1xuXG5cdFx0dGhpcy5ib3VuZGFyeSA9IDE2O1xuXHRcdHRoaXMuaXRlbVNpemUgPSA0O1xuXG5cdH1cblxufVxuXG5jbGFzcyBDb2xvclVuaWZvcm0gZXh0ZW5kcyBVbmlmb3JtIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdmFsdWUgPSBuZXcgQ29sb3IoKSApIHtcblxuXHRcdHN1cGVyKCBuYW1lLCB2YWx1ZSApO1xuXG5cdFx0dGhpcy5pc0NvbG9yVW5pZm9ybSA9IHRydWU7XG5cblx0XHR0aGlzLmJvdW5kYXJ5ID0gMTY7XG5cdFx0dGhpcy5pdGVtU2l6ZSA9IDM7XG5cblx0fVxuXG59XG5cbmNsYXNzIE1hdHJpeDNVbmlmb3JtIGV4dGVuZHMgVW5pZm9ybSB7XG5cblx0Y29uc3RydWN0b3IoIG5hbWUsIHZhbHVlID0gbmV3IE1hdHJpeDMoKSApIHtcblxuXHRcdHN1cGVyKCBuYW1lLCB2YWx1ZSApO1xuXG5cdFx0dGhpcy5pc01hdHJpeDNVbmlmb3JtID0gdHJ1ZTtcblxuXHRcdHRoaXMuYm91bmRhcnkgPSA0ODtcblx0XHR0aGlzLml0ZW1TaXplID0gMTI7XG5cblx0fVxuXG59XG5cbmNsYXNzIE1hdHJpeDRVbmlmb3JtIGV4dGVuZHMgVW5pZm9ybSB7XG5cblx0Y29uc3RydWN0b3IoIG5hbWUsIHZhbHVlID0gbmV3IE1hdHJpeDQoKSApIHtcblxuXHRcdHN1cGVyKCBuYW1lLCB2YWx1ZSApO1xuXG5cdFx0dGhpcy5pc01hdHJpeDRVbmlmb3JtID0gdHJ1ZTtcblxuXHRcdHRoaXMuYm91bmRhcnkgPSA2NDtcblx0XHR0aGlzLml0ZW1TaXplID0gMTY7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7XG5cdE51bWJlclVuaWZvcm0sXG5cdFZlY3RvcjJVbmlmb3JtLCBWZWN0b3IzVW5pZm9ybSwgVmVjdG9yNFVuaWZvcm0sIENvbG9yVW5pZm9ybSxcblx0TWF0cml4M1VuaWZvcm0sIE1hdHJpeDRVbmlmb3JtXG59O1xuIiwiaW1wb3J0IHtcblx0TnVtYmVyVW5pZm9ybSwgVmVjdG9yMlVuaWZvcm0sIFZlY3RvcjNVbmlmb3JtLCBWZWN0b3I0VW5pZm9ybSxcblx0Q29sb3JVbmlmb3JtLCBNYXRyaXgzVW5pZm9ybSwgTWF0cml4NFVuaWZvcm1cbn0gZnJvbSAnLi4vVW5pZm9ybS5qcyc7XG5cbmNsYXNzIE51bWJlck5vZGVVbmlmb3JtIGV4dGVuZHMgTnVtYmVyVW5pZm9ybSB7XG5cblx0Y29uc3RydWN0b3IoIG5vZGVVbmlmb3JtICkge1xuXG5cdFx0c3VwZXIoIG5vZGVVbmlmb3JtLm5hbWUsIG5vZGVVbmlmb3JtLnZhbHVlICk7XG5cblx0XHR0aGlzLm5vZGVVbmlmb3JtID0gbm9kZVVuaWZvcm07XG5cblx0fVxuXG5cdGdldFZhbHVlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9kZVVuaWZvcm0udmFsdWU7XG5cblx0fVxuXG5cdGdldFR5cGUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS50eXBlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBWZWN0b3IyTm9kZVVuaWZvcm0gZXh0ZW5kcyBWZWN0b3IyVW5pZm9ybSB7XG5cblx0Y29uc3RydWN0b3IoIG5vZGVVbmlmb3JtICkge1xuXG5cdFx0c3VwZXIoIG5vZGVVbmlmb3JtLm5hbWUsIG5vZGVVbmlmb3JtLnZhbHVlICk7XG5cblx0XHR0aGlzLm5vZGVVbmlmb3JtID0gbm9kZVVuaWZvcm07XG5cblx0fVxuXG5cdGdldFZhbHVlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9kZVVuaWZvcm0udmFsdWU7XG5cblx0fVxuXG5cdGdldFR5cGUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS50eXBlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBWZWN0b3IzTm9kZVVuaWZvcm0gZXh0ZW5kcyBWZWN0b3IzVW5pZm9ybSB7XG5cblx0Y29uc3RydWN0b3IoIG5vZGVVbmlmb3JtICkge1xuXG5cdFx0c3VwZXIoIG5vZGVVbmlmb3JtLm5hbWUsIG5vZGVVbmlmb3JtLnZhbHVlICk7XG5cblx0XHR0aGlzLm5vZGVVbmlmb3JtID0gbm9kZVVuaWZvcm07XG5cblx0fVxuXG5cdGdldFZhbHVlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9kZVVuaWZvcm0udmFsdWU7XG5cblx0fVxuXG5cdGdldFR5cGUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS50eXBlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBWZWN0b3I0Tm9kZVVuaWZvcm0gZXh0ZW5kcyBWZWN0b3I0VW5pZm9ybSB7XG5cblx0Y29uc3RydWN0b3IoIG5vZGVVbmlmb3JtICkge1xuXG5cdFx0c3VwZXIoIG5vZGVVbmlmb3JtLm5hbWUsIG5vZGVVbmlmb3JtLnZhbHVlICk7XG5cblx0XHR0aGlzLm5vZGVVbmlmb3JtID0gbm9kZVVuaWZvcm07XG5cblx0fVxuXG5cdGdldFZhbHVlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9kZVVuaWZvcm0udmFsdWU7XG5cblx0fVxuXG5cdGdldFR5cGUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS50eXBlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBDb2xvck5vZGVVbmlmb3JtIGV4dGVuZHMgQ29sb3JVbmlmb3JtIHtcblxuXHRjb25zdHJ1Y3Rvciggbm9kZVVuaWZvcm0gKSB7XG5cblx0XHRzdXBlciggbm9kZVVuaWZvcm0ubmFtZSwgbm9kZVVuaWZvcm0udmFsdWUgKTtcblxuXHRcdHRoaXMubm9kZVVuaWZvcm0gPSBub2RlVW5pZm9ybTtcblxuXHR9XG5cblx0Z2V0VmFsdWUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS52YWx1ZTtcblxuXHR9XG5cblx0Z2V0VHlwZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLm5vZGVVbmlmb3JtLnR5cGU7XG5cblx0fVxuXG59XG5cbmNsYXNzIE1hdHJpeDNOb2RlVW5pZm9ybSBleHRlbmRzIE1hdHJpeDNVbmlmb3JtIHtcblxuXHRjb25zdHJ1Y3Rvciggbm9kZVVuaWZvcm0gKSB7XG5cblx0XHRzdXBlciggbm9kZVVuaWZvcm0ubmFtZSwgbm9kZVVuaWZvcm0udmFsdWUgKTtcblxuXHRcdHRoaXMubm9kZVVuaWZvcm0gPSBub2RlVW5pZm9ybTtcblxuXHR9XG5cblx0Z2V0VmFsdWUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS52YWx1ZTtcblxuXHR9XG5cblx0Z2V0VHlwZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLm5vZGVVbmlmb3JtLnR5cGU7XG5cblx0fVxuXG59XG5cbmNsYXNzIE1hdHJpeDROb2RlVW5pZm9ybSBleHRlbmRzIE1hdHJpeDRVbmlmb3JtIHtcblxuXHRjb25zdHJ1Y3Rvciggbm9kZVVuaWZvcm0gKSB7XG5cblx0XHRzdXBlciggbm9kZVVuaWZvcm0ubmFtZSwgbm9kZVVuaWZvcm0udmFsdWUgKTtcblxuXHRcdHRoaXMubm9kZVVuaWZvcm0gPSBub2RlVW5pZm9ybTtcblxuXHR9XG5cblx0Z2V0VmFsdWUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS52YWx1ZTtcblxuXHR9XG5cblx0Z2V0VHlwZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLm5vZGVVbmlmb3JtLnR5cGU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7XG5cdE51bWJlck5vZGVVbmlmb3JtLCBWZWN0b3IyTm9kZVVuaWZvcm0sIFZlY3RvcjNOb2RlVW5pZm9ybSwgVmVjdG9yNE5vZGVVbmlmb3JtLFxuXHRDb2xvck5vZGVVbmlmb3JtLCBNYXRyaXgzTm9kZVVuaWZvcm0sIE1hdHJpeDROb2RlVW5pZm9ybVxufTtcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi4vLi4vLi4vbWF0ZXJpYWxzL25vZGVzL05vZGVNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBnZXREaXJlY3Rpb24sIGJsdXIgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9wbXJlbS9QTVJFTVV0aWxzLmpzJztcbmltcG9ydCB7IGVxdWlyZWN0VVYgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy91dGlscy9FcXVpcmVjdFVWTm9kZS5qcyc7XG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvY29yZS9Vbmlmb3JtTm9kZS5qcyc7XG5pbXBvcnQgeyB1bmlmb3JtQXJyYXkgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvVW5pZm9ybUFycmF5Tm9kZS5qcyc7XG5pbXBvcnQgeyB0ZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcbmltcG9ydCB7IGN1YmVUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvYWNjZXNzb3JzL0N1YmVUZXh0dXJlTm9kZS5qcyc7XG5pbXBvcnQgeyBmbG9hdCwgdmVjMyB9IGZyb20gJy4uLy4uLy4uL25vZGVzL3RzbC9UU0xCYXNlLmpzJztcbmltcG9ydCB7IHV2IH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvYWNjZXNzb3JzL1VWLmpzJztcbmltcG9ydCB7IGF0dHJpYnV0ZSB9IGZyb20gJy4uLy4uLy4uL25vZGVzL2NvcmUvQXR0cmlidXRlTm9kZS5qcyc7XG5cbmltcG9ydCB7IE9ydGhvZ3JhcGhpY0NhbWVyYSB9IGZyb20gJy4uLy4uLy4uL2NhbWVyYXMvT3J0aG9ncmFwaGljQ2FtZXJhLmpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vbWF0aC9Db2xvci5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi8uLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBSZW5kZXJUYXJnZXQgfSBmcm9tICcuLi8uLi8uLi9jb3JlL1JlbmRlclRhcmdldC5qcyc7XG5pbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi4vLi4vLi4vb2JqZWN0cy9NZXNoLmpzJztcbmltcG9ydCB7IFBlcnNwZWN0aXZlQ2FtZXJhIH0gZnJvbSAnLi4vLi4vLi4vY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS5qcyc7XG5pbXBvcnQgeyBNZXNoQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uLy4uLy4uL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBCb3hHZW9tZXRyeSB9IGZyb20gJy4uLy4uLy4uL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanMnO1xuaW1wb3J0IHtcblx0Q3ViZVJlZmxlY3Rpb25NYXBwaW5nLFxuXHRDdWJlUmVmcmFjdGlvbk1hcHBpbmcsXG5cdEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLFxuXHRMaW5lYXJGaWx0ZXIsXG5cdE5vQmxlbmRpbmcsXG5cdFJHQkFGb3JtYXQsXG5cdEhhbGZGbG9hdFR5cGUsXG5cdEJhY2tTaWRlLFxuXHRMaW5lYXJTUkdCQ29sb3JTcGFjZVxufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuXG5jb25zdCBMT0RfTUlOID0gNDtcblxuLy8gVGhlIHN0YW5kYXJkIGRldmlhdGlvbnMgKHJhZGlhbnMpIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXh0cmEgbWlwcy4gVGhlc2UgYXJlXG4vLyBjaG9zZW4gdG8gYXBwcm94aW1hdGUgYSBUcm93YnJpZGdlLVJlaXR6IGRpc3RyaWJ1dGlvbiBmdW5jdGlvbiB0aW1lcyB0aGVcbi8vIGdlb21ldHJpYyBzaGFkb3dpbmcgZnVuY3Rpb24uIFRoZXNlIHNpZ21hIHZhbHVlcyBzcXVhcmVkIG11c3QgbWF0Y2ggdGhlXG4vLyB2YXJpYW5jZSAjZGVmaW5lcyBpbiBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQuZ2xzbC5qcy5cbmNvbnN0IEVYVFJBX0xPRF9TSUdNQSA9IFsgMC4xMjUsIDAuMjE1LCAwLjM1LCAwLjQ0NiwgMC41MjYsIDAuNTgyIF07XG5cbi8vIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgYmx1ciBmb3IgbG9vcC4gU21hbGxlciBzaWdtYXMgd2lsbCB1c2UgZmV3ZXJcbi8vIHNhbXBsZXMgYW5kIGV4aXQgZWFybHksIGJ1dCBub3QgcmVjb21waWxlIHRoZSBzaGFkZXIuXG5jb25zdCBNQVhfU0FNUExFUyA9IDIwO1xuXG5jb25zdCBfZmxhdENhbWVyYSA9IC8qQF9fUFVSRV9fKi8gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSAxLCAxLCAxLCAtIDEsIDAsIDEgKTtcbmNvbnN0IF9jdWJlQ2FtZXJhID0gLypAX19QVVJFX18qLyBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxICk7XG5jb25zdCBfY2xlYXJDb2xvciA9IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCk7XG5sZXQgX29sZFRhcmdldCA9IG51bGw7XG5sZXQgX29sZEFjdGl2ZUN1YmVGYWNlID0gMDtcbmxldCBfb2xkQWN0aXZlTWlwbWFwTGV2ZWwgPSAwO1xuXG4vLyBHb2xkZW4gUmF0aW9cbmNvbnN0IFBISSA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuY29uc3QgSU5WX1BISSA9IDEgLyBQSEk7XG5cbi8vIFZlcnRpY2VzIG9mIGEgZG9kZWNhaGVkcm9uIChleGNlcHQgdGhlIG9wcG9zaXRlcywgd2hpY2ggcmVwcmVzZW50IHRoZVxuLy8gc2FtZSBheGlzKSwgdXNlZCBhcyBheGlzIGRpcmVjdGlvbnMgZXZlbmx5IHNwcmVhZCBvbiBhIHNwaGVyZS5cbmNvbnN0IF9heGlzRGlyZWN0aW9ucyA9IFtcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggLSBQSEksIElOVl9QSEksIDAgKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggUEhJLCBJTlZfUEhJLCAwICksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIC0gSU5WX1BISSwgMCwgUEhJICksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIElOVl9QSEksIDAsIFBISSApLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCBQSEksIC0gSU5WX1BISSApLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCBQSEksIElOVl9QSEkgKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggLSAxLCAxLCAtIDEgKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMSwgMSwgLSAxICksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIC0gMSwgMSwgMSApLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAxLCAxLCAxIClcbl07XG5cbi8vXG5cbi8vIFdlYkdQVSBGYWNlIGluZGljZXNcbmNvbnN0IF9mYWNlTGliID0gW1xuXHQzLCAxLCA1LFxuXHQwLCA0LCAyXG5dO1xuXG5jb25zdCBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oIHV2KCksIGF0dHJpYnV0ZSggJ2ZhY2VJbmRleCcgKSApLm5vcm1hbGl6ZSgpO1xuY29uc3Qgb3V0cHV0RGlyZWN0aW9uID0gdmVjMyggZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55Lm5lZ2F0ZSgpLCBkaXJlY3Rpb24ueiApO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgZ2VuZXJhdGVzIGEgUHJlZmlsdGVyZWQsIE1pcG1hcHBlZCBSYWRpYW5jZSBFbnZpcm9ubWVudCBNYXBcbiAqIChQTVJFTSkgZnJvbSBhIGN1YmVNYXAgZW52aXJvbm1lbnQgdGV4dHVyZS4gVGhpcyBhbGxvd3MgZGlmZmVyZW50IGxldmVscyBvZlxuICogYmx1ciB0byBiZSBxdWlja2x5IGFjY2Vzc2VkIGJhc2VkIG9uIG1hdGVyaWFsIHJvdWdobmVzcy4gSXQgaXMgcGFja2VkIGludG8gYVxuICogc3BlY2lhbCBDdWJlVVYgZm9ybWF0IHRoYXQgYWxsb3dzIHVzIHRvIHBlcmZvcm0gY3VzdG9tIGludGVycG9sYXRpb24gc28gdGhhdFxuICogd2UgY2FuIHN1cHBvcnQgbm9ubGluZWFyIGZvcm1hdHMgc3VjaCBhcyBSR0JFLiBVbmxpa2UgYSB0cmFkaXRpb25hbCBtaXBtYXBcbiAqIGNoYWluLCBpdCBvbmx5IGdvZXMgZG93biB0byB0aGUgTE9EX01JTiBsZXZlbCAoYWJvdmUpLCBhbmQgdGhlbiBjcmVhdGVzIGV4dHJhXG4gKiBldmVuIG1vcmUgZmlsdGVyZWQgJ21pcHMnIGF0IHRoZSBzYW1lIExPRF9NSU4gcmVzb2x1dGlvbiwgYXNzb2NpYXRlZCB3aXRoXG4gKiBoaWdoZXIgcm91Z2huZXNzIGxldmVscy4gSW4gdGhpcyB3YXkgd2UgbWFpbnRhaW4gcmVzb2x1dGlvbiB0byBzbW9vdGhseVxuICogaW50ZXJwb2xhdGUgZGlmZnVzZSBsaWdodGluZyB3aGlsZSBsaW1pdGluZyBzYW1wbGluZyBjb21wdXRhdGlvbi5cbiAqXG4gKiBQYXBlcjogRmFzdCwgQWNjdXJhdGUgSW1hZ2UtQmFzZWQgTGlnaHRpbmdcbiAqIGh0dHBzOi8vZHJpdmUuZ29vZ2xlLmNvbS9maWxlL2QvMTV5OHJfVXBLbFU5U3ZWNElMYjBDM3FDUGVjUzhwdkx6L3ZpZXdcbiovXG5cbmNsYXNzIFBNUkVNR2VuZXJhdG9yIHtcblxuXHRjb25zdHJ1Y3RvciggcmVuZGVyZXIgKSB7XG5cblx0XHR0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuXHRcdHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuXHRcdHRoaXMuX2xvZE1heCA9IDA7XG5cdFx0dGhpcy5fY3ViZVNpemUgPSAwO1xuXHRcdHRoaXMuX2xvZFBsYW5lcyA9IFtdO1xuXHRcdHRoaXMuX3NpemVMb2RzID0gW107XG5cdFx0dGhpcy5fc2lnbWFzID0gW107XG5cdFx0dGhpcy5fbG9kTWVzaGVzID0gW107XG5cblx0XHR0aGlzLl9ibHVyTWF0ZXJpYWwgPSBudWxsO1xuXHRcdHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9IG51bGw7XG5cdFx0dGhpcy5fZXF1aXJlY3RNYXRlcmlhbCA9IG51bGw7XG5cdFx0dGhpcy5fYmFja2dyb3VuZEJveCA9IG51bGw7XG5cblx0fVxuXG5cdGdldCBfaGFzSW5pdGlhbGl6ZWQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fcmVuZGVyZXIuaGFzSW5pdGlhbGl6ZWQoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIFBNUkVNIGZyb20gYSBzdXBwbGllZCBTY2VuZSwgd2hpY2ggY2FuIGJlIGZhc3RlciB0aGFuIHVzaW5nIGFuXG5cdCAqIGltYWdlIGlmIG5ldHdvcmtpbmcgYmFuZHdpZHRoIGlzIGxvdy4gT3B0aW9uYWwgc2lnbWEgc3BlY2lmaWVzIGEgYmx1ciByYWRpdXNcblx0ICogaW4gcmFkaWFucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBzY2VuZSBiZWZvcmUgUE1SRU0gZ2VuZXJhdGlvbi4gT3B0aW9uYWwgbmVhclxuXHQgKiBhbmQgZmFyIHBsYW5lcyBlbnN1cmUgdGhlIHNjZW5lIGlzIHJlbmRlcmVkIGluIGl0cyBlbnRpcmV0eSAodGhlIGN1YmVDYW1lcmFcblx0ICogaXMgcGxhY2VkIGF0IHRoZSBvcmlnaW4pLlxuXHQgKi9cblx0ZnJvbVNjZW5lKCBzY2VuZSwgc2lnbWEgPSAwLCBuZWFyID0gMC4xLCBmYXIgPSAxMDAsIHJlbmRlclRhcmdldCA9IG51bGwgKSB7XG5cblx0XHR0aGlzLl9zZXRTaXplKCAyNTYgKTtcblxuXHRcdGlmICggdGhpcy5faGFzSW5pdGlhbGl6ZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5QTVJFTUdlbmVyYXRvcjogLmZyb21TY2VuZSgpIGNhbGxlZCBiZWZvcmUgdGhlIGJhY2tlbmQgaXMgaW5pdGlhbGl6ZWQuIFRyeSB1c2luZyAuZnJvbVNjZW5lQXN5bmMoKSBpbnN0ZWFkLicgKTtcblxuXHRcdFx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0IHx8IHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO1xuXG5cdFx0XHR0aGlzLmZyb21TY2VuZUFzeW5jKCBzY2VuZSwgc2lnbWEsIG5lYXIsIGZhciwgY3ViZVVWUmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG5cblx0XHR9XG5cblx0XHRfb2xkVGFyZ2V0ID0gdGhpcy5fcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdFx0X29sZEFjdGl2ZUN1YmVGYWNlID0gdGhpcy5fcmVuZGVyZXIuZ2V0QWN0aXZlQ3ViZUZhY2UoKTtcblx0XHRfb2xkQWN0aXZlTWlwbWFwTGV2ZWwgPSB0aGlzLl9yZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpO1xuXG5cdFx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0IHx8IHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO1xuXHRcdGN1YmVVVlJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9IHRydWU7XG5cblx0XHR0aGlzLl9zY2VuZVRvQ3ViZVVWKCBzY2VuZSwgbmVhciwgZmFyLCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblxuXHRcdGlmICggc2lnbWEgPiAwICkge1xuXG5cdFx0XHR0aGlzLl9ibHVyKCBjdWJlVVZSZW5kZXJUYXJnZXQsIDAsIDAsIHNpZ21hICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9hcHBseVBNUkVNKCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblxuXHRcdHRoaXMuX2NsZWFudXAoIGN1YmVVVlJlbmRlclRhcmdldCApO1xuXG5cdFx0cmV0dXJuIGN1YmVVVlJlbmRlclRhcmdldDtcblxuXHR9XG5cblx0YXN5bmMgZnJvbVNjZW5lQXN5bmMoIHNjZW5lLCBzaWdtYSA9IDAsIG5lYXIgPSAwLjEsIGZhciA9IDEwMCwgcmVuZGVyVGFyZ2V0ID0gbnVsbCApIHtcblxuXHRcdGlmICggdGhpcy5faGFzSW5pdGlhbGl6ZWQgPT09IGZhbHNlICkgYXdhaXQgdGhpcy5fcmVuZGVyZXIuaW5pdCgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZnJvbVNjZW5lKCBzY2VuZSwgc2lnbWEsIG5lYXIsIGZhciwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGFuIGVxdWlyZWN0YW5ndWxhciB0ZXh0dXJlLCB3aGljaCBjYW4gYmUgZWl0aGVyIExEUlxuXHQgKiBvciBIRFIuIFRoZSBpZGVhbCBpbnB1dCBpbWFnZSBzaXplIGlzIDFrICgxMDI0IHggNTEyKSxcblx0ICogYXMgdGhpcyBtYXRjaGVzIGJlc3Qgd2l0aCB0aGUgMjU2IHggMjU2IGN1YmVtYXAgb3V0cHV0LlxuXHQgKi9cblx0ZnJvbUVxdWlyZWN0YW5ndWxhciggZXF1aXJlY3Rhbmd1bGFyLCByZW5kZXJUYXJnZXQgPSBudWxsICkge1xuXG5cdFx0aWYgKCB0aGlzLl9oYXNJbml0aWFsaXplZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBNUkVNR2VuZXJhdG9yOiAuZnJvbUVxdWlyZWN0YW5ndWxhcigpIGNhbGxlZCBiZWZvcmUgdGhlIGJhY2tlbmQgaXMgaW5pdGlhbGl6ZWQuIFRyeSB1c2luZyAuZnJvbUVxdWlyZWN0YW5ndWxhckFzeW5jKCkgaW5zdGVhZC4nICk7XG5cblx0XHRcdHRoaXMuX3NldFNpemVGcm9tVGV4dHVyZSggZXF1aXJlY3Rhbmd1bGFyICk7XG5cblx0XHRcdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldCB8fCB0aGlzLl9hbGxvY2F0ZVRhcmdldHMoKTtcblxuXHRcdFx0dGhpcy5mcm9tRXF1aXJlY3Rhbmd1bGFyQXN5bmMoIGVxdWlyZWN0YW5ndWxhciwgY3ViZVVWUmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoIGVxdWlyZWN0YW5ndWxhciwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0fVxuXG5cdGFzeW5jIGZyb21FcXVpcmVjdGFuZ3VsYXJBc3luYyggZXF1aXJlY3Rhbmd1bGFyLCByZW5kZXJUYXJnZXQgPSBudWxsICkge1xuXG5cdFx0aWYgKCB0aGlzLl9oYXNJbml0aWFsaXplZCA9PT0gZmFsc2UgKSBhd2FpdCB0aGlzLl9yZW5kZXJlci5pbml0KCk7XG5cblx0XHRyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoIGVxdWlyZWN0YW5ndWxhciwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGFuIGN1YmVtYXAgdGV4dHVyZSwgd2hpY2ggY2FuIGJlIGVpdGhlciBMRFJcblx0ICogb3IgSERSLiBUaGUgaWRlYWwgaW5wdXQgY3ViZSBzaXplIGlzIDI1NiB4IDI1Nixcblx0ICogYXMgdGhpcyBtYXRjaGVzIGJlc3Qgd2l0aCB0aGUgMjU2IHggMjU2IGN1YmVtYXAgb3V0cHV0LlxuXHQgKi9cblx0ZnJvbUN1YmVtYXAoIGN1YmVtYXAsIHJlbmRlclRhcmdldCA9IG51bGwgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2hhc0luaXRpYWxpemVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUE1SRU1HZW5lcmF0b3I6IC5mcm9tQ3ViZW1hcCgpIGNhbGxlZCBiZWZvcmUgdGhlIGJhY2tlbmQgaXMgaW5pdGlhbGl6ZWQuIFRyeSB1c2luZyAuZnJvbUN1YmVtYXBBc3luYygpIGluc3RlYWQuJyApO1xuXG5cdFx0XHR0aGlzLl9zZXRTaXplRnJvbVRleHR1cmUoIGN1YmVtYXAgKTtcblxuXHRcdFx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0IHx8IHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO1xuXG5cdFx0XHR0aGlzLmZyb21DdWJlbWFwQXN5bmMoIGN1YmVtYXAsIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRyZXR1cm4gY3ViZVVWUmVuZGVyVGFyZ2V0O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX2Zyb21UZXh0dXJlKCBjdWJlbWFwLCByZW5kZXJUYXJnZXQgKTtcblxuXHR9XG5cblx0YXN5bmMgZnJvbUN1YmVtYXBBc3luYyggY3ViZW1hcCwgcmVuZGVyVGFyZ2V0ID0gbnVsbCApIHtcblxuXHRcdGlmICggdGhpcy5faGFzSW5pdGlhbGl6ZWQgPT09IGZhbHNlICkgYXdhaXQgdGhpcy5fcmVuZGVyZXIuaW5pdCgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2Zyb21UZXh0dXJlKCBjdWJlbWFwLCByZW5kZXJUYXJnZXQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFByZS1jb21waWxlcyB0aGUgY3ViZW1hcCBzaGFkZXIuIFlvdSBjYW4gZ2V0IGZhc3RlciBzdGFydC11cCBieSBpbnZva2luZyB0aGlzIG1ldGhvZCBkdXJpbmdcblx0ICogeW91ciB0ZXh0dXJlJ3MgbmV0d29yayBmZXRjaCBmb3IgaW5jcmVhc2VkIGNvbmN1cnJlbmN5LlxuXHQgKi9cblx0YXN5bmMgY29tcGlsZUN1YmVtYXBTaGFkZXIoKSB7XG5cblx0XHRpZiAoIHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fY3ViZW1hcE1hdGVyaWFsID0gX2dldEN1YmVtYXBNYXRlcmlhbCgpO1xuXHRcdFx0YXdhaXQgdGhpcy5fY29tcGlsZU1hdGVyaWFsKCB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFByZS1jb21waWxlcyB0aGUgZXF1aXJlY3Rhbmd1bGFyIHNoYWRlci4gWW91IGNhbiBnZXQgZmFzdGVyIHN0YXJ0LXVwIGJ5IGludm9raW5nIHRoaXMgbWV0aG9kIGR1cmluZ1xuXHQgKiB5b3VyIHRleHR1cmUncyBuZXR3b3JrIGZldGNoIGZvciBpbmNyZWFzZWQgY29uY3VycmVuY3kuXG5cdCAqL1xuXHRhc3luYyBjb21waWxlRXF1aXJlY3Rhbmd1bGFyU2hhZGVyKCkge1xuXG5cdFx0aWYgKCB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID0gX2dldEVxdWlyZWN0TWF0ZXJpYWwoKTtcblx0XHRcdGF3YWl0IHRoaXMuX2NvbXBpbGVNYXRlcmlhbCggdGhpcy5fZXF1aXJlY3RNYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogRGlzcG9zZXMgb2YgdGhlIFBNUkVNR2VuZXJhdG9yJ3MgaW50ZXJuYWwgbWVtb3J5LiBOb3RlIHRoYXQgUE1SRU1HZW5lcmF0b3IgaXMgYSBzdGF0aWMgY2xhc3MsXG5cdCAqIHNvIHlvdSBzaG91bGQgbm90IG5lZWQgbW9yZSB0aGFuIG9uZSBQTVJFTUdlbmVyYXRvciBvYmplY3QuIElmIHlvdSBkbywgY2FsbGluZyBkaXNwb3NlKCkgb25cblx0ICogb25lIG9mIHRoZW0gd2lsbCBjYXVzZSBhbnkgb3RoZXJzIHRvIGFsc28gYmVjb21lIHVudXNhYmxlLlxuXHQgKi9cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuX2Rpc3Bvc2UoKTtcblxuXHRcdGlmICggdGhpcy5fY3ViZW1hcE1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5fY3ViZW1hcE1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHRpZiAoIHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgIT09IG51bGwgKSB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHRpZiAoIHRoaXMuX2JhY2tncm91bmRCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2JhY2tncm91bmRCb3guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy5fYmFja2dyb3VuZEJveC5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIHByaXZhdGUgaW50ZXJmYWNlXG5cblx0X3NldFNpemVGcm9tVGV4dHVyZSggdGV4dHVyZSApIHtcblxuXHRcdGlmICggdGV4dHVyZS5tYXBwaW5nID09PSBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgfHwgdGV4dHVyZS5tYXBwaW5nID09PSBDdWJlUmVmcmFjdGlvbk1hcHBpbmcgKSB7XG5cblx0XHRcdHRoaXMuX3NldFNpemUoIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSAwID8gMTYgOiAoIHRleHR1cmUuaW1hZ2VbIDAgXS53aWR0aCB8fCB0ZXh0dXJlLmltYWdlWyAwIF0uaW1hZ2Uud2lkdGggKSApO1xuXG5cdFx0fSBlbHNlIHsgLy8gRXF1aXJlY3Rhbmd1bGFyXG5cblx0XHRcdHRoaXMuX3NldFNpemUoIHRleHR1cmUuaW1hZ2Uud2lkdGggLyA0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9zZXRTaXplKCBjdWJlU2l6ZSApIHtcblxuXHRcdHRoaXMuX2xvZE1heCA9IE1hdGguZmxvb3IoIE1hdGgubG9nMiggY3ViZVNpemUgKSApO1xuXHRcdHRoaXMuX2N1YmVTaXplID0gTWF0aC5wb3coIDIsIHRoaXMuX2xvZE1heCApO1xuXG5cdH1cblxuXHRfZGlzcG9zZSgpIHtcblxuXHRcdGlmICggdGhpcy5fYmx1ck1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5fYmx1ck1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHRcdGlmICggdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQgIT09IG51bGwgKSB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC5kaXNwb3NlKCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLl9sb2RQbGFuZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLl9sb2RQbGFuZXNbIGkgXS5kaXNwb3NlKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9jbGVhbnVwKCBvdXRwdXRUYXJnZXQgKSB7XG5cblx0XHR0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIF9vbGRUYXJnZXQsIF9vbGRBY3RpdmVDdWJlRmFjZSwgX29sZEFjdGl2ZU1pcG1hcExldmVsICk7XG5cdFx0b3V0cHV0VGFyZ2V0LnNjaXNzb3JUZXN0ID0gZmFsc2U7XG5cdFx0X3NldFZpZXdwb3J0KCBvdXRwdXRUYXJnZXQsIDAsIDAsIG91dHB1dFRhcmdldC53aWR0aCwgb3V0cHV0VGFyZ2V0LmhlaWdodCApO1xuXG5cdH1cblxuXHRfZnJvbVRleHR1cmUoIHRleHR1cmUsIHJlbmRlclRhcmdldCApIHtcblxuXHRcdHRoaXMuX3NldFNpemVGcm9tVGV4dHVyZSggdGV4dHVyZSApO1xuXG5cdFx0X29sZFRhcmdldCA9IHRoaXMuX3JlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXHRcdF9vbGRBY3RpdmVDdWJlRmFjZSA9IHRoaXMuX3JlbmRlcmVyLmdldEFjdGl2ZUN1YmVGYWNlKCk7XG5cdFx0X29sZEFjdGl2ZU1pcG1hcExldmVsID0gdGhpcy5fcmVuZGVyZXIuZ2V0QWN0aXZlTWlwbWFwTGV2ZWwoKTtcblxuXHRcdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldCB8fCB0aGlzLl9hbGxvY2F0ZVRhcmdldHMoKTtcblx0XHR0aGlzLl90ZXh0dXJlVG9DdWJlVVYoIHRleHR1cmUsIGN1YmVVVlJlbmRlclRhcmdldCApO1xuXHRcdHRoaXMuX2FwcGx5UE1SRU0oIGN1YmVVVlJlbmRlclRhcmdldCApO1xuXHRcdHRoaXMuX2NsZWFudXAoIGN1YmVVVlJlbmRlclRhcmdldCApO1xuXG5cdFx0cmV0dXJuIGN1YmVVVlJlbmRlclRhcmdldDtcblxuXHR9XG5cblx0X2FsbG9jYXRlVGFyZ2V0cygpIHtcblxuXHRcdGNvbnN0IHdpZHRoID0gMyAqIE1hdGgubWF4KCB0aGlzLl9jdWJlU2l6ZSwgMTYgKiA3ICk7XG5cdFx0Y29uc3QgaGVpZ2h0ID0gNCAqIHRoaXMuX2N1YmVTaXplO1xuXG5cdFx0Y29uc3QgcGFyYW1zID0ge1xuXHRcdFx0bWFnRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG5cdFx0XHRtaW5GaWx0ZXI6IExpbmVhckZpbHRlcixcblx0XHRcdGdlbmVyYXRlTWlwbWFwczogZmFsc2UsXG5cdFx0XHR0eXBlOiBIYWxmRmxvYXRUeXBlLFxuXHRcdFx0Zm9ybWF0OiBSR0JBRm9ybWF0LFxuXHRcdFx0Y29sb3JTcGFjZTogTGluZWFyU1JHQkNvbG9yU3BhY2UsXG5cdFx0XHQvL2RlcHRoQnVmZmVyOiBmYWxzZVxuXHRcdH07XG5cblx0XHRjb25zdCBjdWJlVVZSZW5kZXJUYXJnZXQgPSBfY3JlYXRlUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBwYXJhbXMgKTtcblxuXHRcdGlmICggdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQgPT09IG51bGwgfHwgdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQud2lkdGggIT09IHdpZHRoIHx8IHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LmhlaWdodCAhPT0gaGVpZ2h0ICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuX2Rpc3Bvc2UoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCA9IF9jcmVhdGVSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIHBhcmFtcyApO1xuXG5cdFx0XHRjb25zdCB7IF9sb2RNYXggfSA9IHRoaXM7XG5cdFx0XHQoIHsgc2l6ZUxvZHM6IHRoaXMuX3NpemVMb2RzLCBsb2RQbGFuZXM6IHRoaXMuX2xvZFBsYW5lcywgc2lnbWFzOiB0aGlzLl9zaWdtYXMsIGxvZE1lc2hlczogdGhpcy5fbG9kTWVzaGVzIH0gPSBfY3JlYXRlUGxhbmVzKCBfbG9kTWF4ICkgKTtcblxuXHRcdFx0dGhpcy5fYmx1ck1hdGVyaWFsID0gX2dldEJsdXJTaGFkZXIoIF9sb2RNYXgsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG5cblx0fVxuXG5cdGFzeW5jIF9jb21waWxlTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xuXG5cdFx0Y29uc3QgdG1wTWVzaCA9IG5ldyBNZXNoKCB0aGlzLl9sb2RQbGFuZXNbIDAgXSwgbWF0ZXJpYWwgKTtcblx0XHRhd2FpdCB0aGlzLl9yZW5kZXJlci5jb21waWxlKCB0bXBNZXNoLCBfZmxhdENhbWVyYSApO1xuXG5cdH1cblxuXHRfc2NlbmVUb0N1YmVVViggc2NlbmUsIG5lYXIsIGZhciwgY3ViZVVWUmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgY3ViZUNhbWVyYSA9IF9jdWJlQ2FtZXJhO1xuXHRcdGN1YmVDYW1lcmEubmVhciA9IG5lYXI7XG5cdFx0Y3ViZUNhbWVyYS5mYXIgPSBmYXI7XG5cblx0XHQvLyBweCwgcHksIHB6LCBueCwgbnksIG56XG5cdFx0Y29uc3QgdXBTaWduID0gWyAtIDEsIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSBdO1xuXHRcdGNvbnN0IGZvcndhcmRTaWduID0gWyAxLCAxLCAxLCAtIDEsIC0gMSwgLSAxIF07XG5cblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuXG5cdFx0Y29uc3Qgb3JpZ2luYWxBdXRvQ2xlYXIgPSByZW5kZXJlci5hdXRvQ2xlYXI7XG5cblx0XHRyZW5kZXJlci5nZXRDbGVhckNvbG9yKCBfY2xlYXJDb2xvciApO1xuXG5cdFx0cmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7XG5cblx0XHRsZXQgYmFja2dyb3VuZEJveCA9IHRoaXMuX2JhY2tncm91bmRCb3g7XG5cblx0XHRpZiAoIGJhY2tncm91bmRCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IGJhY2tncm91bmRNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCgge1xuXHRcdFx0XHRuYW1lOiAnUE1SRU0uQmFja2dyb3VuZCcsXG5cdFx0XHRcdHNpZGU6IEJhY2tTaWRlLFxuXHRcdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcblx0XHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxuXHRcdFx0fSApO1xuXG5cdFx0XHRiYWNrZ3JvdW5kQm94ID0gbmV3IE1lc2goIG5ldyBCb3hHZW9tZXRyeSgpLCBiYWNrZ3JvdW5kTWF0ZXJpYWwgKTtcblxuXHRcdH1cblxuXHRcdGxldCB1c2VTb2xpZENvbG9yID0gZmFsc2U7XG5cdFx0Y29uc3QgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XG5cblx0XHRpZiAoIGJhY2tncm91bmQgKSB7XG5cblx0XHRcdGlmICggYmFja2dyb3VuZC5pc0NvbG9yICkge1xuXG5cdFx0XHRcdGJhY2tncm91bmRCb3gubWF0ZXJpYWwuY29sb3IuY29weSggYmFja2dyb3VuZCApO1xuXHRcdFx0XHRzY2VuZS5iYWNrZ3JvdW5kID0gbnVsbDtcblx0XHRcdFx0dXNlU29saWRDb2xvciA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGJhY2tncm91bmRCb3gubWF0ZXJpYWwuY29sb3IuY29weSggX2NsZWFyQ29sb3IgKTtcblx0XHRcdHVzZVNvbGlkQ29sb3IgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJlbmRlcmVyLmNsZWFyKCk7XG5cblx0XHRpZiAoIHVzZVNvbGlkQ29sb3IgKSB7XG5cblx0XHRcdHJlbmRlcmVyLnJlbmRlciggYmFja2dyb3VuZEJveCwgY3ViZUNhbWVyYSApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY29sID0gaSAlIDM7XG5cblx0XHRcdGlmICggY29sID09PSAwICkge1xuXG5cdFx0XHRcdGN1YmVDYW1lcmEudXAuc2V0KCAwLCB1cFNpZ25bIGkgXSwgMCApO1xuXHRcdFx0XHRjdWJlQ2FtZXJhLmxvb2tBdCggZm9yd2FyZFNpZ25bIGkgXSwgMCwgMCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBjb2wgPT09IDEgKSB7XG5cblx0XHRcdFx0Y3ViZUNhbWVyYS51cC5zZXQoIDAsIDAsIHVwU2lnblsgaSBdICk7XG5cdFx0XHRcdGN1YmVDYW1lcmEubG9va0F0KCAwLCBmb3J3YXJkU2lnblsgaSBdLCAwICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y3ViZUNhbWVyYS51cC5zZXQoIDAsIHVwU2lnblsgaSBdLCAwICk7XG5cdFx0XHRcdGN1YmVDYW1lcmEubG9va0F0KCAwLCAwLCBmb3J3YXJkU2lnblsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2l6ZSA9IHRoaXMuX2N1YmVTaXplO1xuXG5cdFx0XHRfc2V0Vmlld3BvcnQoIGN1YmVVVlJlbmRlclRhcmdldCwgY29sICogc2l6ZSwgaSA+IDIgPyBzaXplIDogMCwgc2l6ZSwgc2l6ZSApO1xuXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjdWJlQ2FtZXJhICk7XG5cblx0XHR9XG5cblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBvcmlnaW5hbEF1dG9DbGVhcjtcblx0XHRzY2VuZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblxuXHR9XG5cblx0X3RleHR1cmVUb0N1YmVVViggdGV4dHVyZSwgY3ViZVVWUmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcblxuXHRcdGNvbnN0IGlzQ3ViZVRleHR1cmUgPSAoIHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIHx8IHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nICk7XG5cblx0XHRpZiAoIGlzQ3ViZVRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggdGhpcy5fY3ViZW1hcE1hdGVyaWFsID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9IF9nZXRDdWJlbWFwTWF0ZXJpYWwoIHRleHR1cmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBfZ2V0RXF1aXJlY3RNYXRlcmlhbCggdGV4dHVyZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IGlzQ3ViZVRleHR1cmUgPyB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgOiB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsO1xuXHRcdG1hdGVyaWFsLmZyYWdtZW50Tm9kZS52YWx1ZSA9IHRleHR1cmU7XG5cblx0XHRjb25zdCBtZXNoID0gdGhpcy5fbG9kTWVzaGVzWyAwIF07XG5cdFx0bWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG5cdFx0Y29uc3Qgc2l6ZSA9IHRoaXMuX2N1YmVTaXplO1xuXG5cdFx0X3NldFZpZXdwb3J0KCBjdWJlVVZSZW5kZXJUYXJnZXQsIDAsIDAsIDMgKiBzaXplLCAyICogc2l6ZSApO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIG1lc2gsIF9mbGF0Q2FtZXJhICk7XG5cblx0fVxuXG5cdF9hcHBseVBNUkVNKCBjdWJlVVZSZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuXHRcdGNvbnN0IGF1dG9DbGVhciA9IHJlbmRlcmVyLmF1dG9DbGVhcjtcblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBmYWxzZTtcblx0XHRjb25zdCBuID0gdGhpcy5fbG9kUGxhbmVzLmxlbmd0aDtcblxuXHRcdGZvciAoIGxldCBpID0gMTsgaSA8IG47IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHNpZ21hID0gTWF0aC5zcXJ0KCB0aGlzLl9zaWdtYXNbIGkgXSAqIHRoaXMuX3NpZ21hc1sgaSBdIC0gdGhpcy5fc2lnbWFzWyBpIC0gMSBdICogdGhpcy5fc2lnbWFzWyBpIC0gMSBdICk7XG5cblx0XHRcdGNvbnN0IHBvbGVBeGlzID0gX2F4aXNEaXJlY3Rpb25zWyAoIG4gLSBpIC0gMSApICUgX2F4aXNEaXJlY3Rpb25zLmxlbmd0aCBdO1xuXG5cdFx0XHR0aGlzLl9ibHVyKCBjdWJlVVZSZW5kZXJUYXJnZXQsIGkgLSAxLCBpLCBzaWdtYSwgcG9sZUF4aXMgKTtcblxuXHRcdH1cblxuXHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IGF1dG9DbGVhcjtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgaXMgYSB0d28tcGFzcyBHYXVzc2lhbiBibHVyIGZvciBhIGN1YmVtYXAuIE5vcm1hbGx5IHRoaXMgaXMgZG9uZVxuXHQgKiB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHksIGJ1dCB0aGlzIGJyZWFrcyBkb3duIG9uIGEgY3ViZS4gSGVyZSB3ZSBhcHBseVxuXHQgKiB0aGUgYmx1ciBsYXRpdHVkaW5hbGx5IChhcm91bmQgdGhlIHBvbGVzKSwgYW5kIHRoZW4gbG9uZ2l0dWRpbmFsbHkgKHRvd2FyZHNcblx0ICogdGhlIHBvbGVzKSB0byBhcHByb3hpbWF0ZSB0aGUgb3J0aG9nb25hbGx5LXNlcGFyYWJsZSBibHVyLiBJdCBpcyBsZWFzdFxuXHQgKiBhY2N1cmF0ZSBhdCB0aGUgcG9sZXMsIGJ1dCBzdGlsbCBkb2VzIGEgZGVjZW50IGpvYi5cblx0ICovXG5cdF9ibHVyKCBjdWJlVVZSZW5kZXJUYXJnZXQsIGxvZEluLCBsb2RPdXQsIHNpZ21hLCBwb2xlQXhpcyApIHtcblxuXHRcdGNvbnN0IHBpbmdQb25nUmVuZGVyVGFyZ2V0ID0gdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQ7XG5cblx0XHR0aGlzLl9oYWxmQmx1cihcblx0XHRcdGN1YmVVVlJlbmRlclRhcmdldCxcblx0XHRcdHBpbmdQb25nUmVuZGVyVGFyZ2V0LFxuXHRcdFx0bG9kSW4sXG5cdFx0XHRsb2RPdXQsXG5cdFx0XHRzaWdtYSxcblx0XHRcdCdsYXRpdHVkaW5hbCcsXG5cdFx0XHRwb2xlQXhpcyApO1xuXG5cdFx0dGhpcy5faGFsZkJsdXIoXG5cdFx0XHRwaW5nUG9uZ1JlbmRlclRhcmdldCxcblx0XHRcdGN1YmVVVlJlbmRlclRhcmdldCxcblx0XHRcdGxvZE91dCxcblx0XHRcdGxvZE91dCxcblx0XHRcdHNpZ21hLFxuXHRcdFx0J2xvbmdpdHVkaW5hbCcsXG5cdFx0XHRwb2xlQXhpcyApO1xuXG5cdH1cblxuXHRfaGFsZkJsdXIoIHRhcmdldEluLCB0YXJnZXRPdXQsIGxvZEluLCBsb2RPdXQsIHNpZ21hUmFkaWFucywgZGlyZWN0aW9uLCBwb2xlQXhpcyApIHtcblxuXHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG5cdFx0Y29uc3QgYmx1ck1hdGVyaWFsID0gdGhpcy5fYmx1ck1hdGVyaWFsO1xuXG5cdFx0aWYgKCBkaXJlY3Rpb24gIT09ICdsYXRpdHVkaW5hbCcgJiYgZGlyZWN0aW9uICE9PSAnbG9uZ2l0dWRpbmFsJyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ2JsdXIgZGlyZWN0aW9uIG11c3QgYmUgZWl0aGVyIGxhdGl0dWRpbmFsIG9yIGxvbmdpdHVkaW5hbCEnICk7XG5cblx0XHR9XG5cblx0XHQvLyBOdW1iZXIgb2Ygc3RhbmRhcmQgZGV2aWF0aW9ucyBhdCB3aGljaCB0byBjdXQgb2ZmIHRoZSBkaXNjcmV0ZSBhcHByb3hpbWF0aW9uLlxuXHRcdGNvbnN0IFNUQU5EQVJEX0RFVklBVElPTlMgPSAzO1xuXG5cdFx0Y29uc3QgYmx1ck1lc2ggPSB0aGlzLl9sb2RNZXNoZXNbIGxvZE91dCBdO1xuXHRcdGJsdXJNZXNoLm1hdGVyaWFsID0gYmx1ck1hdGVyaWFsO1xuXG5cdFx0Y29uc3QgYmx1clVuaWZvcm1zID0gYmx1ck1hdGVyaWFsLnVuaWZvcm1zO1xuXG5cdFx0Y29uc3QgcGl4ZWxzID0gdGhpcy5fc2l6ZUxvZHNbIGxvZEluIF0gLSAxO1xuXHRcdGNvbnN0IHJhZGlhbnNQZXJQaXhlbCA9IGlzRmluaXRlKCBzaWdtYVJhZGlhbnMgKSA/IE1hdGguUEkgLyAoIDIgKiBwaXhlbHMgKSA6IDIgKiBNYXRoLlBJIC8gKCAyICogTUFYX1NBTVBMRVMgLSAxICk7XG5cdFx0Y29uc3Qgc2lnbWFQaXhlbHMgPSBzaWdtYVJhZGlhbnMgLyByYWRpYW5zUGVyUGl4ZWw7XG5cdFx0Y29uc3Qgc2FtcGxlcyA9IGlzRmluaXRlKCBzaWdtYVJhZGlhbnMgKSA/IDEgKyBNYXRoLmZsb29yKCBTVEFOREFSRF9ERVZJQVRJT05TICogc2lnbWFQaXhlbHMgKSA6IE1BWF9TQU1QTEVTO1xuXG5cdFx0aWYgKCBzYW1wbGVzID4gTUFYX1NBTVBMRVMgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggYHNpZ21hUmFkaWFucywgJHtcblx0XHRcdFx0c2lnbWFSYWRpYW5zfSwgaXMgdG9vIGxhcmdlIGFuZCB3aWxsIGNsaXAsIGFzIGl0IHJlcXVlc3RlZCAke1xuXHRcdFx0XHRzYW1wbGVzfSBzYW1wbGVzIHdoZW4gdGhlIG1heGltdW0gaXMgc2V0IHRvICR7TUFYX1NBTVBMRVN9YCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgd2VpZ2h0cyA9IFtdO1xuXHRcdGxldCBzdW0gPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgTUFYX1NBTVBMRVM7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IHggPSBpIC8gc2lnbWFQaXhlbHM7XG5cdFx0XHRjb25zdCB3ZWlnaHQgPSBNYXRoLmV4cCggLSB4ICogeCAvIDIgKTtcblx0XHRcdHdlaWdodHMucHVzaCggd2VpZ2h0ICk7XG5cblx0XHRcdGlmICggaSA9PT0gMCApIHtcblxuXHRcdFx0XHRzdW0gKz0gd2VpZ2h0O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBpIDwgc2FtcGxlcyApIHtcblxuXHRcdFx0XHRzdW0gKz0gMiAqIHdlaWdodDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgd2VpZ2h0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHdlaWdodHNbIGkgXSA9IHdlaWdodHNbIGkgXSAvIHN1bTtcblxuXHRcdH1cblxuXHRcdHRhcmdldEluLnRleHR1cmUuZnJhbWUgPSAoIHRhcmdldEluLnRleHR1cmUuZnJhbWUgfHwgMCApICsgMTtcblxuXHRcdGJsdXJVbmlmb3Jtcy5lbnZNYXAudmFsdWUgPSB0YXJnZXRJbi50ZXh0dXJlO1xuXHRcdGJsdXJVbmlmb3Jtcy5zYW1wbGVzLnZhbHVlID0gc2FtcGxlcztcblx0XHRibHVyVW5pZm9ybXMud2VpZ2h0cy5hcnJheSA9IHdlaWdodHM7XG5cdFx0Ymx1clVuaWZvcm1zLmxhdGl0dWRpbmFsLnZhbHVlID0gZGlyZWN0aW9uID09PSAnbGF0aXR1ZGluYWwnID8gMSA6IDA7XG5cblx0XHRpZiAoIHBvbGVBeGlzICkge1xuXG5cdFx0XHRibHVyVW5pZm9ybXMucG9sZUF4aXMudmFsdWUgPSBwb2xlQXhpcztcblxuXHRcdH1cblxuXHRcdGNvbnN0IHsgX2xvZE1heCB9ID0gdGhpcztcblx0XHRibHVyVW5pZm9ybXMuZFRoZXRhLnZhbHVlID0gcmFkaWFuc1BlclBpeGVsO1xuXHRcdGJsdXJVbmlmb3Jtcy5taXBJbnQudmFsdWUgPSBfbG9kTWF4IC0gbG9kSW47XG5cblx0XHRjb25zdCBvdXRwdXRTaXplID0gdGhpcy5fc2l6ZUxvZHNbIGxvZE91dCBdO1xuXHRcdGNvbnN0IHggPSAzICogb3V0cHV0U2l6ZSAqICggbG9kT3V0ID4gX2xvZE1heCAtIExPRF9NSU4gPyBsb2RPdXQgLSBfbG9kTWF4ICsgTE9EX01JTiA6IDAgKTtcblx0XHRjb25zdCB5ID0gNCAqICggdGhpcy5fY3ViZVNpemUgLSBvdXRwdXRTaXplICk7XG5cblx0XHRfc2V0Vmlld3BvcnQoIHRhcmdldE91dCwgeCwgeSwgMyAqIG91dHB1dFNpemUsIDIgKiBvdXRwdXRTaXplICk7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCB0YXJnZXRPdXQgKTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIGJsdXJNZXNoLCBfZmxhdENhbWVyYSApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBfY3JlYXRlUGxhbmVzKCBsb2RNYXggKSB7XG5cblx0Y29uc3QgbG9kUGxhbmVzID0gW107XG5cdGNvbnN0IHNpemVMb2RzID0gW107XG5cdGNvbnN0IHNpZ21hcyA9IFtdO1xuXHRjb25zdCBsb2RNZXNoZXMgPSBbXTtcblxuXHRsZXQgbG9kID0gbG9kTWF4O1xuXG5cdGNvbnN0IHRvdGFsTG9kcyA9IGxvZE1heCAtIExPRF9NSU4gKyAxICsgRVhUUkFfTE9EX1NJR01BLmxlbmd0aDtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0b3RhbExvZHM7IGkgKysgKSB7XG5cblx0XHRjb25zdCBzaXplTG9kID0gTWF0aC5wb3coIDIsIGxvZCApO1xuXHRcdHNpemVMb2RzLnB1c2goIHNpemVMb2QgKTtcblx0XHRsZXQgc2lnbWEgPSAxLjAgLyBzaXplTG9kO1xuXG5cdFx0aWYgKCBpID4gbG9kTWF4IC0gTE9EX01JTiApIHtcblxuXHRcdFx0c2lnbWEgPSBFWFRSQV9MT0RfU0lHTUFbIGkgLSBsb2RNYXggKyBMT0RfTUlOIC0gMSBdO1xuXG5cdFx0fSBlbHNlIGlmICggaSA9PT0gMCApIHtcblxuXHRcdFx0c2lnbWEgPSAwO1xuXG5cdFx0fVxuXG5cdFx0c2lnbWFzLnB1c2goIHNpZ21hICk7XG5cblx0XHRjb25zdCB0ZXhlbFNpemUgPSAxLjAgLyAoIHNpemVMb2QgLSAyICk7XG5cdFx0Y29uc3QgbWluID0gLSB0ZXhlbFNpemU7XG5cdFx0Y29uc3QgbWF4ID0gMSArIHRleGVsU2l6ZTtcblx0XHRjb25zdCB1djEgPSBbIG1pbiwgbWluLCBtYXgsIG1pbiwgbWF4LCBtYXgsIG1pbiwgbWluLCBtYXgsIG1heCwgbWluLCBtYXggXTtcblxuXHRcdGNvbnN0IGN1YmVGYWNlcyA9IDY7XG5cdFx0Y29uc3QgdmVydGljZXMgPSA2O1xuXHRcdGNvbnN0IHBvc2l0aW9uU2l6ZSA9IDM7XG5cdFx0Y29uc3QgdXZTaXplID0gMjtcblx0XHRjb25zdCBmYWNlSW5kZXhTaXplID0gMTtcblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25TaXplICogdmVydGljZXMgKiBjdWJlRmFjZXMgKTtcblx0XHRjb25zdCB1diA9IG5ldyBGbG9hdDMyQXJyYXkoIHV2U2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzICk7XG5cdFx0Y29uc3QgZmFjZUluZGV4ID0gbmV3IEZsb2F0MzJBcnJheSggZmFjZUluZGV4U2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzICk7XG5cblx0XHRmb3IgKCBsZXQgZmFjZSA9IDA7IGZhY2UgPCBjdWJlRmFjZXM7IGZhY2UgKysgKSB7XG5cblx0XHRcdGNvbnN0IHggPSAoIGZhY2UgJSAzICkgKiAyIC8gMyAtIDE7XG5cdFx0XHRjb25zdCB5ID0gZmFjZSA+IDIgPyAwIDogLSAxO1xuXHRcdFx0Y29uc3QgY29vcmRpbmF0ZXMgPSBbXG5cdFx0XHRcdHgsIHksIDAsXG5cdFx0XHRcdHggKyAyIC8gMywgeSwgMCxcblx0XHRcdFx0eCArIDIgLyAzLCB5ICsgMSwgMCxcblx0XHRcdFx0eCwgeSwgMCxcblx0XHRcdFx0eCArIDIgLyAzLCB5ICsgMSwgMCxcblx0XHRcdFx0eCwgeSArIDEsIDBcblx0XHRcdF07XG5cblx0XHRcdGNvbnN0IGZhY2VJZHggPSBfZmFjZUxpYlsgZmFjZSBdO1xuXHRcdFx0cG9zaXRpb24uc2V0KCBjb29yZGluYXRlcywgcG9zaXRpb25TaXplICogdmVydGljZXMgKiBmYWNlSWR4ICk7XG5cdFx0XHR1di5zZXQoIHV2MSwgdXZTaXplICogdmVydGljZXMgKiBmYWNlSWR4ICk7XG5cdFx0XHRjb25zdCBmaWxsID0gWyBmYWNlSWR4LCBmYWNlSWR4LCBmYWNlSWR4LCBmYWNlSWR4LCBmYWNlSWR4LCBmYWNlSWR4IF07XG5cdFx0XHRmYWNlSW5kZXguc2V0KCBmaWxsLCBmYWNlSW5kZXhTaXplICogdmVydGljZXMgKiBmYWNlSWR4ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwbGFuZXMgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRwbGFuZXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgcG9zaXRpb25TaXplICkgKTtcblx0XHRwbGFuZXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB1diwgdXZTaXplICkgKTtcblx0XHRwbGFuZXMuc2V0QXR0cmlidXRlKCAnZmFjZUluZGV4JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggZmFjZUluZGV4LCBmYWNlSW5kZXhTaXplICkgKTtcblx0XHRsb2RQbGFuZXMucHVzaCggcGxhbmVzICk7XG5cdFx0bG9kTWVzaGVzLnB1c2goIG5ldyBNZXNoKCBwbGFuZXMsIG51bGwgKSApO1xuXG5cdFx0aWYgKCBsb2QgPiBMT0RfTUlOICkge1xuXG5cdFx0XHRsb2QgLS07XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB7IGxvZFBsYW5lcywgc2l6ZUxvZHMsIHNpZ21hcywgbG9kTWVzaGVzIH07XG5cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVJlbmRlclRhcmdldCggd2lkdGgsIGhlaWdodCwgcGFyYW1zICkge1xuXG5cdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IG5ldyBSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIHBhcmFtcyApO1xuXHRjdWJlVVZSZW5kZXJUYXJnZXQudGV4dHVyZS5tYXBwaW5nID0gQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc7XG5cdGN1YmVVVlJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSAnUE1SRU0uY3ViZVV2Jztcblx0Y3ViZVVWUmVuZGVyVGFyZ2V0LnRleHR1cmUuaXNQTVJFTVRleHR1cmUgPSB0cnVlO1xuXHRjdWJlVVZSZW5kZXJUYXJnZXQuc2Npc3NvclRlc3QgPSB0cnVlO1xuXHRyZXR1cm4gY3ViZVVWUmVuZGVyVGFyZ2V0O1xuXG59XG5cbmZ1bmN0aW9uIF9zZXRWaWV3cG9ydCggdGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdHRhcmdldC52aWV3cG9ydC5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKTtcblx0dGFyZ2V0LnNjaXNzb3Iuc2V0KCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICk7XG5cbn1cblxuZnVuY3Rpb24gX2dldE1hdGVyaWFsKCB0eXBlICkge1xuXG5cdGNvbnN0IG1hdGVyaWFsID0gbmV3IE5vZGVNYXRlcmlhbCgpO1xuXHRtYXRlcmlhbC5kZXB0aFRlc3QgPSBmYWxzZTtcblx0bWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGZhbHNlO1xuXHRtYXRlcmlhbC5ibGVuZGluZyA9IE5vQmxlbmRpbmc7XG5cdG1hdGVyaWFsLm5hbWUgPSBgUE1SRU1fJHsgdHlwZSB9YDtcblxuXHRyZXR1cm4gbWF0ZXJpYWw7XG5cbn1cblxuZnVuY3Rpb24gX2dldEJsdXJTaGFkZXIoIGxvZE1heCwgd2lkdGgsIGhlaWdodCApIHtcblxuXHRjb25zdCB3ZWlnaHRzID0gdW5pZm9ybUFycmF5KCBuZXcgQXJyYXkoIE1BWF9TQU1QTEVTICkuZmlsbCggMCApICk7XG5cdGNvbnN0IHBvbGVBeGlzID0gdW5pZm9ybSggbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSApO1xuXHRjb25zdCBkVGhldGEgPSB1bmlmb3JtKCAwICk7XG5cdGNvbnN0IG4gPSBmbG9hdCggTUFYX1NBTVBMRVMgKTtcblx0Y29uc3QgbGF0aXR1ZGluYWwgPSB1bmlmb3JtKCAwICk7IC8vIGZhbHNlLCBib29sXG5cdGNvbnN0IHNhbXBsZXMgPSB1bmlmb3JtKCAxICk7IC8vIGludFxuXHRjb25zdCBlbnZNYXAgPSB0ZXh0dXJlKCBudWxsICk7XG5cdGNvbnN0IG1pcEludCA9IHVuaWZvcm0oIDAgKTsgLy8gaW50XG5cdGNvbnN0IENVQkVVVl9URVhFTF9XSURUSCA9IGZsb2F0KCAxIC8gd2lkdGggKTtcblx0Y29uc3QgQ1VCRVVWX1RFWEVMX0hFSUdIVCA9IGZsb2F0KCAxIC8gaGVpZ2h0ICk7XG5cdGNvbnN0IENVQkVVVl9NQVhfTUlQID0gZmxvYXQoIGxvZE1heCApO1xuXG5cdGNvbnN0IG1hdGVyaWFsVW5pZm9ybXMgPSB7XG5cdFx0bixcblx0XHRsYXRpdHVkaW5hbCxcblx0XHR3ZWlnaHRzLFxuXHRcdHBvbGVBeGlzLFxuXHRcdG91dHB1dERpcmVjdGlvbixcblx0XHRkVGhldGEsXG5cdFx0c2FtcGxlcyxcblx0XHRlbnZNYXAsXG5cdFx0bWlwSW50LFxuXHRcdENVQkVVVl9URVhFTF9XSURUSCxcblx0XHRDVUJFVVZfVEVYRUxfSEVJR0hULFxuXHRcdENVQkVVVl9NQVhfTUlQXG5cdH07XG5cblx0Y29uc3QgbWF0ZXJpYWwgPSBfZ2V0TWF0ZXJpYWwoICdibHVyJyApO1xuXHRtYXRlcmlhbC51bmlmb3JtcyA9IG1hdGVyaWFsVW5pZm9ybXM7IC8vIFRPRE86IE1vdmUgdG8gb3V0c2lkZSBvZiB0aGUgbWF0ZXJpYWxcblx0bWF0ZXJpYWwuZnJhZ21lbnROb2RlID0gYmx1ciggeyAuLi5tYXRlcmlhbFVuaWZvcm1zLCBsYXRpdHVkaW5hbDogbGF0aXR1ZGluYWwuZXF1YWwoIDEgKSB9ICk7XG5cblx0cmV0dXJuIG1hdGVyaWFsO1xuXG59XG5cbmZ1bmN0aW9uIF9nZXRDdWJlbWFwTWF0ZXJpYWwoIGVudlRleHR1cmUgKSB7XG5cblx0Y29uc3QgbWF0ZXJpYWwgPSBfZ2V0TWF0ZXJpYWwoICdjdWJlbWFwJyApO1xuXHRtYXRlcmlhbC5mcmFnbWVudE5vZGUgPSBjdWJlVGV4dHVyZSggZW52VGV4dHVyZSwgb3V0cHV0RGlyZWN0aW9uICk7XG5cblx0cmV0dXJuIG1hdGVyaWFsO1xuXG59XG5cbmZ1bmN0aW9uIF9nZXRFcXVpcmVjdE1hdGVyaWFsKCBlbnZUZXh0dXJlICkge1xuXG5cdGNvbnN0IG1hdGVyaWFsID0gX2dldE1hdGVyaWFsKCAnZXF1aXJlY3QnICk7XG5cdG1hdGVyaWFsLmZyYWdtZW50Tm9kZSA9IHRleHR1cmUoIGVudlRleHR1cmUsIGVxdWlyZWN0VVYoIG91dHB1dERpcmVjdGlvbiApLCAwICk7XG5cblx0cmV0dXJuIG1hdGVyaWFsO1xuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBNUkVNR2VuZXJhdG9yO1xuIiwiaW1wb3J0IE5vZGVVbmlmb3JtIGZyb20gJy4vTm9kZVVuaWZvcm0uanMnO1xuaW1wb3J0IE5vZGVBdHRyaWJ1dGUgZnJvbSAnLi9Ob2RlQXR0cmlidXRlLmpzJztcbmltcG9ydCBOb2RlVmFyeWluZyBmcm9tICcuL05vZGVWYXJ5aW5nLmpzJztcbmltcG9ydCBOb2RlVmFyIGZyb20gJy4vTm9kZVZhci5qcyc7XG5pbXBvcnQgTm9kZUNvZGUgZnJvbSAnLi9Ob2RlQ29kZS5qcyc7XG5pbXBvcnQgTm9kZUNhY2hlIGZyb20gJy4vTm9kZUNhY2hlLmpzJztcbmltcG9ydCBQYXJhbWV0ZXJOb2RlIGZyb20gJy4vUGFyYW1ldGVyTm9kZS5qcyc7XG5pbXBvcnQgRnVuY3Rpb25Ob2RlIGZyb20gJy4uL2NvZGUvRnVuY3Rpb25Ob2RlLmpzJztcbmltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi4vLi4vbWF0ZXJpYWxzL25vZGVzL05vZGVNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBnZXRUeXBlRnJvbUxlbmd0aCB9IGZyb20gJy4vTm9kZVV0aWxzLmpzJztcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlLCBkZWZhdWx0QnVpbGRTdGFnZXMsIHNoYWRlclN0YWdlcyB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcblxuaW1wb3J0IHtcblx0TnVtYmVyTm9kZVVuaWZvcm0sIFZlY3RvcjJOb2RlVW5pZm9ybSwgVmVjdG9yM05vZGVVbmlmb3JtLCBWZWN0b3I0Tm9kZVVuaWZvcm0sXG5cdENvbG9yTm9kZVVuaWZvcm0sIE1hdHJpeDNOb2RlVW5pZm9ybSwgTWF0cml4NE5vZGVVbmlmb3JtXG59IGZyb20gJy4uLy4uL3JlbmRlcmVycy9jb21tb24vbm9kZXMvTm9kZVVuaWZvcm0uanMnO1xuXG5pbXBvcnQgeyBzdGFjayB9IGZyb20gJy4vU3RhY2tOb2RlLmpzJztcbmltcG9ydCB7IGdldEN1cnJlbnRTdGFjaywgc2V0Q3VycmVudFN0YWNrIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xuXG5pbXBvcnQgQ3ViZVJlbmRlclRhcmdldCBmcm9tICcuLi8uLi9yZW5kZXJlcnMvY29tbW9uL0N1YmVSZW5kZXJUYXJnZXQuanMnO1xuaW1wb3J0IENoYWluTWFwIGZyb20gJy4uLy4uL3JlbmRlcmVycy9jb21tb24vQ2hhaW5NYXAuanMnO1xuXG5pbXBvcnQgUE1SRU1HZW5lcmF0b3IgZnJvbSAnLi4vLi4vcmVuZGVyZXJzL2NvbW1vbi9leHRyYXMvUE1SRU1HZW5lcmF0b3IuanMnO1xuXG5pbXBvcnQgQmluZEdyb3VwIGZyb20gJy4uLy4uL3JlbmRlcmVycy9jb21tb24vQmluZEdyb3VwLmpzJztcblxuaW1wb3J0IHsgUkVWSVNJT04gfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi4vLi4vY29yZS9SZW5kZXJUYXJnZXQuanMnO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi9tYXRoL0NvbG9yLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3I0LmpzJztcbmltcG9ydCB7IEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBJbnRUeXBlLCBVbnNpZ25lZEludFR5cGUsIExpbmVhckZpbHRlciwgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciwgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcblxuY29uc3QgcmVuZGVyZXJDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IHR5cGVGcm9tQXJyYXkgPSBuZXcgTWFwKCBbXG5cdFsgSW50OEFycmF5LCAnaW50JyBdLFxuXHRbIEludDE2QXJyYXksICdpbnQnIF0sXG5cdFsgSW50MzJBcnJheSwgJ2ludCcgXSxcblx0WyBVaW50OEFycmF5LCAndWludCcgXSxcblx0WyBVaW50MTZBcnJheSwgJ3VpbnQnIF0sXG5cdFsgVWludDMyQXJyYXksICd1aW50JyBdLFxuXHRbIEZsb2F0MzJBcnJheSwgJ2Zsb2F0JyBdXG5dICk7XG5cbmNvbnN0IHRvRmxvYXQgPSAoIHZhbHVlICkgPT4ge1xuXG5cdGlmICggL2UvZy50ZXN0KCB2YWx1ZSApICkge1xuXG5cdFx0cmV0dXJuIFN0cmluZyggdmFsdWUgKS5yZXBsYWNlKCAvXFwrL2csICcnICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHZhbHVlID0gTnVtYmVyKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHZhbHVlICsgKCB2YWx1ZSAlIDEgPyAnJyA6ICcuMCcgKTtcblxuXHR9XG5cbn07XG5cbmNsYXNzIE5vZGVCdWlsZGVyIHtcblxuXHRjb25zdHJ1Y3Rvciggb2JqZWN0LCByZW5kZXJlciwgcGFyc2VyICkge1xuXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0dGhpcy5tYXRlcmlhbCA9ICggb2JqZWN0ICYmIG9iamVjdC5tYXRlcmlhbCApIHx8IG51bGw7XG5cdFx0dGhpcy5nZW9tZXRyeSA9ICggb2JqZWN0ICYmIG9iamVjdC5nZW9tZXRyeSApIHx8IG51bGw7XG5cdFx0dGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMuc2NlbmUgPSBudWxsO1xuXHRcdHRoaXMuY2FtZXJhID0gbnVsbDtcblxuXHRcdHRoaXMubm9kZXMgPSBbXTtcblx0XHR0aGlzLnNlcXVlbnRpYWxOb2RlcyA9IFtdO1xuXHRcdHRoaXMudXBkYXRlTm9kZXMgPSBbXTtcblx0XHR0aGlzLnVwZGF0ZUJlZm9yZU5vZGVzID0gW107XG5cdFx0dGhpcy51cGRhdGVBZnRlck5vZGVzID0gW107XG5cdFx0dGhpcy5oYXNoTm9kZXMgPSB7fTtcblxuXHRcdHRoaXMubW9uaXRvciA9IG51bGw7XG5cblx0XHR0aGlzLmxpZ2h0c05vZGUgPSBudWxsO1xuXHRcdHRoaXMuZW52aXJvbm1lbnROb2RlID0gbnVsbDtcblx0XHR0aGlzLmZvZ05vZGUgPSBudWxsO1xuXG5cdFx0dGhpcy5jbGlwcGluZ0NvbnRleHQgPSBudWxsO1xuXG5cdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBudWxsO1xuXHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBudWxsO1xuXHRcdHRoaXMuY29tcHV0ZVNoYWRlciA9IG51bGw7XG5cblx0XHR0aGlzLmZsb3dOb2RlcyA9IHsgdmVydGV4OiBbXSwgZnJhZ21lbnQ6IFtdLCBjb21wdXRlOiBbXSB9O1xuXHRcdHRoaXMuZmxvd0NvZGUgPSB7IHZlcnRleDogJycsIGZyYWdtZW50OiAnJywgY29tcHV0ZTogJycgfTtcblx0XHR0aGlzLnVuaWZvcm1zID0geyB2ZXJ0ZXg6IFtdLCBmcmFnbWVudDogW10sIGNvbXB1dGU6IFtdLCBpbmRleDogMCB9O1xuXHRcdHRoaXMuc3RydWN0cyA9IHsgdmVydGV4OiBbXSwgZnJhZ21lbnQ6IFtdLCBjb21wdXRlOiBbXSwgaW5kZXg6IDAgfTtcblx0XHR0aGlzLmJpbmRpbmdzID0geyB2ZXJ0ZXg6IHt9LCBmcmFnbWVudDoge30sIGNvbXB1dGU6IHt9IH07XG5cdFx0dGhpcy5iaW5kaW5nc0luZGV4ZXMgPSB7fTtcblx0XHR0aGlzLmJpbmRHcm91cHMgPSBudWxsO1xuXHRcdHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuXHRcdHRoaXMuYnVmZmVyQXR0cmlidXRlcyA9IFtdO1xuXHRcdHRoaXMudmFyeWluZ3MgPSBbXTtcblx0XHR0aGlzLmNvZGVzID0ge307XG5cdFx0dGhpcy52YXJzID0ge307XG5cdFx0dGhpcy5mbG93ID0geyBjb2RlOiAnJyB9O1xuXHRcdHRoaXMuY2hhaW5pbmcgPSBbXTtcblx0XHR0aGlzLnN0YWNrID0gc3RhY2soKTtcblx0XHR0aGlzLnN0YWNrcyA9IFtdO1xuXHRcdHRoaXMudGFiID0gJ1xcdCc7XG5cblx0XHR0aGlzLmN1cnJlbnRGdW5jdGlvbk5vZGUgPSBudWxsO1xuXG5cdFx0dGhpcy5jb250ZXh0ID0ge1xuXHRcdFx0bWF0ZXJpYWw6IHRoaXMubWF0ZXJpYWxcblx0XHR9O1xuXG5cdFx0dGhpcy5jYWNoZSA9IG5ldyBOb2RlQ2FjaGUoKTtcblx0XHR0aGlzLmdsb2JhbENhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRcdHRoaXMuZmxvd3NEYXRhID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdHRoaXMuc2hhZGVyU3RhZ2UgPSBudWxsO1xuXHRcdHRoaXMuYnVpbGRTdGFnZSA9IG51bGw7XG5cblx0XHR0aGlzLnVzZUNvbXBhcmlzb25NZXRob2QgPSBmYWxzZTtcblxuXHR9XG5cblx0Z2V0QmluZEdyb3Vwc0NhY2hlKCkge1xuXG5cdFx0bGV0IGJpbmRHcm91cHNDYWNoZSA9IHJlbmRlcmVyQ2FjaGUuZ2V0KCB0aGlzLnJlbmRlcmVyICk7XG5cblx0XHRpZiAoIGJpbmRHcm91cHNDYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRiaW5kR3JvdXBzQ2FjaGUgPSBuZXcgQ2hhaW5NYXAoKTtcblxuXHRcdFx0cmVuZGVyZXJDYWNoZS5zZXQoIHRoaXMucmVuZGVyZXIsIGJpbmRHcm91cHNDYWNoZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJpbmRHcm91cHNDYWNoZTtcblxuXHR9XG5cblx0Y3JlYXRlUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xuXG5cdFx0cmV0dXJuIG5ldyBSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcblxuXHR9XG5cblx0Y3JlYXRlQ3ViZVJlbmRlclRhcmdldCggc2l6ZSwgb3B0aW9ucyApIHtcblxuXHRcdHJldHVybiBuZXcgQ3ViZVJlbmRlclRhcmdldCggc2l6ZSwgb3B0aW9ucyApO1xuXG5cdH1cblxuXHRjcmVhdGVQTVJFTUdlbmVyYXRvcigpIHtcblxuXHRcdC8vIFRPRE86IE1vdmUgTWF0ZXJpYWxzLmpzIHRvIG91dHNpZGUgb2YgdGhlIE5vZGVzLmpzIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGZ1bmN0aW9uIGFuZCBpbXByb3ZlIHRyZWUtc2hha2luZyBzdXBwb3J0XG5cblx0XHRyZXR1cm4gbmV3IFBNUkVNR2VuZXJhdG9yKCB0aGlzLnJlbmRlcmVyICk7XG5cblx0fVxuXG5cdGluY2x1ZGVzKCBub2RlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9kZXMuaW5jbHVkZXMoIG5vZGUgKTtcblxuXHR9XG5cblx0X2dldEJpbmRHcm91cCggZ3JvdXBOYW1lLCBiaW5kaW5ncyApIHtcblxuXHRcdGNvbnN0IGJpbmRHcm91cHNDYWNoZSA9IHRoaXMuZ2V0QmluZEdyb3Vwc0NhY2hlKCk7XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgYmluZGluZ3NBcnJheSA9IFtdO1xuXG5cdFx0bGV0IHNoYXJlZEdyb3VwID0gdHJ1ZTtcblxuXHRcdGZvciAoIGNvbnN0IGJpbmRpbmcgb2YgYmluZGluZ3MgKSB7XG5cblx0XHRcdGJpbmRpbmdzQXJyYXkucHVzaCggYmluZGluZyApO1xuXG5cdFx0XHRzaGFyZWRHcm91cCA9IHNoYXJlZEdyb3VwICYmIGJpbmRpbmcuZ3JvdXBOb2RlLnNoYXJlZCAhPT0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRsZXQgYmluZEdyb3VwO1xuXG5cdFx0aWYgKCBzaGFyZWRHcm91cCApIHtcblxuXHRcdFx0YmluZEdyb3VwID0gYmluZEdyb3Vwc0NhY2hlLmdldCggYmluZGluZ3NBcnJheSApO1xuXG5cdFx0XHRpZiAoIGJpbmRHcm91cCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGJpbmRHcm91cCA9IG5ldyBCaW5kR3JvdXAoIGdyb3VwTmFtZSwgYmluZGluZ3NBcnJheSwgdGhpcy5iaW5kaW5nc0luZGV4ZXNbIGdyb3VwTmFtZSBdLmdyb3VwLCBiaW5kaW5nc0FycmF5ICk7XG5cblx0XHRcdFx0YmluZEdyb3Vwc0NhY2hlLnNldCggYmluZGluZ3NBcnJheSwgYmluZEdyb3VwICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGJpbmRHcm91cCA9IG5ldyBCaW5kR3JvdXAoIGdyb3VwTmFtZSwgYmluZGluZ3NBcnJheSwgdGhpcy5iaW5kaW5nc0luZGV4ZXNbIGdyb3VwTmFtZSBdLmdyb3VwLCBiaW5kaW5nc0FycmF5ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYmluZEdyb3VwO1xuXG5cdH1cblxuXHRnZXRCaW5kR3JvdXBBcnJheSggZ3JvdXBOYW1lLCBzaGFkZXJTdGFnZSApIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5iaW5kaW5nc1sgc2hhZGVyU3RhZ2UgXTtcblxuXHRcdGxldCBiaW5kR3JvdXAgPSBiaW5kaW5nc1sgZ3JvdXBOYW1lIF07XG5cblx0XHRpZiAoIGJpbmRHcm91cCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuYmluZGluZ3NJbmRleGVzWyBncm91cE5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuYmluZGluZ3NJbmRleGVzWyBncm91cE5hbWUgXSA9IHsgYmluZGluZzogMCwgZ3JvdXA6IE9iamVjdC5rZXlzKCB0aGlzLmJpbmRpbmdzSW5kZXhlcyApLmxlbmd0aCB9O1xuXG5cdFx0XHR9XG5cblx0XHRcdGJpbmRpbmdzWyBncm91cE5hbWUgXSA9IGJpbmRHcm91cCA9IFtdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJpbmRHcm91cDtcblxuXHR9XG5cblx0Z2V0QmluZGluZ3MoKSB7XG5cblx0XHRsZXQgYmluZGluZ3NHcm91cHMgPSB0aGlzLmJpbmRHcm91cHM7XG5cblx0XHRpZiAoIGJpbmRpbmdzR3JvdXBzID09PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBncm91cHMgPSB7fTtcblx0XHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncztcblxuXHRcdFx0Zm9yICggY29uc3Qgc2hhZGVyU3RhZ2Ugb2Ygc2hhZGVyU3RhZ2VzICkge1xuXG5cdFx0XHRcdGZvciAoIGNvbnN0IGdyb3VwTmFtZSBpbiBiaW5kaW5nc1sgc2hhZGVyU3RhZ2UgXSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gYmluZGluZ3NbIHNoYWRlclN0YWdlIF1bIGdyb3VwTmFtZSBdO1xuXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBVbmlmb3JtcyA9IGdyb3Vwc1sgZ3JvdXBOYW1lIF0gfHwgKCBncm91cHNbIGdyb3VwTmFtZSBdID0gW10gKTtcblx0XHRcdFx0XHRncm91cFVuaWZvcm1zLnB1c2goIC4uLnVuaWZvcm1zICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGJpbmRpbmdzR3JvdXBzID0gW107XG5cblx0XHRcdGZvciAoIGNvbnN0IGdyb3VwTmFtZSBpbiBncm91cHMgKSB7XG5cblx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGdyb3VwTmFtZSBdO1xuXG5cdFx0XHRcdGNvbnN0IGJpbmRpbmdzR3JvdXAgPSB0aGlzLl9nZXRCaW5kR3JvdXAoIGdyb3VwTmFtZSwgZ3JvdXAgKTtcblxuXHRcdFx0XHRiaW5kaW5nc0dyb3Vwcy5wdXNoKCBiaW5kaW5nc0dyb3VwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5iaW5kR3JvdXBzID0gYmluZGluZ3NHcm91cHM7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYmluZGluZ3NHcm91cHM7XG5cblx0fVxuXG5cdHNvcnRCaW5kaW5nR3JvdXBzKCkge1xuXG5cdFx0Y29uc3QgYmluZGluZ3NHcm91cHMgPSB0aGlzLmdldEJpbmRpbmdzKCk7XG5cblx0XHRiaW5kaW5nc0dyb3Vwcy5zb3J0KCAoIGEsIGIgKSA9PiAoIGEuYmluZGluZ3NbIDAgXS5ncm91cE5vZGUub3JkZXIgLSBiLmJpbmRpbmdzWyAwIF0uZ3JvdXBOb2RlLm9yZGVyICkgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGJpbmRpbmdzR3JvdXBzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgYmluZGluZ0dyb3VwID0gYmluZGluZ3NHcm91cHNbIGkgXTtcblx0XHRcdHRoaXMuYmluZGluZ3NJbmRleGVzWyBiaW5kaW5nR3JvdXAubmFtZSBdLmdyb3VwID0gaTtcblxuXHRcdFx0YmluZGluZ0dyb3VwLmluZGV4ID0gaTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2V0SGFzaE5vZGUoIG5vZGUsIGhhc2ggKSB7XG5cblx0XHR0aGlzLmhhc2hOb2Rlc1sgaGFzaCBdID0gbm9kZTtcblxuXHR9XG5cblx0YWRkTm9kZSggbm9kZSApIHtcblxuXHRcdGlmICggdGhpcy5ub2Rlcy5pbmNsdWRlcyggbm9kZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0dGhpcy5ub2Rlcy5wdXNoKCBub2RlICk7XG5cblx0XHRcdHRoaXMuc2V0SGFzaE5vZGUoIG5vZGUsIG5vZGUuZ2V0SGFzaCggdGhpcyApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGFkZFNlcXVlbnRpYWxOb2RlKCBub2RlICkge1xuXG5cdFx0aWYgKCB0aGlzLnNlcXVlbnRpYWxOb2Rlcy5pbmNsdWRlcyggbm9kZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0dGhpcy5zZXF1ZW50aWFsTm9kZXMucHVzaCggbm9kZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRidWlsZFVwZGF0ZU5vZGVzKCkge1xuXG5cdFx0Zm9yICggY29uc3Qgbm9kZSBvZiB0aGlzLm5vZGVzICkge1xuXG5cdFx0XHRjb25zdCB1cGRhdGVUeXBlID0gbm9kZS5nZXRVcGRhdGVUeXBlKCk7XG5cblx0XHRcdGlmICggdXBkYXRlVHlwZSAhPT0gTm9kZVVwZGF0ZVR5cGUuTk9ORSApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZU5vZGVzLnB1c2goIG5vZGUuZ2V0U2VsZigpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIGNvbnN0IG5vZGUgb2YgdGhpcy5zZXF1ZW50aWFsTm9kZXMgKSB7XG5cblx0XHRcdGNvbnN0IHVwZGF0ZUJlZm9yZVR5cGUgPSBub2RlLmdldFVwZGF0ZUJlZm9yZVR5cGUoKTtcblx0XHRcdGNvbnN0IHVwZGF0ZUFmdGVyVHlwZSA9IG5vZGUuZ2V0VXBkYXRlQWZ0ZXJUeXBlKCk7XG5cblx0XHRcdGlmICggdXBkYXRlQmVmb3JlVHlwZSAhPT0gTm9kZVVwZGF0ZVR5cGUuTk9ORSApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZUJlZm9yZU5vZGVzLnB1c2goIG5vZGUuZ2V0U2VsZigpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1cGRhdGVBZnRlclR5cGUgIT09IE5vZGVVcGRhdGVUeXBlLk5PTkUgKSB7XG5cblx0XHRcdFx0dGhpcy51cGRhdGVBZnRlck5vZGVzLnB1c2goIG5vZGUuZ2V0U2VsZigpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Z2V0IGN1cnJlbnROb2RlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY2hhaW5pbmdbIHRoaXMuY2hhaW5pbmcubGVuZ3RoIC0gMSBdO1xuXG5cdH1cblxuXHRpc0ZpbHRlcmVkVGV4dHVyZSggdGV4dHVyZSApIHtcblxuXHRcdHJldHVybiAoIHRleHR1cmUubWFnRmlsdGVyID09PSBMaW5lYXJGaWx0ZXIgfHwgdGV4dHVyZS5tYWdGaWx0ZXIgPT09IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIgfHwgdGV4dHVyZS5tYWdGaWx0ZXIgPT09IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgfHwgdGV4dHVyZS5tYWdGaWx0ZXIgPT09IExpbmVhck1pcG1hcExpbmVhckZpbHRlciB8fFxuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPT09IExpbmVhckZpbHRlciB8fCB0ZXh0dXJlLm1pbkZpbHRlciA9PT0gTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciB8fCB0ZXh0dXJlLm1pbkZpbHRlciA9PT0gTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciB8fCB0ZXh0dXJlLm1pbkZpbHRlciA9PT0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyICk7XG5cblx0fVxuXG5cdGFkZENoYWluKCBub2RlICkge1xuXG5cdFx0Lypcblx0XHRpZiAoIHRoaXMuY2hhaW5pbmcuaW5kZXhPZiggbm9kZSApICE9PSAtIDEgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1JlY3Vyc2l2ZSBub2RlOiAnLCBub2RlICk7XG5cblx0XHR9XG5cdFx0Ki9cblxuXHRcdHRoaXMuY2hhaW5pbmcucHVzaCggbm9kZSApO1xuXG5cdH1cblxuXHRyZW1vdmVDaGFpbiggbm9kZSApIHtcblxuXHRcdGNvbnN0IGxhc3RDaGFpbiA9IHRoaXMuY2hhaW5pbmcucG9wKCk7XG5cblx0XHRpZiAoIGxhc3RDaGFpbiAhPT0gbm9kZSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTm9kZUJ1aWxkZXI6IEludmFsaWQgbm9kZSBjaGFpbmluZyEnICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldE1ldGhvZCggbWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ldGhvZDtcblxuXHR9XG5cblx0Z2V0Tm9kZUZyb21IYXNoKCBoYXNoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaGFzaE5vZGVzWyBoYXNoIF07XG5cblx0fVxuXG5cdGFkZEZsb3coIHNoYWRlclN0YWdlLCBub2RlICkge1xuXG5cdFx0dGhpcy5mbG93Tm9kZXNbIHNoYWRlclN0YWdlIF0ucHVzaCggbm9kZSApO1xuXG5cdFx0cmV0dXJuIG5vZGU7XG5cblx0fVxuXG5cdHNldENvbnRleHQoIGNvbnRleHQgKSB7XG5cblx0XHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXG5cdH1cblxuXHRnZXRDb250ZXh0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dDtcblxuXHR9XG5cblx0Z2V0U2hhcmVkQ29udGV4dCgpIHtcblxuXHRcdGNvbnN0IGNvbnRleHQgPSB7IC4uLnRoaXMuY29udGV4dCB9O1xuXG5cdFx0ZGVsZXRlIGNvbnRleHQubWF0ZXJpYWw7XG5cblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0O1xuXG5cdH1cblxuXHRzZXRDYWNoZSggY2FjaGUgKSB7XG5cblx0XHR0aGlzLmNhY2hlID0gY2FjaGU7XG5cblx0fVxuXG5cdGdldENhY2hlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGU7XG5cblx0fVxuXG5cdGdldENhY2hlRnJvbU5vZGUoIG5vZGUsIHBhcmVudCA9IHRydWUgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhRnJvbU5vZGUoIG5vZGUgKTtcblx0XHRpZiAoIGRhdGEuY2FjaGUgPT09IHVuZGVmaW5lZCApIGRhdGEuY2FjaGUgPSBuZXcgTm9kZUNhY2hlKCBwYXJlbnQgPyB0aGlzLmdldENhY2hlKCkgOiBudWxsICk7XG5cblx0XHRyZXR1cm4gZGF0YS5jYWNoZTtcblxuXHR9XG5cblx0aXNBdmFpbGFibGUoIC8qbmFtZSovICkge1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRnZXRWZXJ0ZXhJbmRleCgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGZ1bmN0aW9uLicgKTtcblxuXHR9XG5cblx0Z2V0SW5zdGFuY2VJbmRleCgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGZ1bmN0aW9uLicgKTtcblxuXHR9XG5cblx0Z2V0RHJhd0luZGV4KCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xuXG5cdH1cblxuXHRnZXRGcm9udEZhY2luZygpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGZ1bmN0aW9uLicgKTtcblxuXHR9XG5cblx0Z2V0RnJhZ0Nvb3JkKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xuXG5cdH1cblxuXHRpc0ZsaXBZKCkge1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRpbmNyZWFzZVVzYWdlKCBub2RlICkge1xuXG5cdFx0Y29uc3Qgbm9kZURhdGEgPSB0aGlzLmdldERhdGFGcm9tTm9kZSggbm9kZSApO1xuXHRcdG5vZGVEYXRhLnVzYWdlQ291bnQgPSBub2RlRGF0YS51c2FnZUNvdW50ID09PSB1bmRlZmluZWQgPyAxIDogbm9kZURhdGEudXNhZ2VDb3VudCArIDE7XG5cblx0XHRyZXR1cm4gbm9kZURhdGEudXNhZ2VDb3VudDtcblxuXHR9XG5cblx0Z2VuZXJhdGVUZXh0dXJlKCAvKiB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCAqLyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGZ1bmN0aW9uLicgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGVUZXh0dXJlTG9kKCAvKiB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgbGV2ZWxTbmlwcGV0ICovICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xuXG5cdH1cblxuXHRnZW5lcmF0ZUNvbnN0KCB0eXBlLCB2YWx1ZSA9IG51bGwgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09ICdmbG9hdCcgfHwgdHlwZSA9PT0gJ2ludCcgfHwgdHlwZSA9PT0gJ3VpbnQnICkgdmFsdWUgPSAwO1xuXHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdib29sJyApIHZhbHVlID0gZmFsc2U7XG5cdFx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ2NvbG9yJyApIHZhbHVlID0gbmV3IENvbG9yKCk7XG5cdFx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ3ZlYzInICkgdmFsdWUgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICd2ZWMzJyApIHZhbHVlID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGVsc2UgaWYgKCB0eXBlID09PSAndmVjNCcgKSB2YWx1ZSA9IG5ldyBWZWN0b3I0KCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHR5cGUgPT09ICdmbG9hdCcgKSByZXR1cm4gdG9GbG9hdCggdmFsdWUgKTtcblx0XHRpZiAoIHR5cGUgPT09ICdpbnQnICkgcmV0dXJuIGAkeyBNYXRoLnJvdW5kKCB2YWx1ZSApIH1gO1xuXHRcdGlmICggdHlwZSA9PT0gJ3VpbnQnICkgcmV0dXJuIHZhbHVlID49IDAgPyBgJHsgTWF0aC5yb3VuZCggdmFsdWUgKSB9dWAgOiAnMHUnO1xuXHRcdGlmICggdHlwZSA9PT0gJ2Jvb2wnICkgcmV0dXJuIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJztcblx0XHRpZiAoIHR5cGUgPT09ICdjb2xvcicgKSByZXR1cm4gYCR7IHRoaXMuZ2V0VHlwZSggJ3ZlYzMnICkgfSggJHsgdG9GbG9hdCggdmFsdWUuciApIH0sICR7IHRvRmxvYXQoIHZhbHVlLmcgKSB9LCAkeyB0b0Zsb2F0KCB2YWx1ZS5iICkgfSApYDtcblxuXHRcdGNvbnN0IHR5cGVMZW5ndGggPSB0aGlzLmdldFR5cGVMZW5ndGgoIHR5cGUgKTtcblxuXHRcdGNvbnN0IGNvbXBvbmVudFR5cGUgPSB0aGlzLmdldENvbXBvbmVudFR5cGUoIHR5cGUgKTtcblxuXHRcdGNvbnN0IGdlbmVyYXRlQ29uc3QgPSB2YWx1ZSA9PiB0aGlzLmdlbmVyYXRlQ29uc3QoIGNvbXBvbmVudFR5cGUsIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVMZW5ndGggPT09IDIgKSB7XG5cblx0XHRcdHJldHVybiBgJHsgdGhpcy5nZXRUeXBlKCB0eXBlICkgfSggJHsgZ2VuZXJhdGVDb25zdCggdmFsdWUueCApIH0sICR7IGdlbmVyYXRlQ29uc3QoIHZhbHVlLnkgKSB9IClgO1xuXG5cdFx0fSBlbHNlIGlmICggdHlwZUxlbmd0aCA9PT0gMyApIHtcblxuXHRcdFx0cmV0dXJuIGAkeyB0aGlzLmdldFR5cGUoIHR5cGUgKSB9KCAkeyBnZW5lcmF0ZUNvbnN0KCB2YWx1ZS54ICkgfSwgJHsgZ2VuZXJhdGVDb25zdCggdmFsdWUueSApIH0sICR7IGdlbmVyYXRlQ29uc3QoIHZhbHVlLnogKSB9IClgO1xuXG5cdFx0fSBlbHNlIGlmICggdHlwZUxlbmd0aCA9PT0gNCApIHtcblxuXHRcdFx0cmV0dXJuIGAkeyB0aGlzLmdldFR5cGUoIHR5cGUgKSB9KCAkeyBnZW5lcmF0ZUNvbnN0KCB2YWx1ZS54ICkgfSwgJHsgZ2VuZXJhdGVDb25zdCggdmFsdWUueSApIH0sICR7IGdlbmVyYXRlQ29uc3QoIHZhbHVlLnogKSB9LCAkeyBnZW5lcmF0ZUNvbnN0KCB2YWx1ZS53ICkgfSApYDtcblxuXHRcdH0gZWxzZSBpZiAoIHR5cGVMZW5ndGggPiA0ICYmIHZhbHVlICYmICggdmFsdWUuaXNNYXRyaXgzIHx8IHZhbHVlLmlzTWF0cml4NCApICkge1xuXG5cdFx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0VHlwZSggdHlwZSApIH0oICR7IHZhbHVlLmVsZW1lbnRzLm1hcCggZ2VuZXJhdGVDb25zdCApLmpvaW4oICcsICcgKSB9IClgO1xuXG5cdFx0fSBlbHNlIGlmICggdHlwZUxlbmd0aCA+IDQgKSB7XG5cblx0XHRcdHJldHVybiBgJHsgdGhpcy5nZXRUeXBlKCB0eXBlICkgfSgpYDtcblxuXHRcdH1cblxuXHRcdHRocm93IG5ldyBFcnJvciggYE5vZGVCdWlsZGVyOiBUeXBlICcke3R5cGV9JyBub3QgZm91bmQgaW4gZ2VuZXJhdGUgY29uc3RhbnQgYXR0ZW1wdC5gICk7XG5cblx0fVxuXG5cdGdldFR5cGUoIHR5cGUgKSB7XG5cblx0XHRpZiAoIHR5cGUgPT09ICdjb2xvcicgKSByZXR1cm4gJ3ZlYzMnO1xuXG5cdFx0cmV0dXJuIHR5cGU7XG5cblx0fVxuXG5cdGhhc0dlb21ldHJ5QXR0cmlidXRlKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSAhPT0gdW5kZWZpbmVkO1xuXG5cdH1cblxuXHRnZXRBdHRyaWJ1dGUoIG5hbWUsIHR5cGUgKSB7XG5cblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gZmluZCBhdHRyaWJ1dGVcblxuXHRcdGZvciAoIGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5uYW1lID09PSBuYW1lICkge1xuXG5cdFx0XHRcdHJldHVybiBhdHRyaWJ1dGU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBhIG5ldyBpZiBubyBleGlzdFxuXG5cdFx0Y29uc3QgYXR0cmlidXRlID0gbmV3IE5vZGVBdHRyaWJ1dGUoIG5hbWUsIHR5cGUgKTtcblxuXHRcdGF0dHJpYnV0ZXMucHVzaCggYXR0cmlidXRlICk7XG5cblx0XHRyZXR1cm4gYXR0cmlidXRlO1xuXG5cdH1cblxuXHRnZXRQcm9wZXJ0eU5hbWUoIG5vZGUvKiwgc2hhZGVyU3RhZ2UqLyApIHtcblxuXHRcdHJldHVybiBub2RlLm5hbWU7XG5cblx0fVxuXG5cdGlzVmVjdG9yKCB0eXBlICkge1xuXG5cdFx0cmV0dXJuIC92ZWNcXGQvLnRlc3QoIHR5cGUgKTtcblxuXHR9XG5cblx0aXNNYXRyaXgoIHR5cGUgKSB7XG5cblx0XHRyZXR1cm4gL21hdFxcZC8udGVzdCggdHlwZSApO1xuXG5cdH1cblxuXHRpc1JlZmVyZW5jZSggdHlwZSApIHtcblxuXHRcdHJldHVybiB0eXBlID09PSAndm9pZCcgfHwgdHlwZSA9PT0gJ3Byb3BlcnR5JyB8fCB0eXBlID09PSAnc2FtcGxlcicgfHwgdHlwZSA9PT0gJ3RleHR1cmUnIHx8IHR5cGUgPT09ICdjdWJlVGV4dHVyZScgfHwgdHlwZSA9PT0gJ3N0b3JhZ2VUZXh0dXJlJyB8fCB0eXBlID09PSAnZGVwdGhUZXh0dXJlJyB8fCB0eXBlID09PSAndGV4dHVyZTNEJztcblxuXHR9XG5cblx0bmVlZHNUb1dvcmtpbmdDb2xvclNwYWNlKCAvKnRleHR1cmUqLyApIHtcblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0Z2V0Q29tcG9uZW50VHlwZUZyb21UZXh0dXJlKCB0ZXh0dXJlICkge1xuXG5cdFx0Y29uc3QgdHlwZSA9IHRleHR1cmUudHlwZTtcblxuXHRcdGlmICggdGV4dHVyZS5pc0RhdGFUZXh0dXJlICkge1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IEludFR5cGUgKSByZXR1cm4gJ2ludCc7XG5cdFx0XHRpZiAoIHR5cGUgPT09IFVuc2lnbmVkSW50VHlwZSApIHJldHVybiAndWludCc7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gJ2Zsb2F0JztcblxuXHR9XG5cblx0Z2V0RWxlbWVudFR5cGUoIHR5cGUgKSB7XG5cblx0XHRpZiAoIHR5cGUgPT09ICdtYXQyJyApIHJldHVybiAndmVjMic7XG5cdFx0aWYgKCB0eXBlID09PSAnbWF0MycgKSByZXR1cm4gJ3ZlYzMnO1xuXHRcdGlmICggdHlwZSA9PT0gJ21hdDQnICkgcmV0dXJuICd2ZWM0JztcblxuXHRcdHJldHVybiB0aGlzLmdldENvbXBvbmVudFR5cGUoIHR5cGUgKTtcblxuXHR9XG5cblx0Z2V0Q29tcG9uZW50VHlwZSggdHlwZSApIHtcblxuXHRcdHR5cGUgPSB0aGlzLmdldFZlY3RvclR5cGUoIHR5cGUgKTtcblxuXHRcdGlmICggdHlwZSA9PT0gJ2Zsb2F0JyB8fCB0eXBlID09PSAnYm9vbCcgfHwgdHlwZSA9PT0gJ2ludCcgfHwgdHlwZSA9PT0gJ3VpbnQnICkgcmV0dXJuIHR5cGU7XG5cblx0XHRjb25zdCBjb21wb25lbnRUeXBlID0gLyhifGl8dXwpKHZlY3xtYXQpKFsyLTRdKS8uZXhlYyggdHlwZSApO1xuXG5cdFx0aWYgKCBjb21wb25lbnRUeXBlID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cblx0XHRpZiAoIGNvbXBvbmVudFR5cGVbIDEgXSA9PT0gJ2InICkgcmV0dXJuICdib29sJztcblx0XHRpZiAoIGNvbXBvbmVudFR5cGVbIDEgXSA9PT0gJ2knICkgcmV0dXJuICdpbnQnO1xuXHRcdGlmICggY29tcG9uZW50VHlwZVsgMSBdID09PSAndScgKSByZXR1cm4gJ3VpbnQnO1xuXG5cdFx0cmV0dXJuICdmbG9hdCc7XG5cblx0fVxuXG5cdGdldFZlY3RvclR5cGUoIHR5cGUgKSB7XG5cblx0XHRpZiAoIHR5cGUgPT09ICdjb2xvcicgKSByZXR1cm4gJ3ZlYzMnO1xuXHRcdGlmICggdHlwZSA9PT0gJ3RleHR1cmUnIHx8IHR5cGUgPT09ICdjdWJlVGV4dHVyZScgfHwgdHlwZSA9PT0gJ3N0b3JhZ2VUZXh0dXJlJyB8fCB0eXBlID09PSAndGV4dHVyZTNEJyApIHJldHVybiAndmVjNCc7XG5cblx0XHRyZXR1cm4gdHlwZTtcblxuXHR9XG5cblx0Z2V0VHlwZUZyb21MZW5ndGgoIGxlbmd0aCwgY29tcG9uZW50VHlwZSA9ICdmbG9hdCcgKSB7XG5cblx0XHRpZiAoIGxlbmd0aCA9PT0gMSApIHJldHVybiBjb21wb25lbnRUeXBlO1xuXG5cdFx0Y29uc3QgYmFzZVR5cGUgPSBnZXRUeXBlRnJvbUxlbmd0aCggbGVuZ3RoICk7XG5cdFx0Y29uc3QgcHJlZml4ID0gY29tcG9uZW50VHlwZSA9PT0gJ2Zsb2F0JyA/ICcnIDogY29tcG9uZW50VHlwZVsgMCBdO1xuXG5cdFx0cmV0dXJuIHByZWZpeCArIGJhc2VUeXBlO1xuXG5cdH1cblxuXHRnZXRUeXBlRnJvbUFycmF5KCBhcnJheSApIHtcblxuXHRcdHJldHVybiB0eXBlRnJvbUFycmF5LmdldCggYXJyYXkuY29uc3RydWN0b3IgKTtcblxuXHR9XG5cblx0Z2V0VHlwZUZyb21BdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuXHRcdGxldCBkYXRhQXR0cmlidXRlID0gYXR0cmlidXRlO1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIGRhdGFBdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcblxuXHRcdGNvbnN0IGFycmF5ID0gZGF0YUF0dHJpYnV0ZS5hcnJheTtcblx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRjb25zdCBub3JtYWxpemVkID0gYXR0cmlidXRlLm5vcm1hbGl6ZWQ7XG5cblx0XHRsZXQgYXJyYXlUeXBlO1xuXG5cdFx0aWYgKCAhICggYXR0cmlidXRlIGluc3RhbmNlb2YgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSApICYmIG5vcm1hbGl6ZWQgIT09IHRydWUgKSB7XG5cblx0XHRcdGFycmF5VHlwZSA9IHRoaXMuZ2V0VHlwZUZyb21BcnJheSggYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmdldFR5cGVGcm9tTGVuZ3RoKCBpdGVtU2l6ZSwgYXJyYXlUeXBlICk7XG5cblx0fVxuXG5cdGdldFR5cGVMZW5ndGgoIHR5cGUgKSB7XG5cblx0XHRjb25zdCB2ZWNUeXBlID0gdGhpcy5nZXRWZWN0b3JUeXBlKCB0eXBlICk7XG5cdFx0Y29uc3QgdmVjTnVtID0gL3ZlYyhbMi00XSkvLmV4ZWMoIHZlY1R5cGUgKTtcblxuXHRcdGlmICggdmVjTnVtICE9PSBudWxsICkgcmV0dXJuIE51bWJlciggdmVjTnVtWyAxIF0gKTtcblx0XHRpZiAoIHZlY1R5cGUgPT09ICdmbG9hdCcgfHwgdmVjVHlwZSA9PT0gJ2Jvb2wnIHx8IHZlY1R5cGUgPT09ICdpbnQnIHx8IHZlY1R5cGUgPT09ICd1aW50JyApIHJldHVybiAxO1xuXHRcdGlmICggL21hdDIvLnRlc3QoIHR5cGUgKSA9PT0gdHJ1ZSApIHJldHVybiA0O1xuXHRcdGlmICggL21hdDMvLnRlc3QoIHR5cGUgKSA9PT0gdHJ1ZSApIHJldHVybiA5O1xuXHRcdGlmICggL21hdDQvLnRlc3QoIHR5cGUgKSA9PT0gdHJ1ZSApIHJldHVybiAxNjtcblxuXHRcdHJldHVybiAwO1xuXG5cdH1cblxuXHRnZXRWZWN0b3JGcm9tTWF0cml4KCB0eXBlICkge1xuXG5cdFx0cmV0dXJuIHR5cGUucmVwbGFjZSggJ21hdCcsICd2ZWMnICk7XG5cblx0fVxuXG5cdGNoYW5nZUNvbXBvbmVudFR5cGUoIHR5cGUsIG5ld0NvbXBvbmVudFR5cGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRUeXBlRnJvbUxlbmd0aCggdGhpcy5nZXRUeXBlTGVuZ3RoKCB0eXBlICksIG5ld0NvbXBvbmVudFR5cGUgKTtcblxuXHR9XG5cblx0Z2V0SW50ZWdlclR5cGUoIHR5cGUgKSB7XG5cblx0XHRjb25zdCBjb21wb25lbnRUeXBlID0gdGhpcy5nZXRDb21wb25lbnRUeXBlKCB0eXBlICk7XG5cblx0XHRpZiAoIGNvbXBvbmVudFR5cGUgPT09ICdpbnQnIHx8IGNvbXBvbmVudFR5cGUgPT09ICd1aW50JyApIHJldHVybiB0eXBlO1xuXG5cdFx0cmV0dXJuIHRoaXMuY2hhbmdlQ29tcG9uZW50VHlwZSggdHlwZSwgJ2ludCcgKTtcblxuXHR9XG5cblx0YWRkU3RhY2soKSB7XG5cblx0XHR0aGlzLnN0YWNrID0gc3RhY2soIHRoaXMuc3RhY2sgKTtcblxuXHRcdHRoaXMuc3RhY2tzLnB1c2goIGdldEN1cnJlbnRTdGFjaygpIHx8IHRoaXMuc3RhY2sgKTtcblx0XHRzZXRDdXJyZW50U3RhY2soIHRoaXMuc3RhY2sgKTtcblxuXHRcdHJldHVybiB0aGlzLnN0YWNrO1xuXG5cdH1cblxuXHRyZW1vdmVTdGFjaygpIHtcblxuXHRcdGNvbnN0IGxhc3RTdGFjayA9IHRoaXMuc3RhY2s7XG5cdFx0dGhpcy5zdGFjayA9IGxhc3RTdGFjay5wYXJlbnQ7XG5cblx0XHRzZXRDdXJyZW50U3RhY2soIHRoaXMuc3RhY2tzLnBvcCgpICk7XG5cblx0XHRyZXR1cm4gbGFzdFN0YWNrO1xuXG5cdH1cblxuXHRnZXREYXRhRnJvbU5vZGUoIG5vZGUsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSwgY2FjaGUgPSBudWxsICkge1xuXG5cdFx0Y2FjaGUgPSBjYWNoZSA9PT0gbnVsbCA/ICggbm9kZS5pc0dsb2JhbCggdGhpcyApID8gdGhpcy5nbG9iYWxDYWNoZSA6IHRoaXMuY2FjaGUgKSA6IGNhY2hlO1xuXG5cdFx0bGV0IG5vZGVEYXRhID0gY2FjaGUuZ2V0RGF0YSggbm9kZSApO1xuXG5cdFx0aWYgKCBub2RlRGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRub2RlRGF0YSA9IHt9O1xuXG5cdFx0XHRjYWNoZS5zZXREYXRhKCBub2RlLCBub2RlRGF0YSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlRGF0YVsgc2hhZGVyU3RhZ2UgXSA9PT0gdW5kZWZpbmVkICkgbm9kZURhdGFbIHNoYWRlclN0YWdlIF0gPSB7fTtcblxuXHRcdHJldHVybiBub2RlRGF0YVsgc2hhZGVyU3RhZ2UgXTtcblxuXHR9XG5cblx0Z2V0Tm9kZVByb3BlcnRpZXMoIG5vZGUsIHNoYWRlclN0YWdlID0gJ2FueScgKSB7XG5cblx0XHRjb25zdCBub2RlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBub2RlLCBzaGFkZXJTdGFnZSApO1xuXG5cdFx0cmV0dXJuIG5vZGVEYXRhLnByb3BlcnRpZXMgfHwgKCBub2RlRGF0YS5wcm9wZXJ0aWVzID0geyBvdXRwdXROb2RlOiBudWxsIH0gKTtcblxuXHR9XG5cblx0Z2V0QnVmZmVyQXR0cmlidXRlRnJvbU5vZGUoIG5vZGUsIHR5cGUgKSB7XG5cblx0XHRjb25zdCBub2RlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBub2RlICk7XG5cblx0XHRsZXQgYnVmZmVyQXR0cmlidXRlID0gbm9kZURhdGEuYnVmZmVyQXR0cmlidXRlO1xuXG5cdFx0aWYgKCBidWZmZXJBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLnVuaWZvcm1zLmluZGV4ICsrO1xuXG5cdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgTm9kZUF0dHJpYnV0ZSggJ25vZGVBdHRyaWJ1dGUnICsgaW5kZXgsIHR5cGUsIG5vZGUgKTtcblxuXHRcdFx0dGhpcy5idWZmZXJBdHRyaWJ1dGVzLnB1c2goIGJ1ZmZlckF0dHJpYnV0ZSApO1xuXG5cdFx0XHRub2RlRGF0YS5idWZmZXJBdHRyaWJ1dGUgPSBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYnVmZmVyQXR0cmlidXRlO1xuXG5cdH1cblxuXHRnZXRTdHJ1Y3RUeXBlRnJvbU5vZGUoIG5vZGUsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcblxuXHRcdGNvbnN0IG5vZGVEYXRhID0gdGhpcy5nZXREYXRhRnJvbU5vZGUoIG5vZGUsIHNoYWRlclN0YWdlICk7XG5cblx0XHRpZiAoIG5vZGVEYXRhLnN0cnVjdFR5cGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLnN0cnVjdHMuaW5kZXggKys7XG5cblx0XHRcdG5vZGUubmFtZSA9IGBTdHJ1Y3RUeXBlJHsgaW5kZXggfWA7XG5cdFx0XHR0aGlzLnN0cnVjdHNbIHNoYWRlclN0YWdlIF0ucHVzaCggbm9kZSApO1xuXG5cdFx0XHRub2RlRGF0YS5zdHJ1Y3RUeXBlID0gbm9kZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlO1xuXG5cdH1cblxuXHRnZXRVbmlmb3JtRnJvbU5vZGUoIG5vZGUsIHR5cGUsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSwgbmFtZSA9IG51bGwgKSB7XG5cblx0XHRjb25zdCBub2RlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBub2RlLCBzaGFkZXJTdGFnZSwgdGhpcy5nbG9iYWxDYWNoZSApO1xuXG5cdFx0bGV0IG5vZGVVbmlmb3JtID0gbm9kZURhdGEudW5pZm9ybTtcblxuXHRcdGlmICggbm9kZVVuaWZvcm0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLnVuaWZvcm1zLmluZGV4ICsrO1xuXG5cdFx0XHRub2RlVW5pZm9ybSA9IG5ldyBOb2RlVW5pZm9ybSggbmFtZSB8fCAoICdub2RlVW5pZm9ybScgKyBpbmRleCApLCB0eXBlLCBub2RlICk7XG5cblx0XHRcdHRoaXMudW5pZm9ybXNbIHNoYWRlclN0YWdlIF0ucHVzaCggbm9kZVVuaWZvcm0gKTtcblxuXHRcdFx0bm9kZURhdGEudW5pZm9ybSA9IG5vZGVVbmlmb3JtO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vZGVVbmlmb3JtO1xuXG5cdH1cblxuXHRnZXRWYXJGcm9tTm9kZSggbm9kZSwgbmFtZSA9IG51bGwsIHR5cGUgPSBub2RlLmdldE5vZGVUeXBlKCB0aGlzICksIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcblxuXHRcdGNvbnN0IG5vZGVEYXRhID0gdGhpcy5nZXREYXRhRnJvbU5vZGUoIG5vZGUsIHNoYWRlclN0YWdlICk7XG5cblx0XHRsZXQgbm9kZVZhciA9IG5vZGVEYXRhLnZhcmlhYmxlO1xuXG5cdFx0aWYgKCBub2RlVmFyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHZhcnMgPSB0aGlzLnZhcnNbIHNoYWRlclN0YWdlIF0gfHwgKCB0aGlzLnZhcnNbIHNoYWRlclN0YWdlIF0gPSBbXSApO1xuXG5cdFx0XHRpZiAoIG5hbWUgPT09IG51bGwgKSBuYW1lID0gJ25vZGVWYXInICsgdmFycy5sZW5ndGg7XG5cblx0XHRcdG5vZGVWYXIgPSBuZXcgTm9kZVZhciggbmFtZSwgdHlwZSApO1xuXG5cdFx0XHR2YXJzLnB1c2goIG5vZGVWYXIgKTtcblxuXHRcdFx0bm9kZURhdGEudmFyaWFibGUgPSBub2RlVmFyO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vZGVWYXI7XG5cblx0fVxuXG5cdGdldFZhcnlpbmdGcm9tTm9kZSggbm9kZSwgbmFtZSA9IG51bGwsIHR5cGUgPSBub2RlLmdldE5vZGVUeXBlKCB0aGlzICkgKSB7XG5cblx0XHRjb25zdCBub2RlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBub2RlLCAnYW55JyApO1xuXG5cdFx0bGV0IG5vZGVWYXJ5aW5nID0gbm9kZURhdGEudmFyeWluZztcblxuXHRcdGlmICggbm9kZVZhcnlpbmcgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgdmFyeWluZ3MgPSB0aGlzLnZhcnlpbmdzO1xuXHRcdFx0Y29uc3QgaW5kZXggPSB2YXJ5aW5ncy5sZW5ndGg7XG5cblx0XHRcdGlmICggbmFtZSA9PT0gbnVsbCApIG5hbWUgPSAnbm9kZVZhcnlpbmcnICsgaW5kZXg7XG5cblx0XHRcdG5vZGVWYXJ5aW5nID0gbmV3IE5vZGVWYXJ5aW5nKCBuYW1lLCB0eXBlICk7XG5cblx0XHRcdHZhcnlpbmdzLnB1c2goIG5vZGVWYXJ5aW5nICk7XG5cblx0XHRcdG5vZGVEYXRhLnZhcnlpbmcgPSBub2RlVmFyeWluZztcblxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlVmFyeWluZztcblxuXHR9XG5cblx0Z2V0Q29kZUZyb21Ob2RlKCBub2RlLCB0eXBlLCBzaGFkZXJTdGFnZSA9IHRoaXMuc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRjb25zdCBub2RlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBub2RlICk7XG5cblx0XHRsZXQgbm9kZUNvZGUgPSBub2RlRGF0YS5jb2RlO1xuXG5cdFx0aWYgKCBub2RlQ29kZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBjb2RlcyA9IHRoaXMuY29kZXNbIHNoYWRlclN0YWdlIF0gfHwgKCB0aGlzLmNvZGVzWyBzaGFkZXJTdGFnZSBdID0gW10gKTtcblx0XHRcdGNvbnN0IGluZGV4ID0gY29kZXMubGVuZ3RoO1xuXG5cdFx0XHRub2RlQ29kZSA9IG5ldyBOb2RlQ29kZSggJ25vZGVDb2RlJyArIGluZGV4LCB0eXBlICk7XG5cblx0XHRcdGNvZGVzLnB1c2goIG5vZGVDb2RlICk7XG5cblx0XHRcdG5vZGVEYXRhLmNvZGUgPSBub2RlQ29kZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlQ29kZTtcblxuXHR9XG5cblx0YWRkRmxvd0NvZGVIaWVyYXJjaHkoIG5vZGUsIG5vZGVCbG9jayApIHtcblxuXHRcdGNvbnN0IHsgZmxvd0NvZGVzLCBmbG93Q29kZUJsb2NrIH0gPSB0aGlzLmdldERhdGFGcm9tTm9kZSggbm9kZSApO1xuXG5cdFx0bGV0IG5lZWRzRmxvd0NvZGUgPSB0cnVlO1xuXHRcdGxldCBub2RlQmxvY2tIaWVyYXJjaHkgPSBub2RlQmxvY2s7XG5cblx0XHR3aGlsZSAoIG5vZGVCbG9ja0hpZXJhcmNoeSApIHtcblxuXHRcdFx0aWYgKCBmbG93Q29kZUJsb2NrLmdldCggbm9kZUJsb2NrSGllcmFyY2h5ICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0bmVlZHNGbG93Q29kZSA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRub2RlQmxvY2tIaWVyYXJjaHkgPSB0aGlzLmdldERhdGFGcm9tTm9kZSggbm9kZUJsb2NrSGllcmFyY2h5ICkucGFyZW50Tm9kZUJsb2NrO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBuZWVkc0Zsb3dDb2RlICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCBmbG93Q29kZSBvZiBmbG93Q29kZXMgKSB7XG5cblx0XHRcdFx0dGhpcy5hZGRMaW5lRmxvd0NvZGUoIGZsb3dDb2RlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0YWRkTGluZUZsb3dDb2RlQmxvY2soIG5vZGUsIGNvZGUsIG5vZGVCbG9jayApIHtcblxuXHRcdGNvbnN0IG5vZGVEYXRhID0gdGhpcy5nZXREYXRhRnJvbU5vZGUoIG5vZGUgKTtcblx0XHRjb25zdCBmbG93Q29kZXMgPSBub2RlRGF0YS5mbG93Q29kZXMgfHwgKCBub2RlRGF0YS5mbG93Q29kZXMgPSBbXSApO1xuXHRcdGNvbnN0IGNvZGVCbG9jayA9IG5vZGVEYXRhLmZsb3dDb2RlQmxvY2sgfHwgKCBub2RlRGF0YS5mbG93Q29kZUJsb2NrID0gbmV3IFdlYWtNYXAoKSApO1xuXG5cdFx0Zmxvd0NvZGVzLnB1c2goIGNvZGUgKTtcblx0XHRjb2RlQmxvY2suc2V0KCBub2RlQmxvY2ssIHRydWUgKTtcblxuXHR9XG5cblx0YWRkTGluZUZsb3dDb2RlKCBjb2RlLCBub2RlID0gbnVsbCApIHtcblxuXHRcdGlmICggY29kZSA9PT0gJycgKSByZXR1cm4gdGhpcztcblxuXHRcdGlmICggbm9kZSAhPT0gbnVsbCAmJiB0aGlzLmNvbnRleHQubm9kZUJsb2NrICkge1xuXG5cdFx0XHR0aGlzLmFkZExpbmVGbG93Q29kZUJsb2NrKCBub2RlLCBjb2RlLCB0aGlzLmNvbnRleHQubm9kZUJsb2NrICk7XG5cblx0XHR9XG5cblx0XHRjb2RlID0gdGhpcy50YWIgKyBjb2RlO1xuXG5cdFx0aWYgKCAhIC87XFxzKiQvLnRlc3QoIGNvZGUgKSApIHtcblxuXHRcdFx0Y29kZSA9IGNvZGUgKyAnO1xcbic7XG5cblx0XHR9XG5cblx0XHR0aGlzLmZsb3cuY29kZSArPSBjb2RlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZEZsb3dDb2RlKCBjb2RlICkge1xuXG5cdFx0dGhpcy5mbG93LmNvZGUgKz0gY29kZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRGbG93VGFiKCkge1xuXG5cdFx0dGhpcy50YWIgKz0gJ1xcdCc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVtb3ZlRmxvd1RhYigpIHtcblxuXHRcdHRoaXMudGFiID0gdGhpcy50YWIuc2xpY2UoIDAsIC0gMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldEZsb3dEYXRhKCBub2RlLyosIHNoYWRlclN0YWdlKi8gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5mbG93c0RhdGEuZ2V0KCBub2RlICk7XG5cblx0fVxuXG5cdGZsb3dOb2RlKCBub2RlICkge1xuXG5cdFx0Y29uc3Qgb3V0cHV0ID0gbm9kZS5nZXROb2RlVHlwZSggdGhpcyApO1xuXG5cdFx0Y29uc3QgZmxvd0RhdGEgPSB0aGlzLmZsb3dDaGlsZE5vZGUoIG5vZGUsIG91dHB1dCApO1xuXG5cdFx0dGhpcy5mbG93c0RhdGEuc2V0KCBub2RlLCBmbG93RGF0YSApO1xuXG5cdFx0cmV0dXJuIGZsb3dEYXRhO1xuXG5cdH1cblxuXHRidWlsZEZ1bmN0aW9uTm9kZSggc2hhZGVyTm9kZSApIHtcblxuXHRcdGNvbnN0IGZuID0gbmV3IEZ1bmN0aW9uTm9kZSgpO1xuXG5cdFx0Y29uc3QgcHJldmlvdXMgPSB0aGlzLmN1cnJlbnRGdW5jdGlvbk5vZGU7XG5cblx0XHR0aGlzLmN1cnJlbnRGdW5jdGlvbk5vZGUgPSBmbjtcblxuXHRcdGZuLmNvZGUgPSB0aGlzLmJ1aWxkRnVuY3Rpb25Db2RlKCBzaGFkZXJOb2RlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRGdW5jdGlvbk5vZGUgPSBwcmV2aW91cztcblxuXHRcdHJldHVybiBmbjtcblxuXHR9XG5cblx0Zmxvd1NoYWRlck5vZGUoIHNoYWRlck5vZGUgKSB7XG5cblx0XHRjb25zdCBsYXlvdXQgPSBzaGFkZXJOb2RlLmxheW91dDtcblxuXHRcdGNvbnN0IGlucHV0cyA9IHtcblx0XHRcdFsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdFx0Y29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyggdGhpcyApO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdG5leHQ6ICgpID0+ICgge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlc1sgaW5kZXggXSxcblx0XHRcdFx0XHRcdGRvbmU6IGluZGV4ICsrID49IHZhbHVlcy5sZW5ndGhcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmb3IgKCBjb25zdCBpbnB1dCBvZiBsYXlvdXQuaW5wdXRzICkge1xuXG5cdFx0XHRpbnB1dHNbIGlucHV0Lm5hbWUgXSA9IG5ldyBQYXJhbWV0ZXJOb2RlKCBpbnB1dC50eXBlLCBpbnB1dC5uYW1lICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0c2hhZGVyTm9kZS5sYXlvdXQgPSBudWxsO1xuXG5cdFx0Y29uc3QgY2FsbE5vZGUgPSBzaGFkZXJOb2RlLmNhbGwoIGlucHV0cyApO1xuXHRcdGNvbnN0IGZsb3dEYXRhID0gdGhpcy5mbG93U3RhZ2VzTm9kZSggY2FsbE5vZGUsIGxheW91dC50eXBlICk7XG5cblx0XHRzaGFkZXJOb2RlLmxheW91dCA9IGxheW91dDtcblxuXHRcdHJldHVybiBmbG93RGF0YTtcblxuXHR9XG5cblx0Zmxvd1N0YWdlc05vZGUoIG5vZGUsIG91dHB1dCA9IG51bGwgKSB7XG5cblx0XHRjb25zdCBwcmV2aW91c0Zsb3cgPSB0aGlzLmZsb3c7XG5cdFx0Y29uc3QgcHJldmlvdXNWYXJzID0gdGhpcy52YXJzO1xuXHRcdGNvbnN0IHByZXZpb3VzQ2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGNvbnN0IHByZXZpb3VzQnVpbGRTdGFnZSA9IHRoaXMuYnVpbGRTdGFnZTtcblx0XHRjb25zdCBwcmV2aW91c1N0YWNrID0gdGhpcy5zdGFjaztcblxuXHRcdGNvbnN0IGZsb3cgPSB7XG5cdFx0XHRjb2RlOiAnJ1xuXHRcdH07XG5cblx0XHR0aGlzLmZsb3cgPSBmbG93O1xuXHRcdHRoaXMudmFycyA9IHt9O1xuXHRcdHRoaXMuY2FjaGUgPSBuZXcgTm9kZUNhY2hlKCk7XG5cdFx0dGhpcy5zdGFjayA9IHN0YWNrKCk7XG5cblx0XHRmb3IgKCBjb25zdCBidWlsZFN0YWdlIG9mIGRlZmF1bHRCdWlsZFN0YWdlcyApIHtcblxuXHRcdFx0dGhpcy5zZXRCdWlsZFN0YWdlKCBidWlsZFN0YWdlICk7XG5cblx0XHRcdGZsb3cucmVzdWx0ID0gbm9kZS5idWlsZCggdGhpcywgb3V0cHV0ICk7XG5cblx0XHR9XG5cblx0XHRmbG93LnZhcnMgPSB0aGlzLmdldFZhcnMoIHRoaXMuc2hhZGVyU3RhZ2UgKTtcblxuXHRcdHRoaXMuZmxvdyA9IHByZXZpb3VzRmxvdztcblx0XHR0aGlzLnZhcnMgPSBwcmV2aW91c1ZhcnM7XG5cdFx0dGhpcy5jYWNoZSA9IHByZXZpb3VzQ2FjaGU7XG5cdFx0dGhpcy5zdGFjayA9IHByZXZpb3VzU3RhY2s7XG5cblx0XHR0aGlzLnNldEJ1aWxkU3RhZ2UoIHByZXZpb3VzQnVpbGRTdGFnZSApO1xuXG5cdFx0cmV0dXJuIGZsb3c7XG5cblx0fVxuXG5cdGdldEZ1bmN0aW9uT3BlcmF0b3IoKSB7XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0Zmxvd0NoaWxkTm9kZSggbm9kZSwgb3V0cHV0ID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IHByZXZpb3VzRmxvdyA9IHRoaXMuZmxvdztcblxuXHRcdGNvbnN0IGZsb3cgPSB7XG5cdFx0XHRjb2RlOiAnJ1xuXHRcdH07XG5cblx0XHR0aGlzLmZsb3cgPSBmbG93O1xuXG5cdFx0Zmxvdy5yZXN1bHQgPSBub2RlLmJ1aWxkKCB0aGlzLCBvdXRwdXQgKTtcblxuXHRcdHRoaXMuZmxvdyA9IHByZXZpb3VzRmxvdztcblxuXHRcdHJldHVybiBmbG93O1xuXG5cdH1cblxuXHRmbG93Tm9kZUZyb21TaGFkZXJTdGFnZSggc2hhZGVyU3RhZ2UsIG5vZGUsIG91dHB1dCA9IG51bGwsIHByb3BlcnR5TmFtZSA9IG51bGwgKSB7XG5cblx0XHRjb25zdCBwcmV2aW91c1NoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZTtcblxuXHRcdHRoaXMuc2V0U2hhZGVyU3RhZ2UoIHNoYWRlclN0YWdlICk7XG5cblx0XHRjb25zdCBmbG93RGF0YSA9IHRoaXMuZmxvd0NoaWxkTm9kZSggbm9kZSwgb3V0cHV0ICk7XG5cblx0XHRpZiAoIHByb3BlcnR5TmFtZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0Zmxvd0RhdGEuY29kZSArPSBgJHsgdGhpcy50YWIgKyBwcm9wZXJ0eU5hbWUgfSA9ICR7IGZsb3dEYXRhLnJlc3VsdCB9O1xcbmA7XG5cblx0XHR9XG5cblx0XHR0aGlzLmZsb3dDb2RlWyBzaGFkZXJTdGFnZSBdID0gdGhpcy5mbG93Q29kZVsgc2hhZGVyU3RhZ2UgXSArIGZsb3dEYXRhLmNvZGU7XG5cblx0XHR0aGlzLnNldFNoYWRlclN0YWdlKCBwcmV2aW91c1NoYWRlclN0YWdlICk7XG5cblx0XHRyZXR1cm4gZmxvd0RhdGE7XG5cblx0fVxuXG5cdGdldEF0dHJpYnV0ZXNBcnJheSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuY29uY2F0KCB0aGlzLmJ1ZmZlckF0dHJpYnV0ZXMgKTtcblxuXHR9XG5cblx0Z2V0QXR0cmlidXRlcyggLypzaGFkZXJTdGFnZSovICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xuXG5cdH1cblxuXHRnZXRWYXJ5aW5ncyggLypzaGFkZXJTdGFnZSovICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xuXG5cdH1cblxuXHRnZXRWYXIoIHR5cGUsIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0VHlwZSggdHlwZSApIH0gJHsgbmFtZSB9YDtcblxuXHR9XG5cblx0Z2V0VmFycyggc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRsZXQgc25pcHBldCA9ICcnO1xuXG5cdFx0Y29uc3QgdmFycyA9IHRoaXMudmFyc1sgc2hhZGVyU3RhZ2UgXTtcblxuXHRcdGlmICggdmFycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCB2YXJpYWJsZSBvZiB2YXJzICkge1xuXG5cdFx0XHRcdHNuaXBwZXQgKz0gYCR7IHRoaXMuZ2V0VmFyKCB2YXJpYWJsZS50eXBlLCB2YXJpYWJsZS5uYW1lICkgfTsgYDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNuaXBwZXQ7XG5cblx0fVxuXG5cdGdldFVuaWZvcm1zKCAvKnNoYWRlclN0YWdlKi8gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdBYnN0cmFjdCBmdW5jdGlvbi4nICk7XG5cblx0fVxuXG5cdGdldENvZGVzKCBzaGFkZXJTdGFnZSApIHtcblxuXHRcdGNvbnN0IGNvZGVzID0gdGhpcy5jb2Rlc1sgc2hhZGVyU3RhZ2UgXTtcblxuXHRcdGxldCBjb2RlID0gJyc7XG5cblx0XHRpZiAoIGNvZGVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IG5vZGVDb2RlIG9mIGNvZGVzICkge1xuXG5cdFx0XHRcdGNvZGUgKz0gbm9kZUNvZGUuY29kZSArICdcXG4nO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY29kZTtcblxuXHR9XG5cblx0Z2V0SGFzaCgpIHtcblxuXHRcdHJldHVybiB0aGlzLnZlcnRleFNoYWRlciArIHRoaXMuZnJhZ21lbnRTaGFkZXIgKyB0aGlzLmNvbXB1dGVTaGFkZXI7XG5cblx0fVxuXG5cdHNldFNoYWRlclN0YWdlKCBzaGFkZXJTdGFnZSApIHtcblxuXHRcdHRoaXMuc2hhZGVyU3RhZ2UgPSBzaGFkZXJTdGFnZTtcblxuXHR9XG5cblx0Z2V0U2hhZGVyU3RhZ2UoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zaGFkZXJTdGFnZTtcblxuXHR9XG5cblx0c2V0QnVpbGRTdGFnZSggYnVpbGRTdGFnZSApIHtcblxuXHRcdHRoaXMuYnVpbGRTdGFnZSA9IGJ1aWxkU3RhZ2U7XG5cblx0fVxuXG5cdGdldEJ1aWxkU3RhZ2UoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5idWlsZFN0YWdlO1xuXG5cdH1cblxuXHRidWlsZENvZGUoKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdBYnN0cmFjdCBmdW5jdGlvbi4nICk7XG5cblx0fVxuXG5cdGJ1aWxkKCkge1xuXG5cdFx0Y29uc3QgeyBvYmplY3QsIG1hdGVyaWFsLCByZW5kZXJlciB9ID0gdGhpcztcblxuXHRcdGlmICggbWF0ZXJpYWwgIT09IG51bGwgKSB7XG5cblx0XHRcdGxldCBub2RlTWF0ZXJpYWwgPSByZW5kZXJlci5saWJyYXJ5LmZyb21NYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0aWYgKCBub2RlTWF0ZXJpYWwgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggYE5vZGVNYXRlcmlhbDogTWF0ZXJpYWwgXCIkeyBtYXRlcmlhbC50eXBlIH1cIiBpcyBub3QgY29tcGF0aWJsZS5gICk7XG5cblx0XHRcdFx0bm9kZU1hdGVyaWFsID0gbmV3IE5vZGVNYXRlcmlhbCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdG5vZGVNYXRlcmlhbC5idWlsZCggdGhpcyApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5hZGRGbG93KCAnY29tcHV0ZScsIG9iamVjdCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gc2V0dXAoKSAtPiBzdGFnZSAxOiBjcmVhdGUgcG9zc2libGUgbmV3IG5vZGVzIGFuZCByZXR1cm5zIGFuIG91dHB1dCByZWZlcmVuY2Ugbm9kZVxuXHRcdC8vIGFuYWx5emUoKSAgIC0+IHN0YWdlIDI6IGFuYWx5emUgbm9kZXMgdG8gcG9zc2libGUgb3B0aW1pemF0aW9uIGFuZCB2YWxpZGF0aW9uXG5cdFx0Ly8gZ2VuZXJhdGUoKSAgLT4gc3RhZ2UgMzogZ2VuZXJhdGUgc2hhZGVyXG5cblx0XHRmb3IgKCBjb25zdCBidWlsZFN0YWdlIG9mIGRlZmF1bHRCdWlsZFN0YWdlcyApIHtcblxuXHRcdFx0dGhpcy5zZXRCdWlsZFN0YWdlKCBidWlsZFN0YWdlICk7XG5cblx0XHRcdGlmICggdGhpcy5jb250ZXh0LnZlcnRleCAmJiB0aGlzLmNvbnRleHQudmVydGV4LmlzTm9kZSApIHtcblxuXHRcdFx0XHR0aGlzLmZsb3dOb2RlRnJvbVNoYWRlclN0YWdlKCAndmVydGV4JywgdGhpcy5jb250ZXh0LnZlcnRleCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGNvbnN0IHNoYWRlclN0YWdlIG9mIHNoYWRlclN0YWdlcyApIHtcblxuXHRcdFx0XHR0aGlzLnNldFNoYWRlclN0YWdlKCBzaGFkZXJTdGFnZSApO1xuXG5cdFx0XHRcdGNvbnN0IGZsb3dOb2RlcyA9IHRoaXMuZmxvd05vZGVzWyBzaGFkZXJTdGFnZSBdO1xuXG5cdFx0XHRcdGZvciAoIGNvbnN0IG5vZGUgb2YgZmxvd05vZGVzICkge1xuXG5cdFx0XHRcdFx0aWYgKCBidWlsZFN0YWdlID09PSAnZ2VuZXJhdGUnICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLmZsb3dOb2RlKCBub2RlICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRub2RlLmJ1aWxkKCB0aGlzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldEJ1aWxkU3RhZ2UoIG51bGwgKTtcblx0XHR0aGlzLnNldFNoYWRlclN0YWdlKCBudWxsICk7XG5cblx0XHQvLyBzdGFnZSA0OiBidWlsZCBjb2RlIGZvciBhIHNwZWNpZmljIG91dHB1dFxuXG5cdFx0dGhpcy5idWlsZENvZGUoKTtcblx0XHR0aGlzLmJ1aWxkVXBkYXRlTm9kZXMoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXROb2RlVW5pZm9ybSggdW5pZm9ybU5vZGUsIHR5cGUgKSB7XG5cblx0XHRpZiAoIHR5cGUgPT09ICdmbG9hdCcgfHwgdHlwZSA9PT0gJ2ludCcgfHwgdHlwZSA9PT0gJ3VpbnQnICkgcmV0dXJuIG5ldyBOdW1iZXJOb2RlVW5pZm9ybSggdW5pZm9ybU5vZGUgKTtcblx0XHRpZiAoIHR5cGUgPT09ICd2ZWMyJyB8fCB0eXBlID09PSAnaXZlYzInIHx8IHR5cGUgPT09ICd1dmVjMicgKSByZXR1cm4gbmV3IFZlY3RvcjJOb2RlVW5pZm9ybSggdW5pZm9ybU5vZGUgKTtcblx0XHRpZiAoIHR5cGUgPT09ICd2ZWMzJyB8fCB0eXBlID09PSAnaXZlYzMnIHx8IHR5cGUgPT09ICd1dmVjMycgKSByZXR1cm4gbmV3IFZlY3RvcjNOb2RlVW5pZm9ybSggdW5pZm9ybU5vZGUgKTtcblx0XHRpZiAoIHR5cGUgPT09ICd2ZWM0JyB8fCB0eXBlID09PSAnaXZlYzQnIHx8IHR5cGUgPT09ICd1dmVjNCcgKSByZXR1cm4gbmV3IFZlY3RvcjROb2RlVW5pZm9ybSggdW5pZm9ybU5vZGUgKTtcblx0XHRpZiAoIHR5cGUgPT09ICdjb2xvcicgKSByZXR1cm4gbmV3IENvbG9yTm9kZVVuaWZvcm0oIHVuaWZvcm1Ob2RlICk7XG5cdFx0aWYgKCB0eXBlID09PSAnbWF0MycgKSByZXR1cm4gbmV3IE1hdHJpeDNOb2RlVW5pZm9ybSggdW5pZm9ybU5vZGUgKTtcblx0XHRpZiAoIHR5cGUgPT09ICdtYXQ0JyApIHJldHVybiBuZXcgTWF0cml4NE5vZGVVbmlmb3JtKCB1bmlmb3JtTm9kZSApO1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBgVW5pZm9ybSBcIiR7dHlwZX1cIiBub3QgZGVjbGFyZWQuYCApO1xuXG5cdH1cblxuXHRjcmVhdGVOb2RlTWF0ZXJpYWwoIHR5cGUgPSAnTm9kZU1hdGVyaWFsJyApIHsgLy8gQGRlcHJlY2F0ZWQsIHIxNjhcblxuXHRcdHRocm93IG5ldyBFcnJvciggYFRIUkVFLk5vZGVCdWlsZGVyOiBjcmVhdGVOb2RlTWF0ZXJpYWwoKSB3YXMgZGVwcmVjYXRlZC4gVXNlIG5ldyAkeyB0eXBlIH0oKSBpbnN0ZWFkLmAgKTtcblxuXHR9XG5cblx0Zm9ybWF0KCBzbmlwcGV0LCBmcm9tVHlwZSwgdG9UeXBlICkge1xuXG5cdFx0ZnJvbVR5cGUgPSB0aGlzLmdldFZlY3RvclR5cGUoIGZyb21UeXBlICk7XG5cdFx0dG9UeXBlID0gdGhpcy5nZXRWZWN0b3JUeXBlKCB0b1R5cGUgKTtcblxuXHRcdGlmICggZnJvbVR5cGUgPT09IHRvVHlwZSB8fCB0b1R5cGUgPT09IG51bGwgfHwgdGhpcy5pc1JlZmVyZW5jZSggdG9UeXBlICkgKSB7XG5cblx0XHRcdHJldHVybiBzbmlwcGV0O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZnJvbVR5cGVMZW5ndGggPSB0aGlzLmdldFR5cGVMZW5ndGgoIGZyb21UeXBlICk7XG5cdFx0Y29uc3QgdG9UeXBlTGVuZ3RoID0gdGhpcy5nZXRUeXBlTGVuZ3RoKCB0b1R5cGUgKTtcblxuXHRcdGlmICggZnJvbVR5cGVMZW5ndGggPT09IDE2ICYmIHRvVHlwZUxlbmd0aCA9PT0gOSApIHtcblxuXHRcdFx0cmV0dXJuIGAkeyB0aGlzLmdldFR5cGUoIHRvVHlwZSApIH0oJHsgc25pcHBldCB9WzBdLnh5eiwgJHsgc25pcHBldCB9WzFdLnh5eiwgJHsgc25pcHBldCB9WzJdLnh5eilgO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBmcm9tVHlwZUxlbmd0aCA9PT0gOSAmJiB0b1R5cGVMZW5ndGggPT09IDQgKSB7XG5cblx0XHRcdHJldHVybiBgJHsgdGhpcy5nZXRUeXBlKCB0b1R5cGUgKSB9KCR7IHNuaXBwZXQgfVswXS54eSwgJHsgc25pcHBldCB9WzFdLnh5KWA7XG5cblx0XHR9XG5cblxuXHRcdGlmICggZnJvbVR5cGVMZW5ndGggPiA0ICkgeyAvLyBmcm9tVHlwZSBpcyBtYXRyaXgtbGlrZVxuXG5cdFx0XHQvLyBAVE9ETzogaWdub3JlIGZvciBub3dcblxuXHRcdFx0cmV0dXJuIHNuaXBwZXQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRvVHlwZUxlbmd0aCA+IDQgfHwgdG9UeXBlTGVuZ3RoID09PSAwICkgeyAvLyB0b1R5cGUgaXMgbWF0cml4LWxpa2Ugb3IgdW5rbm93blxuXG5cdFx0XHQvLyBAVE9ETzogaWdub3JlIGZvciBub3dcblxuXHRcdFx0cmV0dXJuIHNuaXBwZXQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIGZyb21UeXBlTGVuZ3RoID09PSB0b1R5cGVMZW5ndGggKSB7XG5cblx0XHRcdHJldHVybiBgJHsgdGhpcy5nZXRUeXBlKCB0b1R5cGUgKSB9KCAkeyBzbmlwcGV0IH0gKWA7XG5cblx0XHR9XG5cblx0XHRpZiAoIGZyb21UeXBlTGVuZ3RoID4gdG9UeXBlTGVuZ3RoICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5mb3JtYXQoIGAkeyBzbmlwcGV0IH0uJHsgJ3h5eicuc2xpY2UoIDAsIHRvVHlwZUxlbmd0aCApIH1gLCB0aGlzLmdldFR5cGVGcm9tTGVuZ3RoKCB0b1R5cGVMZW5ndGgsIHRoaXMuZ2V0Q29tcG9uZW50VHlwZSggZnJvbVR5cGUgKSApLCB0b1R5cGUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdG9UeXBlTGVuZ3RoID09PSA0ICYmIGZyb21UeXBlTGVuZ3RoID4gMSApIHsgLy8gdG9UeXBlIGlzIHZlYzQtbGlrZVxuXG5cdFx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0VHlwZSggdG9UeXBlICkgfSggJHsgdGhpcy5mb3JtYXQoIHNuaXBwZXQsIGZyb21UeXBlLCAndmVjMycgKSB9LCAxLjAgKWA7XG5cblx0XHR9XG5cblx0XHRpZiAoIGZyb21UeXBlTGVuZ3RoID09PSAyICkgeyAvLyBmcm9tVHlwZSBpcyB2ZWMyLWxpa2UgYW5kIHRvVHlwZSBpcyB2ZWMzLWxpa2VcblxuXHRcdFx0cmV0dXJuIGAkeyB0aGlzLmdldFR5cGUoIHRvVHlwZSApIH0oICR7IHRoaXMuZm9ybWF0KCBzbmlwcGV0LCBmcm9tVHlwZSwgJ3ZlYzInICkgfSwgMC4wIClgO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBmcm9tVHlwZUxlbmd0aCA9PT0gMSAmJiB0b1R5cGVMZW5ndGggPiAxICYmIGZyb21UeXBlICE9PSB0aGlzLmdldENvbXBvbmVudFR5cGUoIHRvVHlwZSApICkgeyAvLyBmcm9tVHlwZSBpcyBmbG9hdC1saWtlXG5cblx0XHRcdC8vIGNvbnZlcnQgYSBudW1iZXIgdmFsdWUgdG8gdmVjdG9yIHR5cGUsIGUuZzpcblx0XHRcdC8vIHZlYzMoIDF1ICkgLT4gdmVjMyggZmxvYXQoIDF1ICkgKVxuXG5cdFx0XHRzbmlwcGV0ID0gYCR7IHRoaXMuZ2V0VHlwZSggdGhpcy5nZXRDb21wb25lbnRUeXBlKCB0b1R5cGUgKSApIH0oICR7IHNuaXBwZXQgfSApYDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBgJHsgdGhpcy5nZXRUeXBlKCB0b1R5cGUgKSB9KCAkeyBzbmlwcGV0IH0gKWA7IC8vIGZyb21UeXBlIGlzIGZsb2F0LWxpa2VcblxuXHR9XG5cblx0Z2V0U2lnbmF0dXJlKCkge1xuXG5cdFx0cmV0dXJuIGAvLyBUaHJlZS5qcyByJHsgUkVWSVNJT04gfSAtIE5vZGUgU3lzdGVtXFxuYDtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTm9kZUJ1aWxkZXI7XG4iLCJpbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcblxuY2xhc3MgTm9kZUZyYW1lIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMudGltZSA9IDA7XG5cdFx0dGhpcy5kZWx0YVRpbWUgPSAwO1xuXG5cdFx0dGhpcy5mcmFtZUlkID0gMDtcblx0XHR0aGlzLnJlbmRlcklkID0gMDtcblxuXHRcdHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdHRoaXMudXBkYXRlTWFwID0gbmV3IFdlYWtNYXAoKTtcblx0XHR0aGlzLnVwZGF0ZUJlZm9yZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0dGhpcy51cGRhdGVBZnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cblx0XHR0aGlzLnJlbmRlcmVyID0gbnVsbDtcblx0XHR0aGlzLm1hdGVyaWFsID0gbnVsbDtcblx0XHR0aGlzLmNhbWVyYSA9IG51bGw7XG5cdFx0dGhpcy5vYmplY3QgPSBudWxsO1xuXHRcdHRoaXMuc2NlbmUgPSBudWxsO1xuXG5cdH1cblxuXHRfZ2V0TWFwcyggcmVmZXJlbmNlTWFwLCBub2RlUmVmICkge1xuXG5cdFx0bGV0IG1hcHMgPSByZWZlcmVuY2VNYXAuZ2V0KCBub2RlUmVmICk7XG5cblx0XHRpZiAoIG1hcHMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bWFwcyA9IHtcblx0XHRcdFx0cmVuZGVyTWFwOiBuZXcgV2Vha01hcCgpLFxuXHRcdFx0XHRmcmFtZU1hcDogbmV3IFdlYWtNYXAoKVxuXHRcdFx0fTtcblxuXHRcdFx0cmVmZXJlbmNlTWFwLnNldCggbm9kZVJlZiwgbWFwcyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hcHM7XG5cblx0fVxuXG5cdHVwZGF0ZUJlZm9yZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRjb25zdCB1cGRhdGVUeXBlID0gbm9kZS5nZXRVcGRhdGVCZWZvcmVUeXBlKCk7XG5cdFx0Y29uc3QgcmVmZXJlbmNlID0gbm9kZS51cGRhdGVSZWZlcmVuY2UoIHRoaXMgKTtcblxuXHRcdGlmICggdXBkYXRlVHlwZSA9PT0gTm9kZVVwZGF0ZVR5cGUuRlJBTUUgKSB7XG5cblx0XHRcdGNvbnN0IHsgZnJhbWVNYXAgfSA9IHRoaXMuX2dldE1hcHMoIHRoaXMudXBkYXRlQmVmb3JlTWFwLCByZWZlcmVuY2UgKTtcblxuXHRcdFx0aWYgKCBmcmFtZU1hcC5nZXQoIHJlZmVyZW5jZSApICE9PSB0aGlzLmZyYW1lSWQgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlLnVwZGF0ZUJlZm9yZSggdGhpcyApICE9PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGZyYW1lTWFwLnNldCggcmVmZXJlbmNlLCB0aGlzLmZyYW1lSWQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHVwZGF0ZVR5cGUgPT09IE5vZGVVcGRhdGVUeXBlLlJFTkRFUiApIHtcblxuXHRcdFx0Y29uc3QgeyByZW5kZXJNYXAgfSA9IHRoaXMuX2dldE1hcHMoIHRoaXMudXBkYXRlQmVmb3JlTWFwLCByZWZlcmVuY2UgKTtcblxuXHRcdFx0aWYgKCByZW5kZXJNYXAuZ2V0KCByZWZlcmVuY2UgKSAhPT0gdGhpcy5yZW5kZXJJZCApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGUudXBkYXRlQmVmb3JlKCB0aGlzICkgIT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyTWFwLnNldCggcmVmZXJlbmNlLCB0aGlzLnJlbmRlcklkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCB1cGRhdGVUeXBlID09PSBOb2RlVXBkYXRlVHlwZS5PQkpFQ1QgKSB7XG5cblx0XHRcdG5vZGUudXBkYXRlQmVmb3JlKCB0aGlzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZUFmdGVyTm9kZSggbm9kZSApIHtcblxuXHRcdGNvbnN0IHVwZGF0ZVR5cGUgPSBub2RlLmdldFVwZGF0ZUFmdGVyVHlwZSgpO1xuXHRcdGNvbnN0IHJlZmVyZW5jZSA9IG5vZGUudXBkYXRlUmVmZXJlbmNlKCB0aGlzICk7XG5cblx0XHRpZiAoIHVwZGF0ZVR5cGUgPT09IE5vZGVVcGRhdGVUeXBlLkZSQU1FICkge1xuXG5cdFx0XHRjb25zdCB7IGZyYW1lTWFwIH0gPSB0aGlzLl9nZXRNYXBzKCB0aGlzLnVwZGF0ZUFmdGVyTWFwLCByZWZlcmVuY2UgKTtcblxuXHRcdFx0aWYgKCBmcmFtZU1hcC5nZXQoIHJlZmVyZW5jZSApICE9PSB0aGlzLmZyYW1lSWQgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlLnVwZGF0ZUFmdGVyKCB0aGlzICkgIT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0ZnJhbWVNYXAuc2V0KCByZWZlcmVuY2UsIHRoaXMuZnJhbWVJZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggdXBkYXRlVHlwZSA9PT0gTm9kZVVwZGF0ZVR5cGUuUkVOREVSICkge1xuXG5cdFx0XHRjb25zdCB7IHJlbmRlck1hcCB9ID0gdGhpcy5fZ2V0TWFwcyggdGhpcy51cGRhdGVBZnRlck1hcCwgcmVmZXJlbmNlICk7XG5cblx0XHRcdGlmICggcmVuZGVyTWFwLmdldCggcmVmZXJlbmNlICkgIT09IHRoaXMucmVuZGVySWQgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlLnVwZGF0ZUFmdGVyKCB0aGlzICkgIT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyTWFwLnNldCggcmVmZXJlbmNlLCB0aGlzLnJlbmRlcklkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCB1cGRhdGVUeXBlID09PSBOb2RlVXBkYXRlVHlwZS5PQkpFQ1QgKSB7XG5cblx0XHRcdG5vZGUudXBkYXRlQWZ0ZXIoIHRoaXMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dXBkYXRlTm9kZSggbm9kZSApIHtcblxuXHRcdGNvbnN0IHVwZGF0ZVR5cGUgPSBub2RlLmdldFVwZGF0ZVR5cGUoKTtcblx0XHRjb25zdCByZWZlcmVuY2UgPSBub2RlLnVwZGF0ZVJlZmVyZW5jZSggdGhpcyApO1xuXG5cdFx0aWYgKCB1cGRhdGVUeXBlID09PSBOb2RlVXBkYXRlVHlwZS5GUkFNRSApIHtcblxuXHRcdFx0Y29uc3QgeyBmcmFtZU1hcCB9ID0gdGhpcy5fZ2V0TWFwcyggdGhpcy51cGRhdGVNYXAsIHJlZmVyZW5jZSApO1xuXG5cdFx0XHRpZiAoIGZyYW1lTWFwLmdldCggcmVmZXJlbmNlICkgIT09IHRoaXMuZnJhbWVJZCApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGUudXBkYXRlKCB0aGlzICkgIT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0ZnJhbWVNYXAuc2V0KCByZWZlcmVuY2UsIHRoaXMuZnJhbWVJZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggdXBkYXRlVHlwZSA9PT0gTm9kZVVwZGF0ZVR5cGUuUkVOREVSICkge1xuXG5cdFx0XHRjb25zdCB7IHJlbmRlck1hcCB9ID0gdGhpcy5fZ2V0TWFwcyggdGhpcy51cGRhdGVNYXAsIHJlZmVyZW5jZSApO1xuXG5cdFx0XHRpZiAoIHJlbmRlck1hcC5nZXQoIHJlZmVyZW5jZSApICE9PSB0aGlzLnJlbmRlcklkICkge1xuXG5cdFx0XHRcdGlmICggbm9kZS51cGRhdGUoIHRoaXMgKSAhPT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJNYXAuc2V0KCByZWZlcmVuY2UsIHRoaXMucmVuZGVySWQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHVwZGF0ZVR5cGUgPT09IE5vZGVVcGRhdGVUeXBlLk9CSkVDVCApIHtcblxuXHRcdFx0bm9kZS51cGRhdGUoIHRoaXMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dXBkYXRlKCkge1xuXG5cdFx0dGhpcy5mcmFtZUlkICsrO1xuXG5cdFx0aWYgKCB0aGlzLmxhc3RUaW1lID09PSB1bmRlZmluZWQgKSB0aGlzLmxhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cblx0XHR0aGlzLmRlbHRhVGltZSA9ICggcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLmxhc3RUaW1lICkgLyAxMDAwO1xuXG5cdFx0dGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG5cdFx0dGhpcy50aW1lICs9IHRoaXMuZGVsdGFUaW1lO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlRnJhbWU7XG4iLCJjbGFzcyBOb2RlRnVuY3Rpb25JbnB1dCB7XG5cblx0Y29uc3RydWN0b3IoIHR5cGUsIG5hbWUsIGNvdW50ID0gbnVsbCwgcXVhbGlmaWVyID0gJycsIGlzQ29uc3QgPSBmYWxzZSApIHtcblxuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR0aGlzLmNvdW50ID0gY291bnQ7XG5cdFx0dGhpcy5xdWFsaWZpZXIgPSBxdWFsaWZpZXI7XG5cdFx0dGhpcy5pc0NvbnN0ID0gaXNDb25zdDtcblxuXHR9XG5cbn1cblxuTm9kZUZ1bmN0aW9uSW5wdXQuaXNOb2RlRnVuY3Rpb25JbnB1dCA9IHRydWU7XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVGdW5jdGlvbklucHV0O1xuIiwiaW1wb3J0IEFuYWx5dGljTGlnaHROb2RlIGZyb20gJy4vQW5hbHl0aWNMaWdodE5vZGUuanMnO1xuaW1wb3J0IHsgbGlnaHRUYXJnZXREaXJlY3Rpb24gfSBmcm9tICcuLi9hY2Nlc3NvcnMvTGlnaHRzLmpzJztcblxuY2xhc3MgRGlyZWN0aW9uYWxMaWdodE5vZGUgZXh0ZW5kcyBBbmFseXRpY0xpZ2h0Tm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdEaXJlY3Rpb25hbExpZ2h0Tm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBsaWdodCA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggbGlnaHQgKTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRzdXBlci5zZXR1cCggYnVpbGRlciApO1xuXG5cdFx0Y29uc3QgbGlnaHRpbmdNb2RlbCA9IGJ1aWxkZXIuY29udGV4dC5saWdodGluZ01vZGVsO1xuXG5cdFx0Y29uc3QgbGlnaHRDb2xvciA9IHRoaXMuY29sb3JOb2RlO1xuXHRcdGNvbnN0IGxpZ2h0RGlyZWN0aW9uID0gbGlnaHRUYXJnZXREaXJlY3Rpb24oIHRoaXMubGlnaHQgKTtcblx0XHRjb25zdCByZWZsZWN0ZWRMaWdodCA9IGJ1aWxkZXIuY29udGV4dC5yZWZsZWN0ZWRMaWdodDtcblxuXHRcdGxpZ2h0aW5nTW9kZWwuZGlyZWN0KCB7XG5cdFx0XHRsaWdodERpcmVjdGlvbixcblx0XHRcdGxpZ2h0Q29sb3IsXG5cdFx0XHRyZWZsZWN0ZWRMaWdodFxuXHRcdH0sIGJ1aWxkZXIuc3RhY2ssIGJ1aWxkZXIgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGlyZWN0aW9uYWxMaWdodE5vZGU7XG4iLCJpbXBvcnQgQW5hbHl0aWNMaWdodE5vZGUgZnJvbSAnLi9BbmFseXRpY0xpZ2h0Tm9kZS5qcyc7XG5pbXBvcnQgeyB0ZXh0dXJlIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcbmltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcbmltcG9ydCB7IGxpZ2h0Vmlld1Bvc2l0aW9uIH0gZnJvbSAnLi4vYWNjZXNzb3JzL0xpZ2h0cy5qcyc7XG5pbXBvcnQgeyByZW5kZXJHcm91cCB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybUdyb3VwTm9kZS5qcyc7XG5cbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi8uLi9tYXRoL01hdHJpeDQuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcblxuY29uc3QgX21hdHJpeDQxID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX21hdHJpeDQyID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG5sZXQgbHRjTGliID0gbnVsbDtcblxuY2xhc3MgUmVjdEFyZWFMaWdodE5vZGUgZXh0ZW5kcyBBbmFseXRpY0xpZ2h0Tm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdSZWN0QXJlYUxpZ2h0Tm9kZSc7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBsaWdodCA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggbGlnaHQgKTtcblxuXHRcdHRoaXMuaGFsZkhlaWdodCA9IHVuaWZvcm0oIG5ldyBWZWN0b3IzKCkgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcblx0XHR0aGlzLmhhbGZXaWR0aCA9IHVuaWZvcm0oIG5ldyBWZWN0b3IzKCkgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcblxuXHRcdHRoaXMudXBkYXRlVHlwZSA9IE5vZGVVcGRhdGVUeXBlLlJFTkRFUjtcblxuXHR9XG5cblx0dXBkYXRlKCBmcmFtZSApIHtcblxuXHRcdHN1cGVyLnVwZGF0ZSggZnJhbWUgKTtcblxuXHRcdGNvbnN0IHsgbGlnaHQgfSA9IHRoaXM7XG5cblx0XHRjb25zdCB2aWV3TWF0cml4ID0gZnJhbWUuY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcblxuXHRcdF9tYXRyaXg0Mi5pZGVudGl0eSgpO1xuXHRcdF9tYXRyaXg0MS5jb3B5KCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdF9tYXRyaXg0MS5wcmVtdWx0aXBseSggdmlld01hdHJpeCApO1xuXHRcdF9tYXRyaXg0Mi5leHRyYWN0Um90YXRpb24oIF9tYXRyaXg0MSApO1xuXG5cdFx0dGhpcy5oYWxmV2lkdGgudmFsdWUuc2V0KCBsaWdodC53aWR0aCAqIDAuNSwgMC4wLCAwLjAgKTtcblx0XHR0aGlzLmhhbGZIZWlnaHQudmFsdWUuc2V0KCAwLjAsIGxpZ2h0LmhlaWdodCAqIDAuNSwgMC4wICk7XG5cblx0XHR0aGlzLmhhbGZXaWR0aC52YWx1ZS5hcHBseU1hdHJpeDQoIF9tYXRyaXg0MiApO1xuXHRcdHRoaXMuaGFsZkhlaWdodC52YWx1ZS5hcHBseU1hdHJpeDQoIF9tYXRyaXg0MiApO1xuXG5cdH1cblxuXHRzZXR1cCggYnVpbGRlciApIHtcblxuXHRcdHN1cGVyLnNldHVwKCBidWlsZGVyICk7XG5cblx0XHRsZXQgbHRjXzEsIGx0Y18yO1xuXG5cdFx0aWYgKCBidWlsZGVyLmlzQXZhaWxhYmxlKCAnZmxvYXQzMkZpbHRlcmFibGUnICkgKSB7XG5cblx0XHRcdGx0Y18xID0gdGV4dHVyZSggbHRjTGliLkxUQ19GTE9BVF8xICk7XG5cdFx0XHRsdGNfMiA9IHRleHR1cmUoIGx0Y0xpYi5MVENfRkxPQVRfMiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bHRjXzEgPSB0ZXh0dXJlKCBsdGNMaWIuTFRDX0hBTEZfMSApO1xuXHRcdFx0bHRjXzIgPSB0ZXh0dXJlKCBsdGNMaWIuTFRDX0hBTEZfMiApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgeyBjb2xvck5vZGUsIGxpZ2h0IH0gPSB0aGlzO1xuXHRcdGNvbnN0IGxpZ2h0aW5nTW9kZWwgPSBidWlsZGVyLmNvbnRleHQubGlnaHRpbmdNb2RlbDtcblxuXHRcdGNvbnN0IGxpZ2h0UG9zaXRpb24gPSBsaWdodFZpZXdQb3NpdGlvbiggbGlnaHQgKTtcblx0XHRjb25zdCByZWZsZWN0ZWRMaWdodCA9IGJ1aWxkZXIuY29udGV4dC5yZWZsZWN0ZWRMaWdodDtcblxuXHRcdGxpZ2h0aW5nTW9kZWwuZGlyZWN0UmVjdEFyZWEoIHtcblx0XHRcdGxpZ2h0Q29sb3I6IGNvbG9yTm9kZSxcblx0XHRcdGxpZ2h0UG9zaXRpb24sXG5cdFx0XHRoYWxmV2lkdGg6IHRoaXMuaGFsZldpZHRoLFxuXHRcdFx0aGFsZkhlaWdodDogdGhpcy5oYWxmSGVpZ2h0LFxuXHRcdFx0cmVmbGVjdGVkTGlnaHQsXG5cdFx0XHRsdGNfMSxcblx0XHRcdGx0Y18yXG5cdFx0fSwgYnVpbGRlci5zdGFjaywgYnVpbGRlciApO1xuXG5cdH1cblxuXHRzdGF0aWMgc2V0TFRDKCBsdGMgKSB7XG5cblx0XHRsdGNMaWIgPSBsdGM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlY3RBcmVhTGlnaHROb2RlO1xuIiwiaW1wb3J0IEFuYWx5dGljTGlnaHROb2RlIGZyb20gJy4vQW5hbHl0aWNMaWdodE5vZGUuanMnO1xuaW1wb3J0IHsgZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiB9IGZyb20gJy4vTGlnaHRVdGlscy5qcyc7XG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XG5pbXBvcnQgeyBzbW9vdGhzdGVwIH0gZnJvbSAnLi4vbWF0aC9NYXRoTm9kZS5qcyc7XG5pbXBvcnQgeyBwb3NpdGlvblZpZXcgfSBmcm9tICcuLi9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xuaW1wb3J0IHsgcmVuZGVyR3JvdXAgfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Hcm91cE5vZGUuanMnO1xuaW1wb3J0IHsgbGlnaHRWaWV3UG9zaXRpb24sIGxpZ2h0VGFyZ2V0RGlyZWN0aW9uLCBsaWdodFByb2plY3Rpb25VViB9IGZyb20gJy4uL2FjY2Vzc29ycy9MaWdodHMuanMnO1xuaW1wb3J0IHsgdGV4dHVyZSB9IGZyb20gJy4uL2FjY2Vzc29ycy9UZXh0dXJlTm9kZS5qcyc7XG5cbmNsYXNzIFNwb3RMaWdodE5vZGUgZXh0ZW5kcyBBbmFseXRpY0xpZ2h0Tm9kZSB7XG5cblx0c3RhdGljIGdldCB0eXBlKCkge1xuXG5cdFx0cmV0dXJuICdTcG90TGlnaHROb2RlJztcblxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGxpZ2h0ID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCBsaWdodCApO1xuXG5cdFx0dGhpcy5jb25lQ29zTm9kZSA9IHVuaWZvcm0oIDAgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcblx0XHR0aGlzLnBlbnVtYnJhQ29zTm9kZSA9IHVuaWZvcm0oIDAgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcblxuXHRcdHRoaXMuY3V0b2ZmRGlzdGFuY2VOb2RlID0gdW5pZm9ybSggMCApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xuXHRcdHRoaXMuZGVjYXlFeHBvbmVudE5vZGUgPSB1bmlmb3JtKCAwICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XG5cblx0fVxuXG5cdHVwZGF0ZSggZnJhbWUgKSB7XG5cblx0XHRzdXBlci51cGRhdGUoIGZyYW1lICk7XG5cblx0XHRjb25zdCB7IGxpZ2h0IH0gPSB0aGlzO1xuXG5cdFx0dGhpcy5jb25lQ29zTm9kZS52YWx1ZSA9IE1hdGguY29zKCBsaWdodC5hbmdsZSApO1xuXHRcdHRoaXMucGVudW1icmFDb3NOb2RlLnZhbHVlID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICogKCAxIC0gbGlnaHQucGVudW1icmEgKSApO1xuXG5cdFx0dGhpcy5jdXRvZmZEaXN0YW5jZU5vZGUudmFsdWUgPSBsaWdodC5kaXN0YW5jZTtcblx0XHR0aGlzLmRlY2F5RXhwb25lbnROb2RlLnZhbHVlID0gbGlnaHQuZGVjYXk7XG5cblx0fVxuXG5cdGdldFNwb3RBdHRlbnVhdGlvbiggYW5nbGVDb3NpbmUgKSB7XG5cblx0XHRjb25zdCB7IGNvbmVDb3NOb2RlLCBwZW51bWJyYUNvc05vZGUgfSA9IHRoaXM7XG5cblx0XHRyZXR1cm4gc21vb3Roc3RlcCggY29uZUNvc05vZGUsIHBlbnVtYnJhQ29zTm9kZSwgYW5nbGVDb3NpbmUgKTtcblxuXHR9XG5cblx0c2V0dXAoIGJ1aWxkZXIgKSB7XG5cblx0XHRzdXBlci5zZXR1cCggYnVpbGRlciApO1xuXG5cdFx0Y29uc3QgbGlnaHRpbmdNb2RlbCA9IGJ1aWxkZXIuY29udGV4dC5saWdodGluZ01vZGVsO1xuXG5cdFx0Y29uc3QgeyBjb2xvck5vZGUsIGN1dG9mZkRpc3RhbmNlTm9kZSwgZGVjYXlFeHBvbmVudE5vZGUsIGxpZ2h0IH0gPSB0aGlzO1xuXG5cdFx0Y29uc3QgbFZlY3RvciA9IGxpZ2h0Vmlld1Bvc2l0aW9uKCBsaWdodCApLnN1YiggcG9zaXRpb25WaWV3ICk7IC8vIEBUT0RPOiBBZGQgaXQgaW50byBMaWdodE5vZGVcblxuXHRcdGNvbnN0IGxpZ2h0RGlyZWN0aW9uID0gbFZlY3Rvci5ub3JtYWxpemUoKTtcblx0XHRjb25zdCBhbmdsZUNvcyA9IGxpZ2h0RGlyZWN0aW9uLmRvdCggbGlnaHRUYXJnZXREaXJlY3Rpb24oIGxpZ2h0ICkgKTtcblx0XHRjb25zdCBzcG90QXR0ZW51YXRpb24gPSB0aGlzLmdldFNwb3RBdHRlbnVhdGlvbiggYW5nbGVDb3MgKTtcblxuXHRcdGNvbnN0IGxpZ2h0RGlzdGFuY2UgPSBsVmVjdG9yLmxlbmd0aCgpO1xuXG5cdFx0Y29uc3QgbGlnaHRBdHRlbnVhdGlvbiA9IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIHtcblx0XHRcdGxpZ2h0RGlzdGFuY2UsXG5cdFx0XHRjdXRvZmZEaXN0YW5jZTogY3V0b2ZmRGlzdGFuY2VOb2RlLFxuXHRcdFx0ZGVjYXlFeHBvbmVudDogZGVjYXlFeHBvbmVudE5vZGVcblx0XHR9ICk7XG5cblx0XHRsZXQgbGlnaHRDb2xvciA9IGNvbG9yTm9kZS5tdWwoIHNwb3RBdHRlbnVhdGlvbiApLm11bCggbGlnaHRBdHRlbnVhdGlvbiApO1xuXG5cdFx0aWYgKCBsaWdodC5tYXAgKSB7XG5cblx0XHRcdGNvbnN0IHNwb3RMaWdodENvb3JkID0gbGlnaHRQcm9qZWN0aW9uVVYoIGxpZ2h0ICk7XG5cdFx0XHRjb25zdCBwcm9qZWN0ZWRUZXh0dXJlID0gdGV4dHVyZSggbGlnaHQubWFwLCBzcG90TGlnaHRDb29yZC54eSApLm9uUmVuZGVyVXBkYXRlKCAoKSA9PiBsaWdodC5tYXAgKTtcblxuXHRcdFx0Y29uc3QgaW5TcG90TGlnaHRNYXAgPSBzcG90TGlnaHRDb29yZC5tdWwoIDIuICkuc3ViKCAxLiApLmFicygpLmxlc3NUaGFuKCAxLiApLmFsbCgpO1xuXG5cdFx0XHRsaWdodENvbG9yID0gaW5TcG90TGlnaHRNYXAuc2VsZWN0KCBsaWdodENvbG9yLm11bCggcHJvamVjdGVkVGV4dHVyZSApLCBsaWdodENvbG9yICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCByZWZsZWN0ZWRMaWdodCA9IGJ1aWxkZXIuY29udGV4dC5yZWZsZWN0ZWRMaWdodDtcblxuXHRcdGxpZ2h0aW5nTW9kZWwuZGlyZWN0KCB7XG5cdFx0XHRsaWdodERpcmVjdGlvbixcblx0XHRcdGxpZ2h0Q29sb3IsXG5cdFx0XHRyZWZsZWN0ZWRMaWdodFxuXHRcdH0sIGJ1aWxkZXIuc3RhY2ssIGJ1aWxkZXIgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3BvdExpZ2h0Tm9kZTtcbiIsImltcG9ydCBTcG90TGlnaHROb2RlIGZyb20gJy4vU3BvdExpZ2h0Tm9kZS5qcyc7XG5pbXBvcnQgeyB0ZXh0dXJlIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcbmltcG9ydCB7IHZlYzIgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XG5cbmNsYXNzIElFU1Nwb3RMaWdodE5vZGUgZXh0ZW5kcyBTcG90TGlnaHROb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0lFU1Nwb3RMaWdodE5vZGUnO1xuXG5cdH1cblxuXHRnZXRTcG90QXR0ZW51YXRpb24oIGFuZ2xlQ29zaW5lICkge1xuXG5cdFx0Y29uc3QgaWVzTWFwID0gdGhpcy5saWdodC5pZXNNYXA7XG5cblx0XHRsZXQgc3BvdEF0dGVudWF0aW9uID0gbnVsbDtcblxuXHRcdGlmICggaWVzTWFwICYmIGllc01hcC5pc1RleHR1cmUgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IGFuZ2xlID0gYW5nbGVDb3NpbmUuYWNvcygpLm11bCggMS4wIC8gTWF0aC5QSSApO1xuXG5cdFx0XHRzcG90QXR0ZW51YXRpb24gPSB0ZXh0dXJlKCBpZXNNYXAsIHZlYzIoIGFuZ2xlLCAwICksIDAgKS5yO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0c3BvdEF0dGVudWF0aW9uID0gc3VwZXIuZ2V0U3BvdEF0dGVudWF0aW9uKCBhbmdsZUNvc2luZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNwb3RBdHRlbnVhdGlvbjtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSUVTU3BvdExpZ2h0Tm9kZTtcbiIsImltcG9ydCBBbmFseXRpY0xpZ2h0Tm9kZSBmcm9tICcuL0FuYWx5dGljTGlnaHROb2RlLmpzJztcblxuY2xhc3MgQW1iaWVudExpZ2h0Tm9kZSBleHRlbmRzIEFuYWx5dGljTGlnaHROb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0FtYmllbnRMaWdodE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggbGlnaHQgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoIGxpZ2h0ICk7XG5cblx0fVxuXG5cdHNldHVwKCB7IGNvbnRleHQgfSApIHtcblxuXHRcdGNvbnRleHQuaXJyYWRpYW5jZS5hZGRBc3NpZ24oIHRoaXMuY29sb3JOb2RlICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFtYmllbnRMaWdodE5vZGU7XG4iLCJpbXBvcnQgQW5hbHl0aWNMaWdodE5vZGUgZnJvbSAnLi9BbmFseXRpY0xpZ2h0Tm9kZS5qcyc7XG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XG5pbXBvcnQgeyBtaXggfSBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJztcbmltcG9ydCB7IG5vcm1hbFZpZXcgfSBmcm9tICcuLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcbmltcG9ydCB7IGxpZ2h0UG9zaXRpb24gfSBmcm9tICcuLi9hY2Nlc3NvcnMvTGlnaHRzLmpzJztcbmltcG9ydCB7IHJlbmRlckdyb3VwIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcblxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi9tYXRoL0NvbG9yLmpzJztcblxuY2xhc3MgSGVtaXNwaGVyZUxpZ2h0Tm9kZSBleHRlbmRzIEFuYWx5dGljTGlnaHROb2RlIHtcblxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XG5cblx0XHRyZXR1cm4gJ0hlbWlzcGhlcmVMaWdodE5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggbGlnaHQgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoIGxpZ2h0ICk7XG5cblx0XHR0aGlzLmxpZ2h0UG9zaXRpb25Ob2RlID0gbGlnaHRQb3NpdGlvbiggbGlnaHQgKTtcblx0XHR0aGlzLmxpZ2h0RGlyZWN0aW9uTm9kZSA9IHRoaXMubGlnaHRQb3NpdGlvbk5vZGUubm9ybWFsaXplKCk7XG5cblx0XHR0aGlzLmdyb3VuZENvbG9yTm9kZSA9IHVuaWZvcm0oIG5ldyBDb2xvcigpICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XG5cblx0fVxuXG5cdHVwZGF0ZSggZnJhbWUgKSB7XG5cblx0XHRjb25zdCB7IGxpZ2h0IH0gPSB0aGlzO1xuXG5cdFx0c3VwZXIudXBkYXRlKCBmcmFtZSApO1xuXG5cdFx0dGhpcy5saWdodFBvc2l0aW9uTm9kZS5vYmplY3QzZCA9IGxpZ2h0O1xuXG5cdFx0dGhpcy5ncm91bmRDb2xvck5vZGUudmFsdWUuY29weSggbGlnaHQuZ3JvdW5kQ29sb3IgKS5tdWx0aXBseVNjYWxhciggbGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgeyBjb2xvck5vZGUsIGdyb3VuZENvbG9yTm9kZSwgbGlnaHREaXJlY3Rpb25Ob2RlIH0gPSB0aGlzO1xuXG5cdFx0Y29uc3QgZG90TkwgPSBub3JtYWxWaWV3LmRvdCggbGlnaHREaXJlY3Rpb25Ob2RlICk7XG5cdFx0Y29uc3QgaGVtaURpZmZ1c2VXZWlnaHQgPSBkb3ROTC5tdWwoIDAuNSApLmFkZCggMC41ICk7XG5cblx0XHRjb25zdCBpcnJhZGlhbmNlID0gbWl4KCBncm91bmRDb2xvck5vZGUsIGNvbG9yTm9kZSwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcblxuXHRcdGJ1aWxkZXIuY29udGV4dC5pcnJhZGlhbmNlLmFkZEFzc2lnbiggaXJyYWRpYW5jZSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBIZW1pc3BoZXJlTGlnaHROb2RlO1xuIiwiaW1wb3J0IEFuYWx5dGljTGlnaHROb2RlIGZyb20gJy4vQW5hbHl0aWNMaWdodE5vZGUuanMnO1xuaW1wb3J0IHsgbm9ybWFsV29ybGQgfSBmcm9tICcuLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcbmltcG9ydCB7IHVuaWZvcm1BcnJheSB9IGZyb20gJy4uL2FjY2Vzc29ycy9Vbmlmb3JtQXJyYXlOb2RlLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IGdldFNoSXJyYWRpYW5jZUF0IGZyb20gJy4uL2Z1bmN0aW9ucy9tYXRlcmlhbC9nZXRTaElycmFkaWFuY2VBdC5qcyc7XG5cbmNsYXNzIExpZ2h0UHJvYmVOb2RlIGV4dGVuZHMgQW5hbHl0aWNMaWdodE5vZGUge1xuXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcblxuXHRcdHJldHVybiAnTGlnaHRQcm9iZU5vZGUnO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggbGlnaHQgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoIGxpZ2h0ICk7XG5cblx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIGFycmF5LnB1c2goIG5ldyBWZWN0b3IzKCkgKTtcblxuXHRcdHRoaXMubGlnaHRQcm9iZSA9IHVuaWZvcm1BcnJheSggYXJyYXkgKTtcblxuXHR9XG5cblx0dXBkYXRlKCBmcmFtZSApIHtcblxuXHRcdGNvbnN0IHsgbGlnaHQgfSA9IHRoaXM7XG5cblx0XHRzdXBlci51cGRhdGUoIGZyYW1lICk7XG5cblx0XHQvL1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5saWdodFByb2JlLmFycmF5WyBpIF0uY29weSggbGlnaHQuc2guY29lZmZpY2llbnRzWyBpIF0gKS5tdWx0aXBseVNjYWxhciggbGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldHVwKCBidWlsZGVyICkge1xuXG5cdFx0Y29uc3QgaXJyYWRpYW5jZSA9IGdldFNoSXJyYWRpYW5jZUF0KCBub3JtYWxXb3JsZCwgdGhpcy5saWdodFByb2JlICk7XG5cblx0XHRidWlsZGVyLmNvbnRleHQuaXJyYWRpYW5jZS5hZGRBc3NpZ24oIGlycmFkaWFuY2UgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlnaHRQcm9iZU5vZGU7XG4iLCJjbGFzcyBOb2RlUGFyc2VyIHtcblxuXHRwYXJzZUZ1bmN0aW9uKCAvKnNvdXJjZSovICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlUGFyc2VyO1xuIiwiY2xhc3MgTm9kZUZ1bmN0aW9uIHtcblxuXHRjb25zdHJ1Y3RvciggdHlwZSwgaW5wdXRzLCBuYW1lID0gJycsIHByZWNpc2lvbiA9ICcnICkge1xuXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmlucHV0cyA9IGlucHV0cztcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuXG5cdH1cblxuXHRnZXRDb2RlKCAvKm5hbWUgPSB0aGlzLm5hbWUqLyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGZ1bmN0aW9uLicgKTtcblxuXHR9XG5cbn1cblxuTm9kZUZ1bmN0aW9uLmlzTm9kZUZ1bmN0aW9uID0gdHJ1ZTtcblxuZXhwb3J0IGRlZmF1bHQgTm9kZUZ1bmN0aW9uO1xuIiwiaW1wb3J0IE5vZGVGdW5jdGlvbiBmcm9tICcuLi9jb3JlL05vZGVGdW5jdGlvbi5qcyc7XG5pbXBvcnQgTm9kZUZ1bmN0aW9uSW5wdXQgZnJvbSAnLi4vY29yZS9Ob2RlRnVuY3Rpb25JbnB1dC5qcyc7XG5cbmNvbnN0IGRlY2xhcmF0aW9uUmVnZXhwID0gL15cXHMqKGhpZ2hwfG1lZGl1bXB8bG93cCk/XFxzKihbYS16XzAtOV0rKVxccyooW2Etel8wLTldKyk/XFxzKlxcKChbXFxzXFxTXSo/KVxcKS9pO1xuY29uc3QgcHJvcGVydGllc1JlZ2V4cCA9IC9bYS16XzAtOV0rL2lnO1xuXG5jb25zdCBwcmFnbWFNYWluID0gJyNwcmFnbWEgbWFpbic7XG5cbmNvbnN0IHBhcnNlID0gKCBzb3VyY2UgKSA9PiB7XG5cblx0c291cmNlID0gc291cmNlLnRyaW0oKTtcblxuXHRjb25zdCBwcmFnbWFNYWluSW5kZXggPSBzb3VyY2UuaW5kZXhPZiggcHJhZ21hTWFpbiApO1xuXG5cdGNvbnN0IG1haW5Db2RlID0gcHJhZ21hTWFpbkluZGV4ICE9PSAtIDEgPyBzb3VyY2Uuc2xpY2UoIHByYWdtYU1haW5JbmRleCArIHByYWdtYU1haW4ubGVuZ3RoICkgOiBzb3VyY2U7XG5cblx0Y29uc3QgZGVjbGFyYXRpb24gPSBtYWluQ29kZS5tYXRjaCggZGVjbGFyYXRpb25SZWdleHAgKTtcblxuXHRpZiAoIGRlY2xhcmF0aW9uICE9PSBudWxsICYmIGRlY2xhcmF0aW9uLmxlbmd0aCA9PT0gNSApIHtcblxuXHRcdC8vIHRva2VuaXplclxuXG5cdFx0Y29uc3QgaW5wdXRzQ29kZSA9IGRlY2xhcmF0aW9uWyA0IF07XG5cdFx0Y29uc3QgcHJvcHNNYXRjaGVzID0gW107XG5cblx0XHRsZXQgbmFtZU1hdGNoID0gbnVsbDtcblxuXHRcdHdoaWxlICggKCBuYW1lTWF0Y2ggPSBwcm9wZXJ0aWVzUmVnZXhwLmV4ZWMoIGlucHV0c0NvZGUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRwcm9wc01hdGNoZXMucHVzaCggbmFtZU1hdGNoICk7XG5cblx0XHR9XG5cblx0XHQvLyBwYXJzZXJcblxuXHRcdGNvbnN0IGlucHV0cyA9IFtdO1xuXG5cdFx0bGV0IGkgPSAwO1xuXG5cdFx0d2hpbGUgKCBpIDwgcHJvcHNNYXRjaGVzLmxlbmd0aCApIHtcblxuXHRcdFx0Y29uc3QgaXNDb25zdCA9IHByb3BzTWF0Y2hlc1sgaSBdWyAwIF0gPT09ICdjb25zdCc7XG5cblx0XHRcdGlmICggaXNDb25zdCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRpICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBxdWFsaWZpZXIgPSBwcm9wc01hdGNoZXNbIGkgXVsgMCBdO1xuXG5cdFx0XHRpZiAoIHF1YWxpZmllciA9PT0gJ2luJyB8fCBxdWFsaWZpZXIgPT09ICdvdXQnIHx8IHF1YWxpZmllciA9PT0gJ2lub3V0JyApIHtcblxuXHRcdFx0XHRpICsrO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHF1YWxpZmllciA9ICcnO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHR5cGUgPSBwcm9wc01hdGNoZXNbIGkgKysgXVsgMCBdO1xuXG5cdFx0XHRsZXQgY291bnQgPSBOdW1iZXIucGFyc2VJbnQoIHByb3BzTWF0Y2hlc1sgaSBdWyAwIF0gKTtcblxuXHRcdFx0aWYgKCBOdW1iZXIuaXNOYU4oIGNvdW50ICkgPT09IGZhbHNlICkgaSArKztcblx0XHRcdGVsc2UgY291bnQgPSBudWxsO1xuXG5cdFx0XHRjb25zdCBuYW1lID0gcHJvcHNNYXRjaGVzWyBpICsrIF1bIDAgXTtcblxuXHRcdFx0aW5wdXRzLnB1c2goIG5ldyBOb2RlRnVuY3Rpb25JbnB1dCggdHlwZSwgbmFtZSwgY291bnQsIHF1YWxpZmllciwgaXNDb25zdCApICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgYmxvY2tDb2RlID0gbWFpbkNvZGUuc3Vic3RyaW5nKCBkZWNsYXJhdGlvblsgMCBdLmxlbmd0aCApO1xuXG5cdFx0Y29uc3QgbmFtZSA9IGRlY2xhcmF0aW9uWyAzIF0gIT09IHVuZGVmaW5lZCA/IGRlY2xhcmF0aW9uWyAzIF0gOiAnJztcblx0XHRjb25zdCB0eXBlID0gZGVjbGFyYXRpb25bIDIgXTtcblxuXHRcdGNvbnN0IHByZWNpc2lvbiA9IGRlY2xhcmF0aW9uWyAxIF0gIT09IHVuZGVmaW5lZCA/IGRlY2xhcmF0aW9uWyAxIF0gOiAnJztcblxuXHRcdGNvbnN0IGhlYWRlckNvZGUgPSBwcmFnbWFNYWluSW5kZXggIT09IC0gMSA/IHNvdXJjZS5zbGljZSggMCwgcHJhZ21hTWFpbkluZGV4ICkgOiAnJztcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlLFxuXHRcdFx0aW5wdXRzLFxuXHRcdFx0bmFtZSxcblx0XHRcdHByZWNpc2lvbixcblx0XHRcdGlucHV0c0NvZGUsXG5cdFx0XHRibG9ja0NvZGUsXG5cdFx0XHRoZWFkZXJDb2RlXG5cdFx0fTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnRnVuY3Rpb25Ob2RlOiBGdW5jdGlvbiBpcyBub3QgYSBHTFNMIGNvZGUuJyApO1xuXG5cdH1cblxufTtcblxuY2xhc3MgR0xTTE5vZGVGdW5jdGlvbiBleHRlbmRzIE5vZGVGdW5jdGlvbiB7XG5cblx0Y29uc3RydWN0b3IoIHNvdXJjZSApIHtcblxuXHRcdGNvbnN0IHsgdHlwZSwgaW5wdXRzLCBuYW1lLCBwcmVjaXNpb24sIGlucHV0c0NvZGUsIGJsb2NrQ29kZSwgaGVhZGVyQ29kZSB9ID0gcGFyc2UoIHNvdXJjZSApO1xuXG5cdFx0c3VwZXIoIHR5cGUsIGlucHV0cywgbmFtZSwgcHJlY2lzaW9uICk7XG5cblx0XHR0aGlzLmlucHV0c0NvZGUgPSBpbnB1dHNDb2RlO1xuXHRcdHRoaXMuYmxvY2tDb2RlID0gYmxvY2tDb2RlO1xuXHRcdHRoaXMuaGVhZGVyQ29kZSA9IGhlYWRlckNvZGU7XG5cblx0fVxuXG5cdGdldENvZGUoIG5hbWUgPSB0aGlzLm5hbWUgKSB7XG5cblx0XHRsZXQgY29kZTtcblxuXHRcdGNvbnN0IGJsb2NrQ29kZSA9IHRoaXMuYmxvY2tDb2RlO1xuXG5cdFx0aWYgKCBibG9ja0NvZGUgIT09ICcnICkge1xuXG5cdFx0XHRjb25zdCB7IHR5cGUsIGlucHV0c0NvZGUsIGhlYWRlckNvZGUsIHByZWNpc2lvbiB9ID0gdGhpcztcblxuXHRcdFx0bGV0IGRlY2xhcmF0aW9uQ29kZSA9IGAkeyB0eXBlIH0gJHsgbmFtZSB9ICggJHsgaW5wdXRzQ29kZS50cmltKCkgfSApYDtcblxuXHRcdFx0aWYgKCBwcmVjaXNpb24gIT09ICcnICkge1xuXG5cdFx0XHRcdGRlY2xhcmF0aW9uQ29kZSA9IGAkeyBwcmVjaXNpb24gfSAkeyBkZWNsYXJhdGlvbkNvZGUgfWA7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29kZSA9IGhlYWRlckNvZGUgKyBkZWNsYXJhdGlvbkNvZGUgKyBibG9ja0NvZGU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBpbnRlcmZhY2UgZnVuY3Rpb25cblxuXHRcdFx0Y29kZSA9ICcnO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvZGU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEdMU0xOb2RlRnVuY3Rpb247XG4iLCJpbXBvcnQgTm9kZVBhcnNlciBmcm9tICcuLi9jb3JlL05vZGVQYXJzZXIuanMnO1xuaW1wb3J0IEdMU0xOb2RlRnVuY3Rpb24gZnJvbSAnLi9HTFNMTm9kZUZ1bmN0aW9uLmpzJztcblxuY2xhc3MgR0xTTE5vZGVQYXJzZXIgZXh0ZW5kcyBOb2RlUGFyc2VyIHtcblxuXHRwYXJzZUZ1bmN0aW9uKCBzb3VyY2UgKSB7XG5cblx0XHRyZXR1cm4gbmV3IEdMU0xOb2RlRnVuY3Rpb24oIHNvdXJjZSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBHTFNMTm9kZVBhcnNlcjtcbiIsImltcG9ydCBEYXRhTWFwIGZyb20gJy4uL0RhdGFNYXAuanMnO1xuaW1wb3J0IENoYWluTWFwIGZyb20gJy4uL0NoYWluTWFwLmpzJztcbmltcG9ydCBOb2RlQnVpbGRlclN0YXRlIGZyb20gJy4vTm9kZUJ1aWxkZXJTdGF0ZS5qcyc7XG5pbXBvcnQgeyBjdWJlTWFwTm9kZSB9IGZyb20gJy4uLy4uLy4uL25vZGVzL3V0aWxzL0N1YmVNYXBOb2RlLmpzJztcbmltcG9ydCB7IE5vZGVGcmFtZSB9IGZyb20gJy4uLy4uLy4uL25vZGVzL05vZGVzLmpzJztcbmltcG9ydCB7IG9iamVjdEdyb3VwLCByZW5kZXJHcm91cCwgZnJhbWVHcm91cCwgY3ViZVRleHR1cmUsIHRleHR1cmUsIHJhbmdlRm9nLCBkZW5zaXR5Rm9nLCByZWZlcmVuY2UsIHBtcmVtVGV4dHVyZSwgc2NyZWVuVVYgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9UU0wuanMnO1xuXG5pbXBvcnQgeyBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZywgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGhhc2hBcnJheSB9IGZyb20gJy4uLy4uLy4uL25vZGVzL2NvcmUvTm9kZVV0aWxzLmpzJztcblxuY29uc3Qgb3V0cHV0Tm9kZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbmNsYXNzIE5vZGVzIGV4dGVuZHMgRGF0YU1hcCB7XG5cblx0Y29uc3RydWN0b3IoIHJlbmRlcmVyLCBiYWNrZW5kICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblx0XHR0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xuXHRcdHRoaXMubm9kZUZyYW1lID0gbmV3IE5vZGVGcmFtZSgpO1xuXHRcdHRoaXMubm9kZUJ1aWxkZXJDYWNoZSA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLmNhbGxIYXNoQ2FjaGUgPSBuZXcgQ2hhaW5NYXAoKTtcblx0XHR0aGlzLmdyb3Vwc0RhdGEgPSBuZXcgQ2hhaW5NYXAoKTtcblxuXHR9XG5cblx0dXBkYXRlR3JvdXAoIG5vZGVVbmlmb3Jtc0dyb3VwICkge1xuXG5cdFx0Y29uc3QgZ3JvdXBOb2RlID0gbm9kZVVuaWZvcm1zR3JvdXAuZ3JvdXBOb2RlO1xuXHRcdGNvbnN0IG5hbWUgPSBncm91cE5vZGUubmFtZTtcblxuXHRcdC8vIG9iamVjdEdyb3VwIGlzIGV2ZXJ5IHVwZGF0ZWRcblxuXHRcdGlmICggbmFtZSA9PT0gb2JqZWN0R3JvdXAubmFtZSApIHJldHVybiB0cnVlO1xuXG5cdFx0Ly8gcmVuZGVyR3JvdXAgaXMgdXBkYXRlZCBvbmNlIHBlciByZW5kZXIvY29tcHV0ZSBjYWxsXG5cblx0XHRpZiAoIG5hbWUgPT09IHJlbmRlckdyb3VwLm5hbWUgKSB7XG5cblx0XHRcdGNvbnN0IHVuaWZvcm1zR3JvdXBEYXRhID0gdGhpcy5nZXQoIG5vZGVVbmlmb3Jtc0dyb3VwICk7XG5cdFx0XHRjb25zdCByZW5kZXJJZCA9IHRoaXMubm9kZUZyYW1lLnJlbmRlcklkO1xuXG5cdFx0XHRpZiAoIHVuaWZvcm1zR3JvdXBEYXRhLnJlbmRlcklkICE9PSByZW5kZXJJZCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtc0dyb3VwRGF0YS5yZW5kZXJJZCA9IHJlbmRlcklkO1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdC8vIGZyYW1lR3JvdXAgaXMgdXBkYXRlZCBvbmNlIHBlciBmcmFtZVxuXG5cdFx0aWYgKCBuYW1lID09PSBmcmFtZUdyb3VwLm5hbWUgKSB7XG5cblx0XHRcdGNvbnN0IHVuaWZvcm1zR3JvdXBEYXRhID0gdGhpcy5nZXQoIG5vZGVVbmlmb3Jtc0dyb3VwICk7XG5cdFx0XHRjb25zdCBmcmFtZUlkID0gdGhpcy5ub2RlRnJhbWUuZnJhbWVJZDtcblxuXHRcdFx0aWYgKCB1bmlmb3Jtc0dyb3VwRGF0YS5mcmFtZUlkICE9PSBmcmFtZUlkICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zR3JvdXBEYXRhLmZyYW1lSWQgPSBmcmFtZUlkO1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdC8vIG90aGVyIGdyb3VwcyBhcmUgdXBkYXRlZCBqdXN0IHdoZW4gZ3JvdXBOb2RlLm5lZWRzVXBkYXRlIGlzIHRydWVcblxuXHRcdGNvbnN0IGdyb3VwQ2hhaW4gPSBbIGdyb3VwTm9kZSwgbm9kZVVuaWZvcm1zR3JvdXAgXTtcblxuXHRcdGxldCBncm91cERhdGEgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0KCBncm91cENoYWluICk7XG5cdFx0aWYgKCBncm91cERhdGEgPT09IHVuZGVmaW5lZCApIHRoaXMuZ3JvdXBzRGF0YS5zZXQoIGdyb3VwQ2hhaW4sIGdyb3VwRGF0YSA9IHt9ICk7XG5cblx0XHRpZiAoIGdyb3VwRGF0YS52ZXJzaW9uICE9PSBncm91cE5vZGUudmVyc2lvbiApIHtcblxuXHRcdFx0Z3JvdXBEYXRhLnZlcnNpb24gPSBncm91cE5vZGUudmVyc2lvbjtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdGdldEZvclJlbmRlckNhY2hlS2V5KCByZW5kZXJPYmplY3QgKSB7XG5cblx0XHRyZXR1cm4gcmVuZGVyT2JqZWN0LmluaXRpYWxDYWNoZUtleTtcblxuXHR9XG5cblx0Z2V0Rm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKSB7XG5cblx0XHRjb25zdCByZW5kZXJPYmplY3REYXRhID0gdGhpcy5nZXQoIHJlbmRlck9iamVjdCApO1xuXG5cdFx0bGV0IG5vZGVCdWlsZGVyU3RhdGUgPSByZW5kZXJPYmplY3REYXRhLm5vZGVCdWlsZGVyU3RhdGU7XG5cblx0XHRpZiAoIG5vZGVCdWlsZGVyU3RhdGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgeyBub2RlQnVpbGRlckNhY2hlIH0gPSB0aGlzO1xuXG5cdFx0XHRjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0Rm9yUmVuZGVyQ2FjaGVLZXkoIHJlbmRlck9iamVjdCApO1xuXG5cdFx0XHRub2RlQnVpbGRlclN0YXRlID0gbm9kZUJ1aWxkZXJDYWNoZS5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRcdGlmICggbm9kZUJ1aWxkZXJTdGF0ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnN0IG5vZGVCdWlsZGVyID0gdGhpcy5iYWNrZW5kLmNyZWF0ZU5vZGVCdWlsZGVyKCByZW5kZXJPYmplY3Qub2JqZWN0LCB0aGlzLnJlbmRlcmVyICk7XG5cdFx0XHRcdG5vZGVCdWlsZGVyLnNjZW5lID0gcmVuZGVyT2JqZWN0LnNjZW5lO1xuXHRcdFx0XHRub2RlQnVpbGRlci5tYXRlcmlhbCA9IHJlbmRlck9iamVjdC5tYXRlcmlhbDtcblx0XHRcdFx0bm9kZUJ1aWxkZXIuY2FtZXJhID0gcmVuZGVyT2JqZWN0LmNhbWVyYTtcblx0XHRcdFx0bm9kZUJ1aWxkZXIuY29udGV4dC5tYXRlcmlhbCA9IHJlbmRlck9iamVjdC5tYXRlcmlhbDtcblx0XHRcdFx0bm9kZUJ1aWxkZXIubGlnaHRzTm9kZSA9IHJlbmRlck9iamVjdC5saWdodHNOb2RlO1xuXHRcdFx0XHRub2RlQnVpbGRlci5lbnZpcm9ubWVudE5vZGUgPSB0aGlzLmdldEVudmlyb25tZW50Tm9kZSggcmVuZGVyT2JqZWN0LnNjZW5lICk7XG5cdFx0XHRcdG5vZGVCdWlsZGVyLmZvZ05vZGUgPSB0aGlzLmdldEZvZ05vZGUoIHJlbmRlck9iamVjdC5zY2VuZSApO1xuXHRcdFx0XHRub2RlQnVpbGRlci5jbGlwcGluZ0NvbnRleHQgPSByZW5kZXJPYmplY3QuY2xpcHBpbmdDb250ZXh0O1xuXHRcdFx0XHRub2RlQnVpbGRlci5idWlsZCgpO1xuXG5cdFx0XHRcdG5vZGVCdWlsZGVyU3RhdGUgPSB0aGlzLl9jcmVhdGVOb2RlQnVpbGRlclN0YXRlKCBub2RlQnVpbGRlciApO1xuXG5cdFx0XHRcdG5vZGVCdWlsZGVyQ2FjaGUuc2V0KCBjYWNoZUtleSwgbm9kZUJ1aWxkZXJTdGF0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG5vZGVCdWlsZGVyU3RhdGUudXNlZFRpbWVzICsrO1xuXG5cdFx0XHRyZW5kZXJPYmplY3REYXRhLm5vZGVCdWlsZGVyU3RhdGUgPSBub2RlQnVpbGRlclN0YXRlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vZGVCdWlsZGVyU3RhdGU7XG5cblx0fVxuXG5cdGRlbGV0ZSggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBvYmplY3QuaXNSZW5kZXJPYmplY3QgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGVCdWlsZGVyU3RhdGUgPSB0aGlzLmdldCggb2JqZWN0ICkubm9kZUJ1aWxkZXJTdGF0ZTtcblx0XHRcdG5vZGVCdWlsZGVyU3RhdGUudXNlZFRpbWVzIC0tO1xuXG5cdFx0XHRpZiAoIG5vZGVCdWlsZGVyU3RhdGUudXNlZFRpbWVzID09PSAwICkge1xuXG5cdFx0XHRcdHRoaXMubm9kZUJ1aWxkZXJDYWNoZS5kZWxldGUoIHRoaXMuZ2V0Rm9yUmVuZGVyQ2FjaGVLZXkoIG9iamVjdCApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBzdXBlci5kZWxldGUoIG9iamVjdCApO1xuXG5cdH1cblxuXHRnZXRGb3JDb21wdXRlKCBjb21wdXRlTm9kZSApIHtcblxuXHRcdGNvbnN0IGNvbXB1dGVEYXRhID0gdGhpcy5nZXQoIGNvbXB1dGVOb2RlICk7XG5cblx0XHRsZXQgbm9kZUJ1aWxkZXJTdGF0ZSA9IGNvbXB1dGVEYXRhLm5vZGVCdWlsZGVyU3RhdGU7XG5cblx0XHRpZiAoIG5vZGVCdWlsZGVyU3RhdGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZUJ1aWxkZXIgPSB0aGlzLmJhY2tlbmQuY3JlYXRlTm9kZUJ1aWxkZXIoIGNvbXB1dGVOb2RlLCB0aGlzLnJlbmRlcmVyICk7XG5cdFx0XHRub2RlQnVpbGRlci5idWlsZCgpO1xuXG5cdFx0XHRub2RlQnVpbGRlclN0YXRlID0gdGhpcy5fY3JlYXRlTm9kZUJ1aWxkZXJTdGF0ZSggbm9kZUJ1aWxkZXIgKTtcblxuXHRcdFx0Y29tcHV0ZURhdGEubm9kZUJ1aWxkZXJTdGF0ZSA9IG5vZGVCdWlsZGVyU3RhdGU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbm9kZUJ1aWxkZXJTdGF0ZTtcblxuXHR9XG5cblx0X2NyZWF0ZU5vZGVCdWlsZGVyU3RhdGUoIG5vZGVCdWlsZGVyICkge1xuXG5cdFx0cmV0dXJuIG5ldyBOb2RlQnVpbGRlclN0YXRlKFxuXHRcdFx0bm9kZUJ1aWxkZXIudmVydGV4U2hhZGVyLFxuXHRcdFx0bm9kZUJ1aWxkZXIuZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRub2RlQnVpbGRlci5jb21wdXRlU2hhZGVyLFxuXHRcdFx0bm9kZUJ1aWxkZXIuZ2V0QXR0cmlidXRlc0FycmF5KCksXG5cdFx0XHRub2RlQnVpbGRlci5nZXRCaW5kaW5ncygpLFxuXHRcdFx0bm9kZUJ1aWxkZXIudXBkYXRlTm9kZXMsXG5cdFx0XHRub2RlQnVpbGRlci51cGRhdGVCZWZvcmVOb2Rlcyxcblx0XHRcdG5vZGVCdWlsZGVyLnVwZGF0ZUFmdGVyTm9kZXMsXG5cdFx0XHRub2RlQnVpbGRlci5tb25pdG9yLFxuXHRcdFx0bm9kZUJ1aWxkZXIudHJhbnNmb3Jtc1xuXHRcdCk7XG5cblx0fVxuXG5cdGdldEVudmlyb25tZW50Tm9kZSggc2NlbmUgKSB7XG5cblx0XHRyZXR1cm4gc2NlbmUuZW52aXJvbm1lbnROb2RlIHx8IHRoaXMuZ2V0KCBzY2VuZSApLmVudmlyb25tZW50Tm9kZSB8fCBudWxsO1xuXG5cdH1cblxuXHRnZXRCYWNrZ3JvdW5kTm9kZSggc2NlbmUgKSB7XG5cblx0XHRyZXR1cm4gc2NlbmUuYmFja2dyb3VuZE5vZGUgfHwgdGhpcy5nZXQoIHNjZW5lICkuYmFja2dyb3VuZE5vZGUgfHwgbnVsbDtcblxuXHR9XG5cblx0Z2V0Rm9nTm9kZSggc2NlbmUgKSB7XG5cblx0XHRyZXR1cm4gc2NlbmUuZm9nTm9kZSB8fCB0aGlzLmdldCggc2NlbmUgKS5mb2dOb2RlIHx8IG51bGw7XG5cblx0fVxuXG5cdGdldENhY2hlS2V5KCBzY2VuZSwgbGlnaHRzTm9kZSApIHtcblxuXHRcdGNvbnN0IGNoYWluID0gWyBzY2VuZSwgbGlnaHRzTm9kZSBdO1xuXHRcdGNvbnN0IGNhbGxJZCA9IHRoaXMucmVuZGVyZXIuaW5mby5jYWxscztcblxuXHRcdGxldCBjYWNoZUtleURhdGEgPSB0aGlzLmNhbGxIYXNoQ2FjaGUuZ2V0KCBjaGFpbiApO1xuXG5cdFx0aWYgKCBjYWNoZUtleURhdGEgPT09IHVuZGVmaW5lZCB8fCBjYWNoZUtleURhdGEuY2FsbElkICE9PSBjYWxsSWQgKSB7XG5cblx0XHRcdGNvbnN0IGVudmlyb25tZW50Tm9kZSA9IHRoaXMuZ2V0RW52aXJvbm1lbnROb2RlKCBzY2VuZSApO1xuXHRcdFx0Y29uc3QgZm9nTm9kZSA9IHRoaXMuZ2V0Rm9nTm9kZSggc2NlbmUgKTtcblxuXHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cblx0XHRcdGlmICggbGlnaHRzTm9kZSApIHZhbHVlcy5wdXNoKCBsaWdodHNOb2RlLmdldENhY2hlS2V5KCB0cnVlICkgKTtcblx0XHRcdGlmICggZW52aXJvbm1lbnROb2RlICkgdmFsdWVzLnB1c2goIGVudmlyb25tZW50Tm9kZS5nZXRDYWNoZUtleSgpICk7XG5cdFx0XHRpZiAoIGZvZ05vZGUgKSB2YWx1ZXMucHVzaCggZm9nTm9kZS5nZXRDYWNoZUtleSgpICk7XG5cblx0XHRcdHZhbHVlcy5wdXNoKCB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkID8gMSA6IDAgKTtcblxuXHRcdFx0Y2FjaGVLZXlEYXRhID0ge1xuXHRcdFx0XHRjYWxsSWQsXG5cdFx0XHRcdGNhY2hlS2V5OiBoYXNoQXJyYXkoIHZhbHVlcyApXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmNhbGxIYXNoQ2FjaGUuc2V0KCBjaGFpbiwgY2FjaGVLZXlEYXRhICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2FjaGVLZXlEYXRhLmNhY2hlS2V5O1xuXG5cdH1cblxuXHR1cGRhdGVTY2VuZSggc2NlbmUgKSB7XG5cblx0XHR0aGlzLnVwZGF0ZUVudmlyb25tZW50KCBzY2VuZSApO1xuXHRcdHRoaXMudXBkYXRlRm9nKCBzY2VuZSApO1xuXHRcdHRoaXMudXBkYXRlQmFja2dyb3VuZCggc2NlbmUgKTtcblxuXHR9XG5cblx0Z2V0IGlzVG9uZU1hcHBpbmdTdGF0ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpID8gZmFsc2UgOiB0cnVlO1xuXG5cdH1cblxuXHR1cGRhdGVCYWNrZ3JvdW5kKCBzY2VuZSApIHtcblxuXHRcdGNvbnN0IHNjZW5lRGF0YSA9IHRoaXMuZ2V0KCBzY2VuZSApO1xuXHRcdGNvbnN0IGJhY2tncm91bmQgPSBzY2VuZS5iYWNrZ3JvdW5kO1xuXG5cdFx0aWYgKCBiYWNrZ3JvdW5kICkge1xuXG5cdFx0XHRjb25zdCBmb3JjZVVwZGF0ZSA9ICggc2NlbmUuYmFja2dyb3VuZEJsdXJyaW5lc3MgPT09IDAgJiYgc2NlbmVEYXRhLmJhY2tncm91bmRCbHVycmluZXNzID4gMCApIHx8ICggc2NlbmUuYmFja2dyb3VuZEJsdXJyaW5lc3MgPiAwICYmIHNjZW5lRGF0YS5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9PT0gMCApO1xuXG5cdFx0XHRpZiAoIHNjZW5lRGF0YS5iYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kIHx8IGZvcmNlVXBkYXRlICkge1xuXG5cdFx0XHRcdGxldCBiYWNrZ3JvdW5kTm9kZSA9IG51bGw7XG5cblx0XHRcdFx0aWYgKCBiYWNrZ3JvdW5kLmlzQ3ViZVRleHR1cmUgPT09IHRydWUgfHwgKCBiYWNrZ3JvdW5kLm1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nIHx8IGJhY2tncm91bmQubWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgfHwgYmFja2dyb3VuZC5tYXBwaW5nID09PSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBzY2VuZS5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA+IDAgfHwgYmFja2dyb3VuZC5tYXBwaW5nID09PSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyApIHtcblxuXHRcdFx0XHRcdFx0YmFja2dyb3VuZE5vZGUgPSBwbXJlbVRleHR1cmUoIGJhY2tncm91bmQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGxldCBlbnZNYXA7XG5cblx0XHRcdFx0XHRcdGlmICggYmFja2dyb3VuZC5pc0N1YmVUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdGVudk1hcCA9IGN1YmVUZXh0dXJlKCBiYWNrZ3JvdW5kICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0ZW52TWFwID0gdGV4dHVyZSggYmFja2dyb3VuZCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJhY2tncm91bmROb2RlID0gY3ViZU1hcE5vZGUoIGVudk1hcCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGJhY2tncm91bmQuaXNUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0YmFja2dyb3VuZE5vZGUgPSB0ZXh0dXJlKCBiYWNrZ3JvdW5kLCBzY3JlZW5VVi5mbGlwWSgpICkuc2V0VXBkYXRlTWF0cml4KCB0cnVlICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggYmFja2dyb3VuZC5pc0NvbG9yICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1dlYkdQVU5vZGVzOiBVbnN1cHBvcnRlZCBiYWNrZ3JvdW5kIGNvbmZpZ3VyYXRpb24uJywgYmFja2dyb3VuZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY2VuZURhdGEuYmFja2dyb3VuZE5vZGUgPSBiYWNrZ3JvdW5kTm9kZTtcblx0XHRcdFx0c2NlbmVEYXRhLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXHRcdFx0XHRzY2VuZURhdGEuYmFja2dyb3VuZEJsdXJyaW5lc3MgPSBzY2VuZS5iYWNrZ3JvdW5kQmx1cnJpbmVzcztcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggc2NlbmVEYXRhLmJhY2tncm91bmROb2RlICkge1xuXG5cdFx0XHRkZWxldGUgc2NlbmVEYXRhLmJhY2tncm91bmROb2RlO1xuXHRcdFx0ZGVsZXRlIHNjZW5lRGF0YS5iYWNrZ3JvdW5kO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGVGb2coIHNjZW5lICkge1xuXG5cdFx0Y29uc3Qgc2NlbmVEYXRhID0gdGhpcy5nZXQoIHNjZW5lICk7XG5cdFx0Y29uc3QgZm9nID0gc2NlbmUuZm9nO1xuXG5cdFx0aWYgKCBmb2cgKSB7XG5cblx0XHRcdGlmICggc2NlbmVEYXRhLmZvZyAhPT0gZm9nICkge1xuXG5cdFx0XHRcdGxldCBmb2dOb2RlID0gbnVsbDtcblxuXHRcdFx0XHRpZiAoIGZvZy5pc0ZvZ0V4cDIgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBjb2xvciA9IHJlZmVyZW5jZSggJ2NvbG9yJywgJ2NvbG9yJywgZm9nICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XG5cdFx0XHRcdFx0Y29uc3QgZGVuc2l0eSA9IHJlZmVyZW5jZSggJ2RlbnNpdHknLCAnZmxvYXQnLCBmb2cgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcblxuXHRcdFx0XHRcdGZvZ05vZGUgPSBkZW5zaXR5Rm9nKCBjb2xvciwgZGVuc2l0eSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGZvZy5pc0ZvZyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNvbG9yID0gcmVmZXJlbmNlKCAnY29sb3InLCAnY29sb3InLCBmb2cgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcblx0XHRcdFx0XHRjb25zdCBuZWFyID0gcmVmZXJlbmNlKCAnbmVhcicsICdmbG9hdCcsIGZvZyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xuXHRcdFx0XHRcdGNvbnN0IGZhciA9IHJlZmVyZW5jZSggJ2ZhcicsICdmbG9hdCcsIGZvZyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xuXG5cdFx0XHRcdFx0Zm9nTm9kZSA9IHJhbmdlRm9nKCBjb2xvciwgbmVhciwgZmFyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVOb2RlczogVW5zdXBwb3J0ZWQgZm9nIGNvbmZpZ3VyYXRpb24uJywgZm9nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjZW5lRGF0YS5mb2dOb2RlID0gZm9nTm9kZTtcblx0XHRcdFx0c2NlbmVEYXRhLmZvZyA9IGZvZztcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZGVsZXRlIHNjZW5lRGF0YS5mb2dOb2RlO1xuXHRcdFx0ZGVsZXRlIHNjZW5lRGF0YS5mb2c7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZUVudmlyb25tZW50KCBzY2VuZSApIHtcblxuXHRcdGNvbnN0IHNjZW5lRGF0YSA9IHRoaXMuZ2V0KCBzY2VuZSApO1xuXHRcdGNvbnN0IGVudmlyb25tZW50ID0gc2NlbmUuZW52aXJvbm1lbnQ7XG5cblx0XHRpZiAoIGVudmlyb25tZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjZW5lRGF0YS5lbnZpcm9ubWVudCAhPT0gZW52aXJvbm1lbnQgKSB7XG5cblx0XHRcdFx0bGV0IGVudmlyb25tZW50Tm9kZSA9IG51bGw7XG5cblx0XHRcdFx0aWYgKCBlbnZpcm9ubWVudC5pc0N1YmVUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0ZW52aXJvbm1lbnROb2RlID0gY3ViZVRleHR1cmUoIGVudmlyb25tZW50ICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggZW52aXJvbm1lbnQuaXNUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0ZW52aXJvbm1lbnROb2RlID0gdGV4dHVyZSggZW52aXJvbm1lbnQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ05vZGVzOiBVbnN1cHBvcnRlZCBlbnZpcm9ubWVudCBjb25maWd1cmF0aW9uLicsIGVudmlyb25tZW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjZW5lRGF0YS5lbnZpcm9ubWVudE5vZGUgPSBlbnZpcm9ubWVudE5vZGU7XG5cdFx0XHRcdHNjZW5lRGF0YS5lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBzY2VuZURhdGEuZW52aXJvbm1lbnROb2RlICkge1xuXG5cdFx0XHRkZWxldGUgc2NlbmVEYXRhLmVudmlyb25tZW50Tm9kZTtcblx0XHRcdGRlbGV0ZSBzY2VuZURhdGEuZW52aXJvbm1lbnQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldE5vZGVGcmFtZSggcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLCBzY2VuZSA9IG51bGwsIG9iamVjdCA9IG51bGwsIGNhbWVyYSA9IG51bGwsIG1hdGVyaWFsID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IG5vZGVGcmFtZSA9IHRoaXMubm9kZUZyYW1lO1xuXHRcdG5vZGVGcmFtZS5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXHRcdG5vZGVGcmFtZS5zY2VuZSA9IHNjZW5lO1xuXHRcdG5vZGVGcmFtZS5vYmplY3QgPSBvYmplY3Q7XG5cdFx0bm9kZUZyYW1lLmNhbWVyYSA9IGNhbWVyYTtcblx0XHRub2RlRnJhbWUubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblxuXHRcdHJldHVybiBub2RlRnJhbWU7XG5cblx0fVxuXG5cdGdldE5vZGVGcmFtZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0Tm9kZUZyYW1lKCByZW5kZXJPYmplY3QucmVuZGVyZXIsIHJlbmRlck9iamVjdC5zY2VuZSwgcmVuZGVyT2JqZWN0Lm9iamVjdCwgcmVuZGVyT2JqZWN0LmNhbWVyYSwgcmVuZGVyT2JqZWN0Lm1hdGVyaWFsICk7XG5cblx0fVxuXG5cdGdldE91dHB1dENhY2hlS2V5KCkge1xuXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuXG5cdFx0cmV0dXJuIHJlbmRlcmVyLnRvbmVNYXBwaW5nICsgJywnICsgcmVuZGVyZXIuY3VycmVudENvbG9yU3BhY2U7XG5cblx0fVxuXG5cdGhhc091dHB1dENoYW5nZSggb3V0cHV0VGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBvdXRwdXROb2RlTWFwLmdldCggb3V0cHV0VGFyZ2V0ICk7XG5cblx0XHRyZXR1cm4gY2FjaGVLZXkgIT09IHRoaXMuZ2V0T3V0cHV0Q2FjaGVLZXkoKTtcblxuXHR9XG5cblx0Z2V0T3V0cHV0Tm9kZSggb3V0cHV0VGV4dHVyZSApIHtcblxuXHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcblx0XHRjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0T3V0cHV0Q2FjaGVLZXkoKTtcblxuXHRcdGNvbnN0IG91dHB1dCA9IHRleHR1cmUoIG91dHB1dFRleHR1cmUsIHNjcmVlblVWICkucmVuZGVyT3V0cHV0KCByZW5kZXJlci50b25lTWFwcGluZywgcmVuZGVyZXIuY3VycmVudENvbG9yU3BhY2UgKTtcblxuXHRcdG91dHB1dE5vZGVNYXAuc2V0KCBvdXRwdXRUZXh0dXJlLCBjYWNoZUtleSApO1xuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHR9XG5cblx0dXBkYXRlQmVmb3JlKCByZW5kZXJPYmplY3QgKSB7XG5cblx0XHRjb25zdCBub2RlQnVpbGRlciA9IHJlbmRlck9iamVjdC5nZXROb2RlQnVpbGRlclN0YXRlKCk7XG5cblx0XHRmb3IgKCBjb25zdCBub2RlIG9mIG5vZGVCdWlsZGVyLnVwZGF0ZUJlZm9yZU5vZGVzICkge1xuXG5cdFx0XHQvLyB1cGRhdGUgZnJhbWUgc3RhdGUgZm9yIGVhY2ggbm9kZVxuXG5cdFx0XHR0aGlzLmdldE5vZGVGcmFtZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICkudXBkYXRlQmVmb3JlTm9kZSggbm9kZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGVBZnRlciggcmVuZGVyT2JqZWN0ICkge1xuXG5cdFx0Y29uc3Qgbm9kZUJ1aWxkZXIgPSByZW5kZXJPYmplY3QuZ2V0Tm9kZUJ1aWxkZXJTdGF0ZSgpO1xuXG5cdFx0Zm9yICggY29uc3Qgbm9kZSBvZiBub2RlQnVpbGRlci51cGRhdGVBZnRlck5vZGVzICkge1xuXG5cdFx0XHQvLyB1cGRhdGUgZnJhbWUgc3RhdGUgZm9yIGVhY2ggbm9kZVxuXG5cdFx0XHR0aGlzLmdldE5vZGVGcmFtZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICkudXBkYXRlQWZ0ZXJOb2RlKCBub2RlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZUZvckNvbXB1dGUoIGNvbXB1dGVOb2RlICkge1xuXG5cdFx0Y29uc3Qgbm9kZUZyYW1lID0gdGhpcy5nZXROb2RlRnJhbWUoKTtcblx0XHRjb25zdCBub2RlQnVpbGRlciA9IHRoaXMuZ2V0Rm9yQ29tcHV0ZSggY29tcHV0ZU5vZGUgKTtcblxuXHRcdGZvciAoIGNvbnN0IG5vZGUgb2Ygbm9kZUJ1aWxkZXIudXBkYXRlTm9kZXMgKSB7XG5cblx0XHRcdG5vZGVGcmFtZS51cGRhdGVOb2RlKCBub2RlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICkge1xuXG5cdFx0Y29uc3Qgbm9kZUZyYW1lID0gdGhpcy5nZXROb2RlRnJhbWVGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApO1xuXHRcdGNvbnN0IG5vZGVCdWlsZGVyID0gcmVuZGVyT2JqZWN0LmdldE5vZGVCdWlsZGVyU3RhdGUoKTtcblxuXHRcdGZvciAoIGNvbnN0IG5vZGUgb2Ygbm9kZUJ1aWxkZXIudXBkYXRlTm9kZXMgKSB7XG5cblx0XHRcdG5vZGVGcmFtZS51cGRhdGVOb2RlKCBub2RlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdG5lZWRzUmVmcmVzaCggcmVuZGVyT2JqZWN0ICkge1xuXG5cdFx0Y29uc3Qgbm9kZUZyYW1lID0gdGhpcy5nZXROb2RlRnJhbWVGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApO1xuXHRcdGNvbnN0IG1vbml0b3IgPSByZW5kZXJPYmplY3QuZ2V0TW9uaXRvcigpO1xuXG5cdFx0cmV0dXJuIG1vbml0b3IubmVlZHNSZWZyZXNoKCByZW5kZXJPYmplY3QsIG5vZGVGcmFtZSApO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0c3VwZXIuZGlzcG9zZSgpO1xuXG5cdFx0dGhpcy5ub2RlRnJhbWUgPSBuZXcgTm9kZUZyYW1lKCk7XG5cdFx0dGhpcy5ub2RlQnVpbGRlckNhY2hlID0gbmV3IE1hcCgpO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlcztcbiIsImltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi8uLi9tYXRoL01hdHJpeDMuanMnO1xuaW1wb3J0IHsgUGxhbmUgfSBmcm9tICcuLi8uLi9tYXRoL1BsYW5lLmpzJztcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xuXG5jb25zdCBfcGxhbmUgPSAvKkBfX1BVUkVfXyovIG5ldyBQbGFuZSgpO1xuXG5jbGFzcyBDbGlwcGluZ0NvbnRleHQge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJlbnRDb250ZXh0ID0gbnVsbCApIHtcblxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cblx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBudWxsO1xuXHRcdHRoaXMuY2FjaGVLZXkgPSAnJztcblxuXG5cdFx0aWYgKCBwYXJlbnRDb250ZXh0ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmludGVyc2VjdGlvblBsYW5lcyA9IFtdO1xuXHRcdFx0dGhpcy51bmlvblBsYW5lcyA9IFtdO1xuXG5cdFx0XHR0aGlzLnZpZXdOb3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpO1xuXHRcdFx0dGhpcy5jbGlwcGluZ0dyb3VwQ29udGV4dHMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdFx0XHR0aGlzLnNoYWRvd1Bhc3MgPSBmYWxzZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMudmlld05vcm1hbE1hdHJpeCA9IHBhcmVudENvbnRleHQudmlld05vcm1hbE1hdHJpeDtcblx0XHRcdHRoaXMuY2xpcHBpbmdHcm91cENvbnRleHRzID0gcGFyZW50Q29udGV4dC5jbGlwcGluZ0dyb3VwQ29udGV4dHM7XG5cblx0XHRcdHRoaXMuc2hhZG93UGFzcyA9IHBhcmVudENvbnRleHQuc2hhZG93UGFzcztcblxuXHRcdFx0dGhpcy52aWV3TWF0cml4ID0gcGFyZW50Q29udGV4dC52aWV3TWF0cml4O1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5wYXJlbnRWZXJzaW9uID0gbnVsbDtcblxuXHR9XG5cblx0cHJvamVjdFBsYW5lcyggc291cmNlLCBkZXN0aW5hdGlvbiwgb2Zmc2V0ICkge1xuXG5cdFx0Y29uc3QgbCA9IHNvdXJjZS5sZW5ndGg7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRfcGxhbmUuY29weSggc291cmNlWyBpIF0gKS5hcHBseU1hdHJpeDQoIHRoaXMudmlld01hdHJpeCwgdGhpcy52aWV3Tm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdGNvbnN0IHYgPSBkZXN0aW5hdGlvblsgb2Zmc2V0ICsgaSBdO1xuXHRcdFx0Y29uc3Qgbm9ybWFsID0gX3BsYW5lLm5vcm1hbDtcblxuXHRcdFx0di54ID0gLSBub3JtYWwueDtcblx0XHRcdHYueSA9IC0gbm9ybWFsLnk7XG5cdFx0XHR2LnogPSAtIG5vcm1hbC56O1xuXHRcdFx0di53ID0gX3BsYW5lLmNvbnN0YW50O1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGVHbG9iYWwoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHR0aGlzLnNoYWRvd1Bhc3MgPSAoIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwgJiYgc2NlbmUub3ZlcnJpZGVNYXRlcmlhbC5pc1NoYWRvd05vZGVNYXRlcmlhbCApO1xuXHRcdHRoaXMudmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XG5cblx0XHR0aGlzLnZpZXdOb3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB0aGlzLnZpZXdNYXRyaXggKTtcblxuXHR9XG5cblx0dXBkYXRlKCBwYXJlbnRDb250ZXh0LCBjbGlwcGluZ0dyb3VwICkge1xuXG5cdFx0bGV0IHVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0aWYgKCBwYXJlbnRDb250ZXh0LnZlcnNpb24gIT09IHRoaXMucGFyZW50VmVyc2lvbiApIHtcblxuXHRcdFx0dGhpcy5pbnRlcnNlY3Rpb25QbGFuZXMgPSBBcnJheS5mcm9tKCBwYXJlbnRDb250ZXh0LmludGVyc2VjdGlvblBsYW5lcyApO1xuXHRcdFx0dGhpcy51bmlvblBsYW5lcyA9IEFycmF5LmZyb20oIHBhcmVudENvbnRleHQudW5pb25QbGFuZXMgKTtcblx0XHRcdHRoaXMucGFyZW50VmVyc2lvbiA9IHBhcmVudENvbnRleHQudmVyc2lvbjtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5jbGlwSW50ZXJzZWN0aW9uICE9PSBjbGlwcGluZ0dyb3VwLmNsaXBJbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdHRoaXMuY2xpcEludGVyc2VjdGlvbiA9IGNsaXBwaW5nR3JvdXAuY2xpcEludGVyc2VjdGlvbjtcblxuXHRcdFx0aWYgKCB0aGlzLmNsaXBJbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdFx0dGhpcy51bmlvblBsYW5lcy5sZW5ndGggPSBwYXJlbnRDb250ZXh0LnVuaW9uUGxhbmVzLmxlbmd0aDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmludGVyc2VjdGlvblBsYW5lcy5sZW5ndGggPSBwYXJlbnRDb250ZXh0LmludGVyc2VjdGlvblBsYW5lcy5sZW5ndGg7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IHNyY0NsaXBwaW5nUGxhbmVzID0gY2xpcHBpbmdHcm91cC5jbGlwcGluZ1BsYW5lcztcblx0XHRjb25zdCBsID0gc3JjQ2xpcHBpbmdQbGFuZXMubGVuZ3RoO1xuXG5cdFx0bGV0IGRzdENsaXBwaW5nUGxhbmVzO1xuXHRcdGxldCBvZmZzZXQ7XG5cblx0XHRpZiAoIHRoaXMuY2xpcEludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0ZHN0Q2xpcHBpbmdQbGFuZXMgPSB0aGlzLmludGVyc2VjdGlvblBsYW5lcztcblx0XHRcdG9mZnNldCA9IHBhcmVudENvbnRleHQuaW50ZXJzZWN0aW9uUGxhbmVzLmxlbmd0aDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGRzdENsaXBwaW5nUGxhbmVzID0gdGhpcy51bmlvblBsYW5lcztcblx0XHRcdG9mZnNldCA9IHBhcmVudENvbnRleHQudW5pb25QbGFuZXMubGVuZ3RoO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkc3RDbGlwcGluZ1BsYW5lcy5sZW5ndGggIT09IG9mZnNldCArIGwgKSB7XG5cblx0XHRcdGRzdENsaXBwaW5nUGxhbmVzLmxlbmd0aCA9IG9mZnNldCArIGw7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0ZHN0Q2xpcHBpbmdQbGFuZXNbIG9mZnNldCArIGkgXSA9IG5ldyBWZWN0b3I0KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHRoaXMucHJvamVjdFBsYW5lcyggc3JjQ2xpcHBpbmdQbGFuZXMsIGRzdENsaXBwaW5nUGxhbmVzLCBvZmZzZXQgKTtcblxuXHRcdGlmICggdXBkYXRlICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XG5cdFx0XHR0aGlzLmNhY2hlS2V5ID0gYCR7IHRoaXMuaW50ZXJzZWN0aW9uUGxhbmVzLmxlbmd0aCB9OiR7IHRoaXMudW5pb25QbGFuZXMubGVuZ3RoIH1gO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRnZXRHcm91cENvbnRleHQoIGNsaXBwaW5nR3JvdXAgKSB7XG5cblx0XHRpZiAoIHRoaXMuc2hhZG93UGFzcyAmJiAhIGNsaXBwaW5nR3JvdXAuY2xpcFNoYWRvd3MgKSByZXR1cm4gdGhpcztcblxuXHRcdGxldCBjb250ZXh0ID0gdGhpcy5jbGlwcGluZ0dyb3VwQ29udGV4dHMuZ2V0KCBjbGlwcGluZ0dyb3VwICk7XG5cblx0XHRpZiAoIGNvbnRleHQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29udGV4dCA9IG5ldyBDbGlwcGluZ0NvbnRleHQoIHRoaXMgKTtcblx0XHRcdHRoaXMuY2xpcHBpbmdHcm91cENvbnRleHRzLnNldCggY2xpcHBpbmdHcm91cCwgY29udGV4dCApO1xuXG5cdFx0fVxuXG5cdFx0Y29udGV4dC51cGRhdGUoIHRoaXMsIGNsaXBwaW5nR3JvdXAgKTtcblxuXHRcdHJldHVybiBjb250ZXh0O1xuXG5cdH1cblxuXHRnZXQgdW5pb25DbGlwcGluZ0NvdW50KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudW5pb25QbGFuZXMubGVuZ3RoO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDbGlwcGluZ0NvbnRleHQ7XG4iLCJjbGFzcyBSZW5kZXJCdW5kbGUge1xuXG5cdGNvbnN0cnVjdG9yKCBzY2VuZSwgY2FtZXJhICkge1xuXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xuXHRcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKCBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlckJ1bmRsZTtcbiIsImltcG9ydCBDaGFpbk1hcCBmcm9tICcuL0NoYWluTWFwLmpzJztcbmltcG9ydCBSZW5kZXJCdW5kbGUgZnJvbSAnLi9SZW5kZXJCdW5kbGUuanMnO1xuXG5jbGFzcyBSZW5kZXJCdW5kbGVzIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMubGlzdHMgPSBuZXcgQ2hhaW5NYXAoKTtcblxuXHR9XG5cblx0Z2V0KCBzY2VuZSwgY2FtZXJhICkge1xuXG5cdFx0Y29uc3QgbGlzdHMgPSB0aGlzLmxpc3RzO1xuXHRcdGNvbnN0IGtleXMgPSBbIHNjZW5lLCBjYW1lcmEgXTtcblxuXHRcdGxldCBsaXN0ID0gbGlzdHMuZ2V0KCBrZXlzICk7XG5cblx0XHRpZiAoIGxpc3QgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bGlzdCA9IG5ldyBSZW5kZXJCdW5kbGUoIHNjZW5lLCBjYW1lcmEgKTtcblx0XHRcdGxpc3RzLnNldCgga2V5cywgbGlzdCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxpc3Q7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmxpc3RzID0gbmV3IENoYWluTWFwKCk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlckJ1bmRsZXM7XG4iLCJjbGFzcyBOb2RlTGlicmFyeSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLmxpZ2h0Tm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuXHRcdHRoaXMubWF0ZXJpYWxOb2RlcyA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLnRvbmVNYXBwaW5nTm9kZXMgPSBuZXcgTWFwKCk7XG5cblx0fVxuXG5cdGZyb21NYXRlcmlhbCggbWF0ZXJpYWwgKSB7XG5cblx0XHRpZiAoIG1hdGVyaWFsLmlzTm9kZU1hdGVyaWFsICkgcmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0bGV0IG5vZGVNYXRlcmlhbCA9IG51bGw7XG5cblx0XHRjb25zdCBub2RlTWF0ZXJpYWxDbGFzcyA9IHRoaXMuZ2V0TWF0ZXJpYWxOb2RlQ2xhc3MoIG1hdGVyaWFsLnR5cGUgKTtcblxuXHRcdGlmICggbm9kZU1hdGVyaWFsQ2xhc3MgIT09IG51bGwgKSB7XG5cblx0XHRcdG5vZGVNYXRlcmlhbCA9IG5ldyBub2RlTWF0ZXJpYWxDbGFzcygpO1xuXG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gbWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0bm9kZU1hdGVyaWFsWyBrZXkgXSA9IG1hdGVyaWFsWyBrZXkgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vZGVNYXRlcmlhbDtcblxuXHR9XG5cblx0YWRkVG9uZU1hcHBpbmcoIHRvbmVNYXBwaW5nTm9kZSwgdG9uZU1hcHBpbmcgKSB7XG5cblx0XHR0aGlzLmFkZFR5cGUoIHRvbmVNYXBwaW5nTm9kZSwgdG9uZU1hcHBpbmcsIHRoaXMudG9uZU1hcHBpbmdOb2RlcyApO1xuXG5cdH1cblxuXHRnZXRUb25lTWFwcGluZ0Z1bmN0aW9uKCB0b25lTWFwcGluZyApIHtcblxuXHRcdHJldHVybiB0aGlzLnRvbmVNYXBwaW5nTm9kZXMuZ2V0KCB0b25lTWFwcGluZyApIHx8IG51bGw7XG5cblx0fVxuXG5cdGdldE1hdGVyaWFsTm9kZUNsYXNzKCBtYXRlcmlhbFR5cGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXRlcmlhbE5vZGVzLmdldCggbWF0ZXJpYWxUeXBlICkgfHwgbnVsbDtcblxuXHR9XG5cblx0YWRkTWF0ZXJpYWwoIG1hdGVyaWFsTm9kZUNsYXNzLCBtYXRlcmlhbENsYXNzVHlwZSApIHtcblxuXHRcdHRoaXMuYWRkVHlwZSggbWF0ZXJpYWxOb2RlQ2xhc3MsIG1hdGVyaWFsQ2xhc3NUeXBlLCB0aGlzLm1hdGVyaWFsTm9kZXMgKTtcblxuXHR9XG5cblx0Z2V0TGlnaHROb2RlQ2xhc3MoIGxpZ2h0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubGlnaHROb2Rlcy5nZXQoIGxpZ2h0ICkgfHwgbnVsbDtcblxuXHR9XG5cblx0YWRkTGlnaHQoIGxpZ2h0Tm9kZUNsYXNzLCBsaWdodENsYXNzICkge1xuXG5cdFx0dGhpcy5hZGRDbGFzcyggbGlnaHROb2RlQ2xhc3MsIGxpZ2h0Q2xhc3MsIHRoaXMubGlnaHROb2RlcyApO1xuXG5cdH1cblxuXHRhZGRUeXBlKCBub2RlQ2xhc3MsIHR5cGUsIGxpYnJhcnkgKSB7XG5cblx0XHRpZiAoIGxpYnJhcnkuaGFzKCB0eXBlICkgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggYFJlZGVmaW5pdGlvbiBvZiBub2RlICR7IHR5cGUgfWAgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIG5vZGVDbGFzcyAhPT0gJ2Z1bmN0aW9uJyApIHRocm93IG5ldyBFcnJvciggYE5vZGUgY2xhc3MgJHsgbm9kZUNsYXNzLm5hbWUgfSBpcyBub3QgYSBjbGFzcy5gICk7XG5cdFx0aWYgKCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgKSB0aHJvdyBuZXcgRXJyb3IoIGBCYXNlIGNsYXNzICR7IHR5cGUgfSBpcyBub3QgYSBjbGFzcy5gICk7XG5cblx0XHRsaWJyYXJ5LnNldCggdHlwZSwgbm9kZUNsYXNzICk7XG5cblx0fVxuXG5cdGFkZENsYXNzKCBub2RlQ2xhc3MsIGJhc2VDbGFzcywgbGlicmFyeSApIHtcblxuXHRcdGlmICggbGlicmFyeS5oYXMoIGJhc2VDbGFzcyApICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oIGBSZWRlZmluaXRpb24gb2Ygbm9kZSAkeyBiYXNlQ2xhc3MubmFtZSB9YCApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Ygbm9kZUNsYXNzICE9PSAnZnVuY3Rpb24nICkgdGhyb3cgbmV3IEVycm9yKCBgTm9kZSBjbGFzcyAkeyBub2RlQ2xhc3MubmFtZSB9IGlzIG5vdCBhIGNsYXNzLmAgKTtcblx0XHRpZiAoIHR5cGVvZiBiYXNlQ2xhc3MgIT09ICdmdW5jdGlvbicgKSB0aHJvdyBuZXcgRXJyb3IoIGBCYXNlIGNsYXNzICR7IGJhc2VDbGFzcy5uYW1lIH0gaXMgbm90IGEgY2xhc3MuYCApO1xuXG5cdFx0bGlicmFyeS5zZXQoIGJhc2VDbGFzcywgbm9kZUNsYXNzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVMaWJyYXJ5O1xuIiwiaW1wb3J0IHsgTGlnaHRzTm9kZSB9IGZyb20gJy4uLy4uL25vZGVzL05vZGVzLmpzJztcbmltcG9ydCBDaGFpbk1hcCBmcm9tICcuL0NoYWluTWFwLmpzJztcblxuY29uc3QgX2RlZmF1bHRMaWdodHMgPSAvKkBfX1BVUkVfXyovIG5ldyBMaWdodHNOb2RlKCk7XG5cbmNsYXNzIExpZ2h0aW5nIGV4dGVuZHMgQ2hhaW5NYXAge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHR9XG5cblx0Y3JlYXRlTm9kZSggbGlnaHRzID0gW10gKSB7XG5cblx0XHRyZXR1cm4gbmV3IExpZ2h0c05vZGUoKS5zZXRMaWdodHMoIGxpZ2h0cyApO1xuXG5cdH1cblxuXHRnZXROb2RlKCBzY2VuZSwgY2FtZXJhICkge1xuXG5cdFx0Ly8gaWdub3JlIHBvc3QtcHJvY2Vzc2luZ1xuXG5cdFx0aWYgKCBzY2VuZS5pc1F1YWRNZXNoICkgcmV0dXJuIF9kZWZhdWx0TGlnaHRzO1xuXG5cdFx0Ly8gdGlsZWQgbGlnaHRpbmdcblxuXHRcdGNvbnN0IGtleXMgPSBbIHNjZW5lLCBjYW1lcmEgXTtcblxuXHRcdGxldCBub2RlID0gdGhpcy5nZXQoIGtleXMgKTtcblxuXHRcdGlmICggbm9kZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdFx0XHR0aGlzLnNldCgga2V5cywgbm9kZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vZGU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IExpZ2h0aW5nO1xuIiwiaW1wb3J0IEFuaW1hdGlvbiBmcm9tICcuL0FuaW1hdGlvbi5qcyc7XG5pbXBvcnQgUmVuZGVyT2JqZWN0cyBmcm9tICcuL1JlbmRlck9iamVjdHMuanMnO1xuaW1wb3J0IEF0dHJpYnV0ZXMgZnJvbSAnLi9BdHRyaWJ1dGVzLmpzJztcbmltcG9ydCBHZW9tZXRyaWVzIGZyb20gJy4vR2VvbWV0cmllcy5qcyc7XG5pbXBvcnQgSW5mbyBmcm9tICcuL0luZm8uanMnO1xuaW1wb3J0IFBpcGVsaW5lcyBmcm9tICcuL1BpcGVsaW5lcy5qcyc7XG5pbXBvcnQgQmluZGluZ3MgZnJvbSAnLi9CaW5kaW5ncy5qcyc7XG5pbXBvcnQgUmVuZGVyTGlzdHMgZnJvbSAnLi9SZW5kZXJMaXN0cy5qcyc7XG5pbXBvcnQgUmVuZGVyQ29udGV4dHMgZnJvbSAnLi9SZW5kZXJDb250ZXh0cy5qcyc7XG5pbXBvcnQgVGV4dHVyZXMgZnJvbSAnLi9UZXh0dXJlcy5qcyc7XG5pbXBvcnQgQmFja2dyb3VuZCBmcm9tICcuL0JhY2tncm91bmQuanMnO1xuaW1wb3J0IE5vZGVzIGZyb20gJy4vbm9kZXMvTm9kZXMuanMnO1xuaW1wb3J0IENvbG9yNCBmcm9tICcuL0NvbG9yNC5qcyc7XG5pbXBvcnQgQ2xpcHBpbmdDb250ZXh0IGZyb20gJy4vQ2xpcHBpbmdDb250ZXh0LmpzJztcbmltcG9ydCBRdWFkTWVzaCBmcm9tICcuL1F1YWRNZXNoLmpzJztcbmltcG9ydCBSZW5kZXJCdW5kbGVzIGZyb20gJy4vUmVuZGVyQnVuZGxlcy5qcyc7XG5pbXBvcnQgTm9kZUxpYnJhcnkgZnJvbSAnLi9ub2Rlcy9Ob2RlTGlicmFyeS5qcyc7XG5pbXBvcnQgTGlnaHRpbmcgZnJvbSAnLi9MaWdodGluZy5qcyc7XG5cbmltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi4vLi4vbWF0ZXJpYWxzL25vZGVzL05vZGVNYXRlcmlhbC5qcyc7XG5cbmltcG9ydCB7IFNjZW5lIH0gZnJvbSAnLi4vLi4vc2NlbmVzL1NjZW5lLmpzJztcbmltcG9ydCB7IEZydXN0dW0gfSBmcm9tICcuLi8uLi9tYXRoL0ZydXN0dW0uanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi4vLi4vY29yZS9SZW5kZXJUYXJnZXQuanMnO1xuaW1wb3J0IHsgRG91YmxlU2lkZSwgQmFja1NpZGUsIEZyb250U2lkZSwgU1JHQkNvbG9yU3BhY2UsIE5vVG9uZU1hcHBpbmcsIExpbmVhckZpbHRlciwgTGluZWFyU1JHQkNvbG9yU3BhY2UsIEhhbGZGbG9hdFR5cGUsIFJHQkFGb3JtYXQsIFBDRlNoYWRvd01hcCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IF9zY2VuZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFNjZW5lKCk7XG5jb25zdCBfZHJhd2luZ0J1ZmZlclNpemUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XG5jb25zdCBfc2NyZWVuID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yNCgpO1xuY29uc3QgX2ZydXN0dW0gPSAvKkBfX1BVUkVfXyovIG5ldyBGcnVzdHVtKCk7XG5jb25zdCBfcHJvalNjcmVlbk1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF92ZWN0b3I0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yNCgpO1xuXG5jbGFzcyBSZW5kZXJlciB7XG5cblx0Y29uc3RydWN0b3IoIGJhY2tlbmQsIHBhcmFtZXRlcnMgPSB7fSApIHtcblxuXHRcdHRoaXMuaXNSZW5kZXJlciA9IHRydWU7XG5cblx0XHQvL1xuXG5cdFx0Y29uc3Qge1xuXHRcdFx0bG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9IGZhbHNlLFxuXHRcdFx0YWxwaGEgPSB0cnVlLFxuXHRcdFx0ZGVwdGggPSB0cnVlLFxuXHRcdFx0c3RlbmNpbCA9IGZhbHNlLFxuXHRcdFx0YW50aWFsaWFzID0gZmFsc2UsXG5cdFx0XHRzYW1wbGVzID0gMCxcblx0XHRcdGdldEZhbGxiYWNrID0gbnVsbFxuXHRcdH0gPSBwYXJhbWV0ZXJzO1xuXG5cdFx0Ly8gcHVibGljXG5cdFx0dGhpcy5kb21FbGVtZW50ID0gYmFja2VuZC5nZXREb21FbGVtZW50KCk7XG5cblx0XHR0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xuXG5cdFx0dGhpcy5zYW1wbGVzID0gc2FtcGxlcyB8fCAoIGFudGlhbGlhcyA9PT0gdHJ1ZSApID8gNCA6IDA7XG5cblx0XHR0aGlzLmF1dG9DbGVhciA9IHRydWU7XG5cdFx0dGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRydWU7XG5cdFx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XG5cdFx0dGhpcy5hdXRvQ2xlYXJTdGVuY2lsID0gdHJ1ZTtcblxuXHRcdHRoaXMuYWxwaGEgPSBhbHBoYTtcblxuXHRcdHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9IGxvZ2FyaXRobWljRGVwdGhCdWZmZXI7XG5cblx0XHR0aGlzLm91dHB1dENvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTtcblxuXHRcdHRoaXMudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXHRcdHRoaXMudG9uZU1hcHBpbmdFeHBvc3VyZSA9IDEuMDtcblxuXHRcdHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xuXG5cdFx0dGhpcy5kZXB0aCA9IGRlcHRoO1xuXHRcdHRoaXMuc3RlbmNpbCA9IHN0ZW5jaWw7XG5cblx0XHR0aGlzLmluZm8gPSBuZXcgSW5mbygpO1xuXG5cdFx0dGhpcy5ub2RlcyA9IHtcblx0XHRcdG1vZGVsVmlld01hdHJpeDogbnVsbCxcblx0XHRcdG1vZGVsTm9ybWFsVmlld01hdHJpeDogbnVsbFxuXHRcdH07XG5cblx0XHR0aGlzLmxpYnJhcnkgPSBuZXcgTm9kZUxpYnJhcnkoKTtcblx0XHR0aGlzLmxpZ2h0aW5nID0gbmV3IExpZ2h0aW5nKCk7XG5cblx0XHQvLyBpbnRlcm5hbHNcblxuXHRcdHRoaXMuX2dldEZhbGxiYWNrID0gZ2V0RmFsbGJhY2s7XG5cblx0XHR0aGlzLl9waXhlbFJhdGlvID0gMTtcblx0XHR0aGlzLl93aWR0aCA9IHRoaXMuZG9tRWxlbWVudC53aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSB0aGlzLmRvbUVsZW1lbnQuaGVpZ2h0O1xuXG5cdFx0dGhpcy5fdmlld3BvcnQgPSBuZXcgVmVjdG9yNCggMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCApO1xuXHRcdHRoaXMuX3NjaXNzb3IgPSBuZXcgVmVjdG9yNCggMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCApO1xuXHRcdHRoaXMuX3NjaXNzb3JUZXN0ID0gZmFsc2U7XG5cblx0XHR0aGlzLl9hdHRyaWJ1dGVzID0gbnVsbDtcblx0XHR0aGlzLl9nZW9tZXRyaWVzID0gbnVsbDtcblx0XHR0aGlzLl9ub2RlcyA9IG51bGw7XG5cdFx0dGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcblx0XHR0aGlzLl9iaW5kaW5ncyA9IG51bGw7XG5cdFx0dGhpcy5fb2JqZWN0cyA9IG51bGw7XG5cdFx0dGhpcy5fcGlwZWxpbmVzID0gbnVsbDtcblx0XHR0aGlzLl9idW5kbGVzID0gbnVsbDtcblx0XHR0aGlzLl9yZW5kZXJMaXN0cyA9IG51bGw7XG5cdFx0dGhpcy5fcmVuZGVyQ29udGV4dHMgPSBudWxsO1xuXHRcdHRoaXMuX3RleHR1cmVzID0gbnVsbDtcblx0XHR0aGlzLl9iYWNrZ3JvdW5kID0gbnVsbDtcblxuXHRcdHRoaXMuX3F1YWQgPSBuZXcgUXVhZE1lc2goIG5ldyBOb2RlTWF0ZXJpYWwoKSApO1xuXHRcdHRoaXMuX3F1YWQubWF0ZXJpYWwudHlwZSA9ICdSZW5kZXJlcl9vdXRwdXQnO1xuXG5cdFx0dGhpcy5fY3VycmVudFJlbmRlckNvbnRleHQgPSBudWxsO1xuXG5cdFx0dGhpcy5fb3BhcXVlU29ydCA9IG51bGw7XG5cdFx0dGhpcy5fdHJhbnNwYXJlbnRTb3J0ID0gbnVsbDtcblxuXHRcdHRoaXMuX2ZyYW1lQnVmZmVyVGFyZ2V0ID0gbnVsbDtcblxuXHRcdGNvbnN0IGFscGhhQ2xlYXIgPSB0aGlzLmFscGhhID09PSB0cnVlID8gMCA6IDE7XG5cblx0XHR0aGlzLl9jbGVhckNvbG9yID0gbmV3IENvbG9yNCggMCwgMCwgMCwgYWxwaGFDbGVhciApO1xuXHRcdHRoaXMuX2NsZWFyRGVwdGggPSAxO1xuXHRcdHRoaXMuX2NsZWFyU3RlbmNpbCA9IDA7XG5cblx0XHR0aGlzLl9yZW5kZXJUYXJnZXQgPSBudWxsO1xuXHRcdHRoaXMuX2FjdGl2ZUN1YmVGYWNlID0gMDtcblx0XHR0aGlzLl9hY3RpdmVNaXBtYXBMZXZlbCA9IDA7XG5cblx0XHR0aGlzLl9tcnQgPSBudWxsO1xuXG5cdFx0dGhpcy5fcmVuZGVyT2JqZWN0RnVuY3Rpb24gPSBudWxsO1xuXHRcdHRoaXMuX2N1cnJlbnRSZW5kZXJPYmplY3RGdW5jdGlvbiA9IG51bGw7XG5cdFx0dGhpcy5fY3VycmVudFJlbmRlckJ1bmRsZSA9IG51bGw7XG5cblx0XHR0aGlzLl9oYW5kbGVPYmplY3RGdW5jdGlvbiA9IHRoaXMuX3JlbmRlck9iamVjdERpcmVjdDtcblxuXHRcdHRoaXMuX2lzRGV2aWNlTG9zdCA9IGZhbHNlO1xuXHRcdHRoaXMub25EZXZpY2VMb3N0ID0gdGhpcy5fb25EZXZpY2VMb3N0O1xuXG5cdFx0dGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9pbml0UHJvbWlzZSA9IG51bGw7XG5cblx0XHR0aGlzLl9jb21waWxhdGlvblByb21pc2VzID0gbnVsbDtcblxuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXHRcdHRoaXMub3BhcXVlID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2hhZG93TWFwID0ge1xuXHRcdFx0ZW5hYmxlZDogZmFsc2UsXG5cdFx0XHR0eXBlOiBQQ0ZTaGFkb3dNYXBcblx0XHR9O1xuXG5cdFx0dGhpcy54ciA9IHtcblx0XHRcdGVuYWJsZWQ6IGZhbHNlXG5cdFx0fTtcblxuXHRcdHRoaXMuZGVidWcgPSB7XG5cdFx0XHRjaGVja1NoYWRlckVycm9yczogdHJ1ZSxcblx0XHRcdG9uU2hhZGVyRXJyb3I6IG51bGwsXG5cdFx0XHRnZXRTaGFkZXJBc3luYzogYXN5bmMgKCBzY2VuZSwgY2FtZXJhLCBvYmplY3QgKSA9PiB7XG5cblx0XHRcdFx0YXdhaXQgdGhpcy5jb21waWxlQXN5bmMoIHNjZW5lLCBjYW1lcmEgKTtcblxuXHRcdFx0XHRjb25zdCByZW5kZXJMaXN0ID0gdGhpcy5fcmVuZGVyTGlzdHMuZ2V0KCBzY2VuZSwgY2FtZXJhICk7XG5cdFx0XHRcdGNvbnN0IHJlbmRlckNvbnRleHQgPSB0aGlzLl9yZW5kZXJDb250ZXh0cy5nZXQoIHNjZW5lLCBjYW1lcmEsIHRoaXMuX3JlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCB8fCBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRcdFx0Y29uc3QgcmVuZGVyT2JqZWN0ID0gdGhpcy5fb2JqZWN0cy5nZXQoIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIHJlbmRlckxpc3QubGlnaHRzTm9kZSwgcmVuZGVyQ29udGV4dCwgcmVuZGVyQ29udGV4dC5jbGlwcGluZ0NvbnRleHQgKTtcblxuXHRcdFx0XHRjb25zdCB7IGZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXIgfSA9IHJlbmRlck9iamVjdC5nZXROb2RlQnVpbGRlclN0YXRlKCk7XG5cblx0XHRcdFx0cmV0dXJuIHsgZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlciB9O1xuXG5cdFx0XHR9XG5cdFx0fTtcblxuXHR9XG5cblx0YXN5bmMgaW5pdCgpIHtcblxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1JlbmRlcmVyOiBCYWNrZW5kIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9pbml0UHJvbWlzZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX2luaXRQcm9taXNlO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5faW5pdFByb21pc2UgPSBuZXcgUHJvbWlzZSggYXN5bmMgKCByZXNvbHZlLCByZWplY3QgKSA9PiB7XG5cblx0XHRcdGxldCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdGF3YWl0IGJhY2tlbmQuaW5pdCggdGhpcyApO1xuXG5cdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdFx0aWYgKCB0aGlzLl9nZXRGYWxsYmFjayAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdC8vIHRyeSB0aGUgZmFsbGJhY2tcblxuXHRcdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuYmFja2VuZCA9IGJhY2tlbmQgPSB0aGlzLl9nZXRGYWxsYmFjayggZXJyb3IgKTtcblx0XHRcdFx0XHRcdGF3YWl0IGJhY2tlbmQuaW5pdCggdGhpcyApO1xuXG5cdFx0XHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRcdFx0XHRyZWplY3QoIGVycm9yICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJlamVjdCggZXJyb3IgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX25vZGVzID0gbmV3IE5vZGVzKCB0aGlzLCBiYWNrZW5kICk7XG5cdFx0XHR0aGlzLl9hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCB0aGlzLl9ub2RlcywgdGhpcy5pbmZvICk7XG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGVzID0gbmV3IEF0dHJpYnV0ZXMoIGJhY2tlbmQgKTtcblx0XHRcdHRoaXMuX2JhY2tncm91bmQgPSBuZXcgQmFja2dyb3VuZCggdGhpcywgdGhpcy5fbm9kZXMgKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXMgPSBuZXcgR2VvbWV0cmllcyggdGhpcy5fYXR0cmlidXRlcywgdGhpcy5pbmZvICk7XG5cdFx0XHR0aGlzLl90ZXh0dXJlcyA9IG5ldyBUZXh0dXJlcyggdGhpcywgYmFja2VuZCwgdGhpcy5pbmZvICk7XG5cdFx0XHR0aGlzLl9waXBlbGluZXMgPSBuZXcgUGlwZWxpbmVzKCBiYWNrZW5kLCB0aGlzLl9ub2RlcyApO1xuXHRcdFx0dGhpcy5fYmluZGluZ3MgPSBuZXcgQmluZGluZ3MoIGJhY2tlbmQsIHRoaXMuX25vZGVzLCB0aGlzLl90ZXh0dXJlcywgdGhpcy5fYXR0cmlidXRlcywgdGhpcy5fcGlwZWxpbmVzLCB0aGlzLmluZm8gKTtcblx0XHRcdHRoaXMuX29iamVjdHMgPSBuZXcgUmVuZGVyT2JqZWN0cyggdGhpcywgdGhpcy5fbm9kZXMsIHRoaXMuX2dlb21ldHJpZXMsIHRoaXMuX3BpcGVsaW5lcywgdGhpcy5fYmluZGluZ3MsIHRoaXMuaW5mbyApO1xuXHRcdFx0dGhpcy5fcmVuZGVyTGlzdHMgPSBuZXcgUmVuZGVyTGlzdHMoIHRoaXMubGlnaHRpbmcgKTtcblx0XHRcdHRoaXMuX2J1bmRsZXMgPSBuZXcgUmVuZGVyQnVuZGxlcygpO1xuXHRcdFx0dGhpcy5fcmVuZGVyQ29udGV4dHMgPSBuZXcgUmVuZGVyQ29udGV4dHMoKTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uLnN0YXJ0KCk7XG5cdFx0XHR0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHRcdHJlc29sdmUoKTtcblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiB0aGlzLl9pbml0UHJvbWlzZTtcblxuXHR9XG5cblx0Z2V0IGNvb3JkaW5hdGVTeXN0ZW0oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5iYWNrZW5kLmNvb3JkaW5hdGVTeXN0ZW07XG5cblx0fVxuXG5cdGFzeW5jIGNvbXBpbGVBc3luYyggc2NlbmUsIGNhbWVyYSwgdGFyZ2V0U2NlbmUgPSBudWxsICkge1xuXG5cdFx0aWYgKCB0aGlzLl9pc0RldmljZUxvc3QgPT09IHRydWUgKSByZXR1cm47XG5cblx0XHRpZiAoIHRoaXMuX2luaXRpYWxpemVkID09PSBmYWxzZSApIGF3YWl0IHRoaXMuaW5pdCgpO1xuXG5cdFx0Ly8gcHJlc2VydmUgcmVuZGVyIHRyZWVcblxuXHRcdGNvbnN0IG5vZGVGcmFtZSA9IHRoaXMuX25vZGVzLm5vZGVGcmFtZTtcblxuXHRcdGNvbnN0IHByZXZpb3VzUmVuZGVySWQgPSBub2RlRnJhbWUucmVuZGVySWQ7XG5cdFx0Y29uc3QgcHJldmlvdXNSZW5kZXJDb250ZXh0ID0gdGhpcy5fY3VycmVudFJlbmRlckNvbnRleHQ7XG5cdFx0Y29uc3QgcHJldmlvdXNSZW5kZXJPYmplY3RGdW5jdGlvbiA9IHRoaXMuX2N1cnJlbnRSZW5kZXJPYmplY3RGdW5jdGlvbjtcblx0XHRjb25zdCBwcmV2aW91c0NvbXBpbGF0aW9uUHJvbWlzZXMgPSB0aGlzLl9jb21waWxhdGlvblByb21pc2VzO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IHNjZW5lUmVmID0gKCBzY2VuZS5pc1NjZW5lID09PSB0cnVlICkgPyBzY2VuZSA6IF9zY2VuZTtcblxuXHRcdGlmICggdGFyZ2V0U2NlbmUgPT09IG51bGwgKSB0YXJnZXRTY2VuZSA9IHNjZW5lO1xuXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5fcmVuZGVyVGFyZ2V0O1xuXHRcdGNvbnN0IHJlbmRlckNvbnRleHQgPSB0aGlzLl9yZW5kZXJDb250ZXh0cy5nZXQoIHRhcmdldFNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCApO1xuXHRcdGNvbnN0IGFjdGl2ZU1pcG1hcExldmVsID0gdGhpcy5fYWN0aXZlTWlwbWFwTGV2ZWw7XG5cblx0XHRjb25zdCBjb21waWxhdGlvblByb21pc2VzID0gW107XG5cblx0XHR0aGlzLl9jdXJyZW50UmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG5cdFx0dGhpcy5fY3VycmVudFJlbmRlck9iamVjdEZ1bmN0aW9uID0gdGhpcy5yZW5kZXJPYmplY3Q7XG5cblx0XHR0aGlzLl9oYW5kbGVPYmplY3RGdW5jdGlvbiA9IHRoaXMuX2NyZWF0ZU9iamVjdFBpcGVsaW5lO1xuXG5cdFx0dGhpcy5fY29tcGlsYXRpb25Qcm9taXNlcyA9IGNvbXBpbGF0aW9uUHJvbWlzZXM7XG5cblx0XHRub2RlRnJhbWUucmVuZGVySWQgKys7XG5cblx0XHQvL1xuXG5cdFx0bm9kZUZyYW1lLnVwZGF0ZSgpO1xuXG5cdFx0Ly9cblxuXHRcdHJlbmRlckNvbnRleHQuZGVwdGggPSB0aGlzLmRlcHRoO1xuXHRcdHJlbmRlckNvbnRleHQuc3RlbmNpbCA9IHRoaXMuc3RlbmNpbDtcblxuXHRcdGlmICggISByZW5kZXJDb250ZXh0LmNsaXBwaW5nQ29udGV4dCApIHJlbmRlckNvbnRleHQuY2xpcHBpbmdDb250ZXh0ID0gbmV3IENsaXBwaW5nQ29udGV4dCgpO1xuXHRcdHJlbmRlckNvbnRleHQuY2xpcHBpbmdDb250ZXh0LnVwZGF0ZUdsb2JhbCggc2NlbmVSZWYsIGNhbWVyYSApO1xuXG5cdFx0Ly9cblxuXHRcdHNjZW5lUmVmLm9uQmVmb3JlUmVuZGVyKCB0aGlzLCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdC8vXG5cblx0XHRjb25zdCByZW5kZXJMaXN0ID0gdGhpcy5fcmVuZGVyTGlzdHMuZ2V0KCBzY2VuZSwgY2FtZXJhICk7XG5cdFx0cmVuZGVyTGlzdC5iZWdpbigpO1xuXG5cdFx0dGhpcy5fcHJvamVjdE9iamVjdCggc2NlbmUsIGNhbWVyYSwgMCwgcmVuZGVyTGlzdCwgcmVuZGVyQ29udGV4dC5jbGlwcGluZ0NvbnRleHQgKTtcblxuXHRcdC8vIGluY2x1ZGUgbGlnaHRzIGZyb20gdGFyZ2V0IHNjZW5lXG5cdFx0aWYgKCB0YXJnZXRTY2VuZSAhPT0gc2NlbmUgKSB7XG5cblx0XHRcdHRhcmdldFNjZW5lLnRyYXZlcnNlVmlzaWJsZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuaXNMaWdodCAmJiBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKSApIHtcblxuXHRcdFx0XHRcdHJlbmRlckxpc3QucHVzaExpZ2h0KCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHJlbmRlckxpc3QuZmluaXNoKCk7XG5cblx0XHQvL1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX3RleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0LCBhY3RpdmVNaXBtYXBMZXZlbCApO1xuXG5cdFx0XHRjb25zdCByZW5kZXJUYXJnZXREYXRhID0gdGhpcy5fdGV4dHVyZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0cmVuZGVyQ29udGV4dC50ZXh0dXJlcyA9IHJlbmRlclRhcmdldERhdGEudGV4dHVyZXM7XG5cdFx0XHRyZW5kZXJDb250ZXh0LmRlcHRoVGV4dHVyZSA9IHJlbmRlclRhcmdldERhdGEuZGVwdGhUZXh0dXJlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVuZGVyQ29udGV4dC50ZXh0dXJlcyA9IG51bGw7XG5cdFx0XHRyZW5kZXJDb250ZXh0LmRlcHRoVGV4dHVyZSA9IG51bGw7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0dGhpcy5fbm9kZXMudXBkYXRlU2NlbmUoIHNjZW5lUmVmICk7XG5cblx0XHQvL1xuXG5cdFx0dGhpcy5fYmFja2dyb3VuZC51cGRhdGUoIHNjZW5lUmVmLCByZW5kZXJMaXN0LCByZW5kZXJDb250ZXh0ICk7XG5cblx0XHQvLyBwcm9jZXNzIHJlbmRlciBsaXN0c1xuXG5cdFx0Y29uc3Qgb3BhcXVlT2JqZWN0cyA9IHJlbmRlckxpc3Qub3BhcXVlO1xuXHRcdGNvbnN0IHRyYW5zcGFyZW50T2JqZWN0cyA9IHJlbmRlckxpc3QudHJhbnNwYXJlbnQ7XG5cdFx0Y29uc3QgdHJhbnNwYXJlbnREb3VibGVQYXNzT2JqZWN0cyA9IHJlbmRlckxpc3QudHJhbnNwYXJlbnREb3VibGVQYXNzO1xuXHRcdGNvbnN0IGxpZ2h0c05vZGUgPSByZW5kZXJMaXN0LmxpZ2h0c05vZGU7XG5cblx0XHRpZiAoIHRoaXMub3BhcXVlID09PSB0cnVlICYmIG9wYXF1ZU9iamVjdHMubGVuZ3RoID4gMCApIHRoaXMuX3JlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgc2NlbmVSZWYsIGxpZ2h0c05vZGUgKTtcblx0XHRpZiAoIHRoaXMudHJhbnNwYXJlbnQgPT09IHRydWUgJiYgdHJhbnNwYXJlbnRPYmplY3RzLmxlbmd0aCA+IDAgKSB0aGlzLl9yZW5kZXJUcmFuc3BhcmVudHMoIHRyYW5zcGFyZW50T2JqZWN0cywgdHJhbnNwYXJlbnREb3VibGVQYXNzT2JqZWN0cywgY2FtZXJhLCBzY2VuZVJlZiwgbGlnaHRzTm9kZSApO1xuXG5cdFx0Ly8gcmVzdG9yZSByZW5kZXIgdHJlZVxuXG5cdFx0bm9kZUZyYW1lLnJlbmRlcklkID0gcHJldmlvdXNSZW5kZXJJZDtcblxuXHRcdHRoaXMuX2N1cnJlbnRSZW5kZXJDb250ZXh0ID0gcHJldmlvdXNSZW5kZXJDb250ZXh0O1xuXHRcdHRoaXMuX2N1cnJlbnRSZW5kZXJPYmplY3RGdW5jdGlvbiA9IHByZXZpb3VzUmVuZGVyT2JqZWN0RnVuY3Rpb247XG5cdFx0dGhpcy5fY29tcGlsYXRpb25Qcm9taXNlcyA9IHByZXZpb3VzQ29tcGlsYXRpb25Qcm9taXNlcztcblxuXHRcdHRoaXMuX2hhbmRsZU9iamVjdEZ1bmN0aW9uID0gdGhpcy5fcmVuZGVyT2JqZWN0RGlyZWN0O1xuXG5cdFx0Ly8gd2FpdCBmb3IgYWxsIHByb21pc2VzIHNldHVwIGJ5IGJhY2tlbmRzIGF3YWl0aW5nIGNvbXBpbGF0aW9uL2xpbmtpbmcvcGlwZWxpbmUgY3JlYXRpb24gdG8gY29tcGxldGVcblxuXHRcdGF3YWl0IFByb21pc2UuYWxsKCBjb21waWxhdGlvblByb21pc2VzICk7XG5cblx0fVxuXG5cdGFzeW5jIHJlbmRlckFzeW5jKCBzY2VuZSwgY2FtZXJhICkge1xuXG5cdFx0aWYgKCB0aGlzLl9pbml0aWFsaXplZCA9PT0gZmFsc2UgKSBhd2FpdCB0aGlzLmluaXQoKTtcblxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHQgPSB0aGlzLl9yZW5kZXJTY2VuZSggc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0YXdhaXQgdGhpcy5iYWNrZW5kLnJlc29sdmVUaW1lc3RhbXBBc3luYyggcmVuZGVyQ29udGV4dCwgJ3JlbmRlcicgKTtcblxuXHR9XG5cblx0YXN5bmMgd2FpdEZvckdQVSgpIHtcblxuXHRcdGF3YWl0IHRoaXMuYmFja2VuZC53YWl0Rm9yR1BVKCk7XG5cblx0fVxuXG5cdHNldE1SVCggbXJ0ICkge1xuXG5cdFx0dGhpcy5fbXJ0ID0gbXJ0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE1SVCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9tcnQ7XG5cblx0fVxuXG5cdF9vbkRldmljZUxvc3QoIGluZm8gKSB7XG5cblx0XHRsZXQgZXJyb3JNZXNzYWdlID0gYFRIUkVFLldlYkdQVVJlbmRlcmVyOiAke2luZm8uYXBpfSBEZXZpY2UgTG9zdDpcXG5cXG5NZXNzYWdlOiAke2luZm8ubWVzc2FnZX1gO1xuXG5cdFx0aWYgKCBpbmZvLnJlYXNvbiApIHtcblxuXHRcdFx0ZXJyb3JNZXNzYWdlICs9IGBcXG5SZWFzb246ICR7aW5mby5yZWFzb259YDtcblxuXHRcdH1cblxuXHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yTWVzc2FnZSApO1xuXG5cdFx0dGhpcy5faXNEZXZpY2VMb3N0ID0gdHJ1ZTtcblxuXHR9XG5cblxuXHRfcmVuZGVyQnVuZGxlKCBidW5kbGUsIHNjZW5lUmVmLCBsaWdodHNOb2RlICkge1xuXG5cdFx0Y29uc3QgeyBidW5kbGVHcm91cCwgY2FtZXJhLCByZW5kZXJMaXN0IH0gPSBidW5kbGU7XG5cblx0XHRjb25zdCByZW5kZXJDb250ZXh0ID0gdGhpcy5fY3VycmVudFJlbmRlckNvbnRleHQ7XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgcmVuZGVyQnVuZGxlID0gdGhpcy5fYnVuZGxlcy5nZXQoIGJ1bmRsZUdyb3VwLCBjYW1lcmEgKTtcblx0XHRjb25zdCByZW5kZXJCdW5kbGVEYXRhID0gdGhpcy5iYWNrZW5kLmdldCggcmVuZGVyQnVuZGxlICk7XG5cblx0XHRpZiAoIHJlbmRlckJ1bmRsZURhdGEucmVuZGVyQ29udGV4dHMgPT09IHVuZGVmaW5lZCApIHJlbmRlckJ1bmRsZURhdGEucmVuZGVyQ29udGV4dHMgPSBuZXcgU2V0KCk7XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgbmVlZHNVcGRhdGUgPSBidW5kbGVHcm91cC52ZXJzaW9uICE9PSByZW5kZXJCdW5kbGVEYXRhLnZlcnNpb247XG5cdFx0Y29uc3QgcmVuZGVyQnVuZGxlTmVlZHNVcGRhdGUgPSByZW5kZXJCdW5kbGVEYXRhLnJlbmRlckNvbnRleHRzLmhhcyggcmVuZGVyQ29udGV4dCApID09PSBmYWxzZSB8fCBuZWVkc1VwZGF0ZTtcblxuXHRcdHJlbmRlckJ1bmRsZURhdGEucmVuZGVyQ29udGV4dHMuYWRkKCByZW5kZXJDb250ZXh0ICk7XG5cblx0XHRpZiAoIHJlbmRlckJ1bmRsZU5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHR0aGlzLmJhY2tlbmQuYmVnaW5CdW5kbGUoIHJlbmRlckNvbnRleHQgKTtcblxuXHRcdFx0aWYgKCByZW5kZXJCdW5kbGVEYXRhLnJlbmRlck9iamVjdHMgPT09IHVuZGVmaW5lZCB8fCBuZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHRyZW5kZXJCdW5kbGVEYXRhLnJlbmRlck9iamVjdHMgPSBbXTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jdXJyZW50UmVuZGVyQnVuZGxlID0gcmVuZGVyQnVuZGxlO1xuXG5cdFx0XHRjb25zdCBvcGFxdWVPYmplY3RzID0gcmVuZGVyTGlzdC5vcGFxdWU7XG5cblx0XHRcdGlmICggdGhpcy5vcGFxdWUgPT09IHRydWUgJiYgb3BhcXVlT2JqZWN0cy5sZW5ndGggPiAwICkgdGhpcy5fcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBzY2VuZVJlZiwgbGlnaHRzTm9kZSApO1xuXG5cdFx0XHR0aGlzLl9jdXJyZW50UmVuZGVyQnVuZGxlID0gbnVsbDtcblxuXHRcdFx0Ly9cblxuXHRcdFx0dGhpcy5iYWNrZW5kLmZpbmlzaEJ1bmRsZSggcmVuZGVyQ29udGV4dCwgcmVuZGVyQnVuZGxlICk7XG5cblx0XHRcdHJlbmRlckJ1bmRsZURhdGEudmVyc2lvbiA9IGJ1bmRsZUdyb3VwLnZlcnNpb247XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCB7IHJlbmRlck9iamVjdHMgfSA9IHJlbmRlckJ1bmRsZURhdGE7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJlbmRlck9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCByZW5kZXJPYmplY3QgPSByZW5kZXJPYmplY3RzWyBpIF07XG5cblx0XHRcdFx0aWYgKCB0aGlzLl9ub2Rlcy5uZWVkc1JlZnJlc2goIHJlbmRlck9iamVjdCApICkge1xuXG5cdFx0XHRcdFx0dGhpcy5fbm9kZXMudXBkYXRlQmVmb3JlKCByZW5kZXJPYmplY3QgKTtcblxuXHRcdFx0XHRcdHRoaXMuX25vZGVzLnVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICk7XG5cdFx0XHRcdFx0dGhpcy5fYmluZGluZ3MudXBkYXRlRm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKTtcblxuXHRcdFx0XHRcdHRoaXMuX25vZGVzLnVwZGF0ZUFmdGVyKCByZW5kZXJPYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuYmFja2VuZC5hZGRCdW5kbGUoIHJlbmRlckNvbnRleHQsIHJlbmRlckJ1bmRsZSApO1xuXG5cdH1cblxuXHRyZW5kZXIoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2luaXRpYWxpemVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmVuZGVyZXI6IC5yZW5kZXIoKSBjYWxsZWQgYmVmb3JlIHRoZSBiYWNrZW5kIGlzIGluaXRpYWxpemVkLiBUcnkgdXNpbmcgLnJlbmRlckFzeW5jKCkgaW5zdGVhZC4nICk7XG5cblx0XHRcdHJldHVybiB0aGlzLnJlbmRlckFzeW5jKCBzY2VuZSwgY2FtZXJhICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9yZW5kZXJTY2VuZSggc2NlbmUsIGNhbWVyYSApO1xuXG5cdH1cblxuXHRfZ2V0RnJhbWVCdWZmZXJUYXJnZXQoKSB7XG5cblx0XHRjb25zdCB7IGN1cnJlbnRUb25lTWFwcGluZywgY3VycmVudENvbG9yU3BhY2UgfSA9IHRoaXM7XG5cblx0XHRjb25zdCB1c2VUb25lTWFwcGluZyA9IGN1cnJlbnRUb25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZztcblx0XHRjb25zdCB1c2VDb2xvclNwYWNlID0gY3VycmVudENvbG9yU3BhY2UgIT09IExpbmVhclNSR0JDb2xvclNwYWNlO1xuXG5cdFx0aWYgKCB1c2VUb25lTWFwcGluZyA9PT0gZmFsc2UgJiYgdXNlQ29sb3JTcGFjZSA9PT0gZmFsc2UgKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5nZXREcmF3aW5nQnVmZmVyU2l6ZSggX2RyYXdpbmdCdWZmZXJTaXplICk7XG5cdFx0Y29uc3QgeyBkZXB0aCwgc3RlbmNpbCB9ID0gdGhpcztcblxuXHRcdGxldCBmcmFtZUJ1ZmZlclRhcmdldCA9IHRoaXMuX2ZyYW1lQnVmZmVyVGFyZ2V0O1xuXG5cdFx0aWYgKCBmcmFtZUJ1ZmZlclRhcmdldCA9PT0gbnVsbCApIHtcblxuXHRcdFx0ZnJhbWVCdWZmZXJUYXJnZXQgPSBuZXcgUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCB7XG5cdFx0XHRcdGRlcHRoQnVmZmVyOiBkZXB0aCxcblx0XHRcdFx0c3RlbmNpbEJ1ZmZlcjogc3RlbmNpbCxcblx0XHRcdFx0dHlwZTogSGFsZkZsb2F0VHlwZSwgLy8gRmxvYXRUeXBlXG5cdFx0XHRcdGZvcm1hdDogUkdCQUZvcm1hdCxcblx0XHRcdFx0Y29sb3JTcGFjZTogTGluZWFyU1JHQkNvbG9yU3BhY2UsXG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwczogZmFsc2UsXG5cdFx0XHRcdG1pbkZpbHRlcjogTGluZWFyRmlsdGVyLFxuXHRcdFx0XHRtYWdGaWx0ZXI6IExpbmVhckZpbHRlcixcblx0XHRcdFx0c2FtcGxlczogdGhpcy5zYW1wbGVzXG5cdFx0XHR9ICk7XG5cblx0XHRcdGZyYW1lQnVmZmVyVGFyZ2V0LmlzUG9zdFByb2Nlc3NpbmdSZW5kZXJUYXJnZXQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLl9mcmFtZUJ1ZmZlclRhcmdldCA9IGZyYW1lQnVmZmVyVGFyZ2V0O1xuXG5cdFx0fVxuXG5cdFx0ZnJhbWVCdWZmZXJUYXJnZXQuZGVwdGhCdWZmZXIgPSBkZXB0aDtcblx0XHRmcmFtZUJ1ZmZlclRhcmdldC5zdGVuY2lsQnVmZmVyID0gc3RlbmNpbDtcblx0XHRmcmFtZUJ1ZmZlclRhcmdldC5zZXRTaXplKCB3aWR0aCwgaGVpZ2h0ICk7XG5cdFx0ZnJhbWVCdWZmZXJUYXJnZXQudmlld3BvcnQuY29weSggdGhpcy5fdmlld3BvcnQgKTtcblx0XHRmcmFtZUJ1ZmZlclRhcmdldC5zY2lzc29yLmNvcHkoIHRoaXMuX3NjaXNzb3IgKTtcblx0XHRmcmFtZUJ1ZmZlclRhcmdldC52aWV3cG9ydC5tdWx0aXBseVNjYWxhciggdGhpcy5fcGl4ZWxSYXRpbyApO1xuXHRcdGZyYW1lQnVmZmVyVGFyZ2V0LnNjaXNzb3IubXVsdGlwbHlTY2FsYXIoIHRoaXMuX3BpeGVsUmF0aW8gKTtcblx0XHRmcmFtZUJ1ZmZlclRhcmdldC5zY2lzc29yVGVzdCA9IHRoaXMuX3NjaXNzb3JUZXN0O1xuXG5cdFx0cmV0dXJuIGZyYW1lQnVmZmVyVGFyZ2V0O1xuXG5cdH1cblxuXHRfcmVuZGVyU2NlbmUoIHNjZW5lLCBjYW1lcmEsIHVzZUZyYW1lQnVmZmVyVGFyZ2V0ID0gdHJ1ZSApIHtcblxuXHRcdGlmICggdGhpcy5faXNEZXZpY2VMb3N0ID09PSB0cnVlICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgZnJhbWVCdWZmZXJUYXJnZXQgPSB1c2VGcmFtZUJ1ZmZlclRhcmdldCA/IHRoaXMuX2dldEZyYW1lQnVmZmVyVGFyZ2V0KCkgOiBudWxsO1xuXG5cdFx0Ly8gcHJlc2VydmUgcmVuZGVyIHRyZWVcblxuXHRcdGNvbnN0IG5vZGVGcmFtZSA9IHRoaXMuX25vZGVzLm5vZGVGcmFtZTtcblxuXHRcdGNvbnN0IHByZXZpb3VzUmVuZGVySWQgPSBub2RlRnJhbWUucmVuZGVySWQ7XG5cdFx0Y29uc3QgcHJldmlvdXNSZW5kZXJDb250ZXh0ID0gdGhpcy5fY3VycmVudFJlbmRlckNvbnRleHQ7XG5cdFx0Y29uc3QgcHJldmlvdXNSZW5kZXJPYmplY3RGdW5jdGlvbiA9IHRoaXMuX2N1cnJlbnRSZW5kZXJPYmplY3RGdW5jdGlvbjtcblxuXHRcdC8vXG5cblx0XHRjb25zdCBzY2VuZVJlZiA9ICggc2NlbmUuaXNTY2VuZSA9PT0gdHJ1ZSApID8gc2NlbmUgOiBfc2NlbmU7XG5cblx0XHRjb25zdCBvdXRwdXRSZW5kZXJUYXJnZXQgPSB0aGlzLl9yZW5kZXJUYXJnZXQ7XG5cblx0XHRjb25zdCBhY3RpdmVDdWJlRmFjZSA9IHRoaXMuX2FjdGl2ZUN1YmVGYWNlO1xuXHRcdGNvbnN0IGFjdGl2ZU1pcG1hcExldmVsID0gdGhpcy5fYWN0aXZlTWlwbWFwTGV2ZWw7XG5cblx0XHQvL1xuXG5cdFx0bGV0IHJlbmRlclRhcmdldDtcblxuXHRcdGlmICggZnJhbWVCdWZmZXJUYXJnZXQgIT09IG51bGwgKSB7XG5cblx0XHRcdHJlbmRlclRhcmdldCA9IGZyYW1lQnVmZmVyVGFyZ2V0O1xuXG5cdFx0XHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZW5kZXJUYXJnZXQgPSBvdXRwdXRSZW5kZXJUYXJnZXQ7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dCA9IHRoaXMuX3JlbmRlckNvbnRleHRzLmdldCggc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR0aGlzLl9jdXJyZW50UmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG5cdFx0dGhpcy5fY3VycmVudFJlbmRlck9iamVjdEZ1bmN0aW9uID0gdGhpcy5fcmVuZGVyT2JqZWN0RnVuY3Rpb24gfHwgdGhpcy5yZW5kZXJPYmplY3Q7XG5cblx0XHQvL1xuXG5cdFx0dGhpcy5pbmZvLmNhbGxzICsrO1xuXHRcdHRoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XG5cdFx0dGhpcy5pbmZvLnJlbmRlci5mcmFtZUNhbGxzICsrO1xuXG5cdFx0bm9kZUZyYW1lLnJlbmRlcklkID0gdGhpcy5pbmZvLmNhbGxzO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGNvb3JkaW5hdGVTeXN0ZW0gPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW07XG5cblx0XHRpZiAoIGNhbWVyYS5jb29yZGluYXRlU3lzdGVtICE9PSBjb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjYW1lcmEuY29vcmRpbmF0ZVN5c3RlbSA9IGNvb3JkaW5hdGVTeXN0ZW07XG5cblx0XHRcdGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKCBzY2VuZS5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPT09IHRydWUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0aWYgKCBjYW1lcmEucGFyZW50ID09PSBudWxsICYmIGNhbWVyYS5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPT09IHRydWUgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdC8vXG5cblx0XHRsZXQgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydDtcblx0XHRsZXQgc2Npc3NvciA9IHRoaXMuX3NjaXNzb3I7XG5cdFx0bGV0IHBpeGVsUmF0aW8gPSB0aGlzLl9waXhlbFJhdGlvO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgIT09IG51bGwgKSB7XG5cblx0XHRcdHZpZXdwb3J0ID0gcmVuZGVyVGFyZ2V0LnZpZXdwb3J0O1xuXHRcdFx0c2Npc3NvciA9IHJlbmRlclRhcmdldC5zY2lzc29yO1xuXHRcdFx0cGl4ZWxSYXRpbyA9IDE7XG5cblx0XHR9XG5cblx0XHR0aGlzLmdldERyYXdpbmdCdWZmZXJTaXplKCBfZHJhd2luZ0J1ZmZlclNpemUgKTtcblxuXHRcdF9zY3JlZW4uc2V0KCAwLCAwLCBfZHJhd2luZ0J1ZmZlclNpemUud2lkdGgsIF9kcmF3aW5nQnVmZmVyU2l6ZS5oZWlnaHQgKTtcblxuXHRcdGNvbnN0IG1pbkRlcHRoID0gKCB2aWV3cG9ydC5taW5EZXB0aCA9PT0gdW5kZWZpbmVkICkgPyAwIDogdmlld3BvcnQubWluRGVwdGg7XG5cdFx0Y29uc3QgbWF4RGVwdGggPSAoIHZpZXdwb3J0Lm1heERlcHRoID09PSB1bmRlZmluZWQgKSA/IDEgOiB2aWV3cG9ydC5tYXhEZXB0aDtcblxuXHRcdHJlbmRlckNvbnRleHQudmlld3BvcnRWYWx1ZS5jb3B5KCB2aWV3cG9ydCApLm11bHRpcGx5U2NhbGFyKCBwaXhlbFJhdGlvICkuZmxvb3IoKTtcblx0XHRyZW5kZXJDb250ZXh0LnZpZXdwb3J0VmFsdWUud2lkdGggPj49IGFjdGl2ZU1pcG1hcExldmVsO1xuXHRcdHJlbmRlckNvbnRleHQudmlld3BvcnRWYWx1ZS5oZWlnaHQgPj49IGFjdGl2ZU1pcG1hcExldmVsO1xuXHRcdHJlbmRlckNvbnRleHQudmlld3BvcnRWYWx1ZS5taW5EZXB0aCA9IG1pbkRlcHRoO1xuXHRcdHJlbmRlckNvbnRleHQudmlld3BvcnRWYWx1ZS5tYXhEZXB0aCA9IG1heERlcHRoO1xuXHRcdHJlbmRlckNvbnRleHQudmlld3BvcnQgPSByZW5kZXJDb250ZXh0LnZpZXdwb3J0VmFsdWUuZXF1YWxzKCBfc2NyZWVuICkgPT09IGZhbHNlO1xuXG5cdFx0cmVuZGVyQ29udGV4dC5zY2lzc29yVmFsdWUuY29weSggc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBwaXhlbFJhdGlvICkuZmxvb3IoKTtcblx0XHRyZW5kZXJDb250ZXh0LnNjaXNzb3IgPSB0aGlzLl9zY2lzc29yVGVzdCAmJiByZW5kZXJDb250ZXh0LnNjaXNzb3JWYWx1ZS5lcXVhbHMoIF9zY3JlZW4gKSA9PT0gZmFsc2U7XG5cdFx0cmVuZGVyQ29udGV4dC5zY2lzc29yVmFsdWUud2lkdGggPj49IGFjdGl2ZU1pcG1hcExldmVsO1xuXHRcdHJlbmRlckNvbnRleHQuc2Npc3NvclZhbHVlLmhlaWdodCA+Pj0gYWN0aXZlTWlwbWFwTGV2ZWw7XG5cblx0XHRpZiAoICEgcmVuZGVyQ29udGV4dC5jbGlwcGluZ0NvbnRleHQgKSByZW5kZXJDb250ZXh0LmNsaXBwaW5nQ29udGV4dCA9IG5ldyBDbGlwcGluZ0NvbnRleHQoKTtcblx0XHRyZW5kZXJDb250ZXh0LmNsaXBwaW5nQ29udGV4dC51cGRhdGVHbG9iYWwoIHNjZW5lUmVmLCBjYW1lcmEgKTtcblxuXHRcdC8vXG5cblx0XHRzY2VuZVJlZi5vbkJlZm9yZVJlbmRlciggdGhpcywgc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHQvL1xuXG5cdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblx0XHRfZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXgsIGNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdGNvbnN0IHJlbmRlckxpc3QgPSB0aGlzLl9yZW5kZXJMaXN0cy5nZXQoIHNjZW5lLCBjYW1lcmEgKTtcblx0XHRyZW5kZXJMaXN0LmJlZ2luKCk7XG5cblx0XHR0aGlzLl9wcm9qZWN0T2JqZWN0KCBzY2VuZSwgY2FtZXJhLCAwLCByZW5kZXJMaXN0LCByZW5kZXJDb250ZXh0LmNsaXBwaW5nQ29udGV4dCApO1xuXG5cdFx0cmVuZGVyTGlzdC5maW5pc2goKTtcblxuXHRcdGlmICggdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0cmVuZGVyTGlzdC5zb3J0KCB0aGlzLl9vcGFxdWVTb3J0LCB0aGlzLl90cmFuc3BhcmVudFNvcnQgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fdGV4dHVyZXMudXBkYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQsIGFjdGl2ZU1pcG1hcExldmVsICk7XG5cblx0XHRcdGNvbnN0IHJlbmRlclRhcmdldERhdGEgPSB0aGlzLl90ZXh0dXJlcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRyZW5kZXJDb250ZXh0LnRleHR1cmVzID0gcmVuZGVyVGFyZ2V0RGF0YS50ZXh0dXJlcztcblx0XHRcdHJlbmRlckNvbnRleHQuZGVwdGhUZXh0dXJlID0gcmVuZGVyVGFyZ2V0RGF0YS5kZXB0aFRleHR1cmU7XG5cdFx0XHRyZW5kZXJDb250ZXh0LndpZHRoID0gcmVuZGVyVGFyZ2V0RGF0YS53aWR0aDtcblx0XHRcdHJlbmRlckNvbnRleHQuaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0RGF0YS5oZWlnaHQ7XG5cdFx0XHRyZW5kZXJDb250ZXh0LnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcblx0XHRcdHJlbmRlckNvbnRleHQuZGVwdGggPSByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXI7XG5cdFx0XHRyZW5kZXJDb250ZXh0LnN0ZW5jaWwgPSByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlbmRlckNvbnRleHQudGV4dHVyZXMgPSBudWxsO1xuXHRcdFx0cmVuZGVyQ29udGV4dC5kZXB0aFRleHR1cmUgPSBudWxsO1xuXHRcdFx0cmVuZGVyQ29udGV4dC53aWR0aCA9IHRoaXMuZG9tRWxlbWVudC53aWR0aDtcblx0XHRcdHJlbmRlckNvbnRleHQuaGVpZ2h0ID0gdGhpcy5kb21FbGVtZW50LmhlaWdodDtcblx0XHRcdHJlbmRlckNvbnRleHQuZGVwdGggPSB0aGlzLmRlcHRoO1xuXHRcdFx0cmVuZGVyQ29udGV4dC5zdGVuY2lsID0gdGhpcy5zdGVuY2lsO1xuXG5cdFx0fVxuXG5cdFx0cmVuZGVyQ29udGV4dC53aWR0aCA+Pj0gYWN0aXZlTWlwbWFwTGV2ZWw7XG5cdFx0cmVuZGVyQ29udGV4dC5oZWlnaHQgPj49IGFjdGl2ZU1pcG1hcExldmVsO1xuXHRcdHJlbmRlckNvbnRleHQuYWN0aXZlQ3ViZUZhY2UgPSBhY3RpdmVDdWJlRmFjZTtcblx0XHRyZW5kZXJDb250ZXh0LmFjdGl2ZU1pcG1hcExldmVsID0gYWN0aXZlTWlwbWFwTGV2ZWw7XG5cdFx0cmVuZGVyQ29udGV4dC5vY2NsdXNpb25RdWVyeUNvdW50ID0gcmVuZGVyTGlzdC5vY2NsdXNpb25RdWVyeUNvdW50O1xuXG5cdFx0Ly9cblxuXHRcdHRoaXMuX25vZGVzLnVwZGF0ZVNjZW5lKCBzY2VuZVJlZiApO1xuXG5cdFx0Ly9cblxuXHRcdHRoaXMuX2JhY2tncm91bmQudXBkYXRlKCBzY2VuZVJlZiwgcmVuZGVyTGlzdCwgcmVuZGVyQ29udGV4dCApO1xuXG5cdFx0Ly9cblxuXHRcdHRoaXMuYmFja2VuZC5iZWdpblJlbmRlciggcmVuZGVyQ29udGV4dCApO1xuXG5cdFx0Ly8gcHJvY2VzcyByZW5kZXIgbGlzdHNcblxuXHRcdGNvbnN0IHtcblx0XHRcdGJ1bmRsZXMsXG5cdFx0XHRsaWdodHNOb2RlLFxuXHRcdFx0dHJhbnNwYXJlbnREb3VibGVQYXNzOiB0cmFuc3BhcmVudERvdWJsZVBhc3NPYmplY3RzLFxuXHRcdFx0dHJhbnNwYXJlbnQ6IHRyYW5zcGFyZW50T2JqZWN0cyxcblx0XHRcdG9wYXF1ZTogb3BhcXVlT2JqZWN0c1xuXHRcdH0gPSByZW5kZXJMaXN0O1xuXG5cdFx0aWYgKCBidW5kbGVzLmxlbmd0aCA+IDAgKSB0aGlzLl9yZW5kZXJCdW5kbGVzKCBidW5kbGVzLCBzY2VuZVJlZiwgbGlnaHRzTm9kZSApO1xuXHRcdGlmICggdGhpcy5vcGFxdWUgPT09IHRydWUgJiYgb3BhcXVlT2JqZWN0cy5sZW5ndGggPiAwICkgdGhpcy5fcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBzY2VuZVJlZiwgbGlnaHRzTm9kZSApO1xuXHRcdGlmICggdGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSAmJiB0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoID4gMCApIHRoaXMuX3JlbmRlclRyYW5zcGFyZW50cyggdHJhbnNwYXJlbnRPYmplY3RzLCB0cmFuc3BhcmVudERvdWJsZVBhc3NPYmplY3RzLCBjYW1lcmEsIHNjZW5lUmVmLCBsaWdodHNOb2RlICk7XG5cblx0XHQvLyBmaW5pc2ggcmVuZGVyIHBhc3NcblxuXHRcdHRoaXMuYmFja2VuZC5maW5pc2hSZW5kZXIoIHJlbmRlckNvbnRleHQgKTtcblxuXHRcdC8vIHJlc3RvcmUgcmVuZGVyIHRyZWVcblxuXHRcdG5vZGVGcmFtZS5yZW5kZXJJZCA9IHByZXZpb3VzUmVuZGVySWQ7XG5cblx0XHR0aGlzLl9jdXJyZW50UmVuZGVyQ29udGV4dCA9IHByZXZpb3VzUmVuZGVyQ29udGV4dDtcblx0XHR0aGlzLl9jdXJyZW50UmVuZGVyT2JqZWN0RnVuY3Rpb24gPSBwcmV2aW91c1JlbmRlck9iamVjdEZ1bmN0aW9uO1xuXG5cdFx0Ly9cblxuXHRcdGlmICggZnJhbWVCdWZmZXJUYXJnZXQgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCBvdXRwdXRSZW5kZXJUYXJnZXQsIGFjdGl2ZUN1YmVGYWNlLCBhY3RpdmVNaXBtYXBMZXZlbCApO1xuXG5cdFx0XHRjb25zdCBxdWFkID0gdGhpcy5fcXVhZDtcblxuXHRcdFx0aWYgKCB0aGlzLl9ub2Rlcy5oYXNPdXRwdXRDaGFuZ2UoIHJlbmRlclRhcmdldC50ZXh0dXJlICkgKSB7XG5cblx0XHRcdFx0cXVhZC5tYXRlcmlhbC5mcmFnbWVudE5vZGUgPSB0aGlzLl9ub2Rlcy5nZXRPdXRwdXROb2RlKCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXHRcdFx0XHRxdWFkLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZW5kZXJTY2VuZSggcXVhZCwgcXVhZC5jYW1lcmEsIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0c2NlbmVSZWYub25BZnRlclJlbmRlciggdGhpcywgc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHQvL1xuXG5cdFx0cmV0dXJuIHJlbmRlckNvbnRleHQ7XG5cblx0fVxuXG5cdGdldE1heEFuaXNvdHJvcHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5iYWNrZW5kLmdldE1heEFuaXNvdHJvcHkoKTtcblxuXHR9XG5cblx0Z2V0QWN0aXZlQ3ViZUZhY2UoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fYWN0aXZlQ3ViZUZhY2U7XG5cblx0fVxuXG5cdGdldEFjdGl2ZU1pcG1hcExldmVsKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZU1pcG1hcExldmVsO1xuXG5cdH1cblxuXHRhc3luYyBzZXRBbmltYXRpb25Mb29wKCBjYWxsYmFjayApIHtcblxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgPT09IGZhbHNlICkgYXdhaXQgdGhpcy5pbml0KCk7XG5cblx0XHR0aGlzLl9hbmltYXRpb24uc2V0QW5pbWF0aW9uTG9vcCggY2FsbGJhY2sgKTtcblxuXHR9XG5cblx0YXN5bmMgZ2V0QXJyYXlCdWZmZXJBc3luYyggYXR0cmlidXRlICkge1xuXG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMuYmFja2VuZC5nZXRBcnJheUJ1ZmZlckFzeW5jKCBhdHRyaWJ1dGUgKTtcblxuXHR9XG5cblx0Z2V0Q29udGV4dCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmJhY2tlbmQuZ2V0Q29udGV4dCgpO1xuXG5cdH1cblxuXHRnZXRQaXhlbFJhdGlvKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsUmF0aW87XG5cblx0fVxuXG5cdGdldERyYXdpbmdCdWZmZXJTaXplKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldCggdGhpcy5fd2lkdGggKiB0aGlzLl9waXhlbFJhdGlvLCB0aGlzLl9oZWlnaHQgKiB0aGlzLl9waXhlbFJhdGlvICkuZmxvb3IoKTtcblxuXHR9XG5cblx0Z2V0U2l6ZSggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQgKTtcblxuXHR9XG5cblx0c2V0UGl4ZWxSYXRpbyggdmFsdWUgPSAxICkge1xuXG5cdFx0aWYgKCB0aGlzLl9waXhlbFJhdGlvID09PSB2YWx1ZSApIHJldHVybjtcblxuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSB2YWx1ZTtcblxuXHRcdHRoaXMuc2V0U2l6ZSggdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgZmFsc2UgKTtcblxuXHR9XG5cblx0c2V0RHJhd2luZ0J1ZmZlclNpemUoIHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8gKSB7XG5cblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXG5cdFx0dGhpcy5kb21FbGVtZW50LndpZHRoID0gTWF0aC5mbG9vciggd2lkdGggKiBwaXhlbFJhdGlvICk7XG5cdFx0dGhpcy5kb21FbGVtZW50LmhlaWdodCA9IE1hdGguZmxvb3IoIGhlaWdodCAqIHBpeGVsUmF0aW8gKTtcblxuXHRcdHRoaXMuc2V0Vmlld3BvcnQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgKSB0aGlzLmJhY2tlbmQudXBkYXRlU2l6ZSgpO1xuXG5cdH1cblxuXHRzZXRTaXplKCB3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSA9IHRydWUgKSB7XG5cblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuXHRcdHRoaXMuZG9tRWxlbWVudC53aWR0aCA9IE1hdGguZmxvb3IoIHdpZHRoICogdGhpcy5fcGl4ZWxSYXRpbyApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5oZWlnaHQgPSBNYXRoLmZsb29yKCBoZWlnaHQgKiB0aGlzLl9waXhlbFJhdGlvICk7XG5cblx0XHRpZiAoIHVwZGF0ZVN0eWxlID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0XHR0aGlzLmRvbUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuXHRcdH1cblxuXHRcdHRoaXMuc2V0Vmlld3BvcnQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgKSB0aGlzLmJhY2tlbmQudXBkYXRlU2l6ZSgpO1xuXG5cdH1cblxuXHRzZXRPcGFxdWVTb3J0KCBtZXRob2QgKSB7XG5cblx0XHR0aGlzLl9vcGFxdWVTb3J0ID0gbWV0aG9kO1xuXG5cdH1cblxuXHRzZXRUcmFuc3BhcmVudFNvcnQoIG1ldGhvZCApIHtcblxuXHRcdHRoaXMuX3RyYW5zcGFyZW50U29ydCA9IG1ldGhvZDtcblxuXHR9XG5cblx0Z2V0U2Npc3NvciggdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3Qgc2Npc3NvciA9IHRoaXMuX3NjaXNzb3I7XG5cblx0XHR0YXJnZXQueCA9IHNjaXNzb3IueDtcblx0XHR0YXJnZXQueSA9IHNjaXNzb3IueTtcblx0XHR0YXJnZXQud2lkdGggPSBzY2lzc29yLndpZHRoO1xuXHRcdHRhcmdldC5oZWlnaHQgPSBzY2lzc29yLmhlaWdodDtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdHNldFNjaXNzb3IoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRjb25zdCBzY2lzc29yID0gdGhpcy5fc2Npc3NvcjtcblxuXHRcdGlmICggeC5pc1ZlY3RvcjQgKSB7XG5cblx0XHRcdHNjaXNzb3IuY29weSggeCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0c2Npc3Nvci5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2V0U2Npc3NvclRlc3QoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fc2Npc3NvclRlc3Q7XG5cblx0fVxuXG5cdHNldFNjaXNzb3JUZXN0KCBib29sZWFuICkge1xuXG5cdFx0dGhpcy5fc2Npc3NvclRlc3QgPSBib29sZWFuO1xuXG5cdFx0dGhpcy5iYWNrZW5kLnNldFNjaXNzb3JUZXN0KCBib29sZWFuICk7XG5cblx0fVxuXG5cdGdldFZpZXdwb3J0KCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIHRoaXMuX3ZpZXdwb3J0ICk7XG5cblx0fVxuXG5cdHNldFZpZXdwb3J0KCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBtaW5EZXB0aCA9IDAsIG1heERlcHRoID0gMSApIHtcblxuXHRcdGNvbnN0IHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQ7XG5cblx0XHRpZiAoIHguaXNWZWN0b3I0ICkge1xuXG5cdFx0XHR2aWV3cG9ydC5jb3B5KCB4ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2aWV3cG9ydC5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdH1cblxuXHRcdHZpZXdwb3J0Lm1pbkRlcHRoID0gbWluRGVwdGg7XG5cdFx0dmlld3BvcnQubWF4RGVwdGggPSBtYXhEZXB0aDtcblxuXHR9XG5cblx0Z2V0Q2xlYXJDb2xvciggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCB0aGlzLl9jbGVhckNvbG9yICk7XG5cblx0fVxuXG5cdHNldENsZWFyQ29sb3IoIGNvbG9yLCBhbHBoYSA9IDEgKSB7XG5cblx0XHR0aGlzLl9jbGVhckNvbG9yLnNldCggY29sb3IgKTtcblx0XHR0aGlzLl9jbGVhckNvbG9yLmEgPSBhbHBoYTtcblxuXHR9XG5cblx0Z2V0Q2xlYXJBbHBoYSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9jbGVhckNvbG9yLmE7XG5cblx0fVxuXG5cdHNldENsZWFyQWxwaGEoIGFscGhhICkge1xuXG5cdFx0dGhpcy5fY2xlYXJDb2xvci5hID0gYWxwaGE7XG5cblx0fVxuXG5cdGdldENsZWFyRGVwdGgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fY2xlYXJEZXB0aDtcblxuXHR9XG5cblx0c2V0Q2xlYXJEZXB0aCggZGVwdGggKSB7XG5cblx0XHR0aGlzLl9jbGVhckRlcHRoID0gZGVwdGg7XG5cblx0fVxuXG5cdGdldENsZWFyU3RlbmNpbCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9jbGVhclN0ZW5jaWw7XG5cblx0fVxuXG5cdHNldENsZWFyU3RlbmNpbCggc3RlbmNpbCApIHtcblxuXHRcdHRoaXMuX2NsZWFyU3RlbmNpbCA9IHN0ZW5jaWw7XG5cblx0fVxuXG5cdGlzT2NjbHVkZWQoIG9iamVjdCApIHtcblxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHQgPSB0aGlzLl9jdXJyZW50UmVuZGVyQ29udGV4dDtcblxuXHRcdHJldHVybiByZW5kZXJDb250ZXh0ICYmIHRoaXMuYmFja2VuZC5pc09jY2x1ZGVkKCByZW5kZXJDb250ZXh0LCBvYmplY3QgKTtcblxuXHR9XG5cblx0Y2xlYXIoIGNvbG9yID0gdHJ1ZSwgZGVwdGggPSB0cnVlLCBzdGVuY2lsID0gdHJ1ZSApIHtcblxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SZW5kZXJlcjogLmNsZWFyKCkgY2FsbGVkIGJlZm9yZSB0aGUgYmFja2VuZCBpcyBpbml0aWFsaXplZC4gVHJ5IHVzaW5nIC5jbGVhckFzeW5jKCkgaW5zdGVhZC4nICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmNsZWFyQXN5bmMoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5fcmVuZGVyVGFyZ2V0IHx8IHRoaXMuX2dldEZyYW1lQnVmZmVyVGFyZ2V0KCk7XG5cblx0XHRsZXQgcmVuZGVyVGFyZ2V0RGF0YSA9IG51bGw7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fdGV4dHVyZXMudXBkYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0RGF0YSA9IHRoaXMuX3RleHR1cmVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmJhY2tlbmQuY2xlYXIoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCwgcmVuZGVyVGFyZ2V0RGF0YSApO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgIT09IG51bGwgJiYgdGhpcy5fcmVuZGVyVGFyZ2V0ID09PSBudWxsICkge1xuXG5cdFx0XHQvLyBJZiBhIGNvbG9yIHNwYWNlIHRyYW5zZm9ybSBvciB0b25lIG1hcHBpbmcgaXMgcmVxdWlyZWQsXG5cdFx0XHQvLyB0aGUgY2xlYXIgb3BlcmF0aW9uIGNsZWFycyB0aGUgaW50ZXJtZWRpYXRlIHJlbmRlclRhcmdldCB0ZXh0dXJlLCBidXQgZG9lcyBub3QgdXBkYXRlIHRoZSBzY3JlZW4gY2FudmFzLlxuXG5cdFx0XHRjb25zdCBxdWFkID0gdGhpcy5fcXVhZDtcblxuXHRcdFx0aWYgKCB0aGlzLl9ub2Rlcy5oYXNPdXRwdXRDaGFuZ2UoIHJlbmRlclRhcmdldC50ZXh0dXJlICkgKSB7XG5cblx0XHRcdFx0cXVhZC5tYXRlcmlhbC5mcmFnbWVudE5vZGUgPSB0aGlzLl9ub2Rlcy5nZXRPdXRwdXROb2RlKCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXHRcdFx0XHRxdWFkLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZW5kZXJTY2VuZSggcXVhZCwgcXVhZC5jYW1lcmEsIGZhbHNlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsZWFyQ29sb3IoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGVhciggdHJ1ZSwgZmFsc2UsIGZhbHNlICk7XG5cblx0fVxuXG5cdGNsZWFyRGVwdGgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGVhciggZmFsc2UsIHRydWUsIGZhbHNlICk7XG5cblx0fVxuXG5cdGNsZWFyU3RlbmNpbCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmNsZWFyKCBmYWxzZSwgZmFsc2UsIHRydWUgKTtcblxuXHR9XG5cblx0YXN5bmMgY2xlYXJBc3luYyggY29sb3IgPSB0cnVlLCBkZXB0aCA9IHRydWUsIHN0ZW5jaWwgPSB0cnVlICkge1xuXG5cdFx0aWYgKCB0aGlzLl9pbml0aWFsaXplZCA9PT0gZmFsc2UgKSBhd2FpdCB0aGlzLmluaXQoKTtcblxuXHRcdHRoaXMuY2xlYXIoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApO1xuXG5cdH1cblxuXHRjbGVhckNvbG9yQXN5bmMoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGVhckFzeW5jKCB0cnVlLCBmYWxzZSwgZmFsc2UgKTtcblxuXHR9XG5cblx0Y2xlYXJEZXB0aEFzeW5jKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY2xlYXJBc3luYyggZmFsc2UsIHRydWUsIGZhbHNlICk7XG5cblx0fVxuXG5cdGNsZWFyU3RlbmNpbEFzeW5jKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY2xlYXJBc3luYyggZmFsc2UsIGZhbHNlLCB0cnVlICk7XG5cblx0fVxuXG5cdGdldCBjdXJyZW50VG9uZU1hcHBpbmcoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fcmVuZGVyVGFyZ2V0ICE9PSBudWxsID8gTm9Ub25lTWFwcGluZyA6IHRoaXMudG9uZU1hcHBpbmc7XG5cblx0fVxuXG5cdGdldCBjdXJyZW50Q29sb3JTcGFjZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9yZW5kZXJUYXJnZXQgIT09IG51bGwgPyBMaW5lYXJTUkdCQ29sb3JTcGFjZSA6IHRoaXMub3V0cHV0Q29sb3JTcGFjZTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuaW5mby5kaXNwb3NlKCk7XG5cdFx0dGhpcy5iYWNrZW5kLmRpc3Bvc2UoKTtcblxuXHRcdHRoaXMuX2FuaW1hdGlvbi5kaXNwb3NlKCk7XG5cdFx0dGhpcy5fb2JqZWN0cy5kaXNwb3NlKCk7XG5cdFx0dGhpcy5fcGlwZWxpbmVzLmRpc3Bvc2UoKTtcblx0XHR0aGlzLl9ub2Rlcy5kaXNwb3NlKCk7XG5cdFx0dGhpcy5fYmluZGluZ3MuZGlzcG9zZSgpO1xuXHRcdHRoaXMuX3JlbmRlckxpc3RzLmRpc3Bvc2UoKTtcblx0XHR0aGlzLl9yZW5kZXJDb250ZXh0cy5kaXNwb3NlKCk7XG5cdFx0dGhpcy5fdGV4dHVyZXMuZGlzcG9zZSgpO1xuXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcblx0XHR0aGlzLnNldEFuaW1hdGlvbkxvb3AoIG51bGwgKTtcblxuXHR9XG5cblx0c2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQsIGFjdGl2ZUN1YmVGYWNlID0gMCwgYWN0aXZlTWlwbWFwTGV2ZWwgPSAwICkge1xuXG5cdFx0dGhpcy5fcmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuXHRcdHRoaXMuX2FjdGl2ZUN1YmVGYWNlID0gYWN0aXZlQ3ViZUZhY2U7XG5cdFx0dGhpcy5fYWN0aXZlTWlwbWFwTGV2ZWwgPSBhY3RpdmVNaXBtYXBMZXZlbDtcblxuXHR9XG5cblx0Z2V0UmVuZGVyVGFyZ2V0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3JlbmRlclRhcmdldDtcblxuXHR9XG5cblx0c2V0UmVuZGVyT2JqZWN0RnVuY3Rpb24oIHJlbmRlck9iamVjdEZ1bmN0aW9uICkge1xuXG5cdFx0dGhpcy5fcmVuZGVyT2JqZWN0RnVuY3Rpb24gPSByZW5kZXJPYmplY3RGdW5jdGlvbjtcblxuXHR9XG5cblx0Z2V0UmVuZGVyT2JqZWN0RnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fcmVuZGVyT2JqZWN0RnVuY3Rpb247XG5cblx0fVxuXG5cdGNvbXB1dGUoIGNvbXB1dGVOb2RlcyApIHtcblxuXHRcdGlmICggdGhpcy5pc0RldmljZUxvc3QgPT09IHRydWUgKSByZXR1cm47XG5cblx0XHRpZiAoIHRoaXMuX2luaXRpYWxpemVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmVuZGVyZXI6IC5jb21wdXRlKCkgY2FsbGVkIGJlZm9yZSB0aGUgYmFja2VuZCBpcyBpbml0aWFsaXplZC4gVHJ5IHVzaW5nIC5jb21wdXRlQXN5bmMoKSBpbnN0ZWFkLicgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuY29tcHV0ZUFzeW5jKCBjb21wdXRlTm9kZXMgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRjb25zdCBub2RlRnJhbWUgPSB0aGlzLl9ub2Rlcy5ub2RlRnJhbWU7XG5cblx0XHRjb25zdCBwcmV2aW91c1JlbmRlcklkID0gbm9kZUZyYW1lLnJlbmRlcklkO1xuXG5cdFx0Ly9cblxuXHRcdHRoaXMuaW5mby5jYWxscyArKztcblx0XHR0aGlzLmluZm8uY29tcHV0ZS5jYWxscyArKztcblx0XHR0aGlzLmluZm8uY29tcHV0ZS5mcmFtZUNhbGxzICsrO1xuXG5cdFx0bm9kZUZyYW1lLnJlbmRlcklkID0gdGhpcy5pbmZvLmNhbGxzO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGJhY2tlbmQgPSB0aGlzLmJhY2tlbmQ7XG5cdFx0Y29uc3QgcGlwZWxpbmVzID0gdGhpcy5fcGlwZWxpbmVzO1xuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cdFx0Y29uc3Qgbm9kZXMgPSB0aGlzLl9ub2RlcztcblxuXHRcdGNvbnN0IGNvbXB1dGVMaXN0ID0gQXJyYXkuaXNBcnJheSggY29tcHV0ZU5vZGVzICkgPyBjb21wdXRlTm9kZXMgOiBbIGNvbXB1dGVOb2RlcyBdO1xuXG5cdFx0aWYgKCBjb21wdXRlTGlzdFsgMCBdID09PSB1bmRlZmluZWQgfHwgY29tcHV0ZUxpc3RbIDAgXS5pc0NvbXB1dGVOb2RlICE9PSB0cnVlICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5SZW5kZXJlcjogLmNvbXB1dGUoKSBleHBlY3RzIGEgQ29tcHV0ZU5vZGUuJyApO1xuXG5cdFx0fVxuXG5cdFx0YmFja2VuZC5iZWdpbkNvbXB1dGUoIGNvbXB1dGVOb2RlcyApO1xuXG5cdFx0Zm9yICggY29uc3QgY29tcHV0ZU5vZGUgb2YgY29tcHV0ZUxpc3QgKSB7XG5cblx0XHRcdC8vIG9uSW5pdFxuXG5cdFx0XHRpZiAoIHBpcGVsaW5lcy5oYXMoIGNvbXB1dGVOb2RlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG5cblx0XHRcdFx0XHRjb21wdXRlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIGRpc3Bvc2UgKTtcblxuXHRcdFx0XHRcdHBpcGVsaW5lcy5kZWxldGUoIGNvbXB1dGVOb2RlICk7XG5cdFx0XHRcdFx0YmluZGluZ3MuZGVsZXRlKCBjb21wdXRlTm9kZSApO1xuXHRcdFx0XHRcdG5vZGVzLmRlbGV0ZSggY29tcHV0ZU5vZGUgKTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGNvbXB1dGVOb2RlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgZGlzcG9zZSApO1xuXG5cdFx0XHRcdC8vXG5cblx0XHRcdFx0Y29uc3Qgb25Jbml0Rm4gPSBjb21wdXRlTm9kZS5vbkluaXRGdW5jdGlvbjtcblxuXHRcdFx0XHRpZiAoIG9uSW5pdEZuICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0b25Jbml0Rm4uY2FsbCggY29tcHV0ZU5vZGUsIHsgcmVuZGVyZXI6IHRoaXMgfSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRub2Rlcy51cGRhdGVGb3JDb21wdXRlKCBjb21wdXRlTm9kZSApO1xuXHRcdFx0YmluZGluZ3MudXBkYXRlRm9yQ29tcHV0ZSggY29tcHV0ZU5vZGUgKTtcblxuXHRcdFx0Y29uc3QgY29tcHV0ZUJpbmRpbmdzID0gYmluZGluZ3MuZ2V0Rm9yQ29tcHV0ZSggY29tcHV0ZU5vZGUgKTtcblx0XHRcdGNvbnN0IGNvbXB1dGVQaXBlbGluZSA9IHBpcGVsaW5lcy5nZXRGb3JDb21wdXRlKCBjb21wdXRlTm9kZSwgY29tcHV0ZUJpbmRpbmdzICk7XG5cblx0XHRcdGJhY2tlbmQuY29tcHV0ZSggY29tcHV0ZU5vZGVzLCBjb21wdXRlTm9kZSwgY29tcHV0ZUJpbmRpbmdzLCBjb21wdXRlUGlwZWxpbmUgKTtcblxuXHRcdH1cblxuXHRcdGJhY2tlbmQuZmluaXNoQ29tcHV0ZSggY29tcHV0ZU5vZGVzICk7XG5cblx0XHQvL1xuXG5cdFx0bm9kZUZyYW1lLnJlbmRlcklkID0gcHJldmlvdXNSZW5kZXJJZDtcblxuXHR9XG5cblx0YXN5bmMgY29tcHV0ZUFzeW5jKCBjb21wdXRlTm9kZXMgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2luaXRpYWxpemVkID09PSBmYWxzZSApIGF3YWl0IHRoaXMuaW5pdCgpO1xuXG5cdFx0dGhpcy5jb21wdXRlKCBjb21wdXRlTm9kZXMgKTtcblxuXHRcdGF3YWl0IHRoaXMuYmFja2VuZC5yZXNvbHZlVGltZXN0YW1wQXN5bmMoIGNvbXB1dGVOb2RlcywgJ2NvbXB1dGUnICk7XG5cblx0fVxuXG5cdGFzeW5jIGhhc0ZlYXR1cmVBc3luYyggbmFtZSApIHtcblxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgPT09IGZhbHNlICkgYXdhaXQgdGhpcy5pbml0KCk7XG5cblx0XHRyZXR1cm4gdGhpcy5iYWNrZW5kLmhhc0ZlYXR1cmUoIG5hbWUgKTtcblxuXHR9XG5cblx0aGFzRmVhdHVyZSggbmFtZSApIHtcblxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SZW5kZXJlcjogLmhhc0ZlYXR1cmUoKSBjYWxsZWQgYmVmb3JlIHRoZSBiYWNrZW5kIGlzIGluaXRpYWxpemVkLiBUcnkgdXNpbmcgLmhhc0ZlYXR1cmVBc3luYygpIGluc3RlYWQuJyApO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5iYWNrZW5kLmhhc0ZlYXR1cmUoIG5hbWUgKTtcblxuXHR9XG5cblx0aGFzSW5pdGlhbGl6ZWQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5faW5pdGlhbGl6ZWQ7XG5cblx0fVxuXG5cdGFzeW5jIGluaXRUZXh0dXJlQXN5bmMoIHRleHR1cmUgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2luaXRpYWxpemVkID09PSBmYWxzZSApIGF3YWl0IHRoaXMuaW5pdCgpO1xuXG5cdFx0dGhpcy5fdGV4dHVyZXMudXBkYXRlVGV4dHVyZSggdGV4dHVyZSApO1xuXG5cdH1cblxuXHRpbml0VGV4dHVyZSggdGV4dHVyZSApIHtcblxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SZW5kZXJlcjogLmluaXRUZXh0dXJlKCkgY2FsbGVkIGJlZm9yZSB0aGUgYmFja2VuZCBpcyBpbml0aWFsaXplZC4gVHJ5IHVzaW5nIC5pbml0VGV4dHVyZUFzeW5jKCkgaW5zdGVhZC4nICk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX3RleHR1cmVzLnVwZGF0ZVRleHR1cmUoIHRleHR1cmUgKTtcblxuXHR9XG5cblx0Y29weUZyYW1lYnVmZmVyVG9UZXh0dXJlKCBmcmFtZWJ1ZmZlclRleHR1cmUsIHJlY3RhbmdsZSA9IG51bGwgKSB7XG5cblx0XHRpZiAoIHJlY3RhbmdsZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCByZWN0YW5nbGUuaXNWZWN0b3IyICkge1xuXG5cdFx0XHRcdHJlY3RhbmdsZSA9IF92ZWN0b3I0LnNldCggcmVjdGFuZ2xlLngsIHJlY3RhbmdsZS55LCBmcmFtZWJ1ZmZlclRleHR1cmUuaW1hZ2Uud2lkdGgsIGZyYW1lYnVmZmVyVGV4dHVyZS5pbWFnZS5oZWlnaHQgKS5mbG9vcigpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCByZWN0YW5nbGUuaXNWZWN0b3I0ICkge1xuXG5cdFx0XHRcdHJlY3RhbmdsZSA9IF92ZWN0b3I0LmNvcHkoIHJlY3RhbmdsZSApLmZsb29yKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlJlbmRlcmVyLmNvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZTogSW52YWxpZCByZWN0YW5nbGUuJyApO1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVjdGFuZ2xlID0gX3ZlY3RvcjQuc2V0KCAwLCAwLCBmcmFtZWJ1ZmZlclRleHR1cmUuaW1hZ2Uud2lkdGgsIGZyYW1lYnVmZmVyVGV4dHVyZS5pbWFnZS5oZWlnaHQgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRsZXQgcmVuZGVyQ29udGV4dCA9IHRoaXMuX2N1cnJlbnRSZW5kZXJDb250ZXh0O1xuXHRcdGxldCByZW5kZXJUYXJnZXQ7XG5cblx0XHRpZiAoIHJlbmRlckNvbnRleHQgIT09IG51bGwgKSB7XG5cblx0XHRcdHJlbmRlclRhcmdldCA9IHJlbmRlckNvbnRleHQucmVuZGVyVGFyZ2V0O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0ID0gdGhpcy5fcmVuZGVyVGFyZ2V0IHx8IHRoaXMuX2dldEZyYW1lQnVmZmVyVGFyZ2V0KCk7XG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuX3RleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0cmVuZGVyQ29udGV4dCA9IHRoaXMuX3RleHR1cmVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR0aGlzLl90ZXh0dXJlcy51cGRhdGVUZXh0dXJlKCBmcmFtZWJ1ZmZlclRleHR1cmUsIHsgcmVuZGVyVGFyZ2V0IH0gKTtcblxuXHRcdHRoaXMuYmFja2VuZC5jb3B5RnJhbWVidWZmZXJUb1RleHR1cmUoIGZyYW1lYnVmZmVyVGV4dHVyZSwgcmVuZGVyQ29udGV4dCwgcmVjdGFuZ2xlICk7XG5cblx0fVxuXG5cdGNvcHlUZXh0dXJlVG9UZXh0dXJlKCBzcmNUZXh0dXJlLCBkc3RUZXh0dXJlLCBzcmNSZWdpb24gPSBudWxsLCBkc3RQb3NpdGlvbiA9IG51bGwsIGxldmVsID0gMCApIHtcblxuXHRcdHRoaXMuX3RleHR1cmVzLnVwZGF0ZVRleHR1cmUoIHNyY1RleHR1cmUgKTtcblx0XHR0aGlzLl90ZXh0dXJlcy51cGRhdGVUZXh0dXJlKCBkc3RUZXh0dXJlICk7XG5cblx0XHR0aGlzLmJhY2tlbmQuY29weVRleHR1cmVUb1RleHR1cmUoIHNyY1RleHR1cmUsIGRzdFRleHR1cmUsIHNyY1JlZ2lvbiwgZHN0UG9zaXRpb24sIGxldmVsICk7XG5cblx0fVxuXG5cdHJlYWRSZW5kZXJUYXJnZXRQaXhlbHNBc3luYyggcmVuZGVyVGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBpbmRleCA9IDAsIGZhY2VJbmRleCA9IDAgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5iYWNrZW5kLmNvcHlUZXh0dXJlVG9CdWZmZXIoIHJlbmRlclRhcmdldC50ZXh0dXJlc1sgaW5kZXggXSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZmFjZUluZGV4ICk7XG5cblx0fVxuXG5cdF9wcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSwgZ3JvdXBPcmRlciwgcmVuZGVyTGlzdCwgY2xpcHBpbmdDb250ZXh0ICkge1xuXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRjb25zdCB2aXNpYmxlID0gb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICk7XG5cblx0XHRpZiAoIHZpc2libGUgKSB7XG5cblx0XHRcdGlmICggb2JqZWN0LmlzR3JvdXAgKSB7XG5cblx0XHRcdFx0Z3JvdXBPcmRlciA9IG9iamVjdC5yZW5kZXJPcmRlcjtcblxuXHRcdFx0XHRpZiAoIG9iamVjdC5pc0NsaXBwaW5nR3JvdXAgJiYgb2JqZWN0LmVuYWJsZWQgKSBjbGlwcGluZ0NvbnRleHQgPSBjbGlwcGluZ0NvbnRleHQuZ2V0R3JvdXBDb250ZXh0KCBvYmplY3QgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTE9EICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0LmF1dG9VcGRhdGUgPT09IHRydWUgKSBvYmplY3QudXBkYXRlKCBjYW1lcmEgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGlnaHQgKSB7XG5cblx0XHRcdFx0cmVuZGVyTGlzdC5wdXNoTGlnaHQoIG9iamVjdCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNTcHJpdGUgKSB7XG5cblx0XHRcdFx0aWYgKCAhIG9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNTcHJpdGUoIG9iamVjdCApICkge1xuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yNC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApLmFwcGx5TWF0cml4NCggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHsgZ2VvbWV0cnksIG1hdGVyaWFsIH0gPSBvYmplY3Q7XG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLnZpc2libGUgKSB7XG5cblx0XHRcdFx0XHRcdHJlbmRlckxpc3QucHVzaCggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwT3JkZXIsIF92ZWN0b3I0LnosIG51bGwsIGNsaXBwaW5nQ29udGV4dCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGluZUxvb3AgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlJlbmRlcmVyOiBPYmplY3RzIG9mIHR5cGUgVEhSRUUuTGluZUxvb3AgYXJlIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgVEhSRUUuTGluZSBvciBUSFJFRS5MaW5lU2VnbWVudHMuJyApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzICkge1xuXG5cdFx0XHRcdGlmICggISBvYmplY3QuZnJ1c3R1bUN1bGxlZCB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHsgZ2VvbWV0cnksIG1hdGVyaWFsIH0gPSBvYmplY3Q7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0XHRcdFx0X3ZlY3RvcjRcblx0XHRcdFx0XHRcdFx0LmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNlbnRlciApXG5cdFx0XHRcdFx0XHRcdC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApXG5cdFx0XHRcdFx0XHRcdC5hcHBseU1hdHJpeDQoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsWyBncm91cC5tYXRlcmlhbEluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBncm91cE1hdGVyaWFsICYmIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHJlbmRlckxpc3QucHVzaCggb2JqZWN0LCBnZW9tZXRyeSwgZ3JvdXBNYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjQueiwgZ3JvdXAsIGNsaXBwaW5nQ29udGV4dCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwudmlzaWJsZSApIHtcblxuXHRcdFx0XHRcdFx0cmVuZGVyTGlzdC5wdXNoKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjQueiwgbnVsbCwgY2xpcHBpbmdDb250ZXh0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdC5pc0J1bmRsZUdyb3VwID09PSB0cnVlICYmIHRoaXMuYmFja2VuZC5iZWdpbkJ1bmRsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBiYXNlUmVuZGVyTGlzdCA9IHJlbmRlckxpc3Q7XG5cblx0XHRcdC8vIHJlcGxhY2UgcmVuZGVyIGxpc3Rcblx0XHRcdHJlbmRlckxpc3QgPSB0aGlzLl9yZW5kZXJMaXN0cy5nZXQoIG9iamVjdCwgY2FtZXJhICk7XG5cblx0XHRcdHJlbmRlckxpc3QuYmVnaW4oKTtcblxuXHRcdFx0YmFzZVJlbmRlckxpc3QucHVzaEJ1bmRsZSgge1xuXHRcdFx0XHRidW5kbGVHcm91cDogb2JqZWN0LFxuXHRcdFx0XHRjYW1lcmEsXG5cdFx0XHRcdHJlbmRlckxpc3QsXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJlbmRlckxpc3QuZmluaXNoKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuX3Byb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSwgZ3JvdXBPcmRlciwgcmVuZGVyTGlzdCwgY2xpcHBpbmdDb250ZXh0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9yZW5kZXJCdW5kbGVzKCBidW5kbGVzLCBzY2VuZVJlZiwgbGlnaHRzTm9kZSApIHtcblxuXHRcdGZvciAoIGNvbnN0IGJ1bmRsZSBvZiBidW5kbGVzICkge1xuXG5cdFx0XHR0aGlzLl9yZW5kZXJCdW5kbGUoIGJ1bmRsZSwgc2NlbmVSZWYsIGxpZ2h0c05vZGUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0X3JlbmRlclRyYW5zcGFyZW50cyggcmVuZGVyTGlzdCwgZG91YmxlUGFzc0xpc3QsIGNhbWVyYSwgc2NlbmUsIGxpZ2h0c05vZGUgKSB7XG5cblx0XHRpZiAoIGRvdWJsZVBhc3NMaXN0Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdC8vIHJlbmRlciBiYWNrIHNpZGVcblxuXHRcdFx0Zm9yICggY29uc3QgeyBtYXRlcmlhbCB9IG9mIGRvdWJsZVBhc3NMaXN0ICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBCYWNrU2lkZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZW5kZXJPYmplY3RzKCBkb3VibGVQYXNzTGlzdCwgY2FtZXJhLCBzY2VuZSwgbGlnaHRzTm9kZSwgJ2JhY2tTaWRlJyApO1xuXG5cdFx0XHQvLyByZW5kZXIgZnJvbnQgc2lkZVxuXG5cdFx0XHRmb3IgKCBjb25zdCB7IG1hdGVyaWFsIH0gb2YgZG91YmxlUGFzc0xpc3QgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwuc2lkZSA9IEZyb250U2lkZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZW5kZXJPYmplY3RzKCByZW5kZXJMaXN0LCBjYW1lcmEsIHNjZW5lLCBsaWdodHNOb2RlICk7XG5cblx0XHRcdC8vIHJlc3RvcmVcblxuXHRcdFx0Zm9yICggY29uc3QgeyBtYXRlcmlhbCB9IG9mIGRvdWJsZVBhc3NMaXN0ICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBEb3VibGVTaWRlO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLl9yZW5kZXJPYmplY3RzKCByZW5kZXJMaXN0LCBjYW1lcmEsIHNjZW5lLCBsaWdodHNOb2RlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9yZW5kZXJPYmplY3RzKCByZW5kZXJMaXN0LCBjYW1lcmEsIHNjZW5lLCBsaWdodHNOb2RlLCBwYXNzSWQgPSBudWxsICkge1xuXG5cdFx0Ly8gcHJvY2VzcyByZW5kZXJhYmxlIG9iamVjdHNcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFsgaSBdO1xuXG5cdFx0XHQvLyBAVE9ETzogQWRkIHN1cHBvcnQgZm9yIG11bHRpcGxlIG1hdGVyaWFscyBwZXIgb2JqZWN0LiBUaGlzIHdpbGwgcmVxdWlyZSB0byBleHRyYWN0XG5cdFx0XHQvLyB0aGUgbWF0ZXJpYWwgZnJvbSB0aGUgcmVuZGVySXRlbSBvYmplY3QgYW5kIHBhc3MgaXQgd2l0aCBpdHMgZ3JvdXAgZGF0YSB0byByZW5kZXJPYmplY3QoKS5cblxuXHRcdFx0Y29uc3QgeyBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAsIGNsaXBwaW5nQ29udGV4dCB9ID0gcmVuZGVySXRlbTtcblxuXHRcdFx0aWYgKCBjYW1lcmEuaXNBcnJheUNhbWVyYSApIHtcblxuXHRcdFx0XHRjb25zdCBjYW1lcmFzID0gY2FtZXJhLmNhbWVyYXM7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IGNhbWVyYXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBjYW1lcmEyID0gY2FtZXJhc1sgaiBdO1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYTIubGF5ZXJzICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHZwID0gY2FtZXJhMi52aWV3cG9ydDtcblx0XHRcdFx0XHRcdGNvbnN0IG1pbkRlcHRoID0gKCB2cC5taW5EZXB0aCA9PT0gdW5kZWZpbmVkICkgPyAwIDogdnAubWluRGVwdGg7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXhEZXB0aCA9ICggdnAubWF4RGVwdGggPT09IHVuZGVmaW5lZCApID8gMSA6IHZwLm1heERlcHRoO1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2aWV3cG9ydFZhbHVlID0gdGhpcy5fY3VycmVudFJlbmRlckNvbnRleHQudmlld3BvcnRWYWx1ZTtcblx0XHRcdFx0XHRcdHZpZXdwb3J0VmFsdWUuY29weSggdnAgKS5tdWx0aXBseVNjYWxhciggdGhpcy5fcGl4ZWxSYXRpbyApLmZsb29yKCk7XG5cdFx0XHRcdFx0XHR2aWV3cG9ydFZhbHVlLm1pbkRlcHRoID0gbWluRGVwdGg7XG5cdFx0XHRcdFx0XHR2aWV3cG9ydFZhbHVlLm1heERlcHRoID0gbWF4RGVwdGg7XG5cblx0XHRcdFx0XHRcdHRoaXMuYmFja2VuZC51cGRhdGVWaWV3cG9ydCggdGhpcy5fY3VycmVudFJlbmRlckNvbnRleHQgKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5fY3VycmVudFJlbmRlck9iamVjdEZ1bmN0aW9uKCBvYmplY3QsIHNjZW5lLCBjYW1lcmEyLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwLCBsaWdodHNOb2RlLCBjbGlwcGluZ0NvbnRleHQsIHBhc3NJZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl9jdXJyZW50UmVuZGVyT2JqZWN0RnVuY3Rpb24oIG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCwgbGlnaHRzTm9kZSwgY2xpcHBpbmdDb250ZXh0LCBwYXNzSWQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRyZW5kZXJPYmplY3QoIG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCwgbGlnaHRzTm9kZSwgY2xpcHBpbmdDb250ZXh0ID0gbnVsbCwgcGFzc0lkID0gbnVsbCApIHtcblxuXHRcdGxldCBvdmVycmlkZVBvc2l0aW9uTm9kZTtcblx0XHRsZXQgb3ZlcnJpZGVDb2xvck5vZGU7XG5cdFx0bGV0IG92ZXJyaWRlRGVwdGhOb2RlO1xuXG5cdFx0Ly9cblxuXHRcdG9iamVjdC5vbkJlZm9yZVJlbmRlciggdGhpcywgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApO1xuXG5cdFx0Ly9cblxuXHRcdGlmICggc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3Qgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwucG9zaXRpb25Ob2RlICYmIG1hdGVyaWFsLnBvc2l0aW9uTm9kZS5pc05vZGUgKSB7XG5cblx0XHRcdFx0b3ZlcnJpZGVQb3NpdGlvbk5vZGUgPSBvdmVycmlkZU1hdGVyaWFsLnBvc2l0aW9uTm9kZTtcblx0XHRcdFx0b3ZlcnJpZGVNYXRlcmlhbC5wb3NpdGlvbk5vZGUgPSBtYXRlcmlhbC5wb3NpdGlvbk5vZGU7XG5cblx0XHRcdH1cblxuXHRcdFx0b3ZlcnJpZGVNYXRlcmlhbC5hbHBoYVRlc3QgPSBtYXRlcmlhbC5hbHBoYVRlc3Q7XG5cdFx0XHRvdmVycmlkZU1hdGVyaWFsLmFscGhhTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cblx0XHRcdGlmICggb3ZlcnJpZGVNYXRlcmlhbC5pc1NoYWRvd05vZGVNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRvdmVycmlkZU1hdGVyaWFsLnNpZGUgPSBtYXRlcmlhbC5zaGFkb3dTaWRlID09PSBudWxsID8gbWF0ZXJpYWwuc2lkZSA6IG1hdGVyaWFsLnNoYWRvd1NpZGU7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5kZXB0aE5vZGUgJiYgbWF0ZXJpYWwuZGVwdGhOb2RlLmlzTm9kZSApIHtcblxuXHRcdFx0XHRcdG92ZXJyaWRlRGVwdGhOb2RlID0gb3ZlcnJpZGVNYXRlcmlhbC5kZXB0aE5vZGU7XG5cdFx0XHRcdFx0b3ZlcnJpZGVNYXRlcmlhbC5kZXB0aE5vZGUgPSBtYXRlcmlhbC5kZXB0aE5vZGU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwuY2FzdFNoYWRvd05vZGUgJiYgbWF0ZXJpYWwuY2FzdFNoYWRvd05vZGUuaXNOb2RlICkge1xuXG5cdFx0XHRcdFx0b3ZlcnJpZGVDb2xvck5vZGUgPSBvdmVycmlkZU1hdGVyaWFsLmNvbG9yTm9kZTtcblx0XHRcdFx0XHRvdmVycmlkZU1hdGVyaWFsLmNvbG9yTm9kZSA9IG1hdGVyaWFsLmNhc3RTaGFkb3dOb2RlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSAmJiBtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlICYmIG1hdGVyaWFsLmZvcmNlU2luZ2xlUGFzcyA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdG1hdGVyaWFsLnNpZGUgPSBCYWNrU2lkZTtcblx0XHRcdHRoaXMuX2hhbmRsZU9iamVjdEZ1bmN0aW9uKCBvYmplY3QsIG1hdGVyaWFsLCBzY2VuZSwgY2FtZXJhLCBsaWdodHNOb2RlLCBncm91cCwgY2xpcHBpbmdDb250ZXh0LCAnYmFja1NpZGUnICk7IC8vIGNyZWF0ZSBiYWNrU2lkZSBwYXNzIGlkXG5cblx0XHRcdG1hdGVyaWFsLnNpZGUgPSBGcm9udFNpZGU7XG5cdFx0XHR0aGlzLl9oYW5kbGVPYmplY3RGdW5jdGlvbiggb2JqZWN0LCBtYXRlcmlhbCwgc2NlbmUsIGNhbWVyYSwgbGlnaHRzTm9kZSwgZ3JvdXAsIGNsaXBwaW5nQ29udGV4dCwgcGFzc0lkICk7IC8vIHVzZSBkZWZhdWx0IHBhc3MgaWRcblxuXHRcdFx0bWF0ZXJpYWwuc2lkZSA9IERvdWJsZVNpZGU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLl9oYW5kbGVPYmplY3RGdW5jdGlvbiggb2JqZWN0LCBtYXRlcmlhbCwgc2NlbmUsIGNhbWVyYSwgbGlnaHRzTm9kZSwgZ3JvdXAsIGNsaXBwaW5nQ29udGV4dCwgcGFzc0lkICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKCBvdmVycmlkZVBvc2l0aW9uTm9kZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzY2VuZS5vdmVycmlkZU1hdGVyaWFsLnBvc2l0aW9uTm9kZSA9IG92ZXJyaWRlUG9zaXRpb25Ob2RlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvdmVycmlkZURlcHRoTm9kZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzY2VuZS5vdmVycmlkZU1hdGVyaWFsLmRlcHRoTm9kZSA9IG92ZXJyaWRlRGVwdGhOb2RlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvdmVycmlkZUNvbG9yTm9kZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzY2VuZS5vdmVycmlkZU1hdGVyaWFsLmNvbG9yTm9kZSA9IG92ZXJyaWRlQ29sb3JOb2RlO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdG9iamVjdC5vbkFmdGVyUmVuZGVyKCB0aGlzLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICk7XG5cblx0fVxuXG5cdF9yZW5kZXJPYmplY3REaXJlY3QoIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIGdyb3VwLCBjbGlwcGluZ0NvbnRleHQsIHBhc3NJZCApIHtcblxuXHRcdGNvbnN0IHJlbmRlck9iamVjdCA9IHRoaXMuX29iamVjdHMuZ2V0KCBvYmplY3QsIG1hdGVyaWFsLCBzY2VuZSwgY2FtZXJhLCBsaWdodHNOb2RlLCB0aGlzLl9jdXJyZW50UmVuZGVyQ29udGV4dCwgY2xpcHBpbmdDb250ZXh0LCBwYXNzSWQgKTtcblx0XHRyZW5kZXJPYmplY3QuZHJhd1JhbmdlID0gb2JqZWN0Lmdlb21ldHJ5LmRyYXdSYW5nZTtcblx0XHRyZW5kZXJPYmplY3QuZ3JvdXAgPSBncm91cDtcblxuXHRcdC8vXG5cblx0XHRjb25zdCBuZWVkc1JlZnJlc2ggPSB0aGlzLl9ub2Rlcy5uZWVkc1JlZnJlc2goIHJlbmRlck9iamVjdCApO1xuXG5cdFx0aWYgKCBuZWVkc1JlZnJlc2ggKSB7XG5cblx0XHRcdHRoaXMuX25vZGVzLnVwZGF0ZUJlZm9yZSggcmVuZGVyT2JqZWN0ICk7XG5cblx0XHRcdHRoaXMuX2dlb21ldHJpZXMudXBkYXRlRm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKTtcblxuXHRcdFx0dGhpcy5fbm9kZXMudXBkYXRlRm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKTtcblx0XHRcdHRoaXMuX2JpbmRpbmdzLnVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9waXBlbGluZXMudXBkYXRlRm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKTtcblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuX2N1cnJlbnRSZW5kZXJCdW5kbGUgIT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IHJlbmRlckJ1bmRsZURhdGEgPSB0aGlzLmJhY2tlbmQuZ2V0KCB0aGlzLl9jdXJyZW50UmVuZGVyQnVuZGxlICk7XG5cblx0XHRcdHJlbmRlckJ1bmRsZURhdGEucmVuZGVyT2JqZWN0cy5wdXNoKCByZW5kZXJPYmplY3QgKTtcblxuXHRcdFx0cmVuZGVyT2JqZWN0LmJ1bmRsZSA9IHRoaXMuX2N1cnJlbnRSZW5kZXJCdW5kbGUuc2NlbmU7XG5cblx0XHR9XG5cblx0XHR0aGlzLmJhY2tlbmQuZHJhdyggcmVuZGVyT2JqZWN0LCB0aGlzLmluZm8gKTtcblxuXHRcdGlmICggbmVlZHNSZWZyZXNoICkgdGhpcy5fbm9kZXMudXBkYXRlQWZ0ZXIoIHJlbmRlck9iamVjdCApO1xuXG5cdH1cblxuXHRfY3JlYXRlT2JqZWN0UGlwZWxpbmUoIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIGNsaXBwaW5nQ29udGV4dCwgcGFzc0lkICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyT2JqZWN0ID0gdGhpcy5fb2JqZWN0cy5nZXQoIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIHRoaXMuX2N1cnJlbnRSZW5kZXJDb250ZXh0LCBjbGlwcGluZ0NvbnRleHQsIHBhc3NJZCApO1xuXG5cdFx0Ly9cblxuXHRcdHRoaXMuX25vZGVzLnVwZGF0ZUJlZm9yZSggcmVuZGVyT2JqZWN0ICk7XG5cblx0XHR0aGlzLl9nZW9tZXRyaWVzLnVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICk7XG5cblx0XHR0aGlzLl9ub2Rlcy51cGRhdGVGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApO1xuXHRcdHRoaXMuX2JpbmRpbmdzLnVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICk7XG5cblx0XHR0aGlzLl9waXBlbGluZXMuZ2V0Rm9yUmVuZGVyKCByZW5kZXJPYmplY3QsIHRoaXMuX2NvbXBpbGF0aW9uUHJvbWlzZXMgKTtcblxuXHRcdHRoaXMuX25vZGVzLnVwZGF0ZUFmdGVyKCByZW5kZXJPYmplY3QgKTtcblxuXHR9XG5cblx0Z2V0IGNvbXBpbGUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jb21waWxlQXN5bmM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlcmVyO1xuIiwiY2xhc3MgQmluZGluZyB7XG5cblx0Y29uc3RydWN0b3IoIG5hbWUgPSAnJyApIHtcblxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cblx0XHR0aGlzLnZpc2liaWxpdHkgPSAwO1xuXG5cdH1cblxuXHRzZXRWaXNpYmlsaXR5KCB2aXNpYmlsaXR5ICkge1xuXG5cdFx0dGhpcy52aXNpYmlsaXR5IHw9IHZpc2liaWxpdHk7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCksIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmluZGluZztcbiIsImltcG9ydCB7IEdQVV9DSFVOS19CWVRFUyB9IGZyb20gJy4vQ29uc3RhbnRzLmpzJztcblxuZnVuY3Rpb24gZ2V0RmxvYXRMZW5ndGgoIGZsb2F0TGVuZ3RoICkge1xuXG5cdC8vIGVuc3VyZSBjaHVuayBzaXplIGFsaWdubWVudCAoU1REMTQwIGxheW91dClcblxuXHRyZXR1cm4gZmxvYXRMZW5ndGggKyAoICggR1BVX0NIVU5LX0JZVEVTIC0gKCBmbG9hdExlbmd0aCAlIEdQVV9DSFVOS19CWVRFUyApICkgJSBHUFVfQ0hVTktfQllURVMgKTtcblxufVxuXG5mdW5jdGlvbiBnZXRWZWN0b3JMZW5ndGgoIGNvdW50LCB2ZWN0b3JMZW5ndGggPSA0ICkge1xuXG5cdGNvbnN0IHN0cmlkZUxlbmd0aCA9IGdldFN0cmlkZUxlbmd0aCggdmVjdG9yTGVuZ3RoICk7XG5cblx0Y29uc3QgZmxvYXRMZW5ndGggPSBzdHJpZGVMZW5ndGggKiBjb3VudDtcblxuXHRyZXR1cm4gZ2V0RmxvYXRMZW5ndGgoIGZsb2F0TGVuZ3RoICk7XG5cbn1cblxuZnVuY3Rpb24gZ2V0U3RyaWRlTGVuZ3RoKCB2ZWN0b3JMZW5ndGggKSB7XG5cblx0Y29uc3Qgc3RyaWRlTGVuZ3RoID0gNDtcblxuXHRyZXR1cm4gdmVjdG9yTGVuZ3RoICsgKCAoIHN0cmlkZUxlbmd0aCAtICggdmVjdG9yTGVuZ3RoICUgc3RyaWRlTGVuZ3RoICkgKSAlIHN0cmlkZUxlbmd0aCApO1xuXG59XG5cbmV4cG9ydCB7XG5cdGdldEZsb2F0TGVuZ3RoLFxuXHRnZXRWZWN0b3JMZW5ndGgsXG5cdGdldFN0cmlkZUxlbmd0aFxufTtcbiIsImltcG9ydCBCaW5kaW5nIGZyb20gJy4vQmluZGluZy5qcyc7XG5pbXBvcnQgeyBnZXRGbG9hdExlbmd0aCB9IGZyb20gJy4vQnVmZmVyVXRpbHMuanMnO1xuXG5jbGFzcyBCdWZmZXIgZXh0ZW5kcyBCaW5kaW5nIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgYnVmZmVyID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCBuYW1lICk7XG5cblx0XHR0aGlzLmlzQnVmZmVyID0gdHJ1ZTtcblxuXHRcdHRoaXMuYnl0ZXNQZXJFbGVtZW50ID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuXG5cdFx0dGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuXG5cdH1cblxuXHRnZXQgYnl0ZUxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBnZXRGbG9hdExlbmd0aCggdGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGggKTtcblxuXHR9XG5cblx0Z2V0IGJ1ZmZlcigpIHtcblxuXHRcdHJldHVybiB0aGlzLl9idWZmZXI7XG5cblx0fVxuXG5cdHVwZGF0ZSgpIHtcblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCdWZmZXI7XG4iLCJpbXBvcnQgQnVmZmVyIGZyb20gJy4vQnVmZmVyLmpzJztcblxuY2xhc3MgVW5pZm9ybUJ1ZmZlciBleHRlbmRzIEJ1ZmZlciB7XG5cblx0Y29uc3RydWN0b3IoIG5hbWUsIGJ1ZmZlciA9IG51bGwgKSB7XG5cblx0XHRzdXBlciggbmFtZSwgYnVmZmVyICk7XG5cblx0XHR0aGlzLmlzVW5pZm9ybUJ1ZmZlciA9IHRydWU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFVuaWZvcm1CdWZmZXI7XG4iLCJpbXBvcnQgVW5pZm9ybUJ1ZmZlciBmcm9tICcuLi9Vbmlmb3JtQnVmZmVyLmpzJztcblxubGV0IF9pZCA9IDA7XG5cbmNsYXNzIE5vZGVVbmlmb3JtQnVmZmVyIGV4dGVuZHMgVW5pZm9ybUJ1ZmZlciB7XG5cblx0Y29uc3RydWN0b3IoIG5vZGVVbmlmb3JtLCBncm91cE5vZGUgKSB7XG5cblx0XHRzdXBlciggJ1VuaWZvcm1CdWZmZXJfJyArIF9pZCArKywgbm9kZVVuaWZvcm0gPyBub2RlVW5pZm9ybS52YWx1ZSA6IG51bGwgKTtcblxuXHRcdHRoaXMubm9kZVVuaWZvcm0gPSBub2RlVW5pZm9ybTtcblx0XHR0aGlzLmdyb3VwTm9kZSA9IGdyb3VwTm9kZTtcblxuXHR9XG5cblx0Z2V0IGJ1ZmZlcigpIHtcblxuXHRcdHJldHVybiB0aGlzLm5vZGVVbmlmb3JtLnZhbHVlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlVW5pZm9ybUJ1ZmZlcjtcbiIsImltcG9ydCBVbmlmb3JtQnVmZmVyIGZyb20gJy4vVW5pZm9ybUJ1ZmZlci5qcyc7XG5pbXBvcnQgeyBHUFVfQ0hVTktfQllURVMgfSBmcm9tICcuL0NvbnN0YW50cy5qcyc7XG5cbmNsYXNzIFVuaWZvcm1zR3JvdXAgZXh0ZW5kcyBVbmlmb3JtQnVmZmVyIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSApIHtcblxuXHRcdHN1cGVyKCBuYW1lICk7XG5cblx0XHR0aGlzLmlzVW5pZm9ybXNHcm91cCA9IHRydWU7XG5cblx0XHR0aGlzLl92YWx1ZXMgPSBudWxsO1xuXG5cdFx0Ly8gdGhlIG9yZGVyIG9mIHVuaWZvcm1zIGluIHRoaXMgYXJyYXkgbXVzdCBtYXRjaCB0aGUgb3JkZXIgb2YgdW5pZm9ybXMgaW4gdGhlIHNoYWRlclxuXG5cdFx0dGhpcy51bmlmb3JtcyA9IFtdO1xuXG5cdH1cblxuXHRhZGRVbmlmb3JtKCB1bmlmb3JtICkge1xuXG5cdFx0dGhpcy51bmlmb3Jtcy5wdXNoKCB1bmlmb3JtICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVtb3ZlVW5pZm9ybSggdW5pZm9ybSApIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy51bmlmb3Jtcy5pbmRleE9mKCB1bmlmb3JtICk7XG5cblx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdHRoaXMudW5pZm9ybXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldCB2YWx1ZXMoKSB7XG5cblx0XHRpZiAoIHRoaXMuX3ZhbHVlcyA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fdmFsdWVzID0gQXJyYXkuZnJvbSggdGhpcy5idWZmZXIgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl92YWx1ZXM7XG5cblx0fVxuXG5cdGdldCBidWZmZXIoKSB7XG5cblx0XHRsZXQgYnVmZmVyID0gdGhpcy5fYnVmZmVyO1xuXG5cdFx0aWYgKCBidWZmZXIgPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGg7XG5cblx0XHRcdGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoIG5ldyBBcnJheUJ1ZmZlciggYnl0ZUxlbmd0aCApICk7XG5cblx0XHRcdHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiBidWZmZXI7XG5cblx0fVxuXG5cdGdldCBieXRlTGVuZ3RoKCkge1xuXG5cdFx0bGV0IG9mZnNldCA9IDA7IC8vIGdsb2JhbCBidWZmZXIgb2Zmc2V0IGluIGJ5dGVzXG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLnVuaWZvcm1zLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zWyBpIF07XG5cblx0XHRcdGNvbnN0IHsgYm91bmRhcnksIGl0ZW1TaXplIH0gPSB1bmlmb3JtO1xuXG5cdFx0XHQvLyBvZmZzZXQgd2l0aGluIGEgc2luZ2xlIGNodW5rIGluIGJ5dGVzXG5cblx0XHRcdGNvbnN0IGNodW5rT2Zmc2V0ID0gb2Zmc2V0ICUgR1BVX0NIVU5LX0JZVEVTO1xuXHRcdFx0Y29uc3QgcmVtYWluaW5nU2l6ZUluQ2h1bmsgPSBHUFVfQ0hVTktfQllURVMgLSBjaHVua09mZnNldDtcblxuXHRcdFx0Ly8gY29uZm9ybWFuY2UgdGVzdHNcblxuXHRcdFx0aWYgKCBjaHVua09mZnNldCAhPT0gMCAmJiAoIHJlbWFpbmluZ1NpemVJbkNodW5rIC0gYm91bmRhcnkgKSA8IDAgKSB7XG5cblx0XHRcdFx0Ly8gY2hlY2sgZm9yIGNodW5rIG92ZXJmbG93XG5cblx0XHRcdFx0b2Zmc2V0ICs9ICggR1BVX0NIVU5LX0JZVEVTIC0gY2h1bmtPZmZzZXQgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggY2h1bmtPZmZzZXQgJSBib3VuZGFyeSAhPT0gMCApIHtcblxuXHRcdFx0XHQvLyBjaGVjayBmb3IgY29ycmVjdCBhbGlnbm1lbnRcblxuXHRcdFx0XHRvZmZzZXQgKz0gKCBjaHVua09mZnNldCAlIGJvdW5kYXJ5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dW5pZm9ybS5vZmZzZXQgPSAoIG9mZnNldCAvIHRoaXMuYnl0ZXNQZXJFbGVtZW50ICk7XG5cblx0XHRcdG9mZnNldCArPSAoIGl0ZW1TaXplICogdGhpcy5ieXRlc1BlckVsZW1lbnQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLmNlaWwoIG9mZnNldCAvIEdQVV9DSFVOS19CWVRFUyApICogR1BVX0NIVU5LX0JZVEVTO1xuXG5cdH1cblxuXHR1cGRhdGUoKSB7XG5cblx0XHRsZXQgdXBkYXRlZCA9IGZhbHNlO1xuXG5cdFx0Zm9yICggY29uc3QgdW5pZm9ybSBvZiB0aGlzLnVuaWZvcm1zICkge1xuXG5cdFx0XHRpZiAoIHRoaXMudXBkYXRlQnlUeXBlKCB1bmlmb3JtICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1cGRhdGVkO1xuXG5cdH1cblxuXHR1cGRhdGVCeVR5cGUoIHVuaWZvcm0gKSB7XG5cblx0XHRpZiAoIHVuaWZvcm0uaXNOdW1iZXJVbmlmb3JtICkgcmV0dXJuIHRoaXMudXBkYXRlTnVtYmVyKCB1bmlmb3JtICk7XG5cdFx0aWYgKCB1bmlmb3JtLmlzVmVjdG9yMlVuaWZvcm0gKSByZXR1cm4gdGhpcy51cGRhdGVWZWN0b3IyKCB1bmlmb3JtICk7XG5cdFx0aWYgKCB1bmlmb3JtLmlzVmVjdG9yM1VuaWZvcm0gKSByZXR1cm4gdGhpcy51cGRhdGVWZWN0b3IzKCB1bmlmb3JtICk7XG5cdFx0aWYgKCB1bmlmb3JtLmlzVmVjdG9yNFVuaWZvcm0gKSByZXR1cm4gdGhpcy51cGRhdGVWZWN0b3I0KCB1bmlmb3JtICk7XG5cdFx0aWYgKCB1bmlmb3JtLmlzQ29sb3JVbmlmb3JtICkgcmV0dXJuIHRoaXMudXBkYXRlQ29sb3IoIHVuaWZvcm0gKTtcblx0XHRpZiAoIHVuaWZvcm0uaXNNYXRyaXgzVW5pZm9ybSApIHJldHVybiB0aGlzLnVwZGF0ZU1hdHJpeDMoIHVuaWZvcm0gKTtcblx0XHRpZiAoIHVuaWZvcm0uaXNNYXRyaXg0VW5pZm9ybSApIHJldHVybiB0aGlzLnVwZGF0ZU1hdHJpeDQoIHVuaWZvcm0gKTtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHUFVVbmlmb3Jtc0dyb3VwOiBVbnN1cHBvcnRlZCB1bmlmb3JtIHR5cGUuJywgdW5pZm9ybSApO1xuXG5cdH1cblxuXHR1cGRhdGVOdW1iZXIoIHVuaWZvcm0gKSB7XG5cblx0XHRsZXQgdXBkYXRlZCA9IGZhbHNlO1xuXG5cdFx0Y29uc3QgYSA9IHRoaXMudmFsdWVzO1xuXHRcdGNvbnN0IHYgPSB1bmlmb3JtLmdldFZhbHVlKCk7XG5cdFx0Y29uc3Qgb2Zmc2V0ID0gdW5pZm9ybS5vZmZzZXQ7XG5cdFx0Y29uc3QgdHlwZSA9IHVuaWZvcm0uZ2V0VHlwZSgpO1xuXG5cdFx0aWYgKCBhWyBvZmZzZXQgXSAhPT0gdiApIHtcblxuXHRcdFx0Y29uc3QgYiA9IHRoaXMuX2dldEJ1ZmZlckZvclR5cGUoIHR5cGUgKTtcblxuXHRcdFx0Ylsgb2Zmc2V0IF0gPSBhWyBvZmZzZXQgXSA9IHY7XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1cGRhdGVkO1xuXG5cdH1cblxuXHR1cGRhdGVWZWN0b3IyKCB1bmlmb3JtICkge1xuXG5cdFx0bGV0IHVwZGF0ZWQgPSBmYWxzZTtcblxuXHRcdGNvbnN0IGEgPSB0aGlzLnZhbHVlcztcblx0XHRjb25zdCB2ID0gdW5pZm9ybS5nZXRWYWx1ZSgpO1xuXHRcdGNvbnN0IG9mZnNldCA9IHVuaWZvcm0ub2Zmc2V0O1xuXHRcdGNvbnN0IHR5cGUgPSB1bmlmb3JtLmdldFR5cGUoKTtcblxuXHRcdGlmICggYVsgb2Zmc2V0ICsgMCBdICE9PSB2LnggfHwgYVsgb2Zmc2V0ICsgMSBdICE9PSB2LnkgKSB7XG5cblx0XHRcdGNvbnN0IGIgPSB0aGlzLl9nZXRCdWZmZXJGb3JUeXBlKCB0eXBlICk7XG5cblx0XHRcdGJbIG9mZnNldCArIDAgXSA9IGFbIG9mZnNldCArIDAgXSA9IHYueDtcblx0XHRcdGJbIG9mZnNldCArIDEgXSA9IGFbIG9mZnNldCArIDEgXSA9IHYueTtcblxuXHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlZDtcblxuXHR9XG5cblx0dXBkYXRlVmVjdG9yMyggdW5pZm9ybSApIHtcblxuXHRcdGxldCB1cGRhdGVkID0gZmFsc2U7XG5cblx0XHRjb25zdCBhID0gdGhpcy52YWx1ZXM7XG5cdFx0Y29uc3QgdiA9IHVuaWZvcm0uZ2V0VmFsdWUoKTtcblx0XHRjb25zdCBvZmZzZXQgPSB1bmlmb3JtLm9mZnNldDtcblx0XHRjb25zdCB0eXBlID0gdW5pZm9ybS5nZXRUeXBlKCk7XG5cblx0XHRpZiAoIGFbIG9mZnNldCArIDAgXSAhPT0gdi54IHx8IGFbIG9mZnNldCArIDEgXSAhPT0gdi55IHx8IGFbIG9mZnNldCArIDIgXSAhPT0gdi56ICkge1xuXG5cdFx0XHRjb25zdCBiID0gdGhpcy5fZ2V0QnVmZmVyRm9yVHlwZSggdHlwZSApO1xuXG5cdFx0XHRiWyBvZmZzZXQgKyAwIF0gPSBhWyBvZmZzZXQgKyAwIF0gPSB2Lng7XG5cdFx0XHRiWyBvZmZzZXQgKyAxIF0gPSBhWyBvZmZzZXQgKyAxIF0gPSB2Lnk7XG5cdFx0XHRiWyBvZmZzZXQgKyAyIF0gPSBhWyBvZmZzZXQgKyAyIF0gPSB2Lno7XG5cblx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVwZGF0ZWQ7XG5cblx0fVxuXG5cdHVwZGF0ZVZlY3RvcjQoIHVuaWZvcm0gKSB7XG5cblx0XHRsZXQgdXBkYXRlZCA9IGZhbHNlO1xuXG5cdFx0Y29uc3QgYSA9IHRoaXMudmFsdWVzO1xuXHRcdGNvbnN0IHYgPSB1bmlmb3JtLmdldFZhbHVlKCk7XG5cdFx0Y29uc3Qgb2Zmc2V0ID0gdW5pZm9ybS5vZmZzZXQ7XG5cdFx0Y29uc3QgdHlwZSA9IHVuaWZvcm0uZ2V0VHlwZSgpO1xuXG5cdFx0aWYgKCBhWyBvZmZzZXQgKyAwIF0gIT09IHYueCB8fCBhWyBvZmZzZXQgKyAxIF0gIT09IHYueSB8fCBhWyBvZmZzZXQgKyAyIF0gIT09IHYueiB8fCBhWyBvZmZzZXQgKyA0IF0gIT09IHYudyApIHtcblxuXHRcdFx0Y29uc3QgYiA9IHRoaXMuX2dldEJ1ZmZlckZvclR5cGUoIHR5cGUgKTtcblxuXHRcdFx0Ylsgb2Zmc2V0ICsgMCBdID0gYVsgb2Zmc2V0ICsgMCBdID0gdi54O1xuXHRcdFx0Ylsgb2Zmc2V0ICsgMSBdID0gYVsgb2Zmc2V0ICsgMSBdID0gdi55O1xuXHRcdFx0Ylsgb2Zmc2V0ICsgMiBdID0gYVsgb2Zmc2V0ICsgMiBdID0gdi56O1xuXHRcdFx0Ylsgb2Zmc2V0ICsgMyBdID0gYVsgb2Zmc2V0ICsgMyBdID0gdi53O1xuXG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1cGRhdGVkO1xuXG5cdH1cblxuXHR1cGRhdGVDb2xvciggdW5pZm9ybSApIHtcblxuXHRcdGxldCB1cGRhdGVkID0gZmFsc2U7XG5cblx0XHRjb25zdCBhID0gdGhpcy52YWx1ZXM7XG5cdFx0Y29uc3QgYyA9IHVuaWZvcm0uZ2V0VmFsdWUoKTtcblx0XHRjb25zdCBvZmZzZXQgPSB1bmlmb3JtLm9mZnNldDtcblxuXHRcdGlmICggYVsgb2Zmc2V0ICsgMCBdICE9PSBjLnIgfHwgYVsgb2Zmc2V0ICsgMSBdICE9PSBjLmcgfHwgYVsgb2Zmc2V0ICsgMiBdICE9PSBjLmIgKSB7XG5cblx0XHRcdGNvbnN0IGIgPSB0aGlzLmJ1ZmZlcjtcblxuXHRcdFx0Ylsgb2Zmc2V0ICsgMCBdID0gYVsgb2Zmc2V0ICsgMCBdID0gYy5yO1xuXHRcdFx0Ylsgb2Zmc2V0ICsgMSBdID0gYVsgb2Zmc2V0ICsgMSBdID0gYy5nO1xuXHRcdFx0Ylsgb2Zmc2V0ICsgMiBdID0gYVsgb2Zmc2V0ICsgMiBdID0gYy5iO1xuXG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1cGRhdGVkO1xuXG5cdH1cblxuXHR1cGRhdGVNYXRyaXgzKCB1bmlmb3JtICkge1xuXG5cdFx0bGV0IHVwZGF0ZWQgPSBmYWxzZTtcblxuXHRcdGNvbnN0IGEgPSB0aGlzLnZhbHVlcztcblx0XHRjb25zdCBlID0gdW5pZm9ybS5nZXRWYWx1ZSgpLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG9mZnNldCA9IHVuaWZvcm0ub2Zmc2V0O1xuXG5cdFx0aWYgKCBhWyBvZmZzZXQgKyAwIF0gIT09IGVbIDAgXSB8fCBhWyBvZmZzZXQgKyAxIF0gIT09IGVbIDEgXSB8fCBhWyBvZmZzZXQgKyAyIF0gIT09IGVbIDIgXSB8fFxuXHRcdFx0YVsgb2Zmc2V0ICsgNCBdICE9PSBlWyAzIF0gfHwgYVsgb2Zmc2V0ICsgNSBdICE9PSBlWyA0IF0gfHwgYVsgb2Zmc2V0ICsgNiBdICE9PSBlWyA1IF0gfHxcblx0XHRcdGFbIG9mZnNldCArIDggXSAhPT0gZVsgNiBdIHx8IGFbIG9mZnNldCArIDkgXSAhPT0gZVsgNyBdIHx8IGFbIG9mZnNldCArIDEwIF0gIT09IGVbIDggXSApIHtcblxuXHRcdFx0Y29uc3QgYiA9IHRoaXMuYnVmZmVyO1xuXG5cdFx0XHRiWyBvZmZzZXQgKyAwIF0gPSBhWyBvZmZzZXQgKyAwIF0gPSBlWyAwIF07XG5cdFx0XHRiWyBvZmZzZXQgKyAxIF0gPSBhWyBvZmZzZXQgKyAxIF0gPSBlWyAxIF07XG5cdFx0XHRiWyBvZmZzZXQgKyAyIF0gPSBhWyBvZmZzZXQgKyAyIF0gPSBlWyAyIF07XG5cdFx0XHRiWyBvZmZzZXQgKyA0IF0gPSBhWyBvZmZzZXQgKyA0IF0gPSBlWyAzIF07XG5cdFx0XHRiWyBvZmZzZXQgKyA1IF0gPSBhWyBvZmZzZXQgKyA1IF0gPSBlWyA0IF07XG5cdFx0XHRiWyBvZmZzZXQgKyA2IF0gPSBhWyBvZmZzZXQgKyA2IF0gPSBlWyA1IF07XG5cdFx0XHRiWyBvZmZzZXQgKyA4IF0gPSBhWyBvZmZzZXQgKyA4IF0gPSBlWyA2IF07XG5cdFx0XHRiWyBvZmZzZXQgKyA5IF0gPSBhWyBvZmZzZXQgKyA5IF0gPSBlWyA3IF07XG5cdFx0XHRiWyBvZmZzZXQgKyAxMCBdID0gYVsgb2Zmc2V0ICsgMTAgXSA9IGVbIDggXTtcblxuXHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlZDtcblxuXHR9XG5cblx0dXBkYXRlTWF0cml4NCggdW5pZm9ybSApIHtcblxuXHRcdGxldCB1cGRhdGVkID0gZmFsc2U7XG5cblx0XHRjb25zdCBhID0gdGhpcy52YWx1ZXM7XG5cdFx0Y29uc3QgZSA9IHVuaWZvcm0uZ2V0VmFsdWUoKS5lbGVtZW50cztcblx0XHRjb25zdCBvZmZzZXQgPSB1bmlmb3JtLm9mZnNldDtcblxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGEsIGUsIG9mZnNldCApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc3QgYiA9IHRoaXMuYnVmZmVyO1xuXHRcdFx0Yi5zZXQoIGUsIG9mZnNldCApO1xuXHRcdFx0c2V0QXJyYXkoIGEsIGUsIG9mZnNldCApO1xuXHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlZDtcblxuXHR9XG5cblx0X2dldEJ1ZmZlckZvclR5cGUoIHR5cGUgKSB7XG5cblx0XHRpZiAoIHR5cGUgPT09ICdpbnQnIHx8IHR5cGUgPT09ICdpdmVjMicgfHwgdHlwZSA9PT0gJ2l2ZWMzJyB8fCB0eXBlID09PSAnaXZlYzQnICkgcmV0dXJuIG5ldyBJbnQzMkFycmF5KCB0aGlzLmJ1ZmZlci5idWZmZXIgKTtcblx0XHRpZiAoIHR5cGUgPT09ICd1aW50JyB8fCB0eXBlID09PSAndXZlYzInIHx8IHR5cGUgPT09ICd1dmVjMycgfHwgdHlwZSA9PT0gJ3V2ZWM0JyApIHJldHVybiBuZXcgVWludDMyQXJyYXkoIHRoaXMuYnVmZmVyLmJ1ZmZlciApO1xuXHRcdHJldHVybiB0aGlzLmJ1ZmZlcjtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gc2V0QXJyYXkoIGEsIGIsIG9mZnNldCApIHtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBiLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRhWyBvZmZzZXQgKyBpIF0gPSBiWyBpIF07XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGFycmF5c0VxdWFsKCBhLCBiLCBvZmZzZXQgKSB7XG5cblx0Zm9yICggbGV0IGkgPSAwLCBsID0gYi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0aWYgKCBhWyBvZmZzZXQgKyBpIF0gIT09IGJbIGkgXSApIHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVW5pZm9ybXNHcm91cDtcbiIsImltcG9ydCBVbmlmb3Jtc0dyb3VwIGZyb20gJy4uL1VuaWZvcm1zR3JvdXAuanMnO1xuXG5sZXQgX2lkID0gMDtcblxuY2xhc3MgTm9kZVVuaWZvcm1zR3JvdXAgZXh0ZW5kcyBVbmlmb3Jtc0dyb3VwIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgZ3JvdXBOb2RlICkge1xuXG5cdFx0c3VwZXIoIG5hbWUgKTtcblxuXHRcdHRoaXMuaWQgPSBfaWQgKys7XG5cdFx0dGhpcy5ncm91cE5vZGUgPSBncm91cE5vZGU7XG5cblx0XHR0aGlzLmlzTm9kZVVuaWZvcm1zR3JvdXAgPSB0cnVlO1xuXG5cdH1cblxuXHRnZXROb2RlcygpIHtcblxuXHRcdGNvbnN0IG5vZGVzID0gW107XG5cblx0XHRmb3IgKCBjb25zdCB1bmlmb3JtIG9mIHRoaXMudW5pZm9ybXMgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGUgPSB1bmlmb3JtLm5vZGVVbmlmb3JtLm5vZGU7XG5cblx0XHRcdGlmICggISBub2RlICkgdGhyb3cgbmV3IEVycm9yKCAnTm9kZVVuaWZvcm1zR3JvdXA6IFVuaWZvcm0gaGFzIG5vIG5vZGUuJyApO1xuXG5cdFx0XHRub2Rlcy5wdXNoKCBub2RlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbm9kZXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVVbmlmb3Jtc0dyb3VwO1xuIiwiaW1wb3J0IEJpbmRpbmcgZnJvbSAnLi9CaW5kaW5nLmpzJztcblxubGV0IF9pZCA9IDA7XG5cbmNsYXNzIFNhbXBsZWRUZXh0dXJlIGV4dGVuZHMgQmluZGluZyB7XG5cblx0Y29uc3RydWN0b3IoIG5hbWUsIHRleHR1cmUgKSB7XG5cblx0XHRzdXBlciggbmFtZSApO1xuXG5cdFx0dGhpcy5pZCA9IF9pZCArKztcblxuXHRcdHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG5cdFx0dGhpcy52ZXJzaW9uID0gdGV4dHVyZSA/IHRleHR1cmUudmVyc2lvbiA6IDA7XG5cdFx0dGhpcy5zdG9yZSA9IGZhbHNlO1xuXHRcdHRoaXMuZ2VuZXJhdGlvbiA9IG51bGw7XG5cblx0XHR0aGlzLmlzU2FtcGxlZFRleHR1cmUgPSB0cnVlO1xuXG5cdH1cblxuXHRuZWVkc0JpbmRpbmdzVXBkYXRlKCBnZW5lcmF0aW9uICkge1xuXG5cdFx0Y29uc3QgeyB0ZXh0dXJlIH0gPSB0aGlzO1xuXG5cdFx0aWYgKCBnZW5lcmF0aW9uICE9PSB0aGlzLmdlbmVyYXRpb24gKSB7XG5cblx0XHRcdHRoaXMuZ2VuZXJhdGlvbiA9IGdlbmVyYXRpb247XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmUuaXNWaWRlb1RleHR1cmU7XG5cblx0fVxuXG5cdHVwZGF0ZSgpIHtcblxuXHRcdGNvbnN0IHsgdGV4dHVyZSwgdmVyc2lvbiB9ID0gdGhpcztcblxuXHRcdGlmICggdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxufVxuXG5jbGFzcyBTYW1wbGVkQXJyYXlUZXh0dXJlIGV4dGVuZHMgU2FtcGxlZFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0ZXh0dXJlICkge1xuXG5cdFx0c3VwZXIoIG5hbWUsIHRleHR1cmUgKTtcblxuXHRcdHRoaXMuaXNTYW1wbGVkQXJyYXlUZXh0dXJlID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgU2FtcGxlZDNEVGV4dHVyZSBleHRlbmRzIFNhbXBsZWRUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdGV4dHVyZSApIHtcblxuXHRcdHN1cGVyKCBuYW1lLCB0ZXh0dXJlICk7XG5cblx0XHR0aGlzLmlzU2FtcGxlZDNEVGV4dHVyZSA9IHRydWU7XG5cblx0fVxuXG59XG5cbmNsYXNzIFNhbXBsZWRDdWJlVGV4dHVyZSBleHRlbmRzIFNhbXBsZWRUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdGV4dHVyZSApIHtcblxuXHRcdHN1cGVyKCBuYW1lLCB0ZXh0dXJlICk7XG5cblx0XHR0aGlzLmlzU2FtcGxlZEN1YmVUZXh0dXJlID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU2FtcGxlZFRleHR1cmUsIFNhbXBsZWRBcnJheVRleHR1cmUsIFNhbXBsZWQzRFRleHR1cmUsIFNhbXBsZWRDdWJlVGV4dHVyZSB9O1xuIiwiaW1wb3J0IHsgU2FtcGxlZFRleHR1cmUgfSBmcm9tICcuLi9TYW1wbGVkVGV4dHVyZS5qcyc7XG5cbmNsYXNzIE5vZGVTYW1wbGVkVGV4dHVyZSBleHRlbmRzIFNhbXBsZWRUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdGV4dHVyZU5vZGUsIGdyb3VwTm9kZSwgYWNjZXNzID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCBuYW1lLCB0ZXh0dXJlTm9kZSA/IHRleHR1cmVOb2RlLnZhbHVlIDogbnVsbCApO1xuXG5cdFx0dGhpcy50ZXh0dXJlTm9kZSA9IHRleHR1cmVOb2RlO1xuXHRcdHRoaXMuZ3JvdXBOb2RlID0gZ3JvdXBOb2RlO1xuXG5cdFx0dGhpcy5hY2Nlc3MgPSBhY2Nlc3M7XG5cblx0fVxuXG5cdG5lZWRzQmluZGluZ3NVcGRhdGUoIGdlbmVyYXRpb24gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlTm9kZS52YWx1ZSAhPT0gdGhpcy50ZXh0dXJlIHx8IHN1cGVyLm5lZWRzQmluZGluZ3NVcGRhdGUoIGdlbmVyYXRpb24gKTtcblxuXHR9XG5cblx0dXBkYXRlKCkge1xuXG5cdFx0Y29uc3QgeyB0ZXh0dXJlTm9kZSB9ID0gdGhpcztcblxuXHRcdGlmICggdGhpcy50ZXh0dXJlICE9PSB0ZXh0dXJlTm9kZS52YWx1ZSApIHtcblxuXHRcdFx0dGhpcy50ZXh0dXJlID0gdGV4dHVyZU5vZGUudmFsdWU7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1cGVyLnVwZGF0ZSgpO1xuXG5cdH1cblxufVxuXG5jbGFzcyBOb2RlU2FtcGxlZEN1YmVUZXh0dXJlIGV4dGVuZHMgTm9kZVNhbXBsZWRUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdGV4dHVyZU5vZGUsIGdyb3VwTm9kZSwgYWNjZXNzICkge1xuXG5cdFx0c3VwZXIoIG5hbWUsIHRleHR1cmVOb2RlLCBncm91cE5vZGUsIGFjY2VzcyApO1xuXG5cdFx0dGhpcy5pc1NhbXBsZWRDdWJlVGV4dHVyZSA9IHRydWU7XG5cblx0fVxuXG59XG5cbmNsYXNzIE5vZGVTYW1wbGVkVGV4dHVyZTNEIGV4dGVuZHMgTm9kZVNhbXBsZWRUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdGV4dHVyZU5vZGUsIGdyb3VwTm9kZSwgYWNjZXNzICkge1xuXG5cdFx0c3VwZXIoIG5hbWUsIHRleHR1cmVOb2RlLCBncm91cE5vZGUsIGFjY2VzcyApO1xuXG5cdFx0dGhpcy5pc1NhbXBsZWRUZXh0dXJlM0QgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBOb2RlU2FtcGxlZFRleHR1cmUsIE5vZGVTYW1wbGVkQ3ViZVRleHR1cmUsIE5vZGVTYW1wbGVkVGV4dHVyZTNEIH07XG4iLCJpbXBvcnQgeyBHTFNMTm9kZVBhcnNlciwgTm9kZUJ1aWxkZXIsIFRleHR1cmVOb2RlLCB2ZWN0b3JDb21wb25lbnRzIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvTm9kZXMuanMnO1xuXG5pbXBvcnQgTm9kZVVuaWZvcm1CdWZmZXIgZnJvbSAnLi4vLi4vY29tbW9uL25vZGVzL05vZGVVbmlmb3JtQnVmZmVyLmpzJztcbmltcG9ydCBOb2RlVW5pZm9ybXNHcm91cCBmcm9tICcuLi8uLi9jb21tb24vbm9kZXMvTm9kZVVuaWZvcm1zR3JvdXAuanMnO1xuXG5pbXBvcnQgeyBOb2RlU2FtcGxlZFRleHR1cmUsIE5vZGVTYW1wbGVkQ3ViZVRleHR1cmUsIE5vZGVTYW1wbGVkVGV4dHVyZTNEIH0gZnJvbSAnLi4vLi4vY29tbW9uL25vZGVzL05vZGVTYW1wbGVkVGV4dHVyZS5qcyc7XG5cbmltcG9ydCB7IE5vQ29sb3JTcGFjZSwgQnl0ZVR5cGUsIFNob3J0VHlwZSwgUkdCQUludGVnZXJGb3JtYXQsIFJHQkludGVnZXJGb3JtYXQsIFJlZEludGVnZXJGb3JtYXQsIFJHSW50ZWdlckZvcm1hdCwgVW5zaWduZWRCeXRlVHlwZSwgVW5zaWduZWRJbnRUeXBlLCBVbnNpZ25lZFNob3J0VHlwZSwgUmVkRm9ybWF0LCBSR0Zvcm1hdCwgSW50VHlwZSwgUkdCRm9ybWF0LCBSR0JBRm9ybWF0LCBGbG9hdFR5cGUgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgRGF0YVRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi90ZXh0dXJlcy9EYXRhVGV4dHVyZS5qcyc7XG5cbmNvbnN0IGdsc2xNZXRob2RzID0ge1xuXHRhdGFuMjogJ2F0YW4nLFxuXHR0ZXh0dXJlRGltZW5zaW9uczogJ3RleHR1cmVTaXplJyxcblx0ZXF1YWxzOiAnZXF1YWwnXG59O1xuXG5jb25zdCBwcmVjaXNpb25MaWIgPSB7XG5cdGxvdzogJ2xvd3AnLFxuXHRtZWRpdW06ICdtZWRpdW1wJyxcblx0aGlnaDogJ2hpZ2hwJ1xufTtcblxuY29uc3Qgc3VwcG9ydHMgPSB7XG5cdHN3aXp6bGVBc3NpZ246IHRydWUsXG5cdHN0b3JhZ2VCdWZmZXI6IGZhbHNlXG59O1xuXG5jb25zdCBkZWZhdWx0UHJlY2lzaW9ucyA9IGBcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbnByZWNpc2lvbiBoaWdocCBpbnQ7XG5wcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xucHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIzRDtcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyQ3ViZTtcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkRBcnJheTtcblxucHJlY2lzaW9uIGhpZ2hwIHVzYW1wbGVyMkQ7XG5wcmVjaXNpb24gaGlnaHAgdXNhbXBsZXIzRDtcbnByZWNpc2lvbiBoaWdocCB1c2FtcGxlckN1YmU7XG5wcmVjaXNpb24gaGlnaHAgdXNhbXBsZXIyREFycmF5O1xuXG5wcmVjaXNpb24gaGlnaHAgaXNhbXBsZXIyRDtcbnByZWNpc2lvbiBoaWdocCBpc2FtcGxlcjNEO1xucHJlY2lzaW9uIGhpZ2hwIGlzYW1wbGVyQ3ViZTtcbnByZWNpc2lvbiBoaWdocCBpc2FtcGxlcjJEQXJyYXk7XG5cbnByZWNpc2lvbiBsb3dwIHNhbXBsZXIyRFNoYWRvdztcbmA7XG5cbmNsYXNzIEdMU0xOb2RlQnVpbGRlciBleHRlbmRzIE5vZGVCdWlsZGVyIHtcblxuXHRjb25zdHJ1Y3Rvciggb2JqZWN0LCByZW5kZXJlciApIHtcblxuXHRcdHN1cGVyKCBvYmplY3QsIHJlbmRlcmVyLCBuZXcgR0xTTE5vZGVQYXJzZXIoKSApO1xuXG5cdFx0dGhpcy51bmlmb3JtR3JvdXBzID0ge307XG5cdFx0dGhpcy50cmFuc2Zvcm1zID0gW107XG5cdFx0dGhpcy5leHRlbnNpb25zID0ge307XG5cdFx0dGhpcy5idWlsdGlucyA9IHsgdmVydGV4OiBbXSwgZnJhZ21lbnQ6IFtdLCBjb21wdXRlOiBbXSB9O1xuXG5cdFx0dGhpcy51c2VDb21wYXJpc29uTWV0aG9kID0gdHJ1ZTtcblxuXHR9XG5cblx0bmVlZHNUb1dvcmtpbmdDb2xvclNwYWNlKCB0ZXh0dXJlICkge1xuXG5cdFx0cmV0dXJuIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgPT09IHRydWUgJiYgdGV4dHVyZS5jb2xvclNwYWNlICE9PSBOb0NvbG9yU3BhY2U7XG5cblx0fVxuXG5cdGdldE1ldGhvZCggbWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIGdsc2xNZXRob2RzWyBtZXRob2QgXSB8fCBtZXRob2Q7XG5cblx0fVxuXG5cdGdldE91dHB1dFN0cnVjdE5hbWUoKSB7XG5cblx0XHRyZXR1cm4gJyc7XG5cblx0fVxuXG5cdGJ1aWxkRnVuY3Rpb25Db2RlKCBzaGFkZXJOb2RlICkge1xuXG5cdFx0Y29uc3QgbGF5b3V0ID0gc2hhZGVyTm9kZS5sYXlvdXQ7XG5cdFx0Y29uc3QgZmxvd0RhdGEgPSB0aGlzLmZsb3dTaGFkZXJOb2RlKCBzaGFkZXJOb2RlICk7XG5cblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gW107XG5cblx0XHRmb3IgKCBjb25zdCBpbnB1dCBvZiBsYXlvdXQuaW5wdXRzICkge1xuXG5cdFx0XHRwYXJhbWV0ZXJzLnB1c2goIHRoaXMuZ2V0VHlwZSggaW5wdXQudHlwZSApICsgJyAnICsgaW5wdXQubmFtZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGNvZGUgPSBgJHsgdGhpcy5nZXRUeXBlKCBsYXlvdXQudHlwZSApIH0gJHsgbGF5b3V0Lm5hbWUgfSggJHsgcGFyYW1ldGVycy5qb2luKCAnLCAnICkgfSApIHtcblxuXHQkeyBmbG93RGF0YS52YXJzIH1cblxuJHsgZmxvd0RhdGEuY29kZSB9XG5cdHJldHVybiAkeyBmbG93RGF0YS5yZXN1bHQgfTtcblxufWA7XG5cblx0XHQvL1xuXG5cdFx0cmV0dXJuIGNvZGU7XG5cblx0fVxuXG5cdHNldHVwUEJPKCBzdG9yYWdlQnVmZmVyTm9kZSApIHtcblxuXHRcdGNvbnN0IGF0dHJpYnV0ZSA9IHN0b3JhZ2VCdWZmZXJOb2RlLnZhbHVlO1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGUucGJvID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHRjb25zdCBudW1FbGVtZW50cyA9IGF0dHJpYnV0ZS5jb3VudCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuXHRcdFx0Y29uc3QgeyBpdGVtU2l6ZSB9ID0gYXR0cmlidXRlO1xuXG5cdFx0XHRjb25zdCBpc0ludGVnZXIgPSBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCAnaW50JyApO1xuXG5cdFx0XHRsZXQgZm9ybWF0ID0gaXNJbnRlZ2VyID8gUmVkSW50ZWdlckZvcm1hdCA6IFJlZEZvcm1hdDtcblxuXHRcdFx0aWYgKCBpdGVtU2l6ZSA9PT0gMiApIHtcblxuXHRcdFx0XHRmb3JtYXQgPSBpc0ludGVnZXIgPyBSR0ludGVnZXJGb3JtYXQgOiBSR0Zvcm1hdDtcblxuXHRcdFx0fSBlbHNlIGlmICggaXRlbVNpemUgPT09IDMgKSB7XG5cblx0XHRcdFx0Zm9ybWF0ID0gaXNJbnRlZ2VyID8gUkdCSW50ZWdlckZvcm1hdCA6IFJHQkZvcm1hdDtcblxuXHRcdFx0fSBlbHNlIGlmICggaXRlbVNpemUgPT09IDQgKSB7XG5cblx0XHRcdFx0Zm9ybWF0ID0gaXNJbnRlZ2VyID8gUkdCQUludGVnZXJGb3JtYXQgOiBSR0JBRm9ybWF0O1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHR5cGVNYXAgPSB7XG5cdFx0XHRcdEZsb2F0MzJBcnJheTogRmxvYXRUeXBlLFxuXHRcdFx0XHRVaW50OEFycmF5OiBVbnNpZ25lZEJ5dGVUeXBlLFxuXHRcdFx0XHRVaW50MTZBcnJheTogVW5zaWduZWRTaG9ydFR5cGUsXG5cdFx0XHRcdFVpbnQzMkFycmF5OiBVbnNpZ25lZEludFR5cGUsXG5cdFx0XHRcdEludDhBcnJheTogQnl0ZVR5cGUsXG5cdFx0XHRcdEludDE2QXJyYXk6IFNob3J0VHlwZSxcblx0XHRcdFx0SW50MzJBcnJheTogSW50VHlwZSxcblx0XHRcdFx0VWludDhDbGFtcGVkQXJyYXk6IFVuc2lnbmVkQnl0ZVR5cGUsXG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCB3aWR0aCA9IE1hdGgucG93KCAyLCBNYXRoLmNlaWwoIE1hdGgubG9nMiggTWF0aC5zcXJ0KCBudW1FbGVtZW50cyAvIGl0ZW1TaXplICkgKSApICk7XG5cdFx0XHRsZXQgaGVpZ2h0ID0gTWF0aC5jZWlsKCAoIG51bUVsZW1lbnRzIC8gaXRlbVNpemUgKSAvIHdpZHRoICk7XG5cdFx0XHRpZiAoIHdpZHRoICogaGVpZ2h0ICogaXRlbVNpemUgPCBudW1FbGVtZW50cyApIGhlaWdodCArKzsgLy8gRW5zdXJlIGVub3VnaCBzcGFjZVxuXG5cdFx0XHRjb25zdCBuZXdTaXplID0gd2lkdGggKiBoZWlnaHQgKiBpdGVtU2l6ZTtcblxuXHRcdFx0Y29uc3QgbmV3QXJyYXkgPSBuZXcgb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvciggbmV3U2l6ZSApO1xuXG5cdFx0XHRuZXdBcnJheS5zZXQoIG9yaWdpbmFsQXJyYXksIDAgKTtcblxuXHRcdFx0YXR0cmlidXRlLmFycmF5ID0gbmV3QXJyYXk7XG5cblx0XHRcdGNvbnN0IHBib1RleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoIGF0dHJpYnV0ZS5hcnJheSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlTWFwWyBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IubmFtZSBdIHx8IEZsb2F0VHlwZSApO1xuXHRcdFx0cGJvVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRwYm9UZXh0dXJlLmlzUEJPVGV4dHVyZSA9IHRydWU7XG5cblx0XHRcdGNvbnN0IHBibyA9IG5ldyBUZXh0dXJlTm9kZSggcGJvVGV4dHVyZSwgbnVsbCwgbnVsbCApO1xuXHRcdFx0cGJvLnNldFByZWNpc2lvbiggJ2hpZ2gnICk7XG5cblx0XHRcdGF0dHJpYnV0ZS5wYm9Ob2RlID0gcGJvO1xuXHRcdFx0YXR0cmlidXRlLnBibyA9IHBiby52YWx1ZTtcblxuXHRcdFx0dGhpcy5nZXRVbmlmb3JtRnJvbU5vZGUoIGF0dHJpYnV0ZS5wYm9Ob2RlLCAndGV4dHVyZScsIHRoaXMuc2hhZGVyU3RhZ2UsIHRoaXMuY29udGV4dC5sYWJlbCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRnZXRQcm9wZXJ0eU5hbWUoIG5vZGUsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcblxuXHRcdGlmICggbm9kZS5pc05vZGVVbmlmb3JtICYmIG5vZGUubm9kZS5pc1RleHR1cmVOb2RlICE9PSB0cnVlICYmIG5vZGUubm9kZS5pc0J1ZmZlck5vZGUgIT09IHRydWUgKSB7XG5cblx0XHRcdHJldHVybiBzaGFkZXJTdGFnZS5jaGFyQXQoIDAgKSArICdfJyArIG5vZGUubmFtZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBzdXBlci5nZXRQcm9wZXJ0eU5hbWUoIG5vZGUsIHNoYWRlclN0YWdlICk7XG5cblx0fVxuXG5cdGdlbmVyYXRlUEJPKCBzdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSApIHtcblxuXHRcdGNvbnN0IHsgbm9kZSwgaW5kZXhOb2RlIH0gPSBzdG9yYWdlQXJyYXlFbGVtZW50Tm9kZTtcblx0XHRjb25zdCBhdHRyaWJ1dGUgPSBub2RlLnZhbHVlO1xuXG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVyLmJhY2tlbmQuaGFzKCBhdHRyaWJ1dGUgKSApIHtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlRGF0YSA9IHRoaXMucmVuZGVyZXIuYmFja2VuZC5nZXQoIGF0dHJpYnV0ZSApO1xuXHRcdFx0YXR0cmlidXRlRGF0YS5wYm8gPSBhdHRyaWJ1dGUucGJvO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgbm9kZVVuaWZvcm0gPSB0aGlzLmdldFVuaWZvcm1Gcm9tTm9kZSggYXR0cmlidXRlLnBib05vZGUsICd0ZXh0dXJlJywgdGhpcy5zaGFkZXJTdGFnZSwgdGhpcy5jb250ZXh0LmxhYmVsICk7XG5cdFx0Y29uc3QgdGV4dHVyZU5hbWUgPSB0aGlzLmdldFByb3BlcnR5TmFtZSggbm9kZVVuaWZvcm0gKTtcblxuXHRcdHRoaXMuaW5jcmVhc2VVc2FnZSggaW5kZXhOb2RlICk7IC8vIGZvcmNlIGNhY2hlIGdlbmVyYXRlIHRvIGJlIHVzZWQgYXMgaW5kZXggaW4geCx5XG5cdFx0Y29uc3QgaW5kZXhTbmlwcGV0ID0gaW5kZXhOb2RlLmJ1aWxkKCB0aGlzLCAndWludCcgKTtcblxuXHRcdGNvbnN0IGVsZW1lbnROb2RlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBzdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSApO1xuXG5cdFx0bGV0IHByb3BlcnR5TmFtZSA9IGVsZW1lbnROb2RlRGF0YS5wcm9wZXJ0eU5hbWU7XG5cblx0XHRpZiAoIHByb3BlcnR5TmFtZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBwcm9wZXJ0eSBlbGVtZW50XG5cblx0XHRcdGNvbnN0IG5vZGVWYXIgPSB0aGlzLmdldFZhckZyb21Ob2RlKCBzdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSApO1xuXG5cdFx0XHRwcm9wZXJ0eU5hbWUgPSB0aGlzLmdldFByb3BlcnR5TmFtZSggbm9kZVZhciApO1xuXG5cdFx0XHQvLyBwcm9wZXJ0eSBzaXplXG5cblx0XHRcdGNvbnN0IGJ1ZmZlck5vZGVEYXRhID0gdGhpcy5nZXREYXRhRnJvbU5vZGUoIG5vZGUgKTtcblxuXHRcdFx0bGV0IHByb3BlcnR5U2l6ZU5hbWUgPSBidWZmZXJOb2RlRGF0YS5wcm9wZXJ0eVNpemVOYW1lO1xuXG5cdFx0XHRpZiAoIHByb3BlcnR5U2l6ZU5hbWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwcm9wZXJ0eVNpemVOYW1lID0gcHJvcGVydHlOYW1lICsgJ1NpemUnO1xuXG5cdFx0XHRcdHRoaXMuZ2V0VmFyRnJvbU5vZGUoIG5vZGUsIHByb3BlcnR5U2l6ZU5hbWUsICd1aW50JyApO1xuXG5cdFx0XHRcdHRoaXMuYWRkTGluZUZsb3dDb2RlKCBgJHsgcHJvcGVydHlTaXplTmFtZSB9ID0gdWludCggdGV4dHVyZVNpemUoICR7IHRleHR1cmVOYW1lIH0sIDAgKS54IClgLCBzdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSApO1xuXG5cdFx0XHRcdGJ1ZmZlck5vZGVEYXRhLnByb3BlcnR5U2l6ZU5hbWUgPSBwcm9wZXJ0eVNpemVOYW1lO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGNvbnN0IHsgaXRlbVNpemUgfSA9IGF0dHJpYnV0ZTtcblxuXHRcdFx0Y29uc3QgY2hhbm5lbCA9ICcuJyArIHZlY3RvckNvbXBvbmVudHMuam9pbiggJycgKS5zbGljZSggMCwgaXRlbVNpemUgKTtcblx0XHRcdGNvbnN0IHV2U25pcHBldCA9IGBpdmVjMigke2luZGV4U25pcHBldH0gJSAkeyBwcm9wZXJ0eVNpemVOYW1lIH0sICR7aW5kZXhTbmlwcGV0fSAvICR7IHByb3BlcnR5U2l6ZU5hbWUgfSlgO1xuXG5cdFx0XHRjb25zdCBzbmlwcGV0ID0gdGhpcy5nZW5lcmF0ZVRleHR1cmVMb2FkKCBudWxsLCB0ZXh0dXJlTmFtZSwgdXZTbmlwcGV0LCBudWxsLCAnMCcgKTtcblxuXHRcdFx0Ly9cblxuXG5cdFx0XHRsZXQgcHJlZml4ID0gJ3ZlYzQnO1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5wYm8udHlwZSA9PT0gVW5zaWduZWRJbnRUeXBlICkge1xuXG5cdFx0XHRcdHByZWZpeCA9ICd1dmVjNCc7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGF0dHJpYnV0ZS5wYm8udHlwZSA9PT0gSW50VHlwZSApIHtcblxuXHRcdFx0XHRwcmVmaXggPSAnaXZlYzQnO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYWRkTGluZUZsb3dDb2RlKCBgJHsgcHJvcGVydHlOYW1lIH0gPSAke3ByZWZpeH0oJHsgc25pcHBldCB9KSR7Y2hhbm5lbH1gLCBzdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSApO1xuXG5cdFx0XHRlbGVtZW50Tm9kZURhdGEucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb3BlcnR5TmFtZTtcblxuXHR9XG5cblx0Z2VuZXJhdGVUZXh0dXJlTG9hZCggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dkluZGV4U25pcHBldCwgZGVwdGhTbmlwcGV0LCBsZXZlbFNuaXBwZXQgPSAnMCcgKSB7XG5cblx0XHRpZiAoIGRlcHRoU25pcHBldCApIHtcblxuXHRcdFx0cmV0dXJuIGB0ZXhlbEZldGNoKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgaXZlYzMoICR7IHV2SW5kZXhTbmlwcGV0IH0sICR7IGRlcHRoU25pcHBldCB9ICksICR7IGxldmVsU25pcHBldCB9IClgO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIGB0ZXhlbEZldGNoKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdXZJbmRleFNuaXBwZXQgfSwgJHsgbGV2ZWxTbmlwcGV0IH0gKWA7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdlbmVyYXRlVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGRlcHRoU25pcHBldCApIHtcblxuXHRcdGlmICggdGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcblxuXHRcdFx0cmV0dXJuIGB0ZXh0dXJlKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdXZTbmlwcGV0IH0gKS54YDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggZGVwdGhTbmlwcGV0ICkgdXZTbmlwcGV0ID0gYHZlYzMoICR7IHV2U25pcHBldCB9LCAkeyBkZXB0aFNuaXBwZXQgfSApYDtcblxuXHRcdFx0cmV0dXJuIGB0ZXh0dXJlKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdXZTbmlwcGV0IH0gKWA7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdlbmVyYXRlVGV4dHVyZUxldmVsKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgbGV2ZWxTbmlwcGV0ICkge1xuXG5cdFx0cmV0dXJuIGB0ZXh0dXJlTG9kKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdXZTbmlwcGV0IH0sICR7IGxldmVsU25pcHBldCB9IClgO1xuXG5cdH1cblxuXHRnZW5lcmF0ZVRleHR1cmVCaWFzKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgYmlhc1NuaXBwZXQgKSB7XG5cblx0XHRyZXR1cm4gYHRleHR1cmUoICR7IHRleHR1cmVQcm9wZXJ0eSB9LCAkeyB1dlNuaXBwZXQgfSwgJHsgYmlhc1NuaXBwZXQgfSApYDtcblxuXHR9XG5cblx0Z2VuZXJhdGVUZXh0dXJlR3JhZCggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGdyYWRTbmlwcGV0ICkge1xuXG5cdFx0cmV0dXJuIGB0ZXh0dXJlR3JhZCggJHsgdGV4dHVyZVByb3BlcnR5IH0sICR7IHV2U25pcHBldCB9LCAkeyBncmFkU25pcHBldFsgMCBdIH0sICR7IGdyYWRTbmlwcGV0WyAxIF0gfSApYDtcblxuXHR9XG5cblx0Z2VuZXJhdGVUZXh0dXJlQ29tcGFyZSggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGNvbXBhcmVTbmlwcGV0LCBkZXB0aFNuaXBwZXQsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcblxuXHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgKSB7XG5cblx0XHRcdHJldHVybiBgdGV4dHVyZSggJHsgdGV4dHVyZVByb3BlcnR5IH0sIHZlYzMoICR7IHV2U25pcHBldCB9LCAkeyBjb21wYXJlU25pcHBldCB9ICkgKWA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBgV2ViR1BVUmVuZGVyZXI6IFRIUkVFLkRlcHRoVGV4dHVyZS5jb21wYXJlRnVuY3Rpb24oKSBkb2VzIG5vdCBzdXBwb3J0ICR7IHNoYWRlclN0YWdlIH0gc2hhZGVyLmAgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2V0VmFycyggc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRjb25zdCBzbmlwcGV0cyA9IFtdO1xuXG5cdFx0Y29uc3QgdmFycyA9IHRoaXMudmFyc1sgc2hhZGVyU3RhZ2UgXTtcblxuXHRcdGlmICggdmFycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCB2YXJpYWJsZSBvZiB2YXJzICkge1xuXG5cdFx0XHRcdHNuaXBwZXRzLnB1c2goIGAkeyB0aGlzLmdldFZhciggdmFyaWFibGUudHlwZSwgdmFyaWFibGUubmFtZSApIH07YCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc25pcHBldHMuam9pbiggJ1xcblxcdCcgKTtcblxuXHR9XG5cblx0Z2V0VW5pZm9ybXMoIHNoYWRlclN0YWdlICkge1xuXG5cdFx0Y29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zWyBzaGFkZXJTdGFnZSBdO1xuXG5cdFx0Y29uc3QgYmluZGluZ1NuaXBwZXRzID0gW107XG5cdFx0Y29uc3QgdW5pZm9ybUdyb3VwcyA9IHt9O1xuXG5cdFx0Zm9yICggY29uc3QgdW5pZm9ybSBvZiB1bmlmb3JtcyApIHtcblxuXHRcdFx0bGV0IHNuaXBwZXQgPSBudWxsO1xuXHRcdFx0bGV0IGdyb3VwID0gZmFsc2U7XG5cblx0XHRcdGlmICggdW5pZm9ybS50eXBlID09PSAndGV4dHVyZScgKSB7XG5cblx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHVuaWZvcm0ubm9kZS52YWx1ZTtcblxuXHRcdFx0XHRsZXQgdHlwZVByZWZpeCA9ICcnO1xuXG5cdFx0XHRcdGlmICggdGV4dHVyZS5pc0RhdGFUZXh0dXJlID09PSB0cnVlICkge1xuXG5cblx0XHRcdFx0XHRpZiAoIHRleHR1cmUudHlwZSA9PT0gVW5zaWduZWRJbnRUeXBlICkge1xuXG5cdFx0XHRcdFx0XHR0eXBlUHJlZml4ID0gJ3UnO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS50eXBlID09PSBJbnRUeXBlICkge1xuXG5cdFx0XHRcdFx0XHR0eXBlUHJlZml4ID0gJ2knO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRleHR1cmUuY29tcGFyZUZ1bmN0aW9uICkge1xuXG5cdFx0XHRcdFx0c25pcHBldCA9IGBzYW1wbGVyMkRTaGFkb3cgJHsgdW5pZm9ybS5uYW1lIH07YDtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSA9PT0gdHJ1ZSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHNuaXBwZXQgPSBgJHt0eXBlUHJlZml4fXNhbXBsZXIyREFycmF5ICR7IHVuaWZvcm0ubmFtZSB9O2A7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHNuaXBwZXQgPSBgJHt0eXBlUHJlZml4fXNhbXBsZXIyRCAkeyB1bmlmb3JtLm5hbWUgfTtgO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggdW5pZm9ybS50eXBlID09PSAnY3ViZVRleHR1cmUnICkge1xuXG5cdFx0XHRcdHNuaXBwZXQgPSBgc2FtcGxlckN1YmUgJHsgdW5pZm9ybS5uYW1lIH07YDtcblxuXHRcdFx0fSBlbHNlIGlmICggdW5pZm9ybS50eXBlID09PSAndGV4dHVyZTNEJyApIHtcblxuXHRcdFx0XHRzbmlwcGV0ID0gYHNhbXBsZXIzRCAkeyB1bmlmb3JtLm5hbWUgfTtgO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB1bmlmb3JtLnR5cGUgPT09ICdidWZmZXInICkge1xuXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlck5vZGUgPSB1bmlmb3JtLm5vZGU7XG5cdFx0XHRcdGNvbnN0IGJ1ZmZlclR5cGUgPSB0aGlzLmdldFR5cGUoIGJ1ZmZlck5vZGUuYnVmZmVyVHlwZSApO1xuXHRcdFx0XHRjb25zdCBidWZmZXJDb3VudCA9IGJ1ZmZlck5vZGUuYnVmZmVyQ291bnQ7XG5cblx0XHRcdFx0Y29uc3QgYnVmZmVyQ291bnRTbmlwcGV0ID0gYnVmZmVyQ291bnQgPiAwID8gYnVmZmVyQ291bnQgOiAnJztcblx0XHRcdFx0c25pcHBldCA9IGAke2J1ZmZlck5vZGUubmFtZX0ge1xcblxcdCR7IGJ1ZmZlclR5cGUgfSAkeyB1bmlmb3JtLm5hbWUgfVskeyBidWZmZXJDb3VudFNuaXBwZXQgfV07XFxufTtcXG5gO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IHZlY3RvclR5cGUgPSB0aGlzLmdldFZlY3RvclR5cGUoIHVuaWZvcm0udHlwZSApO1xuXG5cdFx0XHRcdHNuaXBwZXQgPSBgJHsgdmVjdG9yVHlwZSB9ICR7IHRoaXMuZ2V0UHJvcGVydHlOYW1lKCB1bmlmb3JtLCBzaGFkZXJTdGFnZSApIH07YDtcblxuXHRcdFx0XHRncm91cCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcHJlY2lzaW9uID0gdW5pZm9ybS5ub2RlLnByZWNpc2lvbjtcblxuXHRcdFx0aWYgKCBwcmVjaXNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0c25pcHBldCA9IHByZWNpc2lvbkxpYlsgcHJlY2lzaW9uIF0gKyAnICcgKyBzbmlwcGV0O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ3JvdXAgKSB7XG5cblx0XHRcdFx0c25pcHBldCA9ICdcXHQnICsgc25pcHBldDtcblxuXHRcdFx0XHRjb25zdCBncm91cE5hbWUgPSB1bmlmb3JtLmdyb3VwTm9kZS5uYW1lO1xuXHRcdFx0XHRjb25zdCBncm91cFNuaXBwZXRzID0gdW5pZm9ybUdyb3Vwc1sgZ3JvdXBOYW1lIF0gfHwgKCB1bmlmb3JtR3JvdXBzWyBncm91cE5hbWUgXSA9IFtdICk7XG5cblx0XHRcdFx0Z3JvdXBTbmlwcGV0cy5wdXNoKCBzbmlwcGV0ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c25pcHBldCA9ICd1bmlmb3JtICcgKyBzbmlwcGV0O1xuXG5cdFx0XHRcdGJpbmRpbmdTbmlwcGV0cy5wdXNoKCBzbmlwcGV0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGxldCBvdXRwdXQgPSAnJztcblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gdW5pZm9ybUdyb3VwcyApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXBTbmlwcGV0cyA9IHVuaWZvcm1Hcm91cHNbIG5hbWUgXTtcblxuXHRcdFx0b3V0cHV0ICs9IHRoaXMuX2dldEdMU0xVbmlmb3JtU3RydWN0KCBzaGFkZXJTdGFnZSArICdfJyArIG5hbWUsIGdyb3VwU25pcHBldHMuam9pbiggJ1xcbicgKSApICsgJ1xcbic7XG5cblx0XHR9XG5cblx0XHRvdXRwdXQgKz0gYmluZGluZ1NuaXBwZXRzLmpvaW4oICdcXG4nICk7XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdH1cblxuXHRnZXRUeXBlRnJvbUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0bGV0IG5vZGVUeXBlID0gc3VwZXIuZ2V0VHlwZUZyb21BdHRyaWJ1dGUoIGF0dHJpYnV0ZSApO1xuXG5cdFx0aWYgKCAvXltpdV0vLnRlc3QoIG5vZGVUeXBlICkgJiYgYXR0cmlidXRlLmdwdVR5cGUgIT09IEludFR5cGUgKSB7XG5cblx0XHRcdGxldCBkYXRhQXR0cmlidXRlID0gYXR0cmlidXRlO1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgZGF0YUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5kYXRhO1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IGRhdGFBdHRyaWJ1dGUuYXJyYXk7XG5cblx0XHRcdGlmICggKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8IGFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRub2RlVHlwZSA9IG5vZGVUeXBlLnNsaWNlKCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlVHlwZTtcblxuXHR9XG5cblx0Z2V0QXR0cmlidXRlcyggc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRsZXQgc25pcHBldCA9ICcnO1xuXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSA9PT0gJ3ZlcnRleCcgfHwgc2hhZGVyU3RhZ2UgPT09ICdjb21wdXRlJyApIHtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuZ2V0QXR0cmlidXRlc0FycmF5KCk7XG5cblx0XHRcdGxldCBsb2NhdGlvbiA9IDA7XG5cblx0XHRcdGZvciAoIGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdHNuaXBwZXQgKz0gYGxheW91dCggbG9jYXRpb24gPSAkeyBsb2NhdGlvbiArKyB9ICkgaW4gJHsgYXR0cmlidXRlLnR5cGUgfSAkeyBhdHRyaWJ1dGUubmFtZSB9O1xcbmA7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBzbmlwcGV0O1xuXG5cdH1cblxuXHRnZXRTdHJ1Y3RNZW1iZXJzKCBzdHJ1Y3QgKSB7XG5cblx0XHRjb25zdCBzbmlwcGV0cyA9IFtdO1xuXHRcdGNvbnN0IG1lbWJlcnMgPSBzdHJ1Y3QuZ2V0TWVtYmVyVHlwZXMoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG1lbWJlcnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBtZW1iZXIgPSBtZW1iZXJzWyBpIF07XG5cdFx0XHRzbmlwcGV0cy5wdXNoKCBgbGF5b3V0KCBsb2NhdGlvbiA9ICR7aX0gKSBvdXQgJHsgbWVtYmVyfSBtJHtpfTtgICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc25pcHBldHMuam9pbiggJ1xcbicgKTtcblxuXHR9XG5cblx0Z2V0U3RydWN0cyggc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRjb25zdCBzbmlwcGV0cyA9IFtdO1xuXHRcdGNvbnN0IHN0cnVjdHMgPSB0aGlzLnN0cnVjdHNbIHNoYWRlclN0YWdlIF07XG5cblx0XHRpZiAoIHN0cnVjdHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gJ2xheW91dCggbG9jYXRpb24gPSAwICkgb3V0IHZlYzQgZnJhZ0NvbG9yO1xcbic7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBzdHJ1Y3RzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICsrICkge1xuXG5cdFx0XHRjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzWyBpbmRleCBdO1xuXG5cdFx0XHRsZXQgc25pcHBldCA9ICdcXG4nO1xuXHRcdFx0c25pcHBldCArPSB0aGlzLmdldFN0cnVjdE1lbWJlcnMoIHN0cnVjdCApO1xuXHRcdFx0c25pcHBldCArPSAnXFxuJztcblxuXHRcdFx0c25pcHBldHMucHVzaCggc25pcHBldCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNuaXBwZXRzLmpvaW4oICdcXG5cXG4nICk7XG5cblx0fVxuXG5cdGdldFZhcnlpbmdzKCBzaGFkZXJTdGFnZSApIHtcblxuXHRcdGxldCBzbmlwcGV0ID0gJyc7XG5cblx0XHRjb25zdCB2YXJ5aW5ncyA9IHRoaXMudmFyeWluZ3M7XG5cblx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAndmVydGV4JyB8fCBzaGFkZXJTdGFnZSA9PT0gJ2NvbXB1dGUnICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCB2YXJ5aW5nIG9mIHZhcnlpbmdzICkge1xuXG5cdFx0XHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICdjb21wdXRlJyApIHZhcnlpbmcubmVlZHNJbnRlcnBvbGF0aW9uID0gdHJ1ZTtcblx0XHRcdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSggdmFyeWluZy50eXBlICk7XG5cdFx0XHRcdGNvbnN0IGZsYXQgPSB0eXBlLmluY2x1ZGVzKCAnaW50JyApIHx8IHR5cGUuaW5jbHVkZXMoICd1dicgKSB8fCB0eXBlLmluY2x1ZGVzKCAnaXYnICkgPyAnZmxhdCAnIDogJyc7XG5cblx0XHRcdFx0c25pcHBldCArPSBgJHtmbGF0fSR7dmFyeWluZy5uZWVkc0ludGVycG9sYXRpb24gPyAnb3V0JyA6ICcvKm91dCovJ30gJHt0eXBlfSAke3ZhcnlpbmcubmFtZX07XFxuYDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IHZhcnlpbmcgb2YgdmFyeWluZ3MgKSB7XG5cblx0XHRcdFx0aWYgKCB2YXJ5aW5nLm5lZWRzSW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoIHZhcnlpbmcudHlwZSApO1xuXHRcdFx0XHRcdGNvbnN0IGZsYXQgPSB0eXBlLmluY2x1ZGVzKCAnaW50JyApIHx8IHR5cGUuaW5jbHVkZXMoICd1dicgKSB8fCB0eXBlLmluY2x1ZGVzKCAnaXYnICkgPyAnZmxhdCAnIDogJyc7XG5cblx0XHRcdFx0XHRzbmlwcGV0ICs9IGAke2ZsYXR9aW4gJHt0eXBlfSAke3ZhcnlpbmcubmFtZX07XFxuYDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIGNvbnN0IGJ1aWx0aW4gb2YgdGhpcy5idWlsdGluc1sgc2hhZGVyU3RhZ2UgXSApIHtcblxuXHRcdFx0c25pcHBldCArPSBgJHtidWlsdGlufTtcXG5gO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNuaXBwZXQ7XG5cblx0fVxuXG5cdGdldFZlcnRleEluZGV4KCkge1xuXG5cdFx0cmV0dXJuICd1aW50KCBnbF9WZXJ0ZXhJRCApJztcblxuXHR9XG5cblx0Z2V0SW5zdGFuY2VJbmRleCgpIHtcblxuXHRcdHJldHVybiAndWludCggZ2xfSW5zdGFuY2VJRCApJztcblxuXHR9XG5cblx0Z2V0SW52b2NhdGlvbkxvY2FsSW5kZXgoKSB7XG5cblx0XHRjb25zdCB3b3JrZ3JvdXBTaXplID0gdGhpcy5vYmplY3Qud29ya2dyb3VwU2l6ZTtcblxuXHRcdGNvbnN0IHNpemUgPSB3b3JrZ3JvdXBTaXplLnJlZHVjZSggKCBhY2MsIGN1cnIgKSA9PiBhY2MgKiBjdXJyLCAxICk7XG5cblx0XHRyZXR1cm4gYHVpbnQoIGdsX0luc3RhbmNlSUQgKSAlICR7c2l6ZX11YDtcblxuXHR9XG5cblx0Z2V0RHJhd0luZGV4KCkge1xuXG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMucmVuZGVyZXIuYmFja2VuZC5leHRlbnNpb25zO1xuXG5cdFx0aWYgKCBleHRlbnNpb25zLmhhcyggJ1dFQkdMX211bHRpX2RyYXcnICkgKSB7XG5cblx0XHRcdHJldHVybiAndWludCggZ2xfRHJhd0lEICknO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG5cdGdldEZyb250RmFjaW5nKCkge1xuXG5cdFx0cmV0dXJuICdnbF9Gcm9udEZhY2luZyc7XG5cblx0fVxuXG5cdGdldEZyYWdDb29yZCgpIHtcblxuXHRcdHJldHVybiAnZ2xfRnJhZ0Nvb3JkLnh5JztcblxuXHR9XG5cblx0Z2V0RnJhZ0RlcHRoKCkge1xuXG5cdFx0cmV0dXJuICdnbF9GcmFnRGVwdGgnO1xuXG5cdH1cblxuXHRlbmFibGVFeHRlbnNpb24oIG5hbWUsIGJlaGF2aW9yLCBzaGFkZXJTdGFnZSA9IHRoaXMuc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRjb25zdCBtYXAgPSB0aGlzLmV4dGVuc2lvbnNbIHNoYWRlclN0YWdlIF0gfHwgKCB0aGlzLmV4dGVuc2lvbnNbIHNoYWRlclN0YWdlIF0gPSBuZXcgTWFwKCkgKTtcblxuXHRcdGlmICggbWFwLmhhcyggbmFtZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0bWFwLnNldCggbmFtZSwge1xuXHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRiZWhhdmlvclxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRnZXRFeHRlbnNpb25zKCBzaGFkZXJTdGFnZSApIHtcblxuXHRcdGNvbnN0IHNuaXBwZXRzID0gW107XG5cblx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAndmVydGV4JyApIHtcblxuXHRcdFx0Y29uc3QgZXh0ID0gdGhpcy5yZW5kZXJlci5iYWNrZW5kLmV4dGVuc2lvbnM7XG5cdFx0XHRjb25zdCBpc0JhdGNoZWRNZXNoID0gdGhpcy5vYmplY3QuaXNCYXRjaGVkTWVzaDtcblxuXHRcdFx0aWYgKCBpc0JhdGNoZWRNZXNoICYmIGV4dC5oYXMoICdXRUJHTF9tdWx0aV9kcmF3JyApICkge1xuXG5cdFx0XHRcdHRoaXMuZW5hYmxlRXh0ZW5zaW9uKCAnR0xfQU5HTEVfbXVsdGlfZHJhdycsICdyZXF1aXJlJywgc2hhZGVyU3RhZ2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9uc1sgc2hhZGVyU3RhZ2UgXTtcblxuXHRcdGlmICggZXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCB7IG5hbWUsIGJlaGF2aW9yIH0gb2YgZXh0ZW5zaW9ucy52YWx1ZXMoKSApIHtcblxuXHRcdFx0XHRzbmlwcGV0cy5wdXNoKCBgI2V4dGVuc2lvbiAke25hbWV9IDogJHtiZWhhdmlvcn1gICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBzbmlwcGV0cy5qb2luKCAnXFxuJyApO1xuXG5cdH1cblxuXHRnZXRDbGlwRGlzdGFuY2UoKSB7XG5cblx0XHRyZXR1cm4gJ2dsX0NsaXBEaXN0YW5jZSc7XG5cblx0fVxuXG5cdGlzQXZhaWxhYmxlKCBuYW1lICkge1xuXG5cdFx0bGV0IHJlc3VsdCA9IHN1cHBvcnRzWyBuYW1lIF07XG5cblx0XHRpZiAoIHJlc3VsdCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRsZXQgZXh0ZW5zaW9uTmFtZTtcblxuXHRcdFx0cmVzdWx0ID0gZmFsc2U7XG5cblx0XHRcdHN3aXRjaCAoIG5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnZmxvYXQzMkZpbHRlcmFibGUnOlxuXHRcdFx0XHRcdGV4dGVuc2lvbk5hbWUgPSAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdjbGlwRGlzdGFuY2UnOlxuXHRcdFx0XHRcdGV4dGVuc2lvbk5hbWUgPSAnV0VCR0xfY2xpcF9jdWxsX2Rpc3RhbmNlJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbk5hbWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zdCBleHRlbnNpb25zID0gdGhpcy5yZW5kZXJlci5iYWNrZW5kLmV4dGVuc2lvbnM7XG5cblx0XHRcdFx0aWYgKCBleHRlbnNpb25zLmhhcyggZXh0ZW5zaW9uTmFtZSApICkge1xuXG5cdFx0XHRcdFx0ZXh0ZW5zaW9ucy5nZXQoIGV4dGVuc2lvbk5hbWUgKTtcblx0XHRcdFx0XHRyZXN1bHQgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRzdXBwb3J0c1sgbmFtZSBdID0gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0aXNGbGlwWSgpIHtcblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxuXHRlbmFibGVIYXJkd2FyZUNsaXBwaW5nKCBwbGFuZUNvdW50ICkge1xuXG5cdFx0dGhpcy5lbmFibGVFeHRlbnNpb24oICdHTF9BTkdMRV9jbGlwX2N1bGxfZGlzdGFuY2UnLCAncmVxdWlyZScgKTtcblxuXHRcdHRoaXMuYnVpbHRpbnNbICd2ZXJ0ZXgnIF0ucHVzaCggYG91dCBmbG9hdCBnbF9DbGlwRGlzdGFuY2VbICR7IHBsYW5lQ291bnQgfSBdYCApO1xuXG5cdH1cblxuXHRyZWdpc3RlclRyYW5zZm9ybSggdmFyeWluZ05hbWUsIGF0dHJpYnV0ZU5vZGUgKSB7XG5cblx0XHR0aGlzLnRyYW5zZm9ybXMucHVzaCggeyB2YXJ5aW5nTmFtZSwgYXR0cmlidXRlTm9kZSB9ICk7XG5cblx0fVxuXG5cdGdldFRyYW5zZm9ybXMoIC8qIHNoYWRlclN0YWdlICAqLyApIHtcblxuXHRcdGNvbnN0IHRyYW5zZm9ybXMgPSB0aGlzLnRyYW5zZm9ybXM7XG5cblx0XHRsZXQgc25pcHBldCA9ICcnO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbIGkgXTtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuZ2V0UHJvcGVydHlOYW1lKCB0cmFuc2Zvcm0uYXR0cmlidXRlTm9kZSApO1xuXG5cdFx0XHRzbmlwcGV0ICs9IGAkeyB0cmFuc2Zvcm0udmFyeWluZ05hbWUgfSA9ICR7IGF0dHJpYnV0ZU5hbWUgfTtcXG5cXHRgO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNuaXBwZXQ7XG5cblx0fVxuXG5cdF9nZXRHTFNMVW5pZm9ybVN0cnVjdCggbmFtZSwgdmFycyApIHtcblxuXHRcdHJldHVybiBgXG5sYXlvdXQoIHN0ZDE0MCApIHVuaWZvcm0gJHtuYW1lfSB7XG4ke3ZhcnN9XG59O2A7XG5cblx0fVxuXG5cdF9nZXRHTFNMVmVydGV4Q29kZSggc2hhZGVyRGF0YSApIHtcblxuXHRcdHJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG5cbiR7IHRoaXMuZ2V0U2lnbmF0dXJlKCkgfVxuXG4vLyBleHRlbnNpb25zIFxuJHtzaGFkZXJEYXRhLmV4dGVuc2lvbnN9XG5cbi8vIHByZWNpc2lvblxuJHsgZGVmYXVsdFByZWNpc2lvbnMgfVxuXG4vLyB1bmlmb3Jtc1xuJHtzaGFkZXJEYXRhLnVuaWZvcm1zfVxuXG4vLyB2YXJ5aW5nc1xuJHtzaGFkZXJEYXRhLnZhcnlpbmdzfVxuXG4vLyBhdHRyaWJ1dGVzXG4ke3NoYWRlckRhdGEuYXR0cmlidXRlc31cblxuLy8gY29kZXNcbiR7c2hhZGVyRGF0YS5jb2Rlc31cblxudm9pZCBtYWluKCkge1xuXG5cdC8vIHZhcnNcblx0JHtzaGFkZXJEYXRhLnZhcnN9XG5cblx0Ly8gdHJhbnNmb3Jtc1xuXHQke3NoYWRlckRhdGEudHJhbnNmb3Jtc31cblxuXHQvLyBmbG93XG5cdCR7c2hhZGVyRGF0YS5mbG93fVxuXG5cdGdsX1BvaW50U2l6ZSA9IDEuMDtcblxufVxuYDtcblxuXHR9XG5cblx0X2dldEdMU0xGcmFnbWVudENvZGUoIHNoYWRlckRhdGEgKSB7XG5cblx0XHRyZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xuXG4keyB0aGlzLmdldFNpZ25hdHVyZSgpIH1cblxuLy8gcHJlY2lzaW9uXG4keyBkZWZhdWx0UHJlY2lzaW9ucyB9XG5cbi8vIHVuaWZvcm1zXG4ke3NoYWRlckRhdGEudW5pZm9ybXN9XG5cbi8vIHZhcnlpbmdzXG4ke3NoYWRlckRhdGEudmFyeWluZ3N9XG5cbi8vIGNvZGVzXG4ke3NoYWRlckRhdGEuY29kZXN9XG5cbiR7c2hhZGVyRGF0YS5zdHJ1Y3RzfVxuXG52b2lkIG1haW4oKSB7XG5cblx0Ly8gdmFyc1xuXHQke3NoYWRlckRhdGEudmFyc31cblxuXHQvLyBmbG93XG5cdCR7c2hhZGVyRGF0YS5mbG93fVxuXG59XG5gO1xuXG5cdH1cblxuXHRidWlsZENvZGUoKSB7XG5cblx0XHRjb25zdCBzaGFkZXJzRGF0YSA9IHRoaXMubWF0ZXJpYWwgIT09IG51bGwgPyB7IGZyYWdtZW50OiB7fSwgdmVydGV4OiB7fSB9IDogeyBjb21wdXRlOiB7fSB9O1xuXG5cdFx0dGhpcy5zb3J0QmluZGluZ0dyb3VwcygpO1xuXG5cdFx0Zm9yICggY29uc3Qgc2hhZGVyU3RhZ2UgaW4gc2hhZGVyc0RhdGEgKSB7XG5cblx0XHRcdGxldCBmbG93ID0gJy8vIGNvZGVcXG5cXG4nO1xuXHRcdFx0ZmxvdyArPSB0aGlzLmZsb3dDb2RlWyBzaGFkZXJTdGFnZSBdO1xuXG5cdFx0XHRjb25zdCBmbG93Tm9kZXMgPSB0aGlzLmZsb3dOb2Rlc1sgc2hhZGVyU3RhZ2UgXTtcblx0XHRcdGNvbnN0IG1haW5Ob2RlID0gZmxvd05vZGVzWyBmbG93Tm9kZXMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRmb3IgKCBjb25zdCBub2RlIG9mIGZsb3dOb2RlcyApIHtcblxuXHRcdFx0XHRjb25zdCBmbG93U2xvdERhdGEgPSB0aGlzLmdldEZsb3dEYXRhKCBub2RlLyosIHNoYWRlclN0YWdlKi8gKTtcblx0XHRcdFx0Y29uc3Qgc2xvdE5hbWUgPSBub2RlLm5hbWU7XG5cblx0XHRcdFx0aWYgKCBzbG90TmFtZSApIHtcblxuXHRcdFx0XHRcdGlmICggZmxvdy5sZW5ndGggPiAwICkgZmxvdyArPSAnXFxuJztcblxuXHRcdFx0XHRcdGZsb3cgKz0gYFxcdC8vIGZsb3cgLT4gJHsgc2xvdE5hbWUgfVxcblxcdGA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZsb3cgKz0gYCR7IGZsb3dTbG90RGF0YS5jb2RlIH1cXG5cXHRgO1xuXG5cdFx0XHRcdGlmICggbm9kZSA9PT0gbWFpbk5vZGUgJiYgc2hhZGVyU3RhZ2UgIT09ICdjb21wdXRlJyApIHtcblxuXHRcdFx0XHRcdGZsb3cgKz0gJy8vIHJlc3VsdFxcblxcdCc7XG5cblx0XHRcdFx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAndmVydGV4JyApIHtcblxuXHRcdFx0XHRcdFx0ZmxvdyArPSAnZ2xfUG9zaXRpb24gPSAnO1xuXHRcdFx0XHRcdFx0ZmxvdyArPSBgJHsgZmxvd1Nsb3REYXRhLnJlc3VsdCB9O2A7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBzaGFkZXJTdGFnZSA9PT0gJ2ZyYWdtZW50JyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCAhIG5vZGUub3V0cHV0Tm9kZS5pc091dHB1dFN0cnVjdE5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZmxvdyArPSAnZnJhZ0NvbG9yID0gJztcblx0XHRcdFx0XHRcdFx0ZmxvdyArPSBgJHsgZmxvd1Nsb3REYXRhLnJlc3VsdCB9O2A7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc3RhZ2VEYXRhID0gc2hhZGVyc0RhdGFbIHNoYWRlclN0YWdlIF07XG5cblx0XHRcdHN0YWdlRGF0YS5leHRlbnNpb25zID0gdGhpcy5nZXRFeHRlbnNpb25zKCBzaGFkZXJTdGFnZSApO1xuXHRcdFx0c3RhZ2VEYXRhLnVuaWZvcm1zID0gdGhpcy5nZXRVbmlmb3Jtcyggc2hhZGVyU3RhZ2UgKTtcblx0XHRcdHN0YWdlRGF0YS5hdHRyaWJ1dGVzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCBzaGFkZXJTdGFnZSApO1xuXHRcdFx0c3RhZ2VEYXRhLnZhcnlpbmdzID0gdGhpcy5nZXRWYXJ5aW5ncyggc2hhZGVyU3RhZ2UgKTtcblx0XHRcdHN0YWdlRGF0YS52YXJzID0gdGhpcy5nZXRWYXJzKCBzaGFkZXJTdGFnZSApO1xuXHRcdFx0c3RhZ2VEYXRhLnN0cnVjdHMgPSB0aGlzLmdldFN0cnVjdHMoIHNoYWRlclN0YWdlICk7XG5cdFx0XHRzdGFnZURhdGEuY29kZXMgPSB0aGlzLmdldENvZGVzKCBzaGFkZXJTdGFnZSApO1xuXHRcdFx0c3RhZ2VEYXRhLnRyYW5zZm9ybXMgPSB0aGlzLmdldFRyYW5zZm9ybXMoIHNoYWRlclN0YWdlICk7XG5cdFx0XHRzdGFnZURhdGEuZmxvdyA9IGZsb3c7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubWF0ZXJpYWwgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMudmVydGV4U2hhZGVyID0gdGhpcy5fZ2V0R0xTTFZlcnRleENvZGUoIHNoYWRlcnNEYXRhLnZlcnRleCApO1xuXHRcdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IHRoaXMuX2dldEdMU0xGcmFnbWVudENvZGUoIHNoYWRlcnNEYXRhLmZyYWdtZW50ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVTaGFkZXIgPSB0aGlzLl9nZXRHTFNMVmVydGV4Q29kZSggc2hhZGVyc0RhdGEuY29tcHV0ZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRnZXRVbmlmb3JtRnJvbU5vZGUoIG5vZGUsIHR5cGUsIHNoYWRlclN0YWdlLCBuYW1lID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IHVuaWZvcm1Ob2RlID0gc3VwZXIuZ2V0VW5pZm9ybUZyb21Ob2RlKCBub2RlLCB0eXBlLCBzaGFkZXJTdGFnZSwgbmFtZSApO1xuXHRcdGNvbnN0IG5vZGVEYXRhID0gdGhpcy5nZXREYXRhRnJvbU5vZGUoIG5vZGUsIHNoYWRlclN0YWdlLCB0aGlzLmdsb2JhbENhY2hlICk7XG5cblx0XHRsZXQgdW5pZm9ybUdQVSA9IG5vZGVEYXRhLnVuaWZvcm1HUFU7XG5cblx0XHRpZiAoIHVuaWZvcm1HUFUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBub2RlLmdyb3VwTm9kZTtcblx0XHRcdGNvbnN0IGdyb3VwTmFtZSA9IGdyb3VwLm5hbWU7XG5cblx0XHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5nZXRCaW5kR3JvdXBBcnJheSggZ3JvdXBOYW1lLCBzaGFkZXJTdGFnZSApO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09ICd0ZXh0dXJlJyApIHtcblxuXHRcdFx0XHR1bmlmb3JtR1BVID0gbmV3IE5vZGVTYW1wbGVkVGV4dHVyZSggdW5pZm9ybU5vZGUubmFtZSwgdW5pZm9ybU5vZGUubm9kZSwgZ3JvdXAgKTtcblx0XHRcdFx0YmluZGluZ3MucHVzaCggdW5pZm9ybUdQVSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAnY3ViZVRleHR1cmUnICkge1xuXG5cdFx0XHRcdHVuaWZvcm1HUFUgPSBuZXcgTm9kZVNhbXBsZWRDdWJlVGV4dHVyZSggdW5pZm9ybU5vZGUubmFtZSwgdW5pZm9ybU5vZGUubm9kZSwgZ3JvdXAgKTtcblx0XHRcdFx0YmluZGluZ3MucHVzaCggdW5pZm9ybUdQVSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAndGV4dHVyZTNEJyApIHtcblxuXHRcdFx0XHR1bmlmb3JtR1BVID0gbmV3IE5vZGVTYW1wbGVkVGV4dHVyZTNEKCB1bmlmb3JtTm9kZS5uYW1lLCB1bmlmb3JtTm9kZS5ub2RlLCBncm91cCApO1xuXHRcdFx0XHRiaW5kaW5ncy5wdXNoKCB1bmlmb3JtR1BVICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdidWZmZXInICkge1xuXG5cdFx0XHRcdG5vZGUubmFtZSA9IGBOb2RlQnVmZmVyXyR7IG5vZGUuaWQgfWA7XG5cdFx0XHRcdHVuaWZvcm1Ob2RlLm5hbWUgPSBgYnVmZmVyJHsgbm9kZS5pZCB9YDtcblxuXHRcdFx0XHRjb25zdCBidWZmZXIgPSBuZXcgTm9kZVVuaWZvcm1CdWZmZXIoIG5vZGUsIGdyb3VwICk7XG5cdFx0XHRcdGJ1ZmZlci5uYW1lID0gbm9kZS5uYW1lO1xuXG5cdFx0XHRcdGJpbmRpbmdzLnB1c2goIGJ1ZmZlciApO1xuXG5cdFx0XHRcdHVuaWZvcm1HUFUgPSBidWZmZXI7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgdW5pZm9ybXNTdGFnZSA9IHRoaXMudW5pZm9ybUdyb3Vwc1sgc2hhZGVyU3RhZ2UgXSB8fCAoIHRoaXMudW5pZm9ybUdyb3Vwc1sgc2hhZGVyU3RhZ2UgXSA9IHt9ICk7XG5cblx0XHRcdFx0bGV0IHVuaWZvcm1zR3JvdXAgPSB1bmlmb3Jtc1N0YWdlWyBncm91cE5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIHVuaWZvcm1zR3JvdXAgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zR3JvdXAgPSBuZXcgTm9kZVVuaWZvcm1zR3JvdXAoIHNoYWRlclN0YWdlICsgJ18nICsgZ3JvdXBOYW1lLCBncm91cCApO1xuXHRcdFx0XHRcdC8vdW5pZm9ybXNHcm91cC5zZXRWaXNpYmlsaXR5KCBncHVTaGFkZXJTdGFnZUxpYlsgc2hhZGVyU3RhZ2UgXSApO1xuXG5cdFx0XHRcdFx0dW5pZm9ybXNTdGFnZVsgZ3JvdXBOYW1lIF0gPSB1bmlmb3Jtc0dyb3VwO1xuXG5cdFx0XHRcdFx0YmluZGluZ3MucHVzaCggdW5pZm9ybXNHcm91cCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1bmlmb3JtR1BVID0gdGhpcy5nZXROb2RlVW5pZm9ybSggdW5pZm9ybU5vZGUsIHR5cGUgKTtcblxuXHRcdFx0XHR1bmlmb3Jtc0dyb3VwLmFkZFVuaWZvcm0oIHVuaWZvcm1HUFUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRub2RlRGF0YS51bmlmb3JtR1BVID0gdW5pZm9ybUdQVTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmlmb3JtTm9kZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgR0xTTE5vZGVCdWlsZGVyO1xuIiwibGV0IHZlY3RvcjIgPSBudWxsO1xubGV0IHZlY3RvcjQgPSBudWxsO1xubGV0IGNvbG9yNCA9IG51bGw7XG5cbmltcG9ydCBDb2xvcjQgZnJvbSAnLi9Db2xvcjQuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3I0LmpzJztcbmltcG9ydCB7IGNyZWF0ZUNhbnZhc0VsZW1lbnQgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgeyBSRVZJU0lPTiB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbmNsYXNzIEJhY2tlbmQge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzID0ge30gKSB7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgcGFyYW1ldGVycyApO1xuXHRcdHRoaXMuZGF0YSA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0dGhpcy5yZW5kZXJlciA9IG51bGw7XG5cdFx0dGhpcy5kb21FbGVtZW50ID0gbnVsbDtcblxuXHR9XG5cblx0YXN5bmMgaW5pdCggcmVuZGVyZXIgKSB7XG5cblx0XHR0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cblx0fVxuXG5cdC8vIHJlbmRlciBjb250ZXh0XG5cblx0YmVnaW4oIC8qcmVuZGVyQ29udGV4dCovICkgeyB9XG5cblx0ZmluaXNoKCAvKnJlbmRlckNvbnRleHQqLyApIHsgfVxuXG5cdC8vIHJlbmRlciBvYmplY3RcblxuXHRkcmF3KCAvKnJlbmRlck9iamVjdCwgaW5mbyovICkgeyB9XG5cblx0Ly8gcHJvZ3JhbVxuXG5cdGNyZWF0ZVByb2dyYW0oIC8qcHJvZ3JhbSovICkgeyB9XG5cblx0ZGVzdHJveVByb2dyYW0oIC8qcHJvZ3JhbSovICkgeyB9XG5cblx0Ly8gYmluZGluZ3NcblxuXHRjcmVhdGVCaW5kaW5ncyggLypiaW5nR3JvdXAsIGJpbmRpbmdzKi8gKSB7IH1cblxuXHR1cGRhdGVCaW5kaW5ncyggLypiaW5nR3JvdXAsIGJpbmRpbmdzKi8gKSB7IH1cblxuXHQvLyBwaXBlbGluZVxuXG5cdGNyZWF0ZVJlbmRlclBpcGVsaW5lKCAvKnJlbmRlck9iamVjdCovICkgeyB9XG5cblx0Y3JlYXRlQ29tcHV0ZVBpcGVsaW5lKCAvKmNvbXB1dGVOb2RlLCBwaXBlbGluZSovICkgeyB9XG5cblx0ZGVzdHJveVBpcGVsaW5lKCAvKnBpcGVsaW5lKi8gKSB7IH1cblxuXHQvLyBjYWNoZSBrZXlcblxuXHRuZWVkc1JlbmRlclVwZGF0ZSggLypyZW5kZXJPYmplY3QqLyApIHsgfSAvLyByZXR1cm4gQm9vbGVhbiAoIGZhc3QgdGVzdCApXG5cblx0Z2V0UmVuZGVyQ2FjaGVLZXkoIC8qcmVuZGVyT2JqZWN0Ki8gKSB7IH0gLy8gcmV0dXJuIFN0cmluZ1xuXG5cdC8vIG5vZGUgYnVpbGRlclxuXG5cdGNyZWF0ZU5vZGVCdWlsZGVyKCAvKnJlbmRlck9iamVjdCovICkgeyB9IC8vIHJldHVybiBOb2RlQnVpbGRlciAoQUREIElUKVxuXG5cdC8vIHRleHR1cmVzXG5cblx0Y3JlYXRlU2FtcGxlciggLyp0ZXh0dXJlKi8gKSB7IH1cblxuXHRjcmVhdGVEZWZhdWx0VGV4dHVyZSggLyp0ZXh0dXJlKi8gKSB7IH1cblxuXHRjcmVhdGVUZXh0dXJlKCAvKnRleHR1cmUqLyApIHsgfVxuXG5cdGNvcHlUZXh0dXJlVG9CdWZmZXIoIC8qdGV4dHVyZSwgeCwgeSwgd2lkdGgsIGhlaWdodCovICkge31cblxuXHQvLyBhdHRyaWJ1dGVzXG5cblx0Y3JlYXRlQXR0cmlidXRlKCAvKmF0dHJpYnV0ZSovICkgeyB9XG5cblx0Y3JlYXRlSW5kZXhBdHRyaWJ1dGUoIC8qYXR0cmlidXRlKi8gKSB7IH1cblxuXHR1cGRhdGVBdHRyaWJ1dGUoIC8qYXR0cmlidXRlKi8gKSB7IH1cblxuXHRkZXN0cm95QXR0cmlidXRlKCAvKmF0dHJpYnV0ZSovICkgeyB9XG5cblx0Ly8gY2FudmFzXG5cblx0Z2V0Q29udGV4dCgpIHsgfVxuXG5cdHVwZGF0ZVNpemUoKSB7IH1cblxuXHQvLyB1dGlsc1xuXG5cdHJlc29sdmVUaW1lc3RhbXBBc3luYyggLypyZW5kZXJDb250ZXh0LCB0eXBlKi8gKSB7IH1cblxuXHRoYXNGZWF0dXJlQXN5bmMoIC8qbmFtZSovICkgeyB9IC8vIHJldHVybiBCb29sZWFuXG5cblx0aGFzRmVhdHVyZSggLypuYW1lKi8gKSB7IH0gLy8gcmV0dXJuIEJvb2xlYW5cblxuXHRnZXRJbnN0YW5jZUNvdW50KCByZW5kZXJPYmplY3QgKSB7XG5cblx0XHRjb25zdCB7IG9iamVjdCwgZ2VvbWV0cnkgfSA9IHJlbmRlck9iamVjdDtcblxuXHRcdHJldHVybiBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID8gZ2VvbWV0cnkuaW5zdGFuY2VDb3VudCA6ICggb2JqZWN0LmNvdW50ID4gMSA/IG9iamVjdC5jb3VudCA6IDEgKTtcblxuXHR9XG5cblx0Z2V0RHJhd2luZ0J1ZmZlclNpemUoKSB7XG5cblx0XHR2ZWN0b3IyID0gdmVjdG9yMiB8fCBuZXcgVmVjdG9yMigpO1xuXG5cdFx0cmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0RHJhd2luZ0J1ZmZlclNpemUoIHZlY3RvcjIgKTtcblxuXHR9XG5cblx0Z2V0U2Npc3NvcigpIHtcblxuXHRcdHZlY3RvcjQgPSB2ZWN0b3I0IHx8IG5ldyBWZWN0b3I0KCk7XG5cblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRTY2lzc29yKCB2ZWN0b3I0ICk7XG5cblx0fVxuXG5cdHNldFNjaXNzb3JUZXN0KCAvKmJvb2xlYW4qLyApIHsgfVxuXG5cdGdldENsZWFyQ29sb3IoKSB7XG5cblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cblx0XHRjb2xvcjQgPSBjb2xvcjQgfHwgbmV3IENvbG9yNCgpO1xuXG5cdFx0cmVuZGVyZXIuZ2V0Q2xlYXJDb2xvciggY29sb3I0ICk7XG5cblx0XHRjb2xvcjQuZ2V0UkdCKCBjb2xvcjQsIHRoaXMucmVuZGVyZXIuY3VycmVudENvbG9yU3BhY2UgKTtcblxuXHRcdHJldHVybiBjb2xvcjQ7XG5cblx0fVxuXG5cdGdldERvbUVsZW1lbnQoKSB7XG5cblx0XHRsZXQgZG9tRWxlbWVudCA9IHRoaXMuZG9tRWxlbWVudDtcblxuXHRcdGlmICggZG9tRWxlbWVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0ZG9tRWxlbWVudCA9ICggdGhpcy5wYXJhbWV0ZXJzLmNhbnZhcyAhPT0gdW5kZWZpbmVkICkgPyB0aGlzLnBhcmFtZXRlcnMuY2FudmFzIDogY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuXG5cdFx0XHQvLyBPZmZzY3JlZW5DYW52YXMgZG9lcyBub3QgaGF2ZSBzZXRBdHRyaWJ1dGUsIHNlZSAjMjI4MTFcblx0XHRcdGlmICggJ3NldEF0dHJpYnV0ZScgaW4gZG9tRWxlbWVudCApIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKCAnZGF0YS1lbmdpbmUnLCBgdGhyZWUuanMgciR7UkVWSVNJT059IHdlYmdwdWAgKTtcblxuXHRcdFx0dGhpcy5kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkb21FbGVtZW50O1xuXG5cdH1cblxuXHQvLyByZXNvdXJjZSBwcm9wZXJ0aWVzXG5cblx0c2V0KCBvYmplY3QsIHZhbHVlICkge1xuXG5cdFx0dGhpcy5kYXRhLnNldCggb2JqZWN0LCB2YWx1ZSApO1xuXG5cdH1cblxuXHRnZXQoIG9iamVjdCApIHtcblxuXHRcdGxldCBtYXAgPSB0aGlzLmRhdGEuZ2V0KCBvYmplY3QgKTtcblxuXHRcdGlmICggbWFwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hcCA9IHt9O1xuXHRcdFx0dGhpcy5kYXRhLnNldCggb2JqZWN0LCBtYXAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXA7XG5cblx0fVxuXG5cdGhhcyggb2JqZWN0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5oYXMoIG9iamVjdCApO1xuXG5cdH1cblxuXHRkZWxldGUoIG9iamVjdCApIHtcblxuXHRcdHRoaXMuZGF0YS5kZWxldGUoIG9iamVjdCApO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkgeyB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFja2VuZDtcbiIsImltcG9ydCB7IEludFR5cGUgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuXG5sZXQgX2lkID0gMDtcblxuY2xhc3MgRHVhbEF0dHJpYnV0ZURhdGEge1xuXG5cdGNvbnN0cnVjdG9yKCBhdHRyaWJ1dGVEYXRhLCBkdWFsQnVmZmVyICkge1xuXG5cdFx0dGhpcy5idWZmZXJzID0gWyBhdHRyaWJ1dGVEYXRhLmJ1ZmZlckdQVSwgZHVhbEJ1ZmZlciBdO1xuXHRcdHRoaXMudHlwZSA9IGF0dHJpYnV0ZURhdGEudHlwZTtcblx0XHR0aGlzLmJ1ZmZlclR5cGUgPSBhdHRyaWJ1dGVEYXRhLmJ1ZmZlclR5cGU7XG5cdFx0dGhpcy5wYm8gPSBhdHRyaWJ1dGVEYXRhLnBibztcblx0XHR0aGlzLmJ5dGVMZW5ndGggPSBhdHRyaWJ1dGVEYXRhLmJ5dGVMZW5ndGg7XG5cdFx0dGhpcy5ieXRlc1BlckVsZW1lbnQgPSBhdHRyaWJ1dGVEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xuXHRcdHRoaXMudmVyc2lvbiA9IGF0dHJpYnV0ZURhdGEudmVyc2lvbjtcblx0XHR0aGlzLmlzSW50ZWdlciA9IGF0dHJpYnV0ZURhdGEuaXNJbnRlZ2VyO1xuXHRcdHRoaXMuYWN0aXZlQnVmZmVySW5kZXggPSAwO1xuXHRcdHRoaXMuYmFzZUlkID0gYXR0cmlidXRlRGF0YS5pZDtcblxuXHR9XG5cblxuXHRnZXQgaWQoKSB7XG5cblx0XHRyZXR1cm4gYCR7IHRoaXMuYmFzZUlkIH18JHsgdGhpcy5hY3RpdmVCdWZmZXJJbmRleCB9YDtcblxuXHR9XG5cblx0Z2V0IGJ1ZmZlckdQVSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmJ1ZmZlcnNbIHRoaXMuYWN0aXZlQnVmZmVySW5kZXggXTtcblxuXHR9XG5cblx0Z2V0IHRyYW5zZm9ybUJ1ZmZlcigpIHtcblxuXHRcdHJldHVybiB0aGlzLmJ1ZmZlcnNbIHRoaXMuYWN0aXZlQnVmZmVySW5kZXggXiAxIF07XG5cblx0fVxuXG5cdHN3aXRjaEJ1ZmZlcnMoKSB7XG5cblx0XHR0aGlzLmFjdGl2ZUJ1ZmZlckluZGV4IF49IDE7XG5cblx0fVxuXG59XG5cbmNsYXNzIFdlYkdMQXR0cmlidXRlVXRpbHMge1xuXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xuXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcblxuXHR9XG5cblx0Y3JlYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XG5cblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXHRcdGNvbnN0IHsgZ2wgfSA9IGJhY2tlbmQ7XG5cblx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcblx0XHRjb25zdCB1c2FnZSA9IGF0dHJpYnV0ZS51c2FnZSB8fCBnbC5TVEFUSUNfRFJBVztcblxuXHRcdGNvbnN0IGJ1ZmZlckF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID8gYXR0cmlidXRlLmRhdGEgOiBhdHRyaWJ1dGU7XG5cdFx0Y29uc3QgYnVmZmVyRGF0YSA9IGJhY2tlbmQuZ2V0KCBidWZmZXJBdHRyaWJ1dGUgKTtcblxuXHRcdGxldCBidWZmZXJHUFUgPSBidWZmZXJEYXRhLmJ1ZmZlckdQVTtcblxuXHRcdGlmICggYnVmZmVyR1BVID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJ1ZmZlckdQVSA9IHRoaXMuX2NyZWF0ZUJ1ZmZlciggZ2wsIGJ1ZmZlclR5cGUsIGFycmF5LCB1c2FnZSApO1xuXG5cdFx0XHRidWZmZXJEYXRhLmJ1ZmZlckdQVSA9IGJ1ZmZlckdQVTtcblx0XHRcdGJ1ZmZlckRhdGEuYnVmZmVyVHlwZSA9IGJ1ZmZlclR5cGU7XG5cdFx0XHRidWZmZXJEYXRhLnZlcnNpb24gPSBidWZmZXJBdHRyaWJ1dGUudmVyc2lvbjtcblxuXHRcdH1cblxuXHRcdC8vYXR0cmlidXRlLm9uVXBsb2FkQ2FsbGJhY2soKTtcblxuXHRcdGxldCB0eXBlO1xuXG5cdFx0aWYgKCBhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSApIHtcblxuXHRcdFx0dHlwZSA9IGdsLkZMT0FUO1xuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSApIHtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXNGbG9hdDE2QnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdHR5cGUgPSBnbC5IQUxGX0ZMT0FUO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9TSE9SVDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5ICkge1xuXG5cdFx0XHR0eXBlID0gZ2wuU0hPUlQ7XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ICkge1xuXG5cdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfSU5UO1xuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5ICkge1xuXG5cdFx0XHR0eXBlID0gZ2wuSU5UO1xuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5CWVRFO1xuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ICkge1xuXG5cdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfQllURTtcblxuXHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgKSB7XG5cblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuV2ViR0xCYWNrZW5kOiBVbnN1cHBvcnRlZCBidWZmZXIgZGF0YSBmb3JtYXQ6ICcgKyBhcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGF0dHJpYnV0ZURhdGEgPSB7XG5cdFx0XHRidWZmZXJHUFUsXG5cdFx0XHRidWZmZXJUeXBlLFxuXHRcdFx0dHlwZSxcblx0XHRcdGJ5dGVMZW5ndGg6IGFycmF5LmJ5dGVMZW5ndGgsXG5cdFx0XHRieXRlc1BlckVsZW1lbnQ6IGFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuXHRcdFx0dmVyc2lvbjogYXR0cmlidXRlLnZlcnNpb24sXG5cdFx0XHRwYm86IGF0dHJpYnV0ZS5wYm8sXG5cdFx0XHRpc0ludGVnZXI6IHR5cGUgPT09IGdsLklOVCB8fCB0eXBlID09PSBnbC5VTlNJR05FRF9JTlQgfHwgYXR0cmlidXRlLmdwdVR5cGUgPT09IEludFR5cGUsXG5cdFx0XHRpZDogX2lkICsrXG5cdFx0fTtcblxuXHRcdGlmICggYXR0cmlidXRlLmlzU3RvcmFnZUJ1ZmZlckF0dHJpYnV0ZSB8fCBhdHRyaWJ1dGUuaXNTdG9yYWdlSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHQvLyBjcmVhdGUgYnVmZmVyIGZvciB0cmFuZm9ybSBmZWVkYmFjayB1c2Vcblx0XHRcdGNvbnN0IGJ1ZmZlckdQVUR1YWwgPSB0aGlzLl9jcmVhdGVCdWZmZXIoIGdsLCBidWZmZXJUeXBlLCBhcnJheSwgdXNhZ2UgKTtcblx0XHRcdGF0dHJpYnV0ZURhdGEgPSBuZXcgRHVhbEF0dHJpYnV0ZURhdGEoIGF0dHJpYnV0ZURhdGEsIGJ1ZmZlckdQVUR1YWwgKTtcblxuXHRcdH1cblxuXHRcdGJhY2tlbmQuc2V0KCBhdHRyaWJ1dGUsIGF0dHJpYnV0ZURhdGEgKTtcblxuXHR9XG5cblx0dXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXHRcdGNvbnN0IHsgZ2wgfSA9IGJhY2tlbmQ7XG5cblx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcblx0XHRjb25zdCBidWZmZXJBdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA/IGF0dHJpYnV0ZS5kYXRhIDogYXR0cmlidXRlO1xuXHRcdGNvbnN0IGJ1ZmZlckRhdGEgPSBiYWNrZW5kLmdldCggYnVmZmVyQXR0cmlidXRlICk7XG5cdFx0Y29uc3QgYnVmZmVyVHlwZSA9IGJ1ZmZlckRhdGEuYnVmZmVyVHlwZTtcblx0XHRjb25zdCB1cGRhdGVSYW5nZXMgPSBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA/IGF0dHJpYnV0ZS5kYXRhLnVwZGF0ZVJhbmdlcyA6IGF0dHJpYnV0ZS51cGRhdGVSYW5nZXM7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBidWZmZXJEYXRhLmJ1ZmZlckdQVSApO1xuXG5cdFx0aWYgKCB1cGRhdGVSYW5nZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHQvLyBOb3QgdXNpbmcgdXBkYXRlIHJhbmdlc1xuXG5cdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCAwLCBhcnJheSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdXBkYXRlUmFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgcmFuZ2UgPSB1cGRhdGVSYW5nZXNbIGkgXTtcblx0XHRcdFx0Z2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgcmFuZ2Uuc3RhcnQgKiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcblx0XHRcdFx0XHRhcnJheSwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmNvdW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YnVmZmVyQXR0cmlidXRlLmNsZWFyVXBkYXRlUmFuZ2VzKCk7XG5cblx0XHR9XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBudWxsICk7XG5cblx0XHRidWZmZXJEYXRhLnZlcnNpb24gPSBidWZmZXJBdHRyaWJ1dGUudmVyc2lvbjtcblxuXHR9XG5cblx0ZGVzdHJveUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcblx0XHRjb25zdCB7IGdsIH0gPSBiYWNrZW5kO1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0YmFja2VuZC5kZWxldGUoIGF0dHJpYnV0ZS5kYXRhICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBhdHRyaWJ1dGVEYXRhID0gYmFja2VuZC5nZXQoIGF0dHJpYnV0ZSApO1xuXG5cdFx0Z2wuZGVsZXRlQnVmZmVyKCBhdHRyaWJ1dGVEYXRhLmJ1ZmZlckdQVSApO1xuXG5cdFx0YmFja2VuZC5kZWxldGUoIGF0dHJpYnV0ZSApO1xuXG5cdH1cblxuXHRhc3luYyBnZXRBcnJheUJ1ZmZlckFzeW5jKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXHRcdGNvbnN0IHsgZ2wgfSA9IGJhY2tlbmQ7XG5cblx0XHRjb25zdCBidWZmZXJBdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA/IGF0dHJpYnV0ZS5kYXRhIDogYXR0cmlidXRlO1xuXHRcdGNvbnN0IHsgYnVmZmVyR1BVIH0gPSBiYWNrZW5kLmdldCggYnVmZmVyQXR0cmlidXRlICk7XG5cblx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcblx0XHRjb25zdCBieXRlTGVuZ3RoID0gYXJyYXkuYnl0ZUxlbmd0aDtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkNPUFlfUkVBRF9CVUZGRVIsIGJ1ZmZlckdQVSApO1xuXG5cdFx0Y29uc3Qgd3JpdGVCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkNPUFlfV1JJVEVfQlVGRkVSLCB3cml0ZUJ1ZmZlciApO1xuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkNPUFlfV1JJVEVfQlVGRkVSLCBieXRlTGVuZ3RoLCBnbC5TVFJFQU1fUkVBRCApO1xuXG5cdFx0Z2wuY29weUJ1ZmZlclN1YkRhdGEoIGdsLkNPUFlfUkVBRF9CVUZGRVIsIGdsLkNPUFlfV1JJVEVfQlVGRkVSLCAwLCAwLCBieXRlTGVuZ3RoICk7XG5cblx0XHRhd2FpdCBiYWNrZW5kLnV0aWxzLl9jbGllbnRXYWl0QXN5bmMoKTtcblxuXHRcdGNvbnN0IGRzdEJ1ZmZlciA9IG5ldyBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IoIGFycmF5Lmxlbmd0aCApO1xuXG5cdFx0Ly8gRW5zdXJlIHRoZSBidWZmZXIgaXMgYm91bmQgYmVmb3JlIHJlYWRpbmdcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5DT1BZX1dSSVRFX0JVRkZFUiwgd3JpdGVCdWZmZXIgKTtcblxuXHRcdGdsLmdldEJ1ZmZlclN1YkRhdGEoIGdsLkNPUFlfV1JJVEVfQlVGRkVSLCAwLCBkc3RCdWZmZXIgKTtcblxuXHRcdGdsLmRlbGV0ZUJ1ZmZlciggd3JpdGVCdWZmZXIgKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkNPUFlfUkVBRF9CVUZGRVIsIG51bGwgKTtcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5DT1BZX1dSSVRFX0JVRkZFUiwgbnVsbCApO1xuXG5cdFx0cmV0dXJuIGRzdEJ1ZmZlci5idWZmZXI7XG5cblx0fVxuXG5cdF9jcmVhdGVCdWZmZXIoIGdsLCBidWZmZXJUeXBlLCBhcnJheSwgdXNhZ2UgKSB7XG5cblx0XHRjb25zdCBidWZmZXJHUFUgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGJ1ZmZlckdQVSApO1xuXHRcdGdsLmJ1ZmZlckRhdGEoIGJ1ZmZlclR5cGUsIGFycmF5LCB1c2FnZSApO1xuXHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIG51bGwgKTtcblxuXHRcdHJldHVybiBidWZmZXJHUFU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdlYkdMQXR0cmlidXRlVXRpbHM7XG4iLCJpbXBvcnQge1xuXHRDdWxsRmFjZU5vbmUsIEN1bGxGYWNlQmFjaywgQ3VsbEZhY2VGcm9udCwgRG91YmxlU2lkZSwgQmFja1NpZGUsXG5cdE5vcm1hbEJsZW5kaW5nLCBOb0JsZW5kaW5nLCBDdXN0b21CbGVuZGluZywgQWRkRXF1YXRpb24sXG5cdEFkZGl0aXZlQmxlbmRpbmcsIFN1YnRyYWN0aXZlQmxlbmRpbmcsIE11bHRpcGx5QmxlbmRpbmcsIFN1YnRyYWN0RXF1YXRpb24sIFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uLFxuXHRaZXJvRmFjdG9yLCBPbmVGYWN0b3IsIFNyY0NvbG9yRmFjdG9yLCBTcmNBbHBoYUZhY3RvciwgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciwgRHN0Q29sb3JGYWN0b3IsIERzdEFscGhhRmFjdG9yLFxuXHRPbmVNaW51c1NyY0NvbG9yRmFjdG9yLCBPbmVNaW51c1NyY0FscGhhRmFjdG9yLCBPbmVNaW51c0RzdENvbG9yRmFjdG9yLCBPbmVNaW51c0RzdEFscGhhRmFjdG9yLFxuXHROZXZlckRlcHRoLCBBbHdheXNEZXB0aCwgTGVzc0RlcHRoLCBMZXNzRXF1YWxEZXB0aCwgRXF1YWxEZXB0aCwgR3JlYXRlckVxdWFsRGVwdGgsIEdyZWF0ZXJEZXB0aCwgTm90RXF1YWxEZXB0aFxufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuXG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZSwgZXF1YXRpb25Ub0dMLCBmYWN0b3JUb0dMO1xuXG5jbGFzcyBXZWJHTFN0YXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYmFja2VuZCApIHtcblxuXHRcdHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XG5cblx0XHR0aGlzLmdsID0gdGhpcy5iYWNrZW5kLmdsO1xuXG5cdFx0dGhpcy5lbmFibGVkID0ge307XG5cdFx0dGhpcy5jdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblx0XHR0aGlzLmN1cnJlbnRDdWxsRmFjZSA9IG51bGw7XG5cdFx0dGhpcy5jdXJyZW50UHJvZ3JhbSA9IG51bGw7XG5cdFx0dGhpcy5jdXJyZW50QmxlbmRpbmdFbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5jdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuXHRcdHRoaXMuY3VycmVudEJsZW5kU3JjID0gbnVsbDtcblx0XHR0aGlzLmN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG5cdFx0dGhpcy5jdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG5cdFx0dGhpcy5jdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0dGhpcy5jdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBudWxsO1xuXHRcdHRoaXMuY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsO1xuXHRcdHRoaXMuY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XG5cdFx0dGhpcy5jdXJyZW50Q29sb3JNYXNrID0gbnVsbDtcblx0XHR0aGlzLmN1cnJlbnREZXB0aEZ1bmMgPSBudWxsO1xuXHRcdHRoaXMuY3VycmVudERlcHRoTWFzayA9IG51bGw7XG5cdFx0dGhpcy5jdXJyZW50U3RlbmNpbEZ1bmMgPSBudWxsO1xuXHRcdHRoaXMuY3VycmVudFN0ZW5jaWxSZWYgPSBudWxsO1xuXHRcdHRoaXMuY3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IG51bGw7XG5cdFx0dGhpcy5jdXJyZW50U3RlbmNpbEZhaWwgPSBudWxsO1xuXHRcdHRoaXMuY3VycmVudFN0ZW5jaWxaRmFpbCA9IG51bGw7XG5cdFx0dGhpcy5jdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcblx0XHR0aGlzLmN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XG5cdFx0dGhpcy5jdXJyZW50TGluZVdpZHRoID0gbnVsbDtcblx0XHR0aGlzLmN1cnJlbnRDbGlwcGluZ1BsYW5lcyA9IDA7XG5cblx0XHR0aGlzLmN1cnJlbnRCb3VuZEZyYW1lYnVmZmVycyA9IHt9O1xuXHRcdHRoaXMuY3VycmVudERyYXdidWZmZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdHRoaXMubWF4VGV4dHVyZXMgPSB0aGlzLmdsLmdldFBhcmFtZXRlciggdGhpcy5nbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xuXHRcdHRoaXMuY3VycmVudFRleHR1cmVTbG90ID0gbnVsbDtcblx0XHR0aGlzLmN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XG5cdFx0dGhpcy5jdXJyZW50Qm91bmRCdWZmZXJCYXNlcyA9IHt9O1xuXG5cdFx0aWYgKCBpbml0aWFsaXplZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRoaXMuX2luaXQoIHRoaXMuZ2wgKTtcblxuXHRcdFx0aW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfaW5pdCggZ2wgKSB7XG5cblx0XHQvLyBTdG9yZSBvbmx5IFdlYkdMIGNvbnN0YW50cyBoZXJlLlxuXG5cdFx0ZXF1YXRpb25Ub0dMID0ge1xuXHRcdFx0WyBBZGRFcXVhdGlvbiBdOiBnbC5GVU5DX0FERCxcblx0XHRcdFsgU3VidHJhY3RFcXVhdGlvbiBdOiBnbC5GVU5DX1NVQlRSQUNULFxuXHRcdFx0WyBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiBdOiBnbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1Rcblx0XHR9O1xuXG5cdFx0ZmFjdG9yVG9HTCA9IHtcblx0XHRcdFsgWmVyb0ZhY3RvciBdOiBnbC5aRVJPLFxuXHRcdFx0WyBPbmVGYWN0b3IgXTogZ2wuT05FLFxuXHRcdFx0WyBTcmNDb2xvckZhY3RvciBdOiBnbC5TUkNfQ09MT1IsXG5cdFx0XHRbIFNyY0FscGhhRmFjdG9yIF06IGdsLlNSQ19BTFBIQSxcblx0XHRcdFsgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciBdOiBnbC5TUkNfQUxQSEFfU0FUVVJBVEUsXG5cdFx0XHRbIERzdENvbG9yRmFjdG9yIF06IGdsLkRTVF9DT0xPUixcblx0XHRcdFsgRHN0QWxwaGFGYWN0b3IgXTogZ2wuRFNUX0FMUEhBLFxuXHRcdFx0WyBPbmVNaW51c1NyY0NvbG9yRmFjdG9yIF06IGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsXG5cdFx0XHRbIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgXTogZ2wuT05FX01JTlVTX1NSQ19BTFBIQSxcblx0XHRcdFsgT25lTWludXNEc3RDb2xvckZhY3RvciBdOiBnbC5PTkVfTUlOVVNfRFNUX0NPTE9SLFxuXHRcdFx0WyBPbmVNaW51c0RzdEFscGhhRmFjdG9yIF06IGdsLk9ORV9NSU5VU19EU1RfQUxQSEFcblx0XHR9O1xuXG5cdH1cblxuXHRlbmFibGUoIGlkICkge1xuXG5cdFx0Y29uc3QgeyBlbmFibGVkIH0gPSB0aGlzO1xuXG5cdFx0aWYgKCBlbmFibGVkWyBpZCBdICE9PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLmdsLmVuYWJsZSggaWQgKTtcblx0XHRcdGVuYWJsZWRbIGlkIF0gPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRkaXNhYmxlKCBpZCApIHtcblxuXHRcdGNvbnN0IHsgZW5hYmxlZCB9ID0gdGhpcztcblxuXHRcdGlmICggZW5hYmxlZFsgaWQgXSAhPT0gZmFsc2UgKSB7XG5cblx0XHRcdHRoaXMuZ2wuZGlzYWJsZSggaWQgKTtcblx0XHRcdGVuYWJsZWRbIGlkIF0gPSBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2V0RmxpcFNpZGVkKCBmbGlwU2lkZWQgKSB7XG5cblx0XHRpZiAoIHRoaXMuY3VycmVudEZsaXBTaWRlZCAhPT0gZmxpcFNpZGVkICkge1xuXG5cdFx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xuXG5cdFx0XHRpZiAoIGZsaXBTaWRlZCApIHtcblxuXHRcdFx0XHRnbC5mcm9udEZhY2UoIGdsLkNXICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldEN1bGxGYWNlKCBjdWxsRmFjZSApIHtcblxuXHRcdGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG5cblx0XHRpZiAoIGN1bGxGYWNlICE9PSBDdWxsRmFjZU5vbmUgKSB7XG5cblx0XHRcdHRoaXMuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdFx0aWYgKCBjdWxsRmFjZSAhPT0gdGhpcy5jdXJyZW50Q3VsbEZhY2UgKSB7XG5cblx0XHRcdFx0aWYgKCBjdWxsRmFjZSA9PT0gQ3VsbEZhY2VCYWNrICkge1xuXG5cdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkJBQ0sgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjdWxsRmFjZSA9PT0gQ3VsbEZhY2VGcm9udCApIHtcblxuXHRcdFx0XHRcdGdsLmN1bGxGYWNlKCBnbC5GUk9OVCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRnbC5jdWxsRmFjZSggZ2wuRlJPTlRfQU5EX0JBQ0sgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmN1cnJlbnRDdWxsRmFjZSA9IGN1bGxGYWNlO1xuXG5cdH1cblxuXHRzZXRMaW5lV2lkdGgoIHdpZHRoICkge1xuXG5cdFx0Y29uc3QgeyBjdXJyZW50TGluZVdpZHRoLCBnbCB9ID0gdGhpcztcblxuXHRcdGlmICggd2lkdGggIT09IGN1cnJlbnRMaW5lV2lkdGggKSB7XG5cblx0XHRcdGdsLmxpbmVXaWR0aCggd2lkdGggKTtcblxuXHRcdFx0dGhpcy5jdXJyZW50TGluZVdpZHRoID0gd2lkdGg7XG5cblx0XHR9XG5cblx0fVxuXG5cblx0c2V0QmxlbmRpbmcoIGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QsIGJsZW5kRXF1YXRpb25BbHBoYSwgYmxlbmRTcmNBbHBoYSwgYmxlbmREc3RBbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhICkge1xuXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcblxuXHRcdGlmICggYmxlbmRpbmcgPT09IE5vQmxlbmRpbmcgKSB7XG5cblx0XHRcdGlmICggdGhpcy5jdXJyZW50QmxlbmRpbmdFbmFibGVkID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHRoaXMuZGlzYWJsZSggZ2wuQkxFTkQgKTtcblx0XHRcdFx0dGhpcy5jdXJyZW50QmxlbmRpbmdFbmFibGVkID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHR0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcblx0XHRcdHRoaXMuY3VycmVudEJsZW5kaW5nRW5hYmxlZCA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIGJsZW5kaW5nICE9PSBDdXN0b21CbGVuZGluZyApIHtcblxuXHRcdFx0aWYgKCBibGVuZGluZyAhPT0gdGhpcy5jdXJyZW50QmxlbmRpbmcgfHwgcHJlbXVsdGlwbGllZEFscGhhICE9PSB0aGlzLmN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSApIHtcblxuXHRcdFx0XHRpZiAoIHRoaXMuY3VycmVudEJsZW5kRXF1YXRpb24gIT09IEFkZEVxdWF0aW9uIHx8IHRoaXMuY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSAhPT0gQWRkRXF1YXRpb24gKSB7XG5cblx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuXG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50QmxlbmRFcXVhdGlvbiA9IEFkZEVxdWF0aW9uO1xuXHRcdFx0XHRcdHRoaXMuY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IEFkZEVxdWF0aW9uO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGJsZW5kaW5nICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlIE5vcm1hbEJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5PTkUsIGdsLk9ORSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBTdWJ0cmFjdGl2ZUJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuT05FICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIE11bHRpcGx5QmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IsIGdsLlpFUk8sIGdsLlNSQ19BTFBIQSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6ICcsIGJsZW5kaW5nICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBibGVuZGluZyApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSBOb3JtYWxCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEFkZGl0aXZlQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgU3VidHJhY3RpdmVCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLlpFUk8sIGdsLk9ORSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBNdWx0aXBseUJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLlNSQ19DT0xPUiApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6ICcsIGJsZW5kaW5nICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG5cdFx0XHRcdHRoaXMuY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcblx0XHRcdFx0dGhpcy5jdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG5cdFx0XHRcdHRoaXMuY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXG5cdFx0XHRcdHRoaXMuY3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XG5cdFx0XHRcdHRoaXMuY3VycmVudFByZW11bHRpcGxlZEFscGhhID0gcHJlbXVsdGlwbGllZEFscGhhO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdC8vIGN1c3RvbSBibGVuZGluZ1xuXG5cdFx0YmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhIHx8IGJsZW5kRXF1YXRpb247XG5cdFx0YmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XG5cdFx0YmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XG5cblx0XHRpZiAoIGJsZW5kRXF1YXRpb24gIT09IHRoaXMuY3VycmVudEJsZW5kRXF1YXRpb24gfHwgYmxlbmRFcXVhdGlvbkFscGhhICE9PSB0aGlzLmN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgKSB7XG5cblx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZXF1YXRpb25Ub0dMWyBibGVuZEVxdWF0aW9uIF0sIGVxdWF0aW9uVG9HTFsgYmxlbmRFcXVhdGlvbkFscGhhIF0gKTtcblxuXHRcdFx0dGhpcy5jdXJyZW50QmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XG5cdFx0XHR0aGlzLmN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGE7XG5cblx0XHR9XG5cblx0XHRpZiAoIGJsZW5kU3JjICE9PSB0aGlzLmN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gdGhpcy5jdXJyZW50QmxlbmREc3QgfHwgYmxlbmRTcmNBbHBoYSAhPT0gdGhpcy5jdXJyZW50QmxlbmRTcmNBbHBoYSB8fCBibGVuZERzdEFscGhhICE9PSB0aGlzLmN1cnJlbnRCbGVuZERzdEFscGhhICkge1xuXG5cdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZmFjdG9yVG9HTFsgYmxlbmRTcmMgXSwgZmFjdG9yVG9HTFsgYmxlbmREc3QgXSwgZmFjdG9yVG9HTFsgYmxlbmRTcmNBbHBoYSBdLCBmYWN0b3JUb0dMWyBibGVuZERzdEFscGhhIF0gKTtcblxuXHRcdFx0dGhpcy5jdXJyZW50QmxlbmRTcmMgPSBibGVuZFNyYztcblx0XHRcdHRoaXMuY3VycmVudEJsZW5kRHN0ID0gYmxlbmREc3Q7XG5cdFx0XHR0aGlzLmN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcblx0XHRcdHRoaXMuY3VycmVudEJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcblx0XHR0aGlzLmN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IGZhbHNlO1xuXG5cdH1cblxuXHRzZXRDb2xvck1hc2soIGNvbG9yTWFzayApIHtcblxuXHRcdGlmICggdGhpcy5jdXJyZW50Q29sb3JNYXNrICE9PSBjb2xvck1hc2sgKSB7XG5cblx0XHRcdHRoaXMuZ2wuY29sb3JNYXNrKCBjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrLCBjb2xvck1hc2sgKTtcblx0XHRcdHRoaXMuY3VycmVudENvbG9yTWFzayA9IGNvbG9yTWFzaztcblxuXHRcdH1cblxuXHR9XG5cblx0c2V0RGVwdGhUZXN0KCBkZXB0aFRlc3QgKSB7XG5cblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xuXG5cdFx0aWYgKCBkZXB0aFRlc3QgKSB7XG5cblx0XHRcdHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2V0RGVwdGhNYXNrKCBkZXB0aE1hc2sgKSB7XG5cblx0XHRpZiAoIHRoaXMuY3VycmVudERlcHRoTWFzayAhPT0gZGVwdGhNYXNrICkge1xuXG5cdFx0XHR0aGlzLmdsLmRlcHRoTWFzayggZGVwdGhNYXNrICk7XG5cdFx0XHR0aGlzLmN1cnJlbnREZXB0aE1hc2sgPSBkZXB0aE1hc2s7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldERlcHRoRnVuYyggZGVwdGhGdW5jICkge1xuXG5cdFx0aWYgKCB0aGlzLmN1cnJlbnREZXB0aEZ1bmMgIT09IGRlcHRoRnVuYyApIHtcblxuXHRcdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcblxuXHRcdFx0c3dpdGNoICggZGVwdGhGdW5jICkge1xuXG5cdFx0XHRcdGNhc2UgTmV2ZXJEZXB0aDpcblxuXHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTkVWRVIgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIEFsd2F5c0RlcHRoOlxuXG5cdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5BTFdBWVMgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIExlc3NEZXB0aDpcblxuXHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVTUyApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgTGVzc0VxdWFsRGVwdGg6XG5cblx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgRXF1YWxEZXB0aDpcblxuXHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuRVFVQUwgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIEdyZWF0ZXJFcXVhbERlcHRoOlxuXG5cdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5HRVFVQUwgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIEdyZWF0ZXJEZXB0aDpcblxuXHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuR1JFQVRFUiApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgTm90RXF1YWxEZXB0aDpcblxuXHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTk9URVFVQUwgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmN1cnJlbnREZXB0aEZ1bmMgPSBkZXB0aEZ1bmM7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldFN0ZW5jaWxUZXN0KCBzdGVuY2lsVGVzdCApIHtcblxuXHRcdGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG5cblx0XHRpZiAoIHN0ZW5jaWxUZXN0ICkge1xuXG5cdFx0XHR0aGlzLmVuYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmRpc2FibGUoIGdsLlNURU5DSUxfVEVTVCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXRTdGVuY2lsTWFzayggc3RlbmNpbE1hc2sgKSB7XG5cblx0XHRpZiAoIHRoaXMuY3VycmVudFN0ZW5jaWxNYXNrICE9PSBzdGVuY2lsTWFzayApIHtcblxuXHRcdFx0dGhpcy5nbC5zdGVuY2lsTWFzayggc3RlbmNpbE1hc2sgKTtcblx0XHRcdHRoaXMuY3VycmVudFN0ZW5jaWxNYXNrID0gc3RlbmNpbE1hc2s7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldFN0ZW5jaWxGdW5jKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKSB7XG5cblx0XHRpZiAoIHRoaXMuY3VycmVudFN0ZW5jaWxGdW5jICE9PSBzdGVuY2lsRnVuYyB8fFxuXHRcdFx0IHRoaXMuY3VycmVudFN0ZW5jaWxSZWYgIT09IHN0ZW5jaWxSZWYgfHxcblx0XHRcdCB0aGlzLmN1cnJlbnRTdGVuY2lsRnVuY01hc2sgIT09IHN0ZW5jaWxNYXNrICkge1xuXG5cdFx0XHR0aGlzLmdsLnN0ZW5jaWxGdW5jKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKTtcblxuXHRcdFx0dGhpcy5jdXJyZW50U3RlbmNpbEZ1bmMgPSBzdGVuY2lsRnVuYztcblx0XHRcdHRoaXMuY3VycmVudFN0ZW5jaWxSZWYgPSBzdGVuY2lsUmVmO1xuXHRcdFx0dGhpcy5jdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gc3RlbmNpbE1hc2s7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldFN0ZW5jaWxPcCggc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICkge1xuXG5cdFx0aWYgKCB0aGlzLmN1cnJlbnRTdGVuY2lsRmFpbCAhPT0gc3RlbmNpbEZhaWwgfHxcblx0XHRcdCB0aGlzLmN1cnJlbnRTdGVuY2lsWkZhaWwgIT09IHN0ZW5jaWxaRmFpbCB8fFxuXHRcdFx0IHRoaXMuY3VycmVudFN0ZW5jaWxaUGFzcyAhPT0gc3RlbmNpbFpQYXNzICkge1xuXG5cdFx0XHR0aGlzLmdsLnN0ZW5jaWxPcCggc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICk7XG5cblx0XHRcdHRoaXMuY3VycmVudFN0ZW5jaWxGYWlsID0gc3RlbmNpbEZhaWw7XG5cdFx0XHR0aGlzLmN1cnJlbnRTdGVuY2lsWkZhaWwgPSBzdGVuY2lsWkZhaWw7XG5cdFx0XHR0aGlzLmN1cnJlbnRTdGVuY2lsWlBhc3MgPSBzdGVuY2lsWlBhc3M7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldE1hdGVyaWFsKCBtYXRlcmlhbCwgZnJvbnRGYWNlQ1csIGhhcmR3YXJlQ2xpcHBpbmdQbGFuZXMgKSB7XG5cblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xuXG5cdFx0bWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZVxuXHRcdFx0PyB0aGlzLmRpc2FibGUoIGdsLkNVTExfRkFDRSApXG5cdFx0XHQ6IHRoaXMuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdGxldCBmbGlwU2lkZWQgPSAoIG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlICk7XG5cdFx0aWYgKCBmcm9udEZhY2VDVyApIGZsaXBTaWRlZCA9ICEgZmxpcFNpZGVkO1xuXG5cdFx0dGhpcy5zZXRGbGlwU2lkZWQoIGZsaXBTaWRlZCApO1xuXG5cdFx0KCBtYXRlcmlhbC5ibGVuZGluZyA9PT0gTm9ybWFsQmxlbmRpbmcgJiYgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IGZhbHNlIClcblx0XHRcdD8gdGhpcy5zZXRCbGVuZGluZyggTm9CbGVuZGluZyApXG5cdFx0XHQ6IHRoaXMuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSwgbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhICk7XG5cblx0XHR0aGlzLnNldERlcHRoRnVuYyggbWF0ZXJpYWwuZGVwdGhGdW5jICk7XG5cdFx0dGhpcy5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xuXHRcdHRoaXMuc2V0RGVwdGhNYXNrKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XG5cdFx0dGhpcy5zZXRDb2xvck1hc2soIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcblxuXHRcdGNvbnN0IHN0ZW5jaWxXcml0ZSA9IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZTtcblx0XHR0aGlzLnNldFN0ZW5jaWxUZXN0KCBzdGVuY2lsV3JpdGUgKTtcblx0XHRpZiAoIHN0ZW5jaWxXcml0ZSApIHtcblxuXHRcdFx0dGhpcy5zZXRTdGVuY2lsTWFzayggbWF0ZXJpYWwuc3RlbmNpbFdyaXRlTWFzayApO1xuXHRcdFx0dGhpcy5zZXRTdGVuY2lsRnVuYyggbWF0ZXJpYWwuc3RlbmNpbEZ1bmMsIG1hdGVyaWFsLnN0ZW5jaWxSZWYsIG1hdGVyaWFsLnN0ZW5jaWxGdW5jTWFzayApO1xuXHRcdFx0dGhpcy5zZXRTdGVuY2lsT3AoIG1hdGVyaWFsLnN0ZW5jaWxGYWlsLCBtYXRlcmlhbC5zdGVuY2lsWkZhaWwsIG1hdGVyaWFsLnN0ZW5jaWxaUGFzcyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcblxuXHRcdG1hdGVyaWFsLmFscGhhVG9Db3ZlcmFnZSA9PT0gdHJ1ZSAmJiB0aGlzLmJhY2tlbmQucmVuZGVyZXIuc2FtcGxlcyA+IDFcblx0XHRcdD8gdGhpcy5lbmFibGUoIGdsLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSApXG5cdFx0XHQ6IHRoaXMuZGlzYWJsZSggZ2wuU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFICk7XG5cblx0XHRpZiAoIGhhcmR3YXJlQ2xpcHBpbmdQbGFuZXMgPiAwICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuY3VycmVudENsaXBwaW5nUGxhbmVzICE9PSBoYXJkd2FyZUNsaXBwaW5nUGxhbmVzICkge1xuXG5cdFx0XHRcdGNvbnN0IENMSVBfRElTVEFOQ0UwX1dFQkdMID0gMHgzMDAwO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGkgPCBoYXJkd2FyZUNsaXBwaW5nUGxhbmVzICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLmVuYWJsZSggQ0xJUF9ESVNUQU5DRTBfV0VCR0wgKyBpICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0aGlzLmRpc2FibGUoIENMSVBfRElTVEFOQ0UwX1dFQkdMICsgaSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXRQb2x5Z29uT2Zmc2V0KCBwb2x5Z29uT2Zmc2V0LCBmYWN0b3IsIHVuaXRzICkge1xuXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcblxuXHRcdGlmICggcG9seWdvbk9mZnNldCApIHtcblxuXHRcdFx0dGhpcy5lbmFibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcblxuXHRcdFx0aWYgKCB0aGlzLmN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSBmYWN0b3IgfHwgdGhpcy5jdXJyZW50UG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cyApIHtcblxuXHRcdFx0XHRnbC5wb2x5Z29uT2Zmc2V0KCBmYWN0b3IsIHVuaXRzICk7XG5cblx0XHRcdFx0dGhpcy5jdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IGZhY3Rvcjtcblx0XHRcdFx0dGhpcy5jdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuZGlzYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR1c2VQcm9ncmFtKCBwcm9ncmFtICkge1xuXG5cdFx0aWYgKCB0aGlzLmN1cnJlbnRQcm9ncmFtICE9PSBwcm9ncmFtICkge1xuXG5cdFx0XHR0aGlzLmdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdFx0dGhpcy5jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHQvLyBmcmFtZWJ1ZmZlclxuXG5cblx0YmluZEZyYW1lYnVmZmVyKCB0YXJnZXQsIGZyYW1lYnVmZmVyICkge1xuXG5cdFx0Y29uc3QgeyBnbCwgY3VycmVudEJvdW5kRnJhbWVidWZmZXJzIH0gPSB0aGlzO1xuXG5cdFx0aWYgKCBjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbIHRhcmdldCBdICE9PSBmcmFtZWJ1ZmZlciApIHtcblxuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKCB0YXJnZXQsIGZyYW1lYnVmZmVyICk7XG5cblx0XHRcdGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVyc1sgdGFyZ2V0IF0gPSBmcmFtZWJ1ZmZlcjtcblxuXHRcdFx0Ly8gZ2wuRFJBV19GUkFNRUJVRkZFUiBpcyBlcXVpdmFsZW50IHRvIGdsLkZSQU1FQlVGRkVSXG5cblx0XHRcdGlmICggdGFyZ2V0ID09PSBnbC5EUkFXX0ZSQU1FQlVGRkVSICkge1xuXG5cdFx0XHRcdGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVyc1sgZ2wuRlJBTUVCVUZGRVIgXSA9IGZyYW1lYnVmZmVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGFyZ2V0ID09PSBnbC5GUkFNRUJVRkZFUiApIHtcblxuXHRcdFx0XHRjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbIGdsLkRSQVdfRlJBTUVCVUZGRVIgXSA9IGZyYW1lYnVmZmVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRkcmF3QnVmZmVycyggcmVuZGVyQ29udGV4dCwgZnJhbWVidWZmZXIgKSB7XG5cblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xuXG5cdFx0bGV0IGRyYXdCdWZmZXJzID0gW107XG5cblx0XHRsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdGlmICggcmVuZGVyQ29udGV4dC50ZXh0dXJlcyAhPT0gbnVsbCApIHtcblxuXHRcdFx0ZHJhd0J1ZmZlcnMgPSB0aGlzLmN1cnJlbnREcmF3YnVmZmVycy5nZXQoIGZyYW1lYnVmZmVyICk7XG5cblx0XHRcdGlmICggZHJhd0J1ZmZlcnMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkcmF3QnVmZmVycyA9IFtdO1xuXHRcdFx0XHR0aGlzLmN1cnJlbnREcmF3YnVmZmVycy5zZXQoIGZyYW1lYnVmZmVyLCBkcmF3QnVmZmVycyApO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJDb250ZXh0LnRleHR1cmVzO1xuXG5cdFx0XHRpZiAoIGRyYXdCdWZmZXJzLmxlbmd0aCAhPT0gdGV4dHVyZXMubGVuZ3RoIHx8IGRyYXdCdWZmZXJzWyAwIF0gIT09IGdsLkNPTE9SX0FUVEFDSE1FTlQwICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0ZXh0dXJlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGRyYXdCdWZmZXJzWyBpIF0gPSBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRyYXdCdWZmZXJzLmxlbmd0aCA9IHRleHR1cmVzLmxlbmd0aDtcblxuXHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBkcmF3QnVmZmVyc1sgMCBdICE9PSBnbC5CQUNLICkge1xuXG5cdFx0XHRcdGRyYXdCdWZmZXJzWyAwIF0gPSBnbC5CQUNLO1xuXG5cdFx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBuZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0Z2wuZHJhd0J1ZmZlcnMoIGRyYXdCdWZmZXJzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cblx0Ly8gdGV4dHVyZVxuXG5cdGFjdGl2ZVRleHR1cmUoIHdlYmdsU2xvdCApIHtcblxuXHRcdGNvbnN0IHsgZ2wsIGN1cnJlbnRUZXh0dXJlU2xvdCwgbWF4VGV4dHVyZXMgfSA9IHRoaXM7XG5cblx0XHRpZiAoIHdlYmdsU2xvdCA9PT0gdW5kZWZpbmVkICkgd2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XG5cblx0XHRpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCAhPT0gd2ViZ2xTbG90ICkge1xuXG5cdFx0XHRnbC5hY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKTtcblx0XHRcdHRoaXMuY3VycmVudFRleHR1cmVTbG90ID0gd2ViZ2xTbG90O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRiaW5kVGV4dHVyZSggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUsIHdlYmdsU2xvdCApIHtcblxuXHRcdGNvbnN0IHsgZ2wsIGN1cnJlbnRUZXh0dXJlU2xvdCwgY3VycmVudEJvdW5kVGV4dHVyZXMsIG1heFRleHR1cmVzIH0gPSB0aGlzO1xuXG5cdFx0aWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0d2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0d2ViZ2xTbG90ID0gY3VycmVudFRleHR1cmVTbG90O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRsZXQgYm91bmRUZXh0dXJlID0gY3VycmVudEJvdW5kVGV4dHVyZXNbIHdlYmdsU2xvdCBdO1xuXG5cdFx0aWYgKCBib3VuZFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ym91bmRUZXh0dXJlID0geyB0eXBlOiB1bmRlZmluZWQsIHRleHR1cmU6IHVuZGVmaW5lZCB9O1xuXHRcdFx0Y3VycmVudEJvdW5kVGV4dHVyZXNbIHdlYmdsU2xvdCBdID0gYm91bmRUZXh0dXJlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBib3VuZFRleHR1cmUudHlwZSAhPT0gd2ViZ2xUeXBlIHx8IGJvdW5kVGV4dHVyZS50ZXh0dXJlICE9PSB3ZWJnbFRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XG5cblx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICk7XG5cdFx0XHRcdHRoaXMuY3VycmVudFRleHR1cmVTbG90ID0gd2ViZ2xTbG90O1xuXG5cdFx0XHR9XG5cblx0XHRcdGdsLmJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSApO1xuXG5cdFx0XHRib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcblx0XHRcdGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gd2ViZ2xUZXh0dXJlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRiaW5kQnVmZmVyQmFzZSggdGFyZ2V0LCBpbmRleCwgYnVmZmVyICkge1xuXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcblxuXHRcdGNvbnN0IGtleSA9IGAke3RhcmdldH0tJHtpbmRleH1gO1xuXG5cdFx0aWYgKCB0aGlzLmN1cnJlbnRCb3VuZEJ1ZmZlckJhc2VzWyBrZXkgXSAhPT0gYnVmZmVyICkge1xuXG5cdFx0XHRnbC5iaW5kQnVmZmVyQmFzZSggdGFyZ2V0LCBpbmRleCwgYnVmZmVyICk7XG5cdFx0XHR0aGlzLmN1cnJlbnRCb3VuZEJ1ZmZlckJhc2VzWyBrZXkgXSA9IGJ1ZmZlcjtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cblx0dW5iaW5kVGV4dHVyZSgpIHtcblxuXHRcdGNvbnN0IHsgZ2wsIGN1cnJlbnRUZXh0dXJlU2xvdCwgY3VycmVudEJvdW5kVGV4dHVyZXMgfSA9IHRoaXM7XG5cblx0XHRjb25zdCBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF07XG5cblx0XHRpZiAoIGJvdW5kVGV4dHVyZSAhPT0gdW5kZWZpbmVkICYmIGJvdW5kVGV4dHVyZS50eXBlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGdsLmJpbmRUZXh0dXJlKCBib3VuZFRleHR1cmUudHlwZSwgbnVsbCApO1xuXG5cdFx0XHRib3VuZFRleHR1cmUudHlwZSA9IHVuZGVmaW5lZDtcblx0XHRcdGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gdW5kZWZpbmVkO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJHTFN0YXRlO1xuIiwiaW1wb3J0IHsgUkdCQV9BU1RDXzR4NF9Gb3JtYXQsIFJHQkFfQVNUQ181eDRfRm9ybWF0LCBSR0JBX0FTVENfNXg1X0Zvcm1hdCwgUkdCQV9BU1RDXzZ4NV9Gb3JtYXQsIFJHQkFfQVNUQ182eDZfRm9ybWF0LCBSR0JBX0FTVENfOHg1X0Zvcm1hdCwgUkdCQV9BU1RDXzh4Nl9Gb3JtYXQsIFJHQkFfQVNUQ184eDhfRm9ybWF0LCBSR0JBX0FTVENfMTB4NV9Gb3JtYXQsIFJHQkFfQVNUQ18xMHg2X0Zvcm1hdCwgUkdCQV9BU1RDXzEweDhfRm9ybWF0LCBSR0JBX0FTVENfMTB4MTBfRm9ybWF0LCBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0LCBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0LCBSR0JfRVRDMV9Gb3JtYXQsIFJHQl9FVEMyX0Zvcm1hdCwgUkdCQV9FVEMyX0VBQ19Gb3JtYXQsIFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCwgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0LCBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCwgUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQsIFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCwgUkdCQV9TM1RDX0RYVDNfRm9ybWF0LCBSR0JBX1MzVENfRFhUMV9Gb3JtYXQsIFJHQl9TM1RDX0RYVDFfRm9ybWF0LCBEZXB0aEZvcm1hdCwgRGVwdGhTdGVuY2lsRm9ybWF0LCBMdW1pbmFuY2VBbHBoYUZvcm1hdCwgTHVtaW5hbmNlRm9ybWF0LCBSZWRGb3JtYXQsIFJHQkZvcm1hdCwgUkdCQUZvcm1hdCwgQWxwaGFGb3JtYXQsIFJlZEludGVnZXJGb3JtYXQsIFJHRm9ybWF0LCBSR0ludGVnZXJGb3JtYXQsIFJHQkFJbnRlZ2VyRm9ybWF0LCBIYWxmRmxvYXRUeXBlLCBGbG9hdFR5cGUsIFVuc2lnbmVkSW50VHlwZSwgSW50VHlwZSwgVW5zaWduZWRTaG9ydFR5cGUsIFNob3J0VHlwZSwgQnl0ZVR5cGUsIFVuc2lnbmVkSW50MjQ4VHlwZSwgVW5zaWduZWRJbnQ1OTk5VHlwZSwgVW5zaWduZWRTaG9ydDU1NTFUeXBlLCBVbnNpZ25lZFNob3J0NDQ0NFR5cGUsIFVuc2lnbmVkQnl0ZVR5cGUsIFJHQkFfQlBUQ19Gb3JtYXQsIFJFRF9SR1RDMV9Gb3JtYXQsIFNJR05FRF9SRURfUkdUQzFfRm9ybWF0LCBSRURfR1JFRU5fUkdUQzJfRm9ybWF0LCBTSUdORURfUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCwgU1JHQkNvbG9yU3BhY2UsIE5vQ29sb3JTcGFjZSB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbmNsYXNzIFdlYkdMVXRpbHMge1xuXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xuXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcblxuXHRcdHRoaXMuZ2wgPSB0aGlzLmJhY2tlbmQuZ2w7XG5cdFx0dGhpcy5leHRlbnNpb25zID0gYmFja2VuZC5leHRlbnNpb25zO1xuXG5cdH1cblxuXHRjb252ZXJ0KCBwLCBjb2xvclNwYWNlID0gTm9Db2xvclNwYWNlICkge1xuXG5cdFx0Y29uc3QgeyBnbCwgZXh0ZW5zaW9ucyB9ID0gdGhpcztcblxuXHRcdGxldCBleHRlbnNpb247XG5cblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkQnl0ZVR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfQllURTtcblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVF80XzRfNF80O1xuXHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDU1NTFUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XG5cdFx0aWYgKCBwID09PSBVbnNpZ25lZEludDU5OTlUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX0lOVF81XzlfOV85X1JFVjtcblxuXHRcdGlmICggcCA9PT0gQnl0ZVR5cGUgKSByZXR1cm4gZ2wuQllURTtcblx0XHRpZiAoIHAgPT09IFNob3J0VHlwZSApIHJldHVybiBnbC5TSE9SVDtcblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnRUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUO1xuXHRcdGlmICggcCA9PT0gSW50VHlwZSApIHJldHVybiBnbC5JTlQ7XG5cdFx0aWYgKCBwID09PSBVbnNpZ25lZEludFR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfSU5UO1xuXHRcdGlmICggcCA9PT0gRmxvYXRUeXBlICkgcmV0dXJuIGdsLkZMT0FUO1xuXG5cdFx0aWYgKCBwID09PSBIYWxmRmxvYXRUeXBlICkge1xuXG5cdFx0XHRyZXR1cm4gZ2wuSEFMRl9GTE9BVDtcblxuXHRcdH1cblxuXHRcdGlmICggcCA9PT0gQWxwaGFGb3JtYXQgKSByZXR1cm4gZ2wuQUxQSEE7XG5cdFx0aWYgKCBwID09PSBSR0JGb3JtYXQgKSByZXR1cm4gZ2wuUkdCO1xuXHRcdGlmICggcCA9PT0gUkdCQUZvcm1hdCApIHJldHVybiBnbC5SR0JBO1xuXHRcdGlmICggcCA9PT0gTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIGdsLkxVTUlOQU5DRTtcblx0XHRpZiAoIHAgPT09IEx1bWluYW5jZUFscGhhRm9ybWF0ICkgcmV0dXJuIGdsLkxVTUlOQU5DRV9BTFBIQTtcblx0XHRpZiAoIHAgPT09IERlcHRoRm9ybWF0ICkgcmV0dXJuIGdsLkRFUFRIX0NPTVBPTkVOVDtcblx0XHRpZiAoIHAgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHJldHVybiBnbC5ERVBUSF9TVEVOQ0lMO1xuXG5cdFx0Ly8gV2ViR0wyIGZvcm1hdHMuXG5cblx0XHRpZiAoIHAgPT09IFJlZEZvcm1hdCApIHJldHVybiBnbC5SRUQ7XG5cdFx0aWYgKCBwID09PSBSZWRJbnRlZ2VyRm9ybWF0ICkgcmV0dXJuIGdsLlJFRF9JTlRFR0VSO1xuXHRcdGlmICggcCA9PT0gUkdGb3JtYXQgKSByZXR1cm4gZ2wuUkc7XG5cdFx0aWYgKCBwID09PSBSR0ludGVnZXJGb3JtYXQgKSByZXR1cm4gZ2wuUkdfSU5URUdFUjtcblx0XHRpZiAoIHAgPT09IFJHQkFJbnRlZ2VyRm9ybWF0ICkgcmV0dXJuIGdsLlJHQkFfSU5URUdFUjtcblxuXHRcdC8vIFMzVENcblxuXHRcdGlmICggcCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCB8fCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSB7XG5cblx0XHRcdGlmICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSB7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiJyApO1xuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFQ7XG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDFfRVhUO1xuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQzX0VYVDtcblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUNV9FWFQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7XG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBQVlJUQ1xuXG5cdFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ICkge1xuXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcblx0XHRcdFx0aWYgKCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO1xuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIEVUQ1xuXG5cdFx0aWYgKCBwID09PSBSR0JfRVRDMV9Gb3JtYXQgfHwgcCA9PT0gUkdCX0VUQzJfRm9ybWF0IHx8IHAgPT09IFJHQkFfRVRDMl9FQUNfRm9ybWF0ICkge1xuXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCX0VUQzFfRm9ybWF0IHx8IHAgPT09IFJHQl9FVEMyX0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9FVEMyIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCOF9FVEMyO1xuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfRVRDMl9FQUNfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQyA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkE4X0VUQzJfRUFDO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBBU1RDXG5cblx0XHRpZiAoIHAgPT09IFJHQkFfQVNUQ180eDRfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ181eDRfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ181eDVfRm9ybWF0IHx8XG5cdFx0XHRwID09PSBSR0JBX0FTVENfNng1X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfNng2X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfOHg1X0Zvcm1hdCB8fFxuXHRcdFx0cCA9PT0gUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDVfRm9ybWF0IHx8XG5cdFx0XHRwID09PSBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDhfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQgfHxcblx0XHRcdHAgPT09IFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCApIHtcblxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0YycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNHg0X0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ180eDRfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzV4NF9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNXg0X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ181eDRfS0hSO1xuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfQVNUQ181eDVfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzV4NV9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfNXg1X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNng1X0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDVfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzZ4NV9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNng2X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ182eDZfS0hSO1xuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfQVNUQ184eDVfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzh4NV9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfOHg1X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfOHg2X0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDZfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4Nl9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOHg4X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ184eDhfS0hSO1xuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfQVNUQ18xMHg1X0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMHg1X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHg1X0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4Nl9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4Nl9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEweDhfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDhfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDhfS0hSO1xuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4MTBfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDEwX0tIUjtcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyeDEwX0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMngxMF9LSFI7XG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMngxMl9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTJ4MTJfS0hSO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBCUFRDXG5cblx0XHRpZiAoIHAgPT09IFJHQkFfQlBUQ19Gb3JtYXQgKSB7XG5cblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfY29tcHJlc3Npb25fYnB0YycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0JQVENfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfQlBUQ19VTk9STV9FWFQgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0JQVENfVU5PUk1fRVhUO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBSR1RDXG5cblx0XHRpZiAoIHAgPT09IFJFRF9SR1RDMV9Gb3JtYXQgfHwgcCA9PT0gU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQgfHwgcCA9PT0gUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCB8fCBwID09PSBTSUdORURfUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCApIHtcblxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9yZ3RjJyApO1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfQlBUQ19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkVEX1JHVEMxX0VYVDtcblx0XHRcdFx0aWYgKCBwID09PSBTSUdORURfUkVEX1JHVEMxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9TSUdORURfUkVEX1JHVEMxX0VYVDtcblx0XHRcdFx0aWYgKCBwID09PSBSRURfR1JFRU5fUkdUQzJfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JFRF9HUkVFTl9SR1RDMl9FWFQ7XG5cdFx0XHRcdGlmICggcCA9PT0gU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9FWFQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkSW50MjQ4VHlwZSApIHtcblxuXHRcdFx0cmV0dXJuIGdsLlVOU0lHTkVEX0lOVF8yNF84O1xuXG5cdFx0fVxuXG5cdFx0Ly8gaWYgXCJwXCIgY2FuJ3QgYmUgcmVzb2x2ZWQsIGFzc3VtZSB0aGUgdXNlciBkZWZpbmVzIGEgV2ViR0wgY29uc3RhbnQgYXMgYSBzdHJpbmcgKGZhbGxiYWNrL3dvcmthcm91bmQgZm9yIHBhY2tlZCBSR0IgZm9ybWF0cylcblxuXHRcdHJldHVybiAoIGdsWyBwIF0gIT09IHVuZGVmaW5lZCApID8gZ2xbIHAgXSA6IG51bGw7XG5cblx0fVxuXG5cdF9jbGllbnRXYWl0QXN5bmMoKSB7XG5cblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xuXG5cdFx0Y29uc3Qgc3luYyA9IGdsLmZlbmNlU3luYyggZ2wuU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsIDAgKTtcblxuXHRcdGdsLmZsdXNoKCk7XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXG5cdFx0XHRmdW5jdGlvbiB0ZXN0KCkge1xuXG5cdFx0XHRcdGNvbnN0IHJlcyA9IGdsLmNsaWVudFdhaXRTeW5jKCBzeW5jLCBnbC5TWU5DX0ZMVVNIX0NPTU1BTkRTX0JJVCwgMCApO1xuXG5cdFx0XHRcdGlmICggcmVzID09PSBnbC5XQUlUX0ZBSUxFRCApIHtcblxuXHRcdFx0XHRcdGdsLmRlbGV0ZVN5bmMoIHN5bmMgKTtcblxuXHRcdFx0XHRcdHJlamVjdCgpO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCByZXMgPT09IGdsLlRJTUVPVVRfRVhQSVJFRCApIHtcblxuXHRcdFx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSggdGVzdCApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2wuZGVsZXRlU3luYyggc3luYyApO1xuXG5cdFx0XHRcdHJlc29sdmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0ZXN0KCk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdlYkdMVXRpbHM7XG4iLCJpbXBvcnQgeyBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciwgTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciwgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsIEZsb2F0VHlwZSwgTWlycm9yZWRSZXBlYXRXcmFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgUmVwZWF0V3JhcHBpbmcsIFNSR0JDb2xvclNwYWNlLCBOZXZlckNvbXBhcmUsIEFsd2F5c0NvbXBhcmUsIExlc3NDb21wYXJlLCBMZXNzRXF1YWxDb21wYXJlLCBFcXVhbENvbXBhcmUsIEdyZWF0ZXJFcXVhbENvbXBhcmUsIEdyZWF0ZXJDb21wYXJlLCBOb3RFcXVhbENvbXBhcmUgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuXG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZSwgd3JhcHBpbmdUb0dMLCBmaWx0ZXJUb0dMLCBjb21wYXJlVG9HTDtcblxuY2xhc3MgV2ViR0xUZXh0dXJlVXRpbHMge1xuXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xuXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcblxuXHRcdHRoaXMuZ2wgPSBiYWNrZW5kLmdsO1xuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IGJhY2tlbmQuZXh0ZW5zaW9ucztcblx0XHR0aGlzLmRlZmF1bHRUZXh0dXJlcyA9IHt9O1xuXG5cdFx0aWYgKCBpbml0aWFsaXplZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRoaXMuX2luaXQoIHRoaXMuZ2wgKTtcblxuXHRcdFx0aW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfaW5pdCggZ2wgKSB7XG5cblx0XHQvLyBTdG9yZSBvbmx5IFdlYkdMIGNvbnN0YW50cyBoZXJlLlxuXG5cdFx0d3JhcHBpbmdUb0dMID0ge1xuXHRcdFx0WyBSZXBlYXRXcmFwcGluZyBdOiBnbC5SRVBFQVQsXG5cdFx0XHRbIENsYW1wVG9FZGdlV3JhcHBpbmcgXTogZ2wuQ0xBTVBfVE9fRURHRSxcblx0XHRcdFsgTWlycm9yZWRSZXBlYXRXcmFwcGluZyBdOiBnbC5NSVJST1JFRF9SRVBFQVRcblx0XHR9O1xuXG5cdFx0ZmlsdGVyVG9HTCA9IHtcblx0XHRcdFsgTmVhcmVzdEZpbHRlciBdOiBnbC5ORUFSRVNULFxuXHRcdFx0WyBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciBdOiBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNULFxuXHRcdFx0WyBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyIF06IGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUixcblxuXHRcdFx0WyBMaW5lYXJGaWx0ZXIgXTogZ2wuTElORUFSLFxuXHRcdFx0WyBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyIF06IGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCxcblx0XHRcdFsgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyIF06IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSXG5cdFx0fTtcblxuXHRcdGNvbXBhcmVUb0dMID0ge1xuXHRcdFx0WyBOZXZlckNvbXBhcmUgXTogZ2wuTkVWRVIsXG5cdFx0XHRbIEFsd2F5c0NvbXBhcmUgXTogZ2wuQUxXQVlTLFxuXHRcdFx0WyBMZXNzQ29tcGFyZSBdOiBnbC5MRVNTLFxuXHRcdFx0WyBMZXNzRXF1YWxDb21wYXJlIF06IGdsLkxFUVVBTCxcblx0XHRcdFsgRXF1YWxDb21wYXJlIF06IGdsLkVRVUFMLFxuXHRcdFx0WyBHcmVhdGVyRXF1YWxDb21wYXJlIF06IGdsLkdFUVVBTCxcblx0XHRcdFsgR3JlYXRlckNvbXBhcmUgXTogZ2wuR1JFQVRFUixcblx0XHRcdFsgTm90RXF1YWxDb21wYXJlIF06IGdsLk5PVEVRVUFMXG5cdFx0fTtcblxuXHR9XG5cblx0ZmlsdGVyRmFsbGJhY2soIGYgKSB7XG5cblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xuXG5cdFx0aWYgKCBmID09PSBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgKSB7XG5cblx0XHRcdHJldHVybiBnbC5ORUFSRVNUO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdsLkxJTkVBUjtcblxuXHR9XG5cblx0Z2V0R0xUZXh0dXJlVHlwZSggdGV4dHVyZSApIHtcblxuXHRcdGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG5cblx0XHRsZXQgZ2xUZXh0dXJlVHlwZTtcblxuXHRcdGlmICggdGV4dHVyZS5pc0N1YmVUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRnbFRleHR1cmVUeXBlID0gZ2wuVEVYVFVSRV9DVUJFX01BUDtcblxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhQXJyYXlUZXh0dXJlID09PSB0cnVlIHx8IHRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRnbFRleHR1cmVUeXBlID0gZ2wuVEVYVFVSRV8yRF9BUlJBWTtcblxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhM0RUZXh0dXJlID09PSB0cnVlICkgeyAvLyBUT0RPOiBpc0NvbXByZXNzZWQzRFRleHR1cmUsIHdhaXQgZm9yICMyNjY0MlxuXG5cdFx0XHRnbFRleHR1cmVUeXBlID0gZ2wuVEVYVFVSRV8zRDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGdsVGV4dHVyZVR5cGUgPSBnbC5URVhUVVJFXzJEO1xuXG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ2xUZXh0dXJlVHlwZTtcblxuXHR9XG5cblx0Z2V0SW50ZXJuYWxGb3JtYXQoIGludGVybmFsRm9ybWF0TmFtZSwgZ2xGb3JtYXQsIGdsVHlwZSwgY29sb3JTcGFjZSwgZm9yY2VMaW5lYXJUcmFuc2ZlciA9IGZhbHNlICkge1xuXG5cdFx0Y29uc3QgeyBnbCwgZXh0ZW5zaW9ucyB9ID0gdGhpcztcblxuXHRcdGlmICggaW50ZXJuYWxGb3JtYXROYW1lICE9PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIGdsWyBpbnRlcm5hbEZvcm1hdE5hbWUgXSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIGdsWyBpbnRlcm5hbEZvcm1hdE5hbWUgXTtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byB1c2Ugbm9uLWV4aXN0aW5nIFdlYkdMIGludGVybmFsIGZvcm1hdCBcXCcnICsgaW50ZXJuYWxGb3JtYXROYW1lICsgJ1xcJycgKTtcblxuXHRcdH1cblxuXHRcdGxldCBpbnRlcm5hbEZvcm1hdCA9IGdsRm9ybWF0O1xuXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuUkVEICkge1xuXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuRkxPQVQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlIzMkY7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuSEFMRl9GTE9BVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUjE2Rjtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SODtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUjE2O1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0lOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUjMyVUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUjhJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlNIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SMTZJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLklOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUjMySTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2xGb3JtYXQgPT09IGdsLlJFRF9JTlRFR0VSICkge1xuXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUjhVSTtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUjE2VUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SMzJVSTtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SOEk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuU0hPUlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlIxNkk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SMzJJO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuUkcgKSB7XG5cblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5GTE9BVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkczMkY7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuSEFMRl9GTE9BVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkcxNkY7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkc4O1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SRzE2O1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0lOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkczMlVJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLkJZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHOEk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuU0hPUlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHMTZJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLklOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkczMkk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdsRm9ybWF0ID09PSBnbC5SR19JTlRFR0VSICkge1xuXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkc4VUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHMTZVSTtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9JTlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHMzJVSTtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SRzhJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlNIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SRzE2STtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5JTlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHMzJJO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuUkdCICkge1xuXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuRkxPQVQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQjMyRjtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5IQUxGX0ZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0IxNkY7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCODtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCMTY7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0IzMlVJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLkJZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQjhJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlNIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0IxNkk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0IzMkk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSAmJiBmb3JjZUxpbmVhclRyYW5zZmVyID09PSBmYWxzZSApID8gZ2wuU1JHQjggOiBnbC5SR0I4O1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUXzVfNl81ICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0I1NjU7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCNV9BMTtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVF80XzRfNF80ICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0I0O1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0lOVF81XzlfOV85X1JFViApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCOV9FNTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2xGb3JtYXQgPT09IGdsLlJHQl9JTlRFR0VSICkge1xuXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCOFVJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0IxNlVJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0lOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCMzJVSTtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0I4STtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5TSE9SVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCMTZJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLklOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCMzJJO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuUkdCQSApIHtcblxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLkZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBMzJGO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLkhBTEZfRkxPQVQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkExNkY7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTg7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkExNjtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9JTlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkEzMlVJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLkJZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE4STtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5TSE9SVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTE2STtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5JTlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkEzMkk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSAmJiBmb3JjZUxpbmVhclRyYW5zZmVyID09PSBmYWxzZSApID8gZ2wuU1JHQjhfQUxQSEE4IDogZ2wuUkdCQTg7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTQ7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCNV9BMTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2xGb3JtYXQgPT09IGdsLlJHQkFfSU5URUdFUiApIHtcblxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0JZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE4VUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkExNlVJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0lOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTMyVUk7XG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQThJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlNIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBMTZJO1xuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLklOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTMySTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2xGb3JtYXQgPT09IGdsLkRFUFRIX0NPTVBPTkVOVCApIHtcblxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0lOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuREVQVEgyNF9TVEVOQ0lMODtcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5GTE9BVCApIGludGVybmFsRm9ybWF0ID0gZ2wuREVQVEhfQ09NUE9ORU5UMzJGO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuREVQVEhfU1RFTkNJTCApIHtcblxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0lOVF8yNF84ICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5ERVBUSDI0X1NURU5DSUw4O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbnRlcm5hbEZvcm1hdCA9PT0gZ2wuUjE2RiB8fCBpbnRlcm5hbEZvcm1hdCA9PT0gZ2wuUjMyRiB8fFxuXHRcdFx0aW50ZXJuYWxGb3JtYXQgPT09IGdsLlJHMTZGIHx8IGludGVybmFsRm9ybWF0ID09PSBnbC5SRzMyRiB8fFxuXHRcdFx0aW50ZXJuYWxGb3JtYXQgPT09IGdsLlJHQkExNkYgfHwgaW50ZXJuYWxGb3JtYXQgPT09IGdsLlJHQkEzMkYgKSB7XG5cblx0XHRcdGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbnRlcm5hbEZvcm1hdDtcblxuXHR9XG5cblx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIHRleHR1cmVUeXBlLCB0ZXh0dXJlICkge1xuXG5cdFx0Y29uc3QgeyBnbCwgZXh0ZW5zaW9ucywgYmFja2VuZCB9ID0gdGhpcztcblxuXG5cdFx0Z2wucGl4ZWxTdG9yZWkoIGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcblx0XHRnbC5waXhlbFN0b3JlaSggZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcblx0XHRnbC5waXhlbFN0b3JlaSggZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcblx0XHRnbC5waXhlbFN0b3JlaSggZ2wuVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgZ2wuTk9ORSApO1xuXG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfV1JBUF9TLCB3cmFwcGluZ1RvR0xbIHRleHR1cmUud3JhcFMgXSApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBnbC5URVhUVVJFX1dSQVBfVCwgd3JhcHBpbmdUb0dMWyB0ZXh0dXJlLndyYXBUIF0gKTtcblxuXHRcdGlmICggdGV4dHVyZVR5cGUgPT09IGdsLlRFWFRVUkVfM0QgfHwgdGV4dHVyZVR5cGUgPT09IGdsLlRFWFRVUkVfMkRfQVJSQVkgKSB7XG5cblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBnbC5URVhUVVJFX1dSQVBfUiwgd3JhcHBpbmdUb0dMWyB0ZXh0dXJlLndyYXBSIF0gKTtcblxuXHRcdH1cblxuXHRcdGdsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlclRvR0xbIHRleHR1cmUubWFnRmlsdGVyIF0gKTtcblxuXG5cdFx0Y29uc3QgaGFzTWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcyAhPT0gdW5kZWZpbmVkICYmIHRleHR1cmUubWlwbWFwcy5sZW5ndGggPiAwO1xuXG5cdFx0Ly8gZm9sbG93IFdlYkdQVSBiYWNrZW5kIG1hcHBpbmcgZm9yIHRleHR1cmUgZmlsdGVyaW5nXG5cdFx0Y29uc3QgbWluRmlsdGVyID0gdGV4dHVyZS5taW5GaWx0ZXIgPT09IExpbmVhckZpbHRlciAmJiBoYXNNaXBtYXBzID8gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyIDogdGV4dHVyZS5taW5GaWx0ZXI7XG5cblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJUb0dMWyBtaW5GaWx0ZXIgXSApO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmNvbXBhcmVGdW5jdGlvbiApIHtcblxuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfQ09NUEFSRV9NT0RFLCBnbC5DT01QQVJFX1JFRl9UT19URVhUVVJFICk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9DT01QQVJFX0ZVTkMsIGNvbXBhcmVUb0dMWyB0ZXh0dXJlLmNvbXBhcmVGdW5jdGlvbiBdICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbnMuaGFzKCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApID09PSB0cnVlICkge1xuXG5cdFx0XHRpZiAoIHRleHR1cmUubWFnRmlsdGVyID09PSBOZWFyZXN0RmlsdGVyICkgcmV0dXJuO1xuXHRcdFx0aWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyICkgcmV0dXJuO1xuXHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmhhcyggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSA9PT0gZmFsc2UgKSByZXR1cm47IC8vIHZlcmlmeSBleHRlbnNpb24gZm9yIFdlYkdMIDEgYW5kIFdlYkdMIDJcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLmFuaXNvdHJvcHkgPiAxICkge1xuXG5cdFx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJmKCB0ZXh0dXJlVHlwZSwgZXh0ZW5zaW9uLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbiggdGV4dHVyZS5hbmlzb3Ryb3B5LCBiYWNrZW5kLmdldE1heEFuaXNvdHJvcHkoKSApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y3JlYXRlRGVmYXVsdFRleHR1cmUoIHRleHR1cmUgKSB7XG5cblx0XHRjb25zdCB7IGdsLCBiYWNrZW5kLCBkZWZhdWx0VGV4dHVyZXMgfSA9IHRoaXM7XG5cblxuXHRcdGNvbnN0IGdsVGV4dHVyZVR5cGUgPSB0aGlzLmdldEdMVGV4dHVyZVR5cGUoIHRleHR1cmUgKTtcblxuXHRcdGxldCB0ZXh0dXJlR1BVID0gZGVmYXVsdFRleHR1cmVzWyBnbFRleHR1cmVUeXBlIF07XG5cblx0XHRpZiAoIHRleHR1cmVHUFUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGV4dHVyZUdQVSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdFx0YmFja2VuZC5zdGF0ZS5iaW5kVGV4dHVyZSggZ2xUZXh0dXJlVHlwZSwgdGV4dHVyZUdQVSApO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2xUZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbFRleHR1cmVUeXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuXHRcdFx0Ly8gZ2wudGV4SW1hZ2UyRCggZ2xUZXh0dXJlVHlwZSwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGF0YSApO1xuXG5cdFx0XHRkZWZhdWx0VGV4dHVyZXNbIGdsVGV4dHVyZVR5cGUgXSA9IHRleHR1cmVHUFU7XG5cblx0XHR9XG5cblx0XHRiYWNrZW5kLnNldCggdGV4dHVyZSwge1xuXHRcdFx0dGV4dHVyZUdQVSxcblx0XHRcdGdsVGV4dHVyZVR5cGUsXG5cdFx0XHRpc0RlZmF1bHQ6IHRydWVcblx0XHR9ICk7XG5cblx0fVxuXG5cdGNyZWF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKSB7XG5cblx0XHRjb25zdCB7IGdsLCBiYWNrZW5kIH0gPSB0aGlzO1xuXHRcdGNvbnN0IHsgbGV2ZWxzLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCB9ID0gb3B0aW9ucztcblxuXHRcdGNvbnN0IGdsRm9ybWF0ID0gYmFja2VuZC51dGlscy5jb252ZXJ0KCB0ZXh0dXJlLmZvcm1hdCwgdGV4dHVyZS5jb2xvclNwYWNlICk7XG5cdFx0Y29uc3QgZ2xUeXBlID0gYmFja2VuZC51dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKTtcblx0XHRjb25zdCBnbEludGVybmFsRm9ybWF0ID0gdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCggdGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5jb2xvclNwYWNlLCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICk7XG5cblx0XHRjb25zdCB0ZXh0dXJlR1BVID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdGNvbnN0IGdsVGV4dHVyZVR5cGUgPSB0aGlzLmdldEdMVGV4dHVyZVR5cGUoIHRleHR1cmUgKTtcblxuXHRcdGJhY2tlbmQuc3RhdGUuYmluZFRleHR1cmUoIGdsVGV4dHVyZVR5cGUsIHRleHR1cmVHUFUgKTtcblxuXHRcdHRoaXMuc2V0VGV4dHVyZVBhcmFtZXRlcnMoIGdsVGV4dHVyZVR5cGUsIHRleHR1cmUgKTtcblxuXHRcdGlmICggdGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUgfHwgdGV4dHVyZS5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUgKSB7XG5cblx0XHRcdGdsLnRleFN0b3JhZ2UzRCggZ2wuVEVYVFVSRV8yRF9BUlJBWSwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCApO1xuXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgKSB7XG5cblx0XHRcdGdsLnRleFN0b3JhZ2UzRCggZ2wuVEVYVFVSRV8zRCwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCApO1xuXG5cdFx0fSBlbHNlIGlmICggISB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICkge1xuXG5cdFx0XHRnbC50ZXhTdG9yYWdlMkQoIGdsVGV4dHVyZVR5cGUsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0fVxuXG5cdFx0YmFja2VuZC5zZXQoIHRleHR1cmUsIHtcblx0XHRcdHRleHR1cmVHUFUsXG5cdFx0XHRnbFRleHR1cmVUeXBlLFxuXHRcdFx0Z2xGb3JtYXQsXG5cdFx0XHRnbFR5cGUsXG5cdFx0XHRnbEludGVybmFsRm9ybWF0XG5cdFx0fSApO1xuXG5cdH1cblxuXHRjb3B5QnVmZmVyVG9UZXh0dXJlKCBidWZmZXIsIHRleHR1cmUgKSB7XG5cblx0XHRjb25zdCB7IGdsLCBiYWNrZW5kIH0gPSB0aGlzO1xuXG5cdFx0Y29uc3QgeyB0ZXh0dXJlR1BVLCBnbFRleHR1cmVUeXBlLCBnbEZvcm1hdCwgZ2xUeXBlIH0gPSBiYWNrZW5kLmdldCggdGV4dHVyZSApO1xuXG5cdFx0Y29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0ZXh0dXJlLnNvdXJjZS5kYXRhO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuUElYRUxfVU5QQUNLX0JVRkZFUiwgYnVmZmVyICk7XG5cblx0XHRiYWNrZW5kLnN0YXRlLmJpbmRUZXh0dXJlKCBnbFRleHR1cmVUeXBlLCB0ZXh0dXJlR1BVICk7XG5cblx0XHRnbC5waXhlbFN0b3JlaSggZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UgKTtcblx0XHRnbC5waXhlbFN0b3JlaSggZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSApO1xuXHRcdGdsLnRleFN1YkltYWdlMkQoIGdsVGV4dHVyZVR5cGUsIDAsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIDAgKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLlBJWEVMX1VOUEFDS19CVUZGRVIsIG51bGwgKTtcblxuXHRcdGJhY2tlbmQuc3RhdGUudW5iaW5kVGV4dHVyZSgpO1xuXHRcdC8vIGRlYnVnXG5cdFx0Ly8gY29uc3QgZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHRcdC8vIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG5cdFx0Ly8gZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2xUZXh0dXJlVHlwZSwgdGV4dHVyZUdQVSwgMCApO1xuXG5cdFx0Ly8gY29uc3QgcmVhZG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoIHdpZHRoICogaGVpZ2h0ICogNCApO1xuXG5cdFx0Ly8gY29uc3QgYWx0Rm9ybWF0ID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCApO1xuXHRcdC8vIGNvbnN0IGFsdFR5cGUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfVFlQRSApO1xuXG5cdFx0Ly8gZ2wucmVhZFBpeGVscyggMCwgMCwgd2lkdGgsIGhlaWdodCwgYWx0Rm9ybWF0LCBhbHRUeXBlLCByZWFkb3V0ICk7XG5cdFx0Ly8gZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXHRcdC8vIGNvbnNvbGUubG9nKCByZWFkb3V0ICk7XG5cblx0fVxuXG5cdHVwZGF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKSB7XG5cblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gb3B0aW9ucztcblx0XHRjb25zdCB7IHRleHR1cmVHUFUsIGdsVGV4dHVyZVR5cGUsIGdsRm9ybWF0LCBnbFR5cGUsIGdsSW50ZXJuYWxGb3JtYXQgfSA9IHRoaXMuYmFja2VuZC5nZXQoIHRleHR1cmUgKTtcblxuXHRcdGlmICggdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgfHwgKCB0ZXh0dXJlR1BVID09PSB1bmRlZmluZWQgLyogdW5zdXBwb3J0ZWQgdGV4dHVyZSBmb3JtYXQgKi8gKSApXG5cdFx0XHRyZXR1cm47XG5cblx0XHRjb25zdCBnZXRJbWFnZSA9ICggc291cmNlICkgPT4ge1xuXG5cdFx0XHRpZiAoIHNvdXJjZS5pc0RhdGFUZXh0dXJlICkge1xuXG5cdFx0XHRcdHJldHVybiBzb3VyY2UuaW1hZ2UuZGF0YTtcblxuXHRcdFx0fSBlbHNlIGlmICggKCB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCApIHx8XG5cdFx0XHRcdCggdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCApIHx8XG5cdFx0XHRcdCggdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCApIHx8XG5cdFx0XHRcdHNvdXJjZSBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcyApIHtcblxuXHRcdFx0XHRyZXR1cm4gc291cmNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzb3VyY2UuZGF0YTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmJhY2tlbmQuc3RhdGUuYmluZFRleHR1cmUoIGdsVGV4dHVyZVR5cGUsIHRleHR1cmVHUFUgKTtcblxuXHRcdHRoaXMuc2V0VGV4dHVyZVBhcmFtZXRlcnMoIGdsVGV4dHVyZVR5cGUsIHRleHR1cmUgKTtcblxuXHRcdGlmICggdGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlICkge1xuXG5cdFx0XHRjb25zdCBtaXBtYXBzID0gdGV4dHVyZS5taXBtYXBzO1xuXHRcdFx0Y29uc3QgaW1hZ2UgPSBvcHRpb25zLmltYWdlO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBtaXBtYXBzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHtcblxuXG5cdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gZ2wuUkdCQSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBnbEZvcm1hdCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRnbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRCggZ2wuVEVYVFVSRV8yRF9BUlJBWSwgaSwgMCwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgZ2xGb3JtYXQsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKScgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Z2wudGV4U3ViSW1hZ2UzRCggZ2wuVEVYVFVSRV8yRF9BUlJBWSwgaSwgMCwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWYgKCBnbEZvcm1hdCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0Z2wuY29tcHJlc3NlZFRleFN1YkltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIGksIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgZ2xGb3JtYXQsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdVbnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0JyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzQ3ViZVRleHR1cmUgKSB7XG5cblx0XHRcdGNvbnN0IGltYWdlcyA9IG9wdGlvbnMuaW1hZ2VzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGltYWdlID0gZ2V0SW1hZ2UoIGltYWdlc1sgaSBdICk7XG5cblx0XHRcdFx0Z2wudGV4U3ViSW1hZ2UyRCggZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUgKSB7XG5cblx0XHRcdGNvbnN0IGltYWdlID0gb3B0aW9ucy5pbWFnZTtcblxuXHRcdFx0Z2wudGV4U3ViSW1hZ2UzRCggZ2wuVEVYVFVSRV8yRF9BUlJBWSwgMCwgMCwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgaW1hZ2UuZGVwdGgsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhM0RUZXh0dXJlICkge1xuXG5cdFx0XHRjb25zdCBpbWFnZSA9IG9wdGlvbnMuaW1hZ2U7XG5cblx0XHRcdGdsLnRleFN1YkltYWdlM0QoIGdsLlRFWFRVUkVfM0QsIDAsIDAsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XG5cblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICkge1xuXG5cdFx0XHR0ZXh0dXJlLnVwZGF0ZSgpO1xuXG5cdFx0XHRnbC50ZXhJbWFnZTJEKCBnbFRleHR1cmVUeXBlLCAwLCBnbEludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBvcHRpb25zLmltYWdlICk7XG5cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGltYWdlID0gZ2V0SW1hZ2UoIG9wdGlvbnMuaW1hZ2UgKTtcblxuXHRcdFx0Z2wudGV4U3ViSW1hZ2UyRCggZ2xUZXh0dXJlVHlwZSwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICkge1xuXG5cdFx0Y29uc3QgeyBnbCwgYmFja2VuZCB9ID0gdGhpcztcblx0XHRjb25zdCB7IHRleHR1cmVHUFUsIGdsVGV4dHVyZVR5cGUgfSA9IGJhY2tlbmQuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRiYWNrZW5kLnN0YXRlLmJpbmRUZXh0dXJlKCBnbFRleHR1cmVUeXBlLCB0ZXh0dXJlR1BVICk7XG5cdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoIGdsVGV4dHVyZVR5cGUgKTtcblxuXHR9XG5cblx0ZGVhbGxvY2F0ZVJlbmRlckJ1ZmZlcnMoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdGNvbnN0IHsgZ2wsIGJhY2tlbmQgfSA9IHRoaXM7XG5cblx0XHQvLyByZW1vdmUgZnJhbWVidWZmZXIgcmVmZXJlbmNlXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gYmFja2VuZC5nZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5yZW5kZXJCdWZmZXJTdG9yYWdlU2V0dXAgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEuZnJhbWVidWZmZXJzICkge1xuXG5cdFx0XHRcdGZvciAoIGNvbnN0IGNhY2hlS2V5IGluIHJlbmRlckNvbnRleHREYXRhLmZyYW1lYnVmZmVycyApIHtcblxuXHRcdFx0XHRcdGdsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJDb250ZXh0RGF0YS5mcmFtZWJ1ZmZlcnNbIGNhY2hlS2V5IF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIHJlbmRlckNvbnRleHREYXRhLmZyYW1lYnVmZmVycztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLmRlcHRoUmVuZGVyYnVmZmVyICkge1xuXG5cdFx0XHRcdGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyQ29udGV4dERhdGEuZGVwdGhSZW5kZXJidWZmZXIgKTtcblx0XHRcdFx0ZGVsZXRlIHJlbmRlckNvbnRleHREYXRhLmRlcHRoUmVuZGVyYnVmZmVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEuc3RlbmNpbFJlbmRlcmJ1ZmZlciApIHtcblxuXHRcdFx0XHRnbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlckNvbnRleHREYXRhLnN0ZW5jaWxSZW5kZXJidWZmZXIgKTtcblx0XHRcdFx0ZGVsZXRlIHJlbmRlckNvbnRleHREYXRhLnN0ZW5jaWxSZW5kZXJidWZmZXI7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByZW5kZXJDb250ZXh0RGF0YS5tc2FhRnJhbWVCdWZmZXIgKSB7XG5cblx0XHRcdFx0Z2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlckNvbnRleHREYXRhLm1zYWFGcmFtZUJ1ZmZlciApO1xuXHRcdFx0XHRkZWxldGUgcmVuZGVyQ29udGV4dERhdGEubXNhYUZyYW1lQnVmZmVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEubXNhYVJlbmRlcmJ1ZmZlcnMgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcmVuZGVyQ29udGV4dERhdGEubXNhYVJlbmRlcmJ1ZmZlcnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Z2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJDb250ZXh0RGF0YS5tc2FhUmVuZGVyYnVmZmVyc1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSByZW5kZXJDb250ZXh0RGF0YS5tc2FhUmVuZGVyYnVmZmVycztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRkZXN0cm95VGV4dHVyZSggdGV4dHVyZSApIHtcblxuXHRcdGNvbnN0IHsgZ2wsIGJhY2tlbmQgfSA9IHRoaXM7XG5cdFx0Y29uc3QgeyB0ZXh0dXJlR1BVLCByZW5kZXJUYXJnZXQgfSA9IGJhY2tlbmQuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHR0aGlzLmRlYWxsb2NhdGVSZW5kZXJCdWZmZXJzKCByZW5kZXJUYXJnZXQgKTtcblx0XHRnbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlR1BVICk7XG5cblx0XHRiYWNrZW5kLmRlbGV0ZSggdGV4dHVyZSApO1xuXG5cdH1cblxuXHRjb3B5VGV4dHVyZVRvVGV4dHVyZSggc3JjVGV4dHVyZSwgZHN0VGV4dHVyZSwgc3JjUmVnaW9uID0gbnVsbCwgZHN0UG9zaXRpb24gPSBudWxsLCBsZXZlbCA9IDAgKSB7XG5cblx0XHRjb25zdCB7IGdsLCBiYWNrZW5kIH0gPSB0aGlzO1xuXHRcdGNvbnN0IHsgc3RhdGUgfSA9IHRoaXMuYmFja2VuZDtcblxuXHRcdGNvbnN0IHsgdGV4dHVyZUdQVTogZHN0VGV4dHVyZUdQVSwgZ2xUZXh0dXJlVHlwZSwgZ2xUeXBlLCBnbEZvcm1hdCB9ID0gYmFja2VuZC5nZXQoIGRzdFRleHR1cmUgKTtcblxuXHRcdGxldCB3aWR0aCwgaGVpZ2h0LCBtaW5YLCBtaW5ZO1xuXHRcdGxldCBkc3RYLCBkc3RZO1xuXG5cdFx0aWYgKCBzcmNSZWdpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdHdpZHRoID0gc3JjUmVnaW9uLm1heC54IC0gc3JjUmVnaW9uLm1pbi54O1xuXHRcdFx0aGVpZ2h0ID0gc3JjUmVnaW9uLm1heC55IC0gc3JjUmVnaW9uLm1pbi55O1xuXHRcdFx0bWluWCA9IHNyY1JlZ2lvbi5taW4ueDtcblx0XHRcdG1pblkgPSBzcmNSZWdpb24ubWluLnk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR3aWR0aCA9IHNyY1RleHR1cmUuaW1hZ2Uud2lkdGg7XG5cdFx0XHRoZWlnaHQgPSBzcmNUZXh0dXJlLmltYWdlLmhlaWdodDtcblx0XHRcdG1pblggPSAwO1xuXHRcdFx0bWluWSA9IDA7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRzdFBvc2l0aW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRkc3RYID0gZHN0UG9zaXRpb24ueDtcblx0XHRcdGRzdFkgPSBkc3RQb3NpdGlvbi55O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZHN0WCA9IDA7XG5cdFx0XHRkc3RZID0gMDtcblxuXHRcdH1cblxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbFRleHR1cmVUeXBlLCBkc3RUZXh0dXJlR1BVICk7XG5cblx0XHQvLyBBcyBhbm90aGVyIHRleHR1cmUgdXBsb2FkIG1heSBoYXZlIGNoYW5nZWQgcGl4ZWxTdG9yZWlcblx0XHQvLyBwYXJhbWV0ZXJzLCBtYWtlIHN1cmUgdGhleSBhcmUgY29ycmVjdCBmb3IgdGhlIGRzdFRleHR1cmVcblx0XHRnbC5waXhlbFN0b3JlaSggZ2wuVU5QQUNLX0FMSUdOTUVOVCwgZHN0VGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcblx0XHRnbC5waXhlbFN0b3JlaSggZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZHN0VGV4dHVyZS5mbGlwWSApO1xuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGRzdFRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfQUxJR05NRU5ULCBkc3RUZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xuXG5cdFx0Y29uc3QgY3VycmVudFVucGFja1Jvd0xlbiA9IGdsLmdldFBhcmFtZXRlciggZ2wuVU5QQUNLX1JPV19MRU5HVEggKTtcblx0XHRjb25zdCBjdXJyZW50VW5wYWNrSW1hZ2VIZWlnaHQgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLlVOUEFDS19JTUFHRV9IRUlHSFQgKTtcblx0XHRjb25zdCBjdXJyZW50VW5wYWNrU2tpcFBpeGVscyA9IGdsLmdldFBhcmFtZXRlciggZ2wuVU5QQUNLX1NLSVBfUElYRUxTICk7XG5cdFx0Y29uc3QgY3VycmVudFVucGFja1NraXBSb3dzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5VTlBBQ0tfU0tJUF9ST1dTICk7XG5cdFx0Y29uc3QgY3VycmVudFVucGFja1NraXBJbWFnZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLlVOUEFDS19TS0lQX0lNQUdFUyApO1xuXG5cdFx0Y29uc3QgaW1hZ2UgPSBzcmNUZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgPyBzcmNUZXh0dXJlLm1pcG1hcHNbIGxldmVsIF0gOiBzcmNUZXh0dXJlLmltYWdlO1xuXG5cdFx0Z2wucGl4ZWxTdG9yZWkoIGdsLlVOUEFDS19ST1dfTEVOR1RILCBpbWFnZS53aWR0aCApO1xuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfSU1BR0VfSEVJR0hULCBpbWFnZS5oZWlnaHQgKTtcblx0XHRnbC5waXhlbFN0b3JlaSggZ2wuVU5QQUNLX1NLSVBfUElYRUxTLCBtaW5YICk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoIGdsLlVOUEFDS19TS0lQX1JPV1MsIG1pblkgKTtcblxuXHRcdGlmICggc3JjVGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgfHwgc3JjVGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcblxuXHRcdFx0Y29uc3Qgc3JjVGV4dHVyZURhdGEgPSBiYWNrZW5kLmdldCggc3JjVGV4dHVyZSApO1xuXHRcdFx0Y29uc3QgZHN0VGV4dHVyZURhdGEgPSBiYWNrZW5kLmdldCggZHN0VGV4dHVyZSApO1xuXG5cdFx0XHRjb25zdCBzcmNSZW5kZXJDb250ZXh0RGF0YSA9IGJhY2tlbmQuZ2V0KCBzcmNUZXh0dXJlRGF0YS5yZW5kZXJUYXJnZXQgKTtcblx0XHRcdGNvbnN0IGRzdFJlbmRlckNvbnRleHREYXRhID0gYmFja2VuZC5nZXQoIGRzdFRleHR1cmVEYXRhLnJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRjb25zdCBzcmNGcmFtZWJ1ZmZlciA9IHNyY1JlbmRlckNvbnRleHREYXRhLmZyYW1lYnVmZmVyc1sgc3JjVGV4dHVyZURhdGEuY2FjaGVLZXkgXTtcblx0XHRcdGNvbnN0IGRzdEZyYW1lYnVmZmVyID0gZHN0UmVuZGVyQ29udGV4dERhdGEuZnJhbWVidWZmZXJzWyBkc3RUZXh0dXJlRGF0YS5jYWNoZUtleSBdO1xuXG5cdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLlJFQURfRlJBTUVCVUZGRVIsIHNyY0ZyYW1lYnVmZmVyICk7XG5cdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLkRSQVdfRlJBTUVCVUZGRVIsIGRzdEZyYW1lYnVmZmVyICk7XG5cblx0XHRcdGxldCBtYXNrID0gZ2wuQ09MT1JfQlVGRkVSX0JJVDtcblxuXHRcdFx0aWYgKCBzcmNUZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkgbWFzayA9IGdsLkRFUFRIX0JVRkZFUl9CSVQ7XG5cblx0XHRcdGdsLmJsaXRGcmFtZWJ1ZmZlciggbWluWCwgbWluWSwgd2lkdGgsIGhlaWdodCwgZHN0WCwgZHN0WSwgd2lkdGgsIGhlaWdodCwgbWFzaywgZ2wuTkVBUkVTVCApO1xuXG5cdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLlJFQURfRlJBTUVCVUZGRVIsIG51bGwgKTtcblx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRFJBV19GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBzcmNUZXh0dXJlLmlzRGF0YVRleHR1cmUgKSB7XG5cblx0XHRcdFx0Z2wudGV4U3ViSW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgbGV2ZWwsIGRzdFgsIGRzdFksIHdpZHRoLCBoZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIHNyY1RleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdGdsLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKCBnbC5URVhUVVJFXzJELCBsZXZlbCwgZHN0WCwgZHN0WSwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgZ2xGb3JtYXQsIGltYWdlLmRhdGEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Z2wudGV4U3ViSW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgbGV2ZWwsIGRzdFgsIGRzdFksIHdpZHRoLCBoZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRnbC5waXhlbFN0b3JlaSggZ2wuVU5QQUNLX1JPV19MRU5HVEgsIGN1cnJlbnRVbnBhY2tSb3dMZW4gKTtcblx0XHRnbC5waXhlbFN0b3JlaSggZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCwgY3VycmVudFVucGFja0ltYWdlSGVpZ2h0ICk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoIGdsLlVOUEFDS19TS0lQX1BJWEVMUywgY3VycmVudFVucGFja1NraXBQaXhlbHMgKTtcblx0XHRnbC5waXhlbFN0b3JlaSggZ2wuVU5QQUNLX1NLSVBfUk9XUywgY3VycmVudFVucGFja1NraXBSb3dzICk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoIGdsLlVOUEFDS19TS0lQX0lNQUdFUywgY3VycmVudFVucGFja1NraXBJbWFnZXMgKTtcblxuXHRcdC8vIEdlbmVyYXRlIG1pcG1hcHMgb25seSB3aGVuIGNvcHlpbmcgbGV2ZWwgMFxuXHRcdGlmICggbGV2ZWwgPT09IDAgJiYgZHN0VGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgKSBnbC5nZW5lcmF0ZU1pcG1hcCggZ2wuVEVYVFVSRV8yRCApO1xuXG5cdFx0c3RhdGUudW5iaW5kVGV4dHVyZSgpO1xuXG5cdH1cblxuXHRjb3B5RnJhbWVidWZmZXJUb1RleHR1cmUoIHRleHR1cmUsIHJlbmRlckNvbnRleHQsIHJlY3RhbmdsZSApIHtcblxuXHRcdGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG5cdFx0Y29uc3QgeyBzdGF0ZSB9ID0gdGhpcy5iYWNrZW5kO1xuXG5cdFx0Y29uc3QgeyB0ZXh0dXJlR1BVIH0gPSB0aGlzLmJhY2tlbmQuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRjb25zdCB7IHgsIHksIHo6IHdpZHRoLCB3OiBoZWlnaHQgfSA9IHJlY3RhbmdsZTtcblxuXHRcdGNvbnN0IHJlcXVpcmVEcmF3RnJhbWVCdWZmZXIgPSB0ZXh0dXJlLmlzRGVwdGhUZXh0dXJlID09PSB0cnVlIHx8ICggcmVuZGVyQ29udGV4dC5yZW5kZXJUYXJnZXQgJiYgcmVuZGVyQ29udGV4dC5yZW5kZXJUYXJnZXQuc2FtcGxlcyA+IDAgKTtcblxuXHRcdGNvbnN0IHNyY0hlaWdodCA9IHJlbmRlckNvbnRleHQucmVuZGVyVGFyZ2V0ID8gcmVuZGVyQ29udGV4dC5yZW5kZXJUYXJnZXQuaGVpZ2h0IDogdGhpcy5iYWNrZW5kLmdlckRyYXdpbmdCdWZmZXJTaXplKCkueTtcblxuXHRcdGlmICggcmVxdWlyZURyYXdGcmFtZUJ1ZmZlciApIHtcblxuXHRcdFx0Y29uc3QgcGFydGlhbCA9ICggeCAhPT0gMCB8fCB5ICE9PSAwICk7XG5cdFx0XHRsZXQgbWFzaztcblx0XHRcdGxldCBhdHRhY2htZW50O1xuXG5cdFx0XHRpZiAoIHRleHR1cmUuaXNEZXB0aFRleHR1cmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0bWFzayA9IGdsLkRFUFRIX0JVRkZFUl9CSVQ7XG5cdFx0XHRcdGF0dGFjaG1lbnQgPSBnbC5ERVBUSF9BVFRBQ0hNRU5UO1xuXG5cdFx0XHRcdGlmICggcmVuZGVyQ29udGV4dC5zdGVuY2lsICkge1xuXG5cdFx0XHRcdFx0bWFzayB8PSBnbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG1hc2sgPSBnbC5DT0xPUl9CVUZGRVJfQklUO1xuXHRcdFx0XHRhdHRhY2htZW50ID0gZ2wuQ09MT1JfQVRUQUNITUVOVDA7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwYXJ0aWFsICkge1xuXG5cdFx0XHRcdGNvbnN0IHJlbmRlclRhcmdldENvbnRleHREYXRhID0gdGhpcy5iYWNrZW5kLmdldCggcmVuZGVyQ29udGV4dC5yZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0XHRjb25zdCBmYiA9IHJlbmRlclRhcmdldENvbnRleHREYXRhLmZyYW1lYnVmZmVyc1sgcmVuZGVyQ29udGV4dC5nZXRDYWNoZUtleSgpIF07XG5cdFx0XHRcdGNvbnN0IG1zYWFGcmFtZUJ1ZmZlciA9IHJlbmRlclRhcmdldENvbnRleHREYXRhLm1zYWFGcmFtZUJ1ZmZlcjtcblxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLkRSQVdfRlJBTUVCVUZGRVIsIGZiICk7XG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggZ2wuUkVBRF9GUkFNRUJVRkZFUiwgbXNhYUZyYW1lQnVmZmVyICk7XG5cblx0XHRcdFx0Y29uc3QgZmxpcHBlZFkgPSBzcmNIZWlnaHQgLSB5IC0gaGVpZ2h0O1xuXG5cdFx0XHRcdGdsLmJsaXRGcmFtZWJ1ZmZlciggeCwgZmxpcHBlZFksIHggKyB3aWR0aCwgZmxpcHBlZFkgKyBoZWlnaHQsIHgsIGZsaXBwZWRZLCB4ICsgd2lkdGgsIGZsaXBwZWRZICsgaGVpZ2h0LCBtYXNrLCBnbC5ORUFSRVNUICk7XG5cblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBnbC5SRUFEX0ZSQU1FQlVGRkVSLCBmYiApO1xuXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlR1BVICk7XG5cblx0XHRcdFx0Z2wuY29weVRleFN1YkltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHgsIGZsaXBwZWRZLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdFx0c3RhdGUudW5iaW5kVGV4dHVyZSgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IGZiID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLkRSQVdfRlJBTUVCVUZGRVIsIGZiICk7XG5cblx0XHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIGdsLkRSQVdfRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnQsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmVHUFUsIDAgKTtcblx0XHRcdFx0Z2wuYmxpdEZyYW1lYnVmZmVyKCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCBtYXNrLCBnbC5ORUFSRVNUICk7XG5cblx0XHRcdFx0Z2wuZGVsZXRlRnJhbWVidWZmZXIoIGZiICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlR1BVICk7XG5cdFx0XHRnbC5jb3B5VGV4U3ViSW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgeCwgc3JjSGVpZ2h0IC0gaGVpZ2h0IC0geSwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICkgdGhpcy5nZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKTtcblxuXHRcdHRoaXMuYmFja2VuZC5fc2V0RnJhbWVidWZmZXIoIHJlbmRlckNvbnRleHQgKTtcblxuXHR9XG5cblx0Ly8gU2V0dXAgc3RvcmFnZSBmb3IgaW50ZXJuYWwgZGVwdGgvc3RlbmNpbCBidWZmZXJzIGFuZCBiaW5kIHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcblx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJidWZmZXIsIHJlbmRlckNvbnRleHQgKSB7XG5cblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xuXHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IHJlbmRlckNvbnRleHQucmVuZGVyVGFyZ2V0O1xuXG5cdFx0Y29uc3QgeyBzYW1wbGVzLCBkZXB0aFRleHR1cmUsIGRlcHRoQnVmZmVyLCBzdGVuY2lsQnVmZmVyLCB3aWR0aCwgaGVpZ2h0IH0gPSByZW5kZXJUYXJnZXQ7XG5cblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0aWYgKCBkZXB0aEJ1ZmZlciAmJiAhIHN0ZW5jaWxCdWZmZXIgKSB7XG5cblx0XHRcdGxldCBnbEludGVybmFsRm9ybWF0ID0gZ2wuREVQVEhfQ09NUE9ORU5UMjQ7XG5cblx0XHRcdGlmICggc2FtcGxlcyA+IDAgKSB7XG5cblx0XHRcdFx0aWYgKCBkZXB0aFRleHR1cmUgJiYgZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBkZXB0aFRleHR1cmUudHlwZSA9PT0gZ2wuRkxPQVQgKSB7XG5cblx0XHRcdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBnbC5ERVBUSF9DT01QT05FTlQzMkY7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSggZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBnbEludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Z2wucmVuZGVyYnVmZmVyU3RvcmFnZSggZ2wuUkVOREVSQlVGRkVSLCBnbEludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0fSBlbHNlIGlmICggZGVwdGhCdWZmZXIgJiYgc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0aWYgKCBzYW1wbGVzID4gMCApIHtcblxuXHRcdFx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoIGdsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2wuREVQVEgyNF9TVEVOQ0lMOCwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0Z2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGFzeW5jIGNvcHlUZXh0dXJlVG9CdWZmZXIoIHRleHR1cmUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZhY2VJbmRleCApIHtcblxuXHRcdGNvbnN0IHsgYmFja2VuZCwgZ2wgfSA9IHRoaXM7XG5cblx0XHRjb25zdCB7IHRleHR1cmVHUFUsIGdsRm9ybWF0LCBnbFR5cGUgfSA9IHRoaXMuYmFja2VuZC5nZXQoIHRleHR1cmUgKTtcblxuXHRcdGNvbnN0IGZiID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuUkVBRF9GUkFNRUJVRkZFUiwgZmIgKTtcblxuXHRcdGNvbnN0IHRhcmdldCA9IHRleHR1cmUuaXNDdWJlVGV4dHVyZSA/IGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGZhY2VJbmRleCA6IGdsLlRFWFRVUkVfMkQ7XG5cblx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggZ2wuUkVBRF9GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRhcmdldCwgdGV4dHVyZUdQVSwgMCApO1xuXG5cdFx0Y29uc3QgdHlwZWRBcnJheVR5cGUgPSB0aGlzLl9nZXRUeXBlZEFycmF5VHlwZSggZ2xUeXBlICk7XG5cdFx0Y29uc3QgYnl0ZXNQZXJUZXhlbCA9IHRoaXMuX2dldEJ5dGVzUGVyVGV4ZWwoIGdsVHlwZSwgZ2xGb3JtYXQgKTtcblxuXHRcdGNvbnN0IGVsZW1lbnRDb3VudCA9IHdpZHRoICogaGVpZ2h0O1xuXHRcdGNvbnN0IGJ5dGVMZW5ndGggPSBlbGVtZW50Q291bnQgKiBieXRlc1BlclRleGVsO1xuXG5cdFx0Y29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmZmVyICk7XG5cdFx0Z2wuYnVmZmVyRGF0YSggZ2wuUElYRUxfUEFDS19CVUZGRVIsIGJ5dGVMZW5ndGgsIGdsLlNUUkVBTV9SRUFEICk7XG5cdFx0Z2wucmVhZFBpeGVscyggeCwgeSwgd2lkdGgsIGhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgMCApO1xuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBudWxsICk7XG5cblx0XHRhd2FpdCBiYWNrZW5kLnV0aWxzLl9jbGllbnRXYWl0QXN5bmMoKTtcblxuXHRcdGNvbnN0IGRzdEJ1ZmZlciA9IG5ldyB0eXBlZEFycmF5VHlwZSggYnl0ZUxlbmd0aCAvIHR5cGVkQXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmZmVyICk7XG5cdFx0Z2wuZ2V0QnVmZmVyU3ViRGF0YSggZ2wuUElYRUxfUEFDS19CVUZGRVIsIDAsIGRzdEJ1ZmZlciApO1xuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBudWxsICk7XG5cblx0XHRnbC5kZWxldGVGcmFtZWJ1ZmZlciggZmIgKTtcblxuXHRcdHJldHVybiBkc3RCdWZmZXI7XG5cblx0fVxuXG5cdF9nZXRUeXBlZEFycmF5VHlwZSggZ2xUeXBlICkge1xuXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcblxuXHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9CWVRFICkgcmV0dXJuIFVpbnQ4QXJyYXk7XG5cblx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNCApIHJldHVybiBVaW50MTZBcnJheTtcblx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMSApIHJldHVybiBVaW50MTZBcnJheTtcblx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlRfNV82XzUgKSByZXR1cm4gVWludDE2QXJyYXk7XG5cdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUICkgcmV0dXJuIFVpbnQxNkFycmF5O1xuXHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9JTlQgKSByZXR1cm4gVWludDMyQXJyYXk7XG5cblx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuSEFMRl9GTE9BVCApIHJldHVybiBVaW50MTZBcnJheTtcblx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuRkxPQVQgKSByZXR1cm4gRmxvYXQzMkFycmF5O1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBgVW5zdXBwb3J0ZWQgV2ViR0wgdHlwZTogJHtnbFR5cGV9YCApO1xuXG5cdH1cblxuXHRfZ2V0Qnl0ZXNQZXJUZXhlbCggZ2xUeXBlLCBnbEZvcm1hdCApIHtcblxuXHRcdGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG5cblx0XHRsZXQgYnl0ZXNQZXJDb21wb25lbnQgPSAwO1xuXG5cdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0JZVEUgKSBieXRlc1BlckNvbXBvbmVudCA9IDE7XG5cblx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNCB8fFxuXHRcdFx0Z2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xIHx8XG5cdFx0XHRnbFR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUXzVfNl81IHx8XG5cdFx0XHRnbFR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUIHx8XG5cdFx0XHRnbFR5cGUgPT09IGdsLkhBTEZfRkxPQVQgKSBieXRlc1BlckNvbXBvbmVudCA9IDI7XG5cblx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfSU5UIHx8XG5cdFx0XHRnbFR5cGUgPT09IGdsLkZMT0FUICkgYnl0ZXNQZXJDb21wb25lbnQgPSA0O1xuXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuUkdCQSApIHJldHVybiBieXRlc1BlckNvbXBvbmVudCAqIDQ7XG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuUkdCICkgcmV0dXJuIGJ5dGVzUGVyQ29tcG9uZW50ICogMztcblx0XHRpZiAoIGdsRm9ybWF0ID09PSBnbC5BTFBIQSApIHJldHVybiBieXRlc1BlckNvbXBvbmVudDtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgV2ViR0xUZXh0dXJlVXRpbHM7XG4iLCJjbGFzcyBXZWJHTEV4dGVuc2lvbnMge1xuXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xuXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcblxuXHRcdHRoaXMuZ2wgPSB0aGlzLmJhY2tlbmQuZ2w7XG5cdFx0dGhpcy5hdmFpbGFibGVFeHRlbnNpb25zID0gdGhpcy5nbC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCk7XG5cblx0XHR0aGlzLmV4dGVuc2lvbnMgPSB7fTtcblxuXHR9XG5cblx0Z2V0KCBuYW1lICkge1xuXG5cdFx0bGV0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5zaW9uc1sgbmFtZSBdO1xuXG5cdFx0aWYgKCBleHRlbnNpb24gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oIG5hbWUgKTtcblxuXHRcdFx0dGhpcy5leHRlbnNpb25zWyBuYW1lIF0gPSBleHRlbnNpb247XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZXh0ZW5zaW9uO1xuXG5cdH1cblxuXHRoYXMoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hdmFpbGFibGVFeHRlbnNpb25zLmluY2x1ZGVzKCBuYW1lICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdlYkdMRXh0ZW5zaW9ucztcbiIsImNsYXNzIFdlYkdMQ2FwYWJpbGl0aWVzIHtcblxuXHRjb25zdHJ1Y3RvciggYmFja2VuZCApIHtcblxuXHRcdHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XG5cblx0XHR0aGlzLm1heEFuaXNvdHJvcHkgPSBudWxsO1xuXG5cdH1cblxuXHRnZXRNYXhBbmlzb3Ryb3B5KCkge1xuXG5cdFx0aWYgKCB0aGlzLm1heEFuaXNvdHJvcHkgIT09IG51bGwgKSByZXR1cm4gdGhpcy5tYXhBbmlzb3Ryb3B5O1xuXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmJhY2tlbmQuZ2w7XG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuYmFja2VuZC5leHRlbnNpb25zO1xuXG5cdFx0aWYgKCBleHRlbnNpb25zLmhhcyggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cblx0XHRcdHRoaXMubWF4QW5pc290cm9weSA9IGdsLmdldFBhcmFtZXRlciggZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5tYXhBbmlzb3Ryb3B5ID0gMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm1heEFuaXNvdHJvcHk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdlYkdMQ2FwYWJpbGl0aWVzO1xuIiwiZXhwb3J0IGNvbnN0IEdMRmVhdHVyZU5hbWUgPSB7XG5cblx0J1dFQkdMX211bHRpX2RyYXcnOiAnV0VCR0xfbXVsdGlfZHJhdycsXG5cdCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0Yyc6ICd0ZXh0dXJlLWNvbXByZXNzaW9uLWFzdGMnLFxuXHQnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0Yyc6ICd0ZXh0dXJlLWNvbXByZXNzaW9uLWV0YzInLFxuXHQnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnOiAndGV4dHVyZS1jb21wcmVzc2lvbi1ldGMxJyxcblx0J1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yyc6ICd0ZXh0dXJlLWNvbXByZXNzaW9uLXB2cnRjJyxcblx0J1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnOiAndGV4dHVyZS1jb21wcmVzc2lvbi1wdnJ0YycsXG5cdCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6ICd0ZXh0dXJlLWNvbXByZXNzaW9uLWJjJyxcblx0J0VYVF90ZXh0dXJlX2NvbXByZXNzaW9uX2JwdGMnOiAndGV4dHVyZS1jb21wcmVzc2lvbi1icHRjJyxcblx0J0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInOiAndGltZXN0YW1wLXF1ZXJ5JyxcblxufTtcbiIsImNsYXNzIFdlYkdMQnVmZmVyUmVuZGVyZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xuXG5cdFx0dGhpcy5nbCA9IGJhY2tlbmQuZ2w7XG5cdFx0dGhpcy5leHRlbnNpb25zID0gYmFja2VuZC5leHRlbnNpb25zO1xuXHRcdHRoaXMuaW5mbyA9IGJhY2tlbmQucmVuZGVyZXIuaW5mbztcblx0XHR0aGlzLm1vZGUgPSBudWxsO1xuXHRcdHRoaXMuaW5kZXggPSAwO1xuXHRcdHRoaXMudHlwZSA9IG51bGw7XG5cdFx0dGhpcy5vYmplY3QgPSBudWxsO1xuXG5cdH1cblxuXHRyZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcblxuXHRcdGNvbnN0IHsgZ2wsIG1vZGUsIG9iamVjdCwgdHlwZSwgaW5mbywgaW5kZXggfSA9IHRoaXM7XG5cblx0XHRpZiAoIGluZGV4ICE9PSAwICkge1xuXG5cdFx0XHRnbC5kcmF3RWxlbWVudHMoIG1vZGUsIGNvdW50LCB0eXBlLCBzdGFydCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Z2wuZHJhd0FycmF5cyggbW9kZSwgc3RhcnQsIGNvdW50ICk7XG5cblx0XHR9XG5cblx0XHRpbmZvLnVwZGF0ZSggb2JqZWN0LCBjb3VudCwgbW9kZSwgMSApO1xuXG5cdH1cblxuXHRyZW5kZXJJbnN0YW5jZXMoIHN0YXJ0LCBjb3VudCwgcHJpbWNvdW50ICkge1xuXG5cdFx0Y29uc3QgeyBnbCwgbW9kZSwgdHlwZSwgaW5kZXgsIG9iamVjdCwgaW5mbyB9ID0gdGhpcztcblxuXHRcdGlmICggcHJpbWNvdW50ID09PSAwICkgcmV0dXJuO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gMCApIHtcblxuXHRcdFx0Z2wuZHJhd0VsZW1lbnRzSW5zdGFuY2VkKCBtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQsIHByaW1jb3VudCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Z2wuZHJhd0FycmF5c0luc3RhbmNlZCggbW9kZSwgc3RhcnQsIGNvdW50LCBwcmltY291bnQgKTtcblxuXHRcdH1cblxuXHRcdGluZm8udXBkYXRlKCBvYmplY3QsIGNvdW50LCBtb2RlLCBwcmltY291bnQgKTtcblxuXHR9XG5cblx0cmVuZGVyTXVsdGlEcmF3KCBzdGFydHMsIGNvdW50cywgZHJhd0NvdW50ICkge1xuXG5cdFx0Y29uc3QgeyBleHRlbnNpb25zLCBtb2RlLCBvYmplY3QsIGluZm8gfSA9IHRoaXM7XG5cblx0XHRpZiAoIGRyYXdDb3VudCA9PT0gMCApIHJldHVybjtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbXVsdGlfZHJhdycgKTtcblxuXHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBkcmF3Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5yZW5kZXIoIHN0YXJ0c1sgaSBdLCBjb3VudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIHRoaXMuaW5kZXggIT09IDAgKSB7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uLm11bHRpRHJhd0VsZW1lbnRzV0VCR0woIG1vZGUsIGNvdW50cywgMCwgdGhpcy50eXBlLCBzdGFydHMsIDAsIGRyYXdDb3VudCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGV4dGVuc2lvbi5tdWx0aURyYXdBcnJheXNXRUJHTCggbW9kZSwgc3RhcnRzLCAwLCBjb3VudHMsIDAsIGRyYXdDb3VudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBlbGVtZW50Q291bnQgPSAwO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZHJhd0NvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdGVsZW1lbnRDb3VudCArPSBjb3VudHNbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpbmZvLnVwZGF0ZSggb2JqZWN0LCBlbGVtZW50Q291bnQsIG1vZGUsIDEgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmVuZGVyTXVsdGlEcmF3SW5zdGFuY2VzKCBzdGFydHMsIGNvdW50cywgZHJhd0NvdW50LCBwcmltY291bnQgKSB7XG5cblx0XHRjb25zdCB7IGV4dGVuc2lvbnMsIG1vZGUsIG9iamVjdCwgaW5mbyB9ID0gdGhpcztcblxuXHRcdGlmICggZHJhd0NvdW50ID09PSAwICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9tdWx0aV9kcmF3JyApO1xuXG5cdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRyYXdDb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnJlbmRlckluc3RhbmNlcyggc3RhcnRzWyBpIF0sIGNvdW50c1sgaSBdLCBwcmltY291bnRbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIHRoaXMuaW5kZXggIT09IDAgKSB7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uLm11bHRpRHJhd0VsZW1lbnRzSW5zdGFuY2VkV0VCR0woIG1vZGUsIGNvdW50cywgMCwgdGhpcy50eXBlLCBzdGFydHMsIDAsIHByaW1jb3VudCwgMCwgZHJhd0NvdW50ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uLm11bHRpRHJhd0FycmF5c0luc3RhbmNlZFdFQkdMKCBtb2RlLCBzdGFydHMsIDAsIGNvdW50cywgMCwgcHJpbWNvdW50LCAwLCBkcmF3Q291bnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgZWxlbWVudENvdW50ID0gMDtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRyYXdDb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRlbGVtZW50Q291bnQgKz0gY291bnRzWyBpIF0gKiBwcmltY291bnRbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpbmZvLnVwZGF0ZSggb2JqZWN0LCBlbGVtZW50Q291bnQsIG1vZGUsIDEgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly9cblxufVxuXG5cbmV4cG9ydCB7IFdlYkdMQnVmZmVyUmVuZGVyZXIgfTtcbiIsImltcG9ydCBHTFNMTm9kZUJ1aWxkZXIgZnJvbSAnLi9ub2Rlcy9HTFNMTm9kZUJ1aWxkZXIuanMnO1xuaW1wb3J0IEJhY2tlbmQgZnJvbSAnLi4vY29tbW9uL0JhY2tlbmQuanMnO1xuaW1wb3J0IHsgZ2V0Q2FjaGVLZXkgfSBmcm9tICcuLi9jb21tb24vUmVuZGVyQ29udGV4dC5qcyc7XG5cbmltcG9ydCBXZWJHTEF0dHJpYnV0ZVV0aWxzIGZyb20gJy4vdXRpbHMvV2ViR0xBdHRyaWJ1dGVVdGlscy5qcyc7XG5pbXBvcnQgV2ViR0xTdGF0ZSBmcm9tICcuL3V0aWxzL1dlYkdMU3RhdGUuanMnO1xuaW1wb3J0IFdlYkdMVXRpbHMgZnJvbSAnLi91dGlscy9XZWJHTFV0aWxzLmpzJztcbmltcG9ydCBXZWJHTFRleHR1cmVVdGlscyBmcm9tICcuL3V0aWxzL1dlYkdMVGV4dHVyZVV0aWxzLmpzJztcbmltcG9ydCBXZWJHTEV4dGVuc2lvbnMgZnJvbSAnLi91dGlscy9XZWJHTEV4dGVuc2lvbnMuanMnO1xuaW1wb3J0IFdlYkdMQ2FwYWJpbGl0aWVzIGZyb20gJy4vdXRpbHMvV2ViR0xDYXBhYmlsaXRpZXMuanMnO1xuaW1wb3J0IHsgR0xGZWF0dXJlTmFtZSB9IGZyb20gJy4vdXRpbHMvV2ViR0xDb25zdGFudHMuanMnO1xuaW1wb3J0IHsgV2ViR0xCdWZmZXJSZW5kZXJlciB9IGZyb20gJy4vV2ViR0xCdWZmZXJSZW5kZXJlci5qcyc7XG5cbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHsgV2ViR0xDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcblxuLy9cblxuY2xhc3MgV2ViR0xCYWNrZW5kIGV4dGVuZHMgQmFja2VuZCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgPSB7fSApIHtcblxuXHRcdHN1cGVyKCBwYXJhbWV0ZXJzICk7XG5cblx0XHR0aGlzLmlzV2ViR0xCYWNrZW5kID0gdHJ1ZTtcblxuXHR9XG5cblx0aW5pdCggcmVuZGVyZXIgKSB7XG5cblx0XHRzdXBlci5pbml0KCByZW5kZXJlciApO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRjb25zdCBnbENvbnRleHQgPSAoIHBhcmFtZXRlcnMuY29udGV4dCAhPT0gdW5kZWZpbmVkICkgPyBwYXJhbWV0ZXJzLmNvbnRleHQgOiByZW5kZXJlci5kb21FbGVtZW50LmdldENvbnRleHQoICd3ZWJnbDInICk7XG5cblx0IFx0ZnVuY3Rpb24gb25Db250ZXh0TG9zdCggZXZlbnQgKSB7XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdGNvbnN0IGNvbnRleHRMb3NzSW5mbyA9IHtcblx0XHRcdFx0YXBpOiAnV2ViR0wnLFxuXHRcdFx0XHRtZXNzYWdlOiBldmVudC5zdGF0dXNNZXNzYWdlIHx8ICdVbmtub3duIHJlYXNvbicsXG5cdFx0XHRcdHJlYXNvbjogbnVsbCxcblx0XHRcdFx0b3JpZ2luYWxFdmVudDogZXZlbnRcblx0XHRcdH07XG5cblx0XHRcdHJlbmRlcmVyLm9uRGV2aWNlTG9zdCggY29udGV4dExvc3NJbmZvICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vbkNvbnRleHRMb3N0ID0gb25Db250ZXh0TG9zdDtcblxuXHRcdHJlbmRlcmVyLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xuXG5cdFx0dGhpcy5nbCA9IGdsQ29udGV4dDtcblxuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IG5ldyBXZWJHTEV4dGVuc2lvbnMoIHRoaXMgKTtcblx0XHR0aGlzLmNhcGFiaWxpdGllcyA9IG5ldyBXZWJHTENhcGFiaWxpdGllcyggdGhpcyApO1xuXHRcdHRoaXMuYXR0cmlidXRlVXRpbHMgPSBuZXcgV2ViR0xBdHRyaWJ1dGVVdGlscyggdGhpcyApO1xuXHRcdHRoaXMudGV4dHVyZVV0aWxzID0gbmV3IFdlYkdMVGV4dHVyZVV0aWxzKCB0aGlzICk7XG5cdFx0dGhpcy5idWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEJ1ZmZlclJlbmRlcmVyKCB0aGlzICk7XG5cblx0XHR0aGlzLnN0YXRlID0gbmV3IFdlYkdMU3RhdGUoIHRoaXMgKTtcblx0XHR0aGlzLnV0aWxzID0gbmV3IFdlYkdMVXRpbHMoIHRoaXMgKTtcblxuXHRcdHRoaXMudmFvQ2FjaGUgPSB7fTtcblx0XHR0aGlzLnRyYW5zZm9ybUZlZWRiYWNrQ2FjaGUgPSB7fTtcblx0XHR0aGlzLmRpc2NhcmQgPSBmYWxzZTtcblx0XHR0aGlzLnRyYWNrVGltZXN0YW1wID0gKCBwYXJhbWV0ZXJzLnRyYWNrVGltZXN0YW1wID09PSB0cnVlICk7XG5cblx0XHR0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcgKTtcblx0XHR0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY2xpcF9jdWxsX2Rpc3RhbmNlJyApO1xuXHRcdHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICk7XG5cdFx0dGhpcy5leHRlbnNpb25zLmdldCggJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcgKTtcblx0XHR0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyApO1xuXHRcdHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9yZW5kZXJfc2hhcmVkX2V4cG9uZW50JyApO1xuXHRcdHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9tdWx0aV9kcmF3JyApO1xuXG5cdFx0dGhpcy5kaXNqb2ludCA9IHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyJyApO1xuXHRcdHRoaXMucGFyYWxsZWwgPSB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnS0hSX3BhcmFsbGVsX3NoYWRlcl9jb21waWxlJyApO1xuXG5cdFx0dGhpcy5fa25vd25CaW5kaW5ncyA9IG5ldyBXZWFrU2V0KCk7XG5cblx0XHR0aGlzLl9jdXJyZW50Q29udGV4dCA9IG51bGw7XG5cblx0fVxuXG5cdGdldCBjb29yZGluYXRlU3lzdGVtKCkge1xuXG5cdFx0cmV0dXJuIFdlYkdMQ29vcmRpbmF0ZVN5c3RlbTtcblxuXHR9XG5cblx0YXN5bmMgZ2V0QXJyYXlCdWZmZXJBc3luYyggYXR0cmlidXRlICkge1xuXG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMuYXR0cmlidXRlVXRpbHMuZ2V0QXJyYXlCdWZmZXJBc3luYyggYXR0cmlidXRlICk7XG5cblx0fVxuXG5cdGFzeW5jIHdhaXRGb3JHUFUoKSB7XG5cblx0XHRhd2FpdCB0aGlzLnV0aWxzLl9jbGllbnRXYWl0QXN5bmMoKTtcblxuXHR9XG5cblx0aW5pdFRpbWVzdGFtcFF1ZXJ5KCByZW5kZXJDb250ZXh0ICkge1xuXG5cdFx0aWYgKCAhIHRoaXMuZGlzam9pbnQgfHwgISB0aGlzLnRyYWNrVGltZXN0YW1wICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dCApO1xuXG5cdFx0aWYgKCB0aGlzLnF1ZXJ5UnVubmluZyApIHtcblxuXHRcdCAgaWYgKCAhIHJlbmRlckNvbnRleHREYXRhLnF1ZXJ5UXVldWUgKSByZW5kZXJDb250ZXh0RGF0YS5xdWVyeVF1ZXVlID0gW107XG5cdFx0ICByZW5kZXJDb250ZXh0RGF0YS5xdWVyeVF1ZXVlLnB1c2goIHJlbmRlckNvbnRleHQgKTtcblx0XHQgIHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEuYWN0aXZlUXVlcnkgKSB7XG5cblx0XHQgIHRoaXMuZ2wuZW5kUXVlcnkoIHRoaXMuZGlzam9pbnQuVElNRV9FTEFQU0VEX0VYVCApO1xuXHRcdCAgcmVuZGVyQ29udGV4dERhdGEuYWN0aXZlUXVlcnkgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0cmVuZGVyQ29udGV4dERhdGEuYWN0aXZlUXVlcnkgPSB0aGlzLmdsLmNyZWF0ZVF1ZXJ5KCk7XG5cblx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLmFjdGl2ZVF1ZXJ5ICE9PSBudWxsICkge1xuXG5cdFx0ICB0aGlzLmdsLmJlZ2luUXVlcnkoIHRoaXMuZGlzam9pbnQuVElNRV9FTEFQU0VEX0VYVCwgcmVuZGVyQ29udGV4dERhdGEuYWN0aXZlUXVlcnkgKTtcblx0XHQgIHRoaXMucXVlcnlSdW5uaW5nID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gdGltZXN0YW1wIHV0aWxzXG5cblx0cHJlcGFyZVRpbWVzdGFtcEJ1ZmZlciggcmVuZGVyQ29udGV4dCApIHtcblxuXHRcdGlmICggISB0aGlzLmRpc2pvaW50IHx8ICEgdGhpcy50cmFja1RpbWVzdGFtcCApIHJldHVybjtcblxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcblxuXHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEuYWN0aXZlUXVlcnkgKSB7XG5cblx0XHQgIHRoaXMuZ2wuZW5kUXVlcnkoIHRoaXMuZGlzam9pbnQuVElNRV9FTEFQU0VEX0VYVCApO1xuXG5cdFx0ICBpZiAoICEgcmVuZGVyQ29udGV4dERhdGEuZ3B1UXVlcmllcyApIHJlbmRlckNvbnRleHREYXRhLmdwdVF1ZXJpZXMgPSBbXTtcblx0XHQgIHJlbmRlckNvbnRleHREYXRhLmdwdVF1ZXJpZXMucHVzaCggeyBxdWVyeTogcmVuZGVyQ29udGV4dERhdGEuYWN0aXZlUXVlcnkgfSApO1xuXHRcdCAgcmVuZGVyQ29udGV4dERhdGEuYWN0aXZlUXVlcnkgPSBudWxsO1xuXHRcdCAgdGhpcy5xdWVyeVJ1bm5pbmcgPSBmYWxzZTtcblxuXHRcdCAgaWYgKCByZW5kZXJDb250ZXh0RGF0YS5xdWVyeVF1ZXVlICYmIHJlbmRlckNvbnRleHREYXRhLnF1ZXJ5UXVldWUubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRjb25zdCBuZXh0UmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHREYXRhLnF1ZXJ5UXVldWUuc2hpZnQoKTtcblx0XHRcdFx0dGhpcy5pbml0VGltZXN0YW1wUXVlcnkoIG5leHRSZW5kZXJDb250ZXh0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0YXN5bmMgcmVzb2x2ZVRpbWVzdGFtcEFzeW5jKCByZW5kZXJDb250ZXh0LCB0eXBlID0gJ3JlbmRlcicgKSB7XG5cblx0XHRpZiAoICEgdGhpcy5kaXNqb2ludCB8fCAhIHRoaXMudHJhY2tUaW1lc3RhbXAgKSByZXR1cm47XG5cblx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0ICk7XG5cblx0XHRpZiAoICEgcmVuZGVyQ29udGV4dERhdGEuZ3B1UXVlcmllcyApIHJlbmRlckNvbnRleHREYXRhLmdwdVF1ZXJpZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHJlbmRlckNvbnRleHREYXRhLmdwdVF1ZXJpZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0ICBjb25zdCBxdWVyeUluZm8gPSByZW5kZXJDb250ZXh0RGF0YS5ncHVRdWVyaWVzWyBpIF07XG5cdFx0ICBjb25zdCBhdmFpbGFibGUgPSB0aGlzLmdsLmdldFF1ZXJ5UGFyYW1ldGVyKCBxdWVyeUluZm8ucXVlcnksIHRoaXMuZ2wuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSApO1xuXHRcdCAgY29uc3QgZGlzam9pbnQgPSB0aGlzLmdsLmdldFBhcmFtZXRlciggdGhpcy5kaXNqb2ludC5HUFVfRElTSk9JTlRfRVhUICk7XG5cblx0XHQgIGlmICggYXZhaWxhYmxlICYmICEgZGlzam9pbnQgKSB7XG5cblx0XHRcdFx0Y29uc3QgZWxhcHNlZCA9IHRoaXMuZ2wuZ2V0UXVlcnlQYXJhbWV0ZXIoIHF1ZXJ5SW5mby5xdWVyeSwgdGhpcy5nbC5RVUVSWV9SRVNVTFQgKTtcblx0XHRcdFx0Y29uc3QgZHVyYXRpb24gPSBOdW1iZXIoIGVsYXBzZWQgKSAvIDEwMDAwMDA7IC8vIENvbnZlcnQgbmFub3NlY29uZHMgdG8gbWlsbGlzZWNvbmRzXG5cdFx0XHRcdHRoaXMuZ2wuZGVsZXRlUXVlcnkoIHF1ZXJ5SW5mby5xdWVyeSApO1xuXHRcdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5ncHVRdWVyaWVzLnNwbGljZSggaSwgMSApOyAvLyBSZW1vdmUgdGhlIHByb2Nlc3NlZCBxdWVyeVxuXHRcdFx0XHRpIC0tO1xuXHRcdFx0XHR0aGlzLnJlbmRlcmVyLmluZm8udXBkYXRlVGltZXN0YW1wKCB0eXBlLCBkdXJhdGlvbiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldENvbnRleHQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nbDtcblxuXHR9XG5cblx0YmVnaW5SZW5kZXIoIHJlbmRlckNvbnRleHQgKSB7XG5cblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcblxuXHRcdC8vXG5cblx0XHQvL1xuXG5cdFx0dGhpcy5pbml0VGltZXN0YW1wUXVlcnkoIHJlbmRlckNvbnRleHQgKTtcblxuXHRcdHJlbmRlckNvbnRleHREYXRhLnByZXZpb3VzQ29udGV4dCA9IHRoaXMuX2N1cnJlbnRDb250ZXh0O1xuXHRcdHRoaXMuX2N1cnJlbnRDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcblxuXHRcdHRoaXMuX3NldEZyYW1lYnVmZmVyKCByZW5kZXJDb250ZXh0ICk7XG5cblx0XHR0aGlzLmNsZWFyKCByZW5kZXJDb250ZXh0LmNsZWFyQ29sb3IsIHJlbmRlckNvbnRleHQuY2xlYXJEZXB0aCwgcmVuZGVyQ29udGV4dC5jbGVhclN0ZW5jaWwsIHJlbmRlckNvbnRleHQsIGZhbHNlICk7XG5cblx0XHQvL1xuXHRcdGlmICggcmVuZGVyQ29udGV4dC52aWV3cG9ydCApIHtcblxuXHRcdFx0dGhpcy51cGRhdGVWaWV3cG9ydCggcmVuZGVyQ29udGV4dCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Z2wudmlld3BvcnQoIDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCByZW5kZXJDb250ZXh0LnNjaXNzb3IgKSB7XG5cblx0XHRcdGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gcmVuZGVyQ29udGV4dC5zY2lzc29yVmFsdWU7XG5cblx0XHRcdGdsLnNjaXNzb3IoIHgsIHJlbmRlckNvbnRleHQuaGVpZ2h0IC0gaGVpZ2h0IC0geSwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb2NjbHVzaW9uUXVlcnlDb3VudCA9IHJlbmRlckNvbnRleHQub2NjbHVzaW9uUXVlcnlDb3VudDtcblxuXHRcdGlmICggb2NjbHVzaW9uUXVlcnlDb3VudCA+IDAgKSB7XG5cblx0XHRcdC8vIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHF1ZXJpZXMuIFRoZSByZW5kZXJDb250ZXh0RGF0YSBwcm9wZXJ0eVxuXHRcdFx0Ly8gY2FuIGJlIGNoYW5nZWQgYnkgYW5vdGhlciByZW5kZXIgcGFzcyBiZWZvcmUgdGhlIGFzeW5jIHJlYWRpbmcgb2YgYWxsIHByZXZpb3VzIHF1ZXJpZXMgY29tcGxldGVcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRPY2NsdXNpb25RdWVyaWVzID0gcmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcmllcztcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRPY2NsdXNpb25RdWVyeU9iamVjdHMgPSByZW5kZXJDb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeU9iamVjdHM7XG5cblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmxhc3RPY2NsdXNpb25PYmplY3QgPSBudWxsO1xuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcmllcyA9IG5ldyBBcnJheSggb2NjbHVzaW9uUXVlcnlDb3VudCApO1xuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlPYmplY3RzID0gbmV3IEFycmF5KCBvY2NsdXNpb25RdWVyeUNvdW50ICk7XG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeUluZGV4ID0gMDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZmluaXNoUmVuZGVyKCByZW5kZXJDb250ZXh0ICkge1xuXG5cdFx0Y29uc3QgeyBnbCwgc3RhdGUgfSA9IHRoaXM7XG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dCApO1xuXHRcdGNvbnN0IHByZXZpb3VzQ29udGV4dCA9IHJlbmRlckNvbnRleHREYXRhLnByZXZpb3VzQ29udGV4dDtcblxuXHRcdGNvbnN0IG9jY2x1c2lvblF1ZXJ5Q291bnQgPSByZW5kZXJDb250ZXh0Lm9jY2x1c2lvblF1ZXJ5Q291bnQ7XG5cblx0XHRpZiAoIG9jY2x1c2lvblF1ZXJ5Q291bnQgPiAwICkge1xuXG5cdFx0XHRpZiAoIG9jY2x1c2lvblF1ZXJ5Q291bnQgPiByZW5kZXJDb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeUluZGV4ICkge1xuXG5cdFx0XHRcdGdsLmVuZFF1ZXJ5KCBnbC5BTllfU0FNUExFU19QQVNTRUQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJlc29sdmVPY2NsdWRlZEFzeW5jKCByZW5kZXJDb250ZXh0ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlckNvbnRleHQudGV4dHVyZXM7XG5cblx0XHRpZiAoIHRleHR1cmVzICE9PSBudWxsICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHRleHR1cmVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyApIHtcblxuXHRcdFx0XHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLl9jdXJyZW50Q29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcblxuXHRcdGlmICggcmVuZGVyQ29udGV4dC50ZXh0dXJlcyAhPT0gbnVsbCAmJiByZW5kZXJDb250ZXh0LnJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dC5yZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0Y29uc3QgeyBzYW1wbGVzIH0gPSByZW5kZXJDb250ZXh0LnJlbmRlclRhcmdldDtcblxuXHRcdFx0aWYgKCBzYW1wbGVzID4gMCApIHtcblxuXHRcdFx0XHRjb25zdCBmYiA9IHJlbmRlclRhcmdldENvbnRleHREYXRhLmZyYW1lYnVmZmVyc1sgcmVuZGVyQ29udGV4dC5nZXRDYWNoZUtleSgpIF07XG5cblx0XHRcdFx0Y29uc3QgbWFzayA9IGdsLkNPTE9SX0JVRkZFUl9CSVQ7XG5cblx0XHRcdFx0Y29uc3QgbXNhYUZyYW1lQnVmZmVyID0gcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEubXNhYUZyYW1lQnVmZmVyO1xuXG5cdFx0XHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyQ29udGV4dC50ZXh0dXJlcztcblxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLlJFQURfRlJBTUVCVUZGRVIsIG1zYWFGcmFtZUJ1ZmZlciApO1xuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLkRSQVdfRlJBTUVCVUZGRVIsIGZiICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Ly8gVE9ETyBBZGQgc3VwcG9ydCBmb3IgTVJUXG5cblx0XHRcdFx0XHRpZiAoIHJlbmRlckNvbnRleHQuc2Npc3NvciApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZW5kZXJDb250ZXh0LnNjaXNzb3JWYWx1ZTtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgdmlld1kgPSByZW5kZXJDb250ZXh0LmhlaWdodCAtIGhlaWdodCAtIHk7XG5cblx0XHRcdFx0XHRcdGdsLmJsaXRGcmFtZWJ1ZmZlciggeCwgdmlld1ksIHggKyB3aWR0aCwgdmlld1kgKyBoZWlnaHQsIHgsIHZpZXdZLCB4ICsgd2lkdGgsIHZpZXdZICsgaGVpZ2h0LCBtYXNrLCBnbC5ORUFSRVNUICk7XG5cdFx0XHRcdFx0XHRnbC5pbnZhbGlkYXRlU3ViRnJhbWVidWZmZXIoIGdsLlJFQURfRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldENvbnRleHREYXRhLmludmFsaWRhdGlvbkFycmF5LCB4LCB2aWV3WSwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Z2wuYmxpdEZyYW1lYnVmZmVyKCAwLCAwLCByZW5kZXJDb250ZXh0LndpZHRoLCByZW5kZXJDb250ZXh0LmhlaWdodCwgMCwgMCwgcmVuZGVyQ29udGV4dC53aWR0aCwgcmVuZGVyQ29udGV4dC5oZWlnaHQsIG1hc2ssIGdsLk5FQVJFU1QgKTtcblx0XHRcdFx0XHRcdGdsLmludmFsaWRhdGVGcmFtZWJ1ZmZlciggZ2wuUkVBRF9GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEuaW52YWxpZGF0aW9uQXJyYXkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXG5cdFx0fVxuXG5cdFx0aWYgKCBwcmV2aW91c0NvbnRleHQgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX3NldEZyYW1lYnVmZmVyKCBwcmV2aW91c0NvbnRleHQgKTtcblxuXHRcdFx0aWYgKCBwcmV2aW91c0NvbnRleHQudmlld3BvcnQgKSB7XG5cblx0XHRcdFx0dGhpcy51cGRhdGVWaWV3cG9ydCggcHJldmlvdXNDb250ZXh0ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Z2wudmlld3BvcnQoIDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLnByZXBhcmVUaW1lc3RhbXBCdWZmZXIoIHJlbmRlckNvbnRleHQgKTtcblxuXHR9XG5cblx0cmVzb2x2ZU9jY2x1ZGVkQXN5bmMoIHJlbmRlckNvbnRleHQgKSB7XG5cblx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0ICk7XG5cblx0XHQvLyBoYW5kbGUgb2NjbHVzaW9uIHF1ZXJ5IHJlc3VsdHNcblxuXHRcdGNvbnN0IHsgY3VycmVudE9jY2x1c2lvblF1ZXJpZXMsIGN1cnJlbnRPY2NsdXNpb25RdWVyeU9iamVjdHMgfSA9IHJlbmRlckNvbnRleHREYXRhO1xuXG5cdFx0aWYgKCBjdXJyZW50T2NjbHVzaW9uUXVlcmllcyAmJiBjdXJyZW50T2NjbHVzaW9uUXVlcnlPYmplY3RzICkge1xuXG5cdFx0XHRjb25zdCBvY2NsdWRlZCA9IG5ldyBXZWFrU2V0KCk7XG5cdFx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xuXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50T2NjbHVzaW9uUXVlcnlPYmplY3RzID0gbnVsbDtcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRPY2NsdXNpb25RdWVyaWVzID0gbnVsbDtcblxuXHRcdFx0Y29uc3QgY2hlY2sgPSAoKSA9PiB7XG5cblx0XHRcdFx0bGV0IGNvbXBsZXRlZCA9IDA7XG5cblx0XHRcdFx0Ly8gY2hlY2sgYWxsIHF1ZXJpZXMgYW5kIHJlcXVldWUgYXMgYXBwcm9wcmlhdGVcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY3VycmVudE9jY2x1c2lvblF1ZXJpZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgcXVlcnkgPSBjdXJyZW50T2NjbHVzaW9uUXVlcmllc1sgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBxdWVyeSA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0aWYgKCBnbC5nZXRRdWVyeVBhcmFtZXRlciggcXVlcnksIGdsLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBnbC5nZXRRdWVyeVBhcmFtZXRlciggcXVlcnksIGdsLlFVRVJZX1JFU1VMVCApID4gMCApIG9jY2x1ZGVkLmFkZCggY3VycmVudE9jY2x1c2lvblF1ZXJ5T2JqZWN0c1sgaSBdICk7XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRPY2NsdXNpb25RdWVyaWVzWyBpIF0gPSBudWxsO1xuXHRcdFx0XHRcdFx0Z2wuZGVsZXRlUXVlcnkoIHF1ZXJ5ICk7XG5cblx0XHRcdFx0XHRcdGNvbXBsZXRlZCArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPCBjdXJyZW50T2NjbHVzaW9uUXVlcmllcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGNoZWNrICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJlbmRlckNvbnRleHREYXRhLm9jY2x1ZGVkID0gb2NjbHVkZWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9O1xuXG5cdFx0XHRjaGVjaygpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRpc09jY2x1ZGVkKCByZW5kZXJDb250ZXh0LCBvYmplY3QgKSB7XG5cblx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0ICk7XG5cblx0XHRyZXR1cm4gcmVuZGVyQ29udGV4dERhdGEub2NjbHVkZWQgJiYgcmVuZGVyQ29udGV4dERhdGEub2NjbHVkZWQuaGFzKCBvYmplY3QgKTtcblxuXHR9XG5cblx0dXBkYXRlVmlld3BvcnQoIHJlbmRlckNvbnRleHQgKSB7XG5cblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XG5cdFx0Y29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZW5kZXJDb250ZXh0LnZpZXdwb3J0VmFsdWU7XG5cblx0XHRnbC52aWV3cG9ydCggeCwgcmVuZGVyQ29udGV4dC5oZWlnaHQgLSBoZWlnaHQgLSB5LCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0fVxuXG5cdHNldFNjaXNzb3JUZXN0KCBib29sZWFuICkge1xuXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXG5cdFx0aWYgKCBib29sZWFuICkge1xuXG5cdFx0XHRnbC5lbmFibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Z2wuZGlzYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwsIGRlc2NyaXB0b3IgPSBudWxsLCBzZXRGcmFtZUJ1ZmZlciA9IHRydWUgKSB7XG5cblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xuXG5cdFx0aWYgKCBkZXNjcmlwdG9yID09PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBjbGVhckNvbG9yID0gdGhpcy5nZXRDbGVhckNvbG9yKCk7XG5cblx0XHRcdC8vIHByZW11bHRpcGx5IGFscGhhXG5cblx0XHRcdGNsZWFyQ29sb3IuciAqPSBjbGVhckNvbG9yLmE7XG5cdFx0XHRjbGVhckNvbG9yLmcgKj0gY2xlYXJDb2xvci5hO1xuXHRcdFx0Y2xlYXJDb2xvci5iICo9IGNsZWFyQ29sb3IuYTtcblxuXHRcdFx0ZGVzY3JpcHRvciA9IHtcblx0XHRcdFx0dGV4dHVyZXM6IG51bGwsXG5cdFx0XHRcdGNsZWFyQ29sb3JWYWx1ZTogY2xlYXJDb2xvclxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRsZXQgY2xlYXIgPSAwO1xuXG5cdFx0aWYgKCBjb2xvciApIGNsZWFyIHw9IGdsLkNPTE9SX0JVRkZFUl9CSVQ7XG5cdFx0aWYgKCBkZXB0aCApIGNsZWFyIHw9IGdsLkRFUFRIX0JVRkZFUl9CSVQ7XG5cdFx0aWYgKCBzdGVuY2lsICkgY2xlYXIgfD0gZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xuXG5cdFx0aWYgKCBjbGVhciAhPT0gMCApIHtcblxuXHRcdFx0bGV0IGNsZWFyQ29sb3I7XG5cblx0XHRcdGlmICggZGVzY3JpcHRvci5jbGVhckNvbG9yVmFsdWUgKSB7XG5cblx0XHRcdFx0Y2xlYXJDb2xvciA9IGRlc2NyaXB0b3IuY2xlYXJDb2xvclZhbHVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNsZWFyQ29sb3IgPSB0aGlzLmdldENsZWFyQ29sb3IoKTtcblxuXHRcdFx0XHQvLyBwcmVtdWx0aXBseSBhbHBoYVxuXG5cdFx0XHRcdGNsZWFyQ29sb3IuciAqPSBjbGVhckNvbG9yLmE7XG5cdFx0XHRcdGNsZWFyQ29sb3IuZyAqPSBjbGVhckNvbG9yLmE7XG5cdFx0XHRcdGNsZWFyQ29sb3IuYiAqPSBjbGVhckNvbG9yLmE7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkZXB0aCApIHRoaXMuc3RhdGUuc2V0RGVwdGhNYXNrKCB0cnVlICk7XG5cblx0XHRcdGlmICggZGVzY3JpcHRvci50ZXh0dXJlcyA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRnbC5jbGVhckNvbG9yKCBjbGVhckNvbG9yLnIsIGNsZWFyQ29sb3IuZywgY2xlYXJDb2xvci5iLCBjbGVhckNvbG9yLmEgKTtcblx0XHRcdFx0Z2wuY2xlYXIoIGNsZWFyICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBzZXRGcmFtZUJ1ZmZlciApIHRoaXMuX3NldEZyYW1lYnVmZmVyKCBkZXNjcmlwdG9yICk7XG5cblx0XHRcdFx0aWYgKCBjb2xvciApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRlc2NyaXB0b3IudGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRnbC5jbGVhckJ1ZmZlcmZ2KCBnbC5DT0xPUiwgaSwgWyBjbGVhckNvbG9yLnIsIGNsZWFyQ29sb3IuZywgY2xlYXJDb2xvci5iLCBjbGVhckNvbG9yLmEgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRlcHRoICYmIHN0ZW5jaWwgKSB7XG5cblx0XHRcdFx0XHRnbC5jbGVhckJ1ZmZlcmZpKCBnbC5ERVBUSF9TVEVOQ0lMLCAwLCAxLCAwICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggZGVwdGggKSB7XG5cblx0XHRcdFx0XHRnbC5jbGVhckJ1ZmZlcmZ2KCBnbC5ERVBUSCwgMCwgWyAxLjAgXSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0ZW5jaWwgKSB7XG5cblx0XHRcdFx0XHRnbC5jbGVhckJ1ZmZlcml2KCBnbC5TVEVOQ0lMLCAwLCBbIDAgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRiZWdpbkNvbXB1dGUoIGNvbXB1dGVHcm91cCApIHtcblxuXHRcdGNvbnN0IHsgc3RhdGUsIGdsIH0gPSB0aGlzO1xuXG5cdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXHRcdHRoaXMuaW5pdFRpbWVzdGFtcFF1ZXJ5KCBjb21wdXRlR3JvdXAgKTtcblxuXHR9XG5cblx0Y29tcHV0ZSggY29tcHV0ZUdyb3VwLCBjb21wdXRlTm9kZSwgYmluZGluZ3MsIHBpcGVsaW5lICkge1xuXG5cdFx0Y29uc3QgeyBzdGF0ZSwgZ2wgfSA9IHRoaXM7XG5cblx0XHRpZiAoICEgdGhpcy5kaXNjYXJkICkge1xuXG5cdFx0XHQvLyByZXF1aXJlZCBoZXJlIHRvIGhhbmRsZSBhc3luYyBiZWhhdmlvdXIgb2YgcmVuZGVyLmNvbXB1dGUoKVxuXHRcdFx0Z2wuZW5hYmxlKCBnbC5SQVNURVJJWkVSX0RJU0NBUkQgKTtcblx0XHRcdHRoaXMuZGlzY2FyZCA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCB7IHByb2dyYW1HUFUsIHRyYW5zZm9ybUJ1ZmZlcnMsIGF0dHJpYnV0ZXMgfSA9IHRoaXMuZ2V0KCBwaXBlbGluZSApO1xuXG5cdFx0Y29uc3QgdmFvS2V5ID0gdGhpcy5fZ2V0VmFvS2V5KCBudWxsLCBhdHRyaWJ1dGVzICk7XG5cblx0XHRjb25zdCB2YW9HUFUgPSB0aGlzLnZhb0NhY2hlWyB2YW9LZXkgXTtcblxuXHRcdGlmICggdmFvR1BVID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuX2NyZWF0ZVZhbyggbnVsbCwgYXR0cmlidXRlcyApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Z2wuYmluZFZlcnRleEFycmF5KCB2YW9HUFUgKTtcblxuXHRcdH1cblxuXHRcdHN0YXRlLnVzZVByb2dyYW0oIHByb2dyYW1HUFUgKTtcblxuXHRcdHRoaXMuX2JpbmRVbmlmb3JtcyggYmluZGluZ3MgKTtcblxuXHRcdGNvbnN0IHRyYW5zZm9ybUZlZWRiYWNrR1BVID0gdGhpcy5fZ2V0VHJhbnNmb3JtRmVlZGJhY2soIHRyYW5zZm9ybUJ1ZmZlcnMgKTtcblxuXHRcdGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayggZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCB0cmFuc2Zvcm1GZWVkYmFja0dQVSApO1xuXHRcdGdsLmJlZ2luVHJhbnNmb3JtRmVlZGJhY2soIGdsLlBPSU5UUyApO1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGVzWyAwIF0uaXNTdG9yYWdlSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKCBnbC5QT0lOVFMsIDAsIDEsIGNvbXB1dGVOb2RlLmNvdW50ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRnbC5kcmF3QXJyYXlzKCBnbC5QT0lOVFMsIDAsIGNvbXB1dGVOb2RlLmNvdW50ICk7XG5cblx0XHR9XG5cblx0XHRnbC5lbmRUcmFuc2Zvcm1GZWVkYmFjaygpO1xuXHRcdGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayggZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCBudWxsICk7XG5cblx0XHQvLyBzd2l0Y2ggYWN0aXZlIGJ1ZmZlcnNcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybUJ1ZmZlcnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBkdWFsQXR0cmlidXRlRGF0YSA9IHRyYW5zZm9ybUJ1ZmZlcnNbIGkgXTtcblxuXHRcdFx0aWYgKCBkdWFsQXR0cmlidXRlRGF0YS5wYm8gKSB7XG5cblx0XHRcdFx0dGhpcy50ZXh0dXJlVXRpbHMuY29weUJ1ZmZlclRvVGV4dHVyZSggZHVhbEF0dHJpYnV0ZURhdGEudHJhbnNmb3JtQnVmZmVyLCBkdWFsQXR0cmlidXRlRGF0YS5wYm8gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRkdWFsQXR0cmlidXRlRGF0YS5zd2l0Y2hCdWZmZXJzKCk7XG5cblxuXHRcdH1cblxuXHR9XG5cblx0ZmluaXNoQ29tcHV0ZSggY29tcHV0ZUdyb3VwICkge1xuXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXG5cdFx0dGhpcy5kaXNjYXJkID0gZmFsc2U7XG5cblx0XHRnbC5kaXNhYmxlKCBnbC5SQVNURVJJWkVSX0RJU0NBUkQgKTtcblxuXHRcdHRoaXMucHJlcGFyZVRpbWVzdGFtcEJ1ZmZlciggY29tcHV0ZUdyb3VwICk7XG5cblx0XHRpZiAoIHRoaXMuX2N1cnJlbnRDb250ZXh0ICkge1xuXG5cdFx0XHR0aGlzLl9zZXRGcmFtZWJ1ZmZlciggdGhpcy5fY3VycmVudENvbnRleHQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZHJhdyggcmVuZGVyT2JqZWN0LyosIGluZm8qLyApIHtcblxuXHRcdGNvbnN0IHsgb2JqZWN0LCBwaXBlbGluZSwgbWF0ZXJpYWwsIGNvbnRleHQsIGhhcmR3YXJlQ2xpcHBpbmdQbGFuZXMgfSA9IHJlbmRlck9iamVjdDtcblx0XHRjb25zdCB7IHByb2dyYW1HUFUgfSA9IHRoaXMuZ2V0KCBwaXBlbGluZSApO1xuXG5cdFx0Y29uc3QgeyBnbCwgc3RhdGUgfSA9IHRoaXM7XG5cblx0XHRjb25zdCBjb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCBjb250ZXh0ICk7XG5cblx0XHRjb25zdCBkcmF3UGFyYW1zID0gcmVuZGVyT2JqZWN0LmdldERyYXdQYXJhbWV0ZXJzKCk7XG5cblx0XHRpZiAoIGRyYXdQYXJhbXMgPT09IG51bGwgKSByZXR1cm47XG5cblx0XHQvL1xuXG5cdFx0dGhpcy5fYmluZFVuaWZvcm1zKCByZW5kZXJPYmplY3QuZ2V0QmluZGluZ3MoKSApO1xuXG5cdFx0Y29uc3QgZnJvbnRGYWNlQ1cgPSAoIG9iamVjdC5pc01lc2ggJiYgb2JqZWN0Lm1hdHJpeFdvcmxkLmRldGVybWluYW50KCkgPCAwICk7XG5cblx0XHRzdGF0ZS5zZXRNYXRlcmlhbCggbWF0ZXJpYWwsIGZyb250RmFjZUNXLCBoYXJkd2FyZUNsaXBwaW5nUGxhbmVzICk7XG5cblx0XHRzdGF0ZS51c2VQcm9ncmFtKCBwcm9ncmFtR1BVICk7XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgcmVuZGVyT2JqZWN0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJPYmplY3QgKTtcblxuXHRcdGxldCB2YW9HUFUgPSByZW5kZXJPYmplY3REYXRhLnN0YXRpY1ZhbztcblxuXHRcdGlmICggdmFvR1BVID09PSB1bmRlZmluZWQgfHwgcmVuZGVyT2JqZWN0RGF0YS5nZW9tZXRyeUlkICE9PSByZW5kZXJPYmplY3QuZ2VvbWV0cnkuaWQgKSB7XG5cblx0XHRcdGNvbnN0IHZhb0tleSA9IHRoaXMuX2dldFZhb0tleSggcmVuZGVyT2JqZWN0LmdldEluZGV4KCksIHJlbmRlck9iamVjdC5nZXRBdHRyaWJ1dGVzKCkgKTtcblxuXHRcdFx0dmFvR1BVID0gdGhpcy52YW9DYWNoZVsgdmFvS2V5IF07XG5cblx0XHRcdGlmICggdmFvR1BVID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bGV0IHN0YXRpY1ZhbztcblxuXHRcdFx0XHQoIHsgdmFvR1BVLCBzdGF0aWNWYW8gfSA9IHRoaXMuX2NyZWF0ZVZhbyggcmVuZGVyT2JqZWN0LmdldEluZGV4KCksIHJlbmRlck9iamVjdC5nZXRBdHRyaWJ1dGVzKCkgKSApO1xuXG5cdFx0XHRcdGlmICggc3RhdGljVmFvICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyT2JqZWN0RGF0YS5zdGF0aWNWYW8gPSB2YW9HUFU7XG5cdFx0XHRcdFx0cmVuZGVyT2JqZWN0RGF0YS5nZW9tZXRyeUlkID0gcmVuZGVyT2JqZWN0Lmdlb21ldHJ5LmlkO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Z2wuYmluZFZlcnRleEFycmF5KCB2YW9HUFUgKTtcblxuXHRcdC8vXG5cblx0XHRjb25zdCBpbmRleCA9IHJlbmRlck9iamVjdC5nZXRJbmRleCgpO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGxhc3RPYmplY3QgPSBjb250ZXh0RGF0YS5sYXN0T2NjbHVzaW9uT2JqZWN0O1xuXG5cdFx0aWYgKCBsYXN0T2JqZWN0ICE9PSBvYmplY3QgJiYgbGFzdE9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIGxhc3RPYmplY3QgIT09IG51bGwgJiYgbGFzdE9iamVjdC5vY2NsdXNpb25UZXN0ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGdsLmVuZFF1ZXJ5KCBnbC5BTllfU0FNUExFU19QQVNTRUQgKTtcblxuXHRcdFx0XHRjb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeUluZGV4ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2JqZWN0Lm9jY2x1c2lvblRlc3QgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Y29uc3QgcXVlcnkgPSBnbC5jcmVhdGVRdWVyeSgpO1xuXG5cdFx0XHRcdGdsLmJlZ2luUXVlcnkoIGdsLkFOWV9TQU1QTEVTX1BBU1NFRCwgcXVlcnkgKTtcblxuXHRcdFx0XHRjb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyaWVzWyBjb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeUluZGV4IF0gPSBxdWVyeTtcblx0XHRcdFx0Y29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlPYmplY3RzWyBjb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeUluZGV4IF0gPSBvYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29udGV4dERhdGEubGFzdE9jY2x1c2lvbk9iamVjdCA9IG9iamVjdDtcblxuXHRcdH1cblxuXHRcdC8vXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLmJ1ZmZlclJlbmRlcmVyO1xuXG5cdFx0aWYgKCBvYmplY3QuaXNQb2ludHMgKSByZW5kZXJlci5tb2RlID0gZ2wuUE9JTlRTO1xuXHRcdGVsc2UgaWYgKCBvYmplY3QuaXNMaW5lU2VnbWVudHMgKSByZW5kZXJlci5tb2RlID0gZ2wuTElORVM7XG5cdFx0ZWxzZSBpZiAoIG9iamVjdC5pc0xpbmUgKSByZW5kZXJlci5tb2RlID0gZ2wuTElORV9TVFJJUDtcblx0XHRlbHNlIGlmICggb2JqZWN0LmlzTGluZUxvb3AgKSByZW5kZXJlci5tb2RlID0gZ2wuTElORV9MT09QO1xuXHRcdGVsc2Uge1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRzdGF0ZS5zZXRMaW5lV2lkdGgoIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCAqIHRoaXMucmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpICk7XG5cdFx0XHRcdHJlbmRlcmVyLm1vZGUgPSBnbC5MSU5FUztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZW5kZXJlci5tb2RlID0gZ2wuVFJJQU5HTEVTO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgeyB2ZXJ0ZXhDb3VudCwgaW5zdGFuY2VDb3VudCB9ID0gZHJhd1BhcmFtcztcblx0XHRsZXQgeyBmaXJzdFZlcnRleCB9ID0gZHJhd1BhcmFtcztcblxuXHRcdHJlbmRlcmVyLm9iamVjdCA9IG9iamVjdDtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdGZpcnN0VmVydGV4ICo9IGluZGV4LmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuXG5cdFx0XHRjb25zdCBpbmRleERhdGEgPSB0aGlzLmdldCggaW5kZXggKTtcblxuXHRcdFx0cmVuZGVyZXIuaW5kZXggPSBpbmRleC5jb3VudDtcblx0XHRcdHJlbmRlcmVyLnR5cGUgPSBpbmRleERhdGEudHlwZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlbmRlcmVyLmluZGV4ID0gMDtcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0LmlzQmF0Y2hlZE1lc2ggKSB7XG5cblx0XHRcdGlmICggb2JqZWN0Ll9tdWx0aURyYXdJbnN0YW5jZXMgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0cmVuZGVyZXIucmVuZGVyTXVsdGlEcmF3SW5zdGFuY2VzKCBvYmplY3QuX211bHRpRHJhd1N0YXJ0cywgb2JqZWN0Ll9tdWx0aURyYXdDb3VudHMsIG9iamVjdC5fbXVsdGlEcmF3Q291bnQsIG9iamVjdC5fbXVsdGlEcmF3SW5zdGFuY2VzICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoICEgdGhpcy5oYXNGZWF0dXJlKCAnV0VCR0xfbXVsdGlfZHJhdycgKSApIHtcblxuXHRcdFx0XHR3YXJuT25jZSggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFdFQkdMX211bHRpX2RyYXcgbm90IHN1cHBvcnRlZC4nICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVuZGVyZXIucmVuZGVyTXVsdGlEcmF3KCBvYmplY3QuX211bHRpRHJhd1N0YXJ0cywgb2JqZWN0Ll9tdWx0aURyYXdDb3VudHMsIG9iamVjdC5fbXVsdGlEcmF3Q291bnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggaW5zdGFuY2VDb3VudCA+IDEgKSB7XG5cblx0XHRcdHJlbmRlcmVyLnJlbmRlckluc3RhbmNlcyggZmlyc3RWZXJ0ZXgsIHZlcnRleENvdW50LCBpbnN0YW5jZUNvdW50ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIGZpcnN0VmVydGV4LCB2ZXJ0ZXhDb3VudCApO1xuXG5cdFx0fVxuXHRcdC8vXG5cblx0XHRnbC5iaW5kVmVydGV4QXJyYXkoIG51bGwgKTtcblxuXHR9XG5cblx0bmVlZHNSZW5kZXJVcGRhdGUoIC8qcmVuZGVyT2JqZWN0Ki8gKSB7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdGdldFJlbmRlckNhY2hlS2V5KCAvKnJlbmRlck9iamVjdCovICkge1xuXG5cdFx0cmV0dXJuICcnO1xuXG5cdH1cblxuXHQvLyB0ZXh0dXJlc1xuXG5cdGNyZWF0ZURlZmF1bHRUZXh0dXJlKCB0ZXh0dXJlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMuY3JlYXRlRGVmYXVsdFRleHR1cmUoIHRleHR1cmUgKTtcblxuXHR9XG5cblx0Y3JlYXRlVGV4dHVyZSggdGV4dHVyZSwgb3B0aW9ucyApIHtcblxuXHRcdHRoaXMudGV4dHVyZVV0aWxzLmNyZWF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKTtcblxuXHR9XG5cblx0dXBkYXRlVGV4dHVyZSggdGV4dHVyZSwgb3B0aW9ucyApIHtcblxuXHRcdHRoaXMudGV4dHVyZVV0aWxzLnVwZGF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMuZ2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICk7XG5cblx0fVxuXG5cblx0ZGVzdHJveVRleHR1cmUoIHRleHR1cmUgKSB7XG5cblx0XHR0aGlzLnRleHR1cmVVdGlscy5kZXN0cm95VGV4dHVyZSggdGV4dHVyZSApO1xuXG5cdH1cblxuXHRjb3B5VGV4dHVyZVRvQnVmZmVyKCB0ZXh0dXJlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmYWNlSW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlVXRpbHMuY29weVRleHR1cmVUb0J1ZmZlciggdGV4dHVyZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZmFjZUluZGV4ICk7XG5cblx0fVxuXG5cdGNyZWF0ZVNhbXBsZXIoIC8qdGV4dHVyZSovICkge1xuXG5cdFx0Ly9jb25zb2xlLndhcm4oICdBYnN0cmFjdCBjbGFzcy4nICk7XG5cblx0fVxuXG5cdGRlc3Ryb3lTYW1wbGVyKCkge31cblxuXHQvLyBub2RlIGJ1aWxkZXJcblxuXHRjcmVhdGVOb2RlQnVpbGRlciggb2JqZWN0LCByZW5kZXJlciApIHtcblxuXHRcdHJldHVybiBuZXcgR0xTTE5vZGVCdWlsZGVyKCBvYmplY3QsIHJlbmRlcmVyICk7XG5cblx0fVxuXG5cdC8vIHByb2dyYW1cblxuXHRjcmVhdGVQcm9ncmFtKCBwcm9ncmFtICkge1xuXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXHRcdGNvbnN0IHsgc3RhZ2UsIGNvZGUgfSA9IHByb2dyYW07XG5cblx0XHRjb25zdCBzaGFkZXIgPSBzdGFnZSA9PT0gJ2ZyYWdtZW50JyA/IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICkgOiBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcblxuXHRcdGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBjb2RlICk7XG5cdFx0Z2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XG5cblx0XHR0aGlzLnNldCggcHJvZ3JhbSwge1xuXHRcdFx0c2hhZGVyR1BVOiBzaGFkZXJcblx0XHR9ICk7XG5cblx0fVxuXG5cdGRlc3Ryb3lQcm9ncmFtKCAvKnByb2dyYW0qLyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGNsYXNzLicgKTtcblxuXHR9XG5cblx0Y3JlYXRlUmVuZGVyUGlwZWxpbmUoIHJlbmRlck9iamVjdCwgcHJvbWlzZXMgKSB7XG5cblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XG5cdFx0Y29uc3QgcGlwZWxpbmUgPSByZW5kZXJPYmplY3QucGlwZWxpbmU7XG5cblx0XHQvLyBQcm9ncmFtXG5cblx0XHRjb25zdCB7IGZyYWdtZW50UHJvZ3JhbSwgdmVydGV4UHJvZ3JhbSB9ID0gcGlwZWxpbmU7XG5cblx0XHRjb25zdCBwcm9ncmFtR1BVID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0Y29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdldCggZnJhZ21lbnRQcm9ncmFtICkuc2hhZGVyR1BVO1xuXHRcdGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMuZ2V0KCB2ZXJ0ZXhQcm9ncmFtICkuc2hhZGVyR1BVO1xuXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtR1BVLCBmcmFnbWVudFNoYWRlciApO1xuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbUdQVSwgdmVydGV4U2hhZGVyICk7XG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW1HUFUgKTtcblxuXHRcdHRoaXMuc2V0KCBwaXBlbGluZSwge1xuXHRcdFx0cHJvZ3JhbUdQVSxcblx0XHRcdGZyYWdtZW50U2hhZGVyLFxuXHRcdFx0dmVydGV4U2hhZGVyXG5cdFx0fSApO1xuXG5cdFx0aWYgKCBwcm9taXNlcyAhPT0gbnVsbCAmJiB0aGlzLnBhcmFsbGVsICkge1xuXG5cdFx0XHRjb25zdCBwID0gbmV3IFByb21pc2UoICggcmVzb2x2ZSAvKiwgcmVqZWN0Ki8gKSA9PiB7XG5cblx0XHRcdFx0Y29uc3QgcGFyYWxsZWwgPSB0aGlzLnBhcmFsbGVsO1xuXHRcdFx0XHRjb25zdCBjaGVja1N0YXR1cyA9ICgpID0+IHtcblxuXHRcdFx0XHRcdGlmICggZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbUdQVSwgcGFyYWxsZWwuQ09NUExFVElPTl9TVEFUVVNfS0hSICkgKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuX2NvbXBsZXRlQ29tcGlsZSggcmVuZGVyT2JqZWN0LCBwaXBlbGluZSApO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBjaGVja1N0YXR1cyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Y2hlY2tTdGF0dXMoKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRwcm9taXNlcy5wdXNoKCBwICk7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHRoaXMuX2NvbXBsZXRlQ29tcGlsZSggcmVuZGVyT2JqZWN0LCBwaXBlbGluZSApO1xuXG5cdH1cblxuXHRfaGFuZGxlU291cmNlKCBzdHJpbmcsIGVycm9yTGluZSApIHtcblxuXHRcdGNvbnN0IGxpbmVzID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApO1xuXHRcdGNvbnN0IGxpbmVzMiA9IFtdO1xuXG5cdFx0Y29uc3QgZnJvbSA9IE1hdGgubWF4KCBlcnJvckxpbmUgLSA2LCAwICk7XG5cdFx0Y29uc3QgdG8gPSBNYXRoLm1pbiggZXJyb3JMaW5lICsgNiwgbGluZXMubGVuZ3RoICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IGZyb207IGkgPCB0bzsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgbGluZSA9IGkgKyAxO1xuXHRcdFx0bGluZXMyLnB1c2goIGAke2xpbmUgPT09IGVycm9yTGluZSA/ICc+JyA6ICcgJ30gJHtsaW5lfTogJHtsaW5lc1sgaSBdfWAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBsaW5lczIuam9pbiggJ1xcbicgKTtcblxuXHR9XG5cblx0X2dldFNoYWRlckVycm9ycyggZ2wsIHNoYWRlciwgdHlwZSApIHtcblxuXHRcdGNvbnN0IHN0YXR1cyA9IGdsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyApO1xuXHRcdGNvbnN0IGVycm9ycyA9IGdsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApLnRyaW0oKTtcblxuXHRcdGlmICggc3RhdHVzICYmIGVycm9ycyA9PT0gJycgKSByZXR1cm4gJyc7XG5cblx0XHRjb25zdCBlcnJvck1hdGNoZXMgPSAvRVJST1I6IDA6KFxcZCspLy5leGVjKCBlcnJvcnMgKTtcblx0XHRpZiAoIGVycm9yTWF0Y2hlcyApIHtcblxuXHRcdFx0Y29uc3QgZXJyb3JMaW5lID0gcGFyc2VJbnQoIGVycm9yTWF0Y2hlc1sgMSBdICk7XG5cdFx0XHRyZXR1cm4gdHlwZS50b1VwcGVyQ2FzZSgpICsgJ1xcblxcbicgKyBlcnJvcnMgKyAnXFxuXFxuJyArIHRoaXMuX2hhbmRsZVNvdXJjZSggZ2wuZ2V0U2hhZGVyU291cmNlKCBzaGFkZXIgKSwgZXJyb3JMaW5lICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gZXJyb3JzO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfbG9nUHJvZ3JhbUVycm9yKCBwcm9ncmFtR1BVLCBnbEZyYWdtZW50U2hhZGVyLCBnbFZlcnRleFNoYWRlciApIHtcblxuXHRcdGlmICggdGhpcy5yZW5kZXJlci5kZWJ1Zy5jaGVja1NoYWRlckVycm9ycyApIHtcblxuXHRcdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXG5cdFx0XHRjb25zdCBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW1HUFUgKS50cmltKCk7XG5cblx0XHRcdGlmICggZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbUdQVSwgZ2wuTElOS19TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XG5cblxuXHRcdFx0XHRpZiAoIHR5cGVvZiB0aGlzLnJlbmRlcmVyLmRlYnVnLm9uU2hhZGVyRXJyb3IgPT09ICdmdW5jdGlvbicgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnJlbmRlcmVyLmRlYnVnLm9uU2hhZGVyRXJyb3IoIGdsLCBwcm9ncmFtR1BVLCBnbFZlcnRleFNoYWRlciwgZ2xGcmFnbWVudFNoYWRlciApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBkZWZhdWx0IGVycm9yIHJlcG9ydGluZ1xuXG5cdFx0XHRcdFx0Y29uc3QgdmVydGV4RXJyb3JzID0gdGhpcy5fZ2V0U2hhZGVyRXJyb3JzKCBnbCwgZ2xWZXJ0ZXhTaGFkZXIsICd2ZXJ0ZXgnICk7XG5cdFx0XHRcdFx0Y29uc3QgZnJhZ21lbnRFcnJvcnMgPSB0aGlzLl9nZXRTaGFkZXJFcnJvcnMoIGdsLCBnbEZyYWdtZW50U2hhZGVyLCAnZnJhZ21lbnQnICk7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHRcdFx0J1RIUkVFLldlYkdMUHJvZ3JhbTogU2hhZGVyIEVycm9yICcgKyBnbC5nZXRFcnJvcigpICsgJyAtICcgK1xuXHRcdFx0XHRcdFx0J1ZBTElEQVRFX1NUQVRVUyAnICsgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbUdQVSwgZ2wuVkFMSURBVEVfU1RBVFVTICkgKyAnXFxuXFxuJyArXG5cdFx0XHRcdFx0XHQnUHJvZ3JhbSBJbmZvIExvZzogJyArIHByb2dyYW1Mb2cgKyAnXFxuJyArXG5cdFx0XHRcdFx0XHR2ZXJ0ZXhFcnJvcnMgKyAnXFxuJyArXG5cdFx0XHRcdFx0XHRmcmFnbWVudEVycm9yc1xuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBwcm9ncmFtTG9nICE9PSAnJyApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IFByb2dyYW0gSW5mbyBMb2c6JywgcHJvZ3JhbUxvZyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdF9jb21wbGV0ZUNvbXBpbGUoIHJlbmRlck9iamVjdCwgcGlwZWxpbmUgKSB7XG5cblx0XHRjb25zdCB7IHN0YXRlLCBnbCB9ID0gdGhpcztcblx0XHRjb25zdCBwaXBlbGluZURhdGEgPSB0aGlzLmdldCggcGlwZWxpbmUgKTtcblx0XHRjb25zdCB7IHByb2dyYW1HUFUsIGZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXIgfSA9IHBpcGVsaW5lRGF0YTtcblxuXHRcdGlmICggZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbUdQVSwgZ2wuTElOS19TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRoaXMuX2xvZ1Byb2dyYW1FcnJvciggcHJvZ3JhbUdQVSwgZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlciApO1xuXG5cdFx0fVxuXG5cdFx0c3RhdGUudXNlUHJvZ3JhbSggcHJvZ3JhbUdQVSApO1xuXG5cdFx0Ly8gQmluZGluZ3NcblxuXHRcdGNvbnN0IGJpbmRpbmdzID0gcmVuZGVyT2JqZWN0LmdldEJpbmRpbmdzKCk7XG5cblx0XHR0aGlzLl9zZXR1cEJpbmRpbmdzKCBiaW5kaW5ncywgcHJvZ3JhbUdQVSApO1xuXG5cdFx0Ly9cblxuXHRcdHRoaXMuc2V0KCBwaXBlbGluZSwge1xuXHRcdFx0cHJvZ3JhbUdQVVxuXHRcdH0gKTtcblxuXHR9XG5cblx0Y3JlYXRlQ29tcHV0ZVBpcGVsaW5lKCBjb21wdXRlUGlwZWxpbmUsIGJpbmRpbmdzICkge1xuXG5cdFx0Y29uc3QgeyBzdGF0ZSwgZ2wgfSA9IHRoaXM7XG5cblx0XHQvLyBQcm9ncmFtXG5cblx0XHRjb25zdCBmcmFnbWVudFByb2dyYW0gPSB7XG5cdFx0XHRzdGFnZTogJ2ZyYWdtZW50Jyxcblx0XHRcdGNvZGU6ICcjdmVyc2lvbiAzMDAgZXNcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudm9pZCBtYWluKCkge30nXG5cdFx0fTtcblxuXHRcdHRoaXMuY3JlYXRlUHJvZ3JhbSggZnJhZ21lbnRQcm9ncmFtICk7XG5cblx0XHRjb25zdCB7IGNvbXB1dGVQcm9ncmFtIH0gPSBjb21wdXRlUGlwZWxpbmU7XG5cblx0XHRjb25zdCBwcm9ncmFtR1BVID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0Y29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdldCggZnJhZ21lbnRQcm9ncmFtICkuc2hhZGVyR1BVO1xuXHRcdGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMuZ2V0KCBjb21wdXRlUHJvZ3JhbSApLnNoYWRlckdQVTtcblxuXHRcdGNvbnN0IHRyYW5zZm9ybXMgPSBjb21wdXRlUHJvZ3JhbS50cmFuc2Zvcm1zO1xuXG5cdFx0Y29uc3QgdHJhbnNmb3JtVmFyeWluZ05hbWVzID0gW107XG5cdFx0Y29uc3QgdHJhbnNmb3JtQXR0cmlidXRlTm9kZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zWyBpIF07XG5cblx0XHRcdHRyYW5zZm9ybVZhcnlpbmdOYW1lcy5wdXNoKCB0cmFuc2Zvcm0udmFyeWluZ05hbWUgKTtcblx0XHRcdHRyYW5zZm9ybUF0dHJpYnV0ZU5vZGVzLnB1c2goIHRyYW5zZm9ybS5hdHRyaWJ1dGVOb2RlICk7XG5cblx0XHR9XG5cblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW1HUFUsIGZyYWdtZW50U2hhZGVyICk7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtR1BVLCB2ZXJ0ZXhTaGFkZXIgKTtcblxuXHRcdGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MoXG5cdFx0XHRwcm9ncmFtR1BVLFxuXHRcdFx0dHJhbnNmb3JtVmFyeWluZ05hbWVzLFxuXHRcdFx0Z2wuU0VQQVJBVEVfQVRUUklCU1xuXHRcdCk7XG5cblx0XHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbUdQVSApO1xuXG5cdFx0aWYgKCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtR1BVLCBnbC5MSU5LX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0dGhpcy5fbG9nUHJvZ3JhbUVycm9yKCBwcm9ncmFtR1BVLCBmcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyICk7XG5cblxuXHRcdH1cblxuXHRcdHN0YXRlLnVzZVByb2dyYW0oIHByb2dyYW1HUFUgKTtcblxuXHRcdC8vIEJpbmRpbmdzXG5cblx0XHR0aGlzLl9zZXR1cEJpbmRpbmdzKCBiaW5kaW5ncywgcHJvZ3JhbUdQVSApO1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlTm9kZXMgPSBjb21wdXRlUHJvZ3JhbS5hdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcblx0XHRjb25zdCB0cmFuc2Zvcm1CdWZmZXJzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVOb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZU5vZGVzWyBpIF0ubm9kZS5hdHRyaWJ1dGU7XG5cblx0XHRcdGF0dHJpYnV0ZXMucHVzaCggYXR0cmlidXRlICk7XG5cblx0XHRcdGlmICggISB0aGlzLmhhcyggYXR0cmlidXRlICkgKSB0aGlzLmF0dHJpYnV0ZVV0aWxzLmNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBnbC5BUlJBWV9CVUZGRVIgKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybUF0dHJpYnV0ZU5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlID0gdHJhbnNmb3JtQXR0cmlidXRlTm9kZXNbIGkgXS5hdHRyaWJ1dGU7XG5cblx0XHRcdGlmICggISB0aGlzLmhhcyggYXR0cmlidXRlICkgKSB0aGlzLmF0dHJpYnV0ZVV0aWxzLmNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBnbC5BUlJBWV9CVUZGRVIgKTtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlRGF0YSA9IHRoaXMuZ2V0KCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0dHJhbnNmb3JtQnVmZmVycy5wdXNoKCBhdHRyaWJ1dGVEYXRhICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0dGhpcy5zZXQoIGNvbXB1dGVQaXBlbGluZSwge1xuXHRcdFx0cHJvZ3JhbUdQVSxcblx0XHRcdHRyYW5zZm9ybUJ1ZmZlcnMsXG5cdFx0XHRhdHRyaWJ1dGVzXG5cdFx0fSApO1xuXG5cdH1cblxuXHRjcmVhdGVCaW5kaW5ncyggYmluZEdyb3VwLCBiaW5kaW5ncyApIHtcblxuXHRcdGlmICggdGhpcy5fa25vd25CaW5kaW5ncy5oYXMoIGJpbmRpbmdzICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHR0aGlzLl9rbm93bkJpbmRpbmdzLmFkZCggYmluZGluZ3MgKTtcblxuXHRcdFx0bGV0IHVuaWZvcm1CdWZmZXJzID0gMDtcblx0XHRcdGxldCB0ZXh0dXJlcyA9IDA7XG5cblx0XHRcdGZvciAoIGNvbnN0IGJpbmRHcm91cCBvZiBiaW5kaW5ncyApIHtcblxuXHRcdFx0XHR0aGlzLnNldCggYmluZEdyb3VwLCB7XG5cdFx0XHRcdFx0dGV4dHVyZXM6IHRleHR1cmVzLFxuXHRcdFx0XHRcdHVuaWZvcm1CdWZmZXJzOiB1bmlmb3JtQnVmZmVyc1xuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Zm9yICggY29uc3QgYmluZGluZyBvZiBiaW5kR3JvdXAuYmluZGluZ3MgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcuaXNVbmlmb3JtQnVmZmVyICkgdW5pZm9ybUJ1ZmZlcnMgKys7XG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nLmlzU2FtcGxlZFRleHR1cmUgKSB0ZXh0dXJlcyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlQmluZGluZ3MoIGJpbmRHcm91cCwgYmluZGluZ3MgKTtcblxuXHR9XG5cblx0dXBkYXRlQmluZGluZ3MoIGJpbmRHcm91cCAvKiwgYmluZGluZ3MqLyApIHtcblxuXHRcdGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG5cblx0XHRjb25zdCBiaW5kR3JvdXBEYXRhID0gdGhpcy5nZXQoIGJpbmRHcm91cCApO1xuXG5cdFx0bGV0IGkgPSBiaW5kR3JvdXBEYXRhLnVuaWZvcm1CdWZmZXJzO1xuXHRcdGxldCB0ID0gYmluZEdyb3VwRGF0YS50ZXh0dXJlcztcblxuXHRcdGZvciAoIGNvbnN0IGJpbmRpbmcgb2YgYmluZEdyb3VwLmJpbmRpbmdzICkge1xuXG5cdFx0XHRpZiAoIGJpbmRpbmcuaXNVbmlmb3Jtc0dyb3VwIHx8IGJpbmRpbmcuaXNVbmlmb3JtQnVmZmVyICkge1xuXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBiaW5kaW5nLmJ1ZmZlcjtcblx0XHRcdFx0Y29uc3QgYnVmZmVyR1BVID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuVU5JRk9STV9CVUZGRVIsIGJ1ZmZlckdQVSApO1xuXHRcdFx0XHRnbC5idWZmZXJEYXRhKCBnbC5VTklGT1JNX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXICk7XG5cblx0XHRcdFx0dGhpcy5zZXQoIGJpbmRpbmcsIHtcblx0XHRcdFx0XHRpbmRleDogaSArKyxcblx0XHRcdFx0XHRidWZmZXJHUFVcblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBiaW5kaW5nLmlzU2FtcGxlZFRleHR1cmUgKSB7XG5cblx0XHRcdFx0Y29uc3QgeyB0ZXh0dXJlR1BVLCBnbFRleHR1cmVUeXBlIH0gPSB0aGlzLmdldCggYmluZGluZy50ZXh0dXJlICk7XG5cblx0XHRcdFx0dGhpcy5zZXQoIGJpbmRpbmcsIHtcblx0XHRcdFx0XHRpbmRleDogdCArKyxcblx0XHRcdFx0XHR0ZXh0dXJlR1BVLFxuXHRcdFx0XHRcdGdsVGV4dHVyZVR5cGVcblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZUJpbmRpbmcoIGJpbmRpbmcgKSB7XG5cblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XG5cblx0XHRpZiAoIGJpbmRpbmcuaXNVbmlmb3Jtc0dyb3VwIHx8IGJpbmRpbmcuaXNVbmlmb3JtQnVmZmVyICkge1xuXG5cdFx0XHRjb25zdCBiaW5kaW5nRGF0YSA9IHRoaXMuZ2V0KCBiaW5kaW5nICk7XG5cdFx0XHRjb25zdCBidWZmZXJHUFUgPSBiaW5kaW5nRGF0YS5idWZmZXJHUFU7XG5cdFx0XHRjb25zdCBkYXRhID0gYmluZGluZy5idWZmZXI7XG5cblx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLlVOSUZPUk1fQlVGRkVSLCBidWZmZXJHUFUgKTtcblx0XHRcdGdsLmJ1ZmZlckRhdGEoIGdsLlVOSUZPUk1fQlVGRkVSLCBkYXRhLCBnbC5EWU5BTUlDX0RSQVcgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gYXR0cmlidXRlc1xuXG5cdGNyZWF0ZUluZGV4QXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XG5cblx0XHR0aGlzLmF0dHJpYnV0ZVV0aWxzLmNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xuXG5cdH1cblxuXHRjcmVhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuXHRcdGlmICggdGhpcy5oYXMoIGF0dHJpYnV0ZSApICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXG5cdFx0dGhpcy5hdHRyaWJ1dGVVdGlscy5jcmVhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cblx0fVxuXG5cdGNyZWF0ZVN0b3JhZ2VBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuXHRcdGlmICggdGhpcy5oYXMoIGF0dHJpYnV0ZSApICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXG5cdFx0dGhpcy5hdHRyaWJ1dGVVdGlscy5jcmVhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cblx0fVxuXG5cdHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0dGhpcy5hdHRyaWJ1dGVVdGlscy51cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApO1xuXG5cdH1cblxuXHRkZXN0cm95QXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHR0aGlzLmF0dHJpYnV0ZVV0aWxzLmRlc3Ryb3lBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApO1xuXG5cdH1cblxuXHR1cGRhdGVTaXplKCkge1xuXG5cdFx0Ly9jb25zb2xlLndhcm4oICdBYnN0cmFjdCBjbGFzcy4nICk7XG5cblx0fVxuXG5cdGhhc0ZlYXR1cmUoIG5hbWUgKSB7XG5cblx0XHRjb25zdCBrZXlzTWF0Y2hpbmcgPSBPYmplY3Qua2V5cyggR0xGZWF0dXJlTmFtZSApLmZpbHRlcigga2V5ID0+IEdMRmVhdHVyZU5hbWVbIGtleSBdID09PSBuYW1lICk7XG5cblx0XHRjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwga2V5c01hdGNoaW5nLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBleHRlbnNpb25zLmhhcygga2V5c01hdGNoaW5nWyBpIF0gKSApIHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRnZXRNYXhBbmlzb3Ryb3B5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKTtcblxuXHR9XG5cblx0Y29weVRleHR1cmVUb1RleHR1cmUoIHNyY1RleHR1cmUsIGRzdFRleHR1cmUsIHNyY1JlZ2lvbiwgZHN0UG9zaXRpb24sIGxldmVsICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMuY29weVRleHR1cmVUb1RleHR1cmUoIHNyY1RleHR1cmUsIGRzdFRleHR1cmUsIHNyY1JlZ2lvbiwgZHN0UG9zaXRpb24sIGxldmVsICk7XG5cblx0fVxuXG5cdGNvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZSggdGV4dHVyZSwgcmVuZGVyQ29udGV4dCwgcmVjdGFuZ2xlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMuY29weUZyYW1lYnVmZmVyVG9UZXh0dXJlKCB0ZXh0dXJlLCByZW5kZXJDb250ZXh0LCByZWN0YW5nbGUgKTtcblxuXHR9XG5cblx0X3NldEZyYW1lYnVmZmVyKCBkZXNjcmlwdG9yICkge1xuXG5cdFx0Y29uc3QgeyBnbCwgc3RhdGUgfSA9IHRoaXM7XG5cblx0XHRsZXQgY3VycmVudEZyYW1lQnVmZmVyID0gbnVsbDtcblxuXHRcdGlmICggZGVzY3JpcHRvci50ZXh0dXJlcyAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gZGVzY3JpcHRvci5yZW5kZXJUYXJnZXQ7XG5cdFx0XHRjb25zdCByZW5kZXJUYXJnZXRDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblx0XHRcdGNvbnN0IHsgc2FtcGxlcywgZGVwdGhCdWZmZXIsIHN0ZW5jaWxCdWZmZXIgfSA9IHJlbmRlclRhcmdldDtcblxuXHRcdFx0Y29uc3QgaXNDdWJlID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID09PSB0cnVlO1xuXG5cdFx0XHRsZXQgbXNhYUZiID0gcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEubXNhYUZyYW1lQnVmZmVyO1xuXHRcdFx0bGV0IGRlcHRoUmVuZGVyYnVmZmVyID0gcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEuZGVwdGhSZW5kZXJidWZmZXI7XG5cblx0XHRcdGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoIGRlc2NyaXB0b3IgKTtcblxuXHRcdFx0bGV0IGZiO1xuXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXRDb250ZXh0RGF0YS5jdWJlRnJhbWVidWZmZXJzIHx8ICggcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEuY3ViZUZyYW1lYnVmZmVycyA9IHt9ICk7XG5cblx0XHRcdFx0ZmIgPSByZW5kZXJUYXJnZXRDb250ZXh0RGF0YS5jdWJlRnJhbWVidWZmZXJzWyBjYWNoZUtleSBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlbmRlclRhcmdldENvbnRleHREYXRhLmZyYW1lYnVmZmVycyB8fCAoIHJlbmRlclRhcmdldENvbnRleHREYXRhLmZyYW1lYnVmZmVycyA9IHt9ICk7XG5cblx0XHRcdFx0ZmIgPSByZW5kZXJUYXJnZXRDb250ZXh0RGF0YS5mcmFtZWJ1ZmZlcnNbIGNhY2hlS2V5IF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmYiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGZiID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBmYiApO1xuXG5cdFx0XHRcdGNvbnN0IHRleHR1cmVzID0gZGVzY3JpcHRvci50ZXh0dXJlcztcblxuXHRcdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0XHRcdHJlbmRlclRhcmdldENvbnRleHREYXRhLmN1YmVGcmFtZWJ1ZmZlcnNbIGNhY2hlS2V5IF0gPSBmYjtcblxuXHRcdFx0XHRcdGNvbnN0IHsgdGV4dHVyZUdQVSB9ID0gdGhpcy5nZXQoIHRleHR1cmVzWyAwIF0gKTtcblxuXHRcdFx0XHRcdGNvbnN0IGN1YmVGYWNlID0gdGhpcy5yZW5kZXJlci5fYWN0aXZlQ3ViZUZhY2U7XG5cblx0XHRcdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBjdWJlRmFjZSwgdGV4dHVyZUdQVSwgMCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRDb250ZXh0RGF0YS5mcmFtZWJ1ZmZlcnNbIGNhY2hlS2V5IF0gPSBmYjtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHRleHR1cmVzWyBpIF07XG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IHRoaXMuZ2V0KCB0ZXh0dXJlICk7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlRGF0YS5yZW5kZXJUYXJnZXQgPSBkZXNjcmlwdG9yLnJlbmRlclRhcmdldDtcblx0XHRcdFx0XHRcdHRleHR1cmVEYXRhLmNhY2hlS2V5ID0gY2FjaGVLZXk7IC8vIHJlcXVpcmVkIGZvciBjb3B5VGV4dHVyZVRvVGV4dHVyZSgpXG5cblx0XHRcdFx0XHRcdGNvbnN0IGF0dGFjaG1lbnQgPSBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGk7XG5cblx0XHRcdFx0XHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBnbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZURhdGEudGV4dHVyZUdQVSwgMCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RhdGUuZHJhd0J1ZmZlcnMoIGRlc2NyaXB0b3IsIGZiICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZGVzY3JpcHRvci5kZXB0aFRleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IHRoaXMuZ2V0KCBkZXNjcmlwdG9yLmRlcHRoVGV4dHVyZSApO1xuXHRcdFx0XHRcdGNvbnN0IGRlcHRoU3R5bGUgPSBzdGVuY2lsQnVmZmVyID8gZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UIDogZ2wuREVQVEhfQVRUQUNITUVOVDtcblx0XHRcdFx0XHR0ZXh0dXJlRGF0YS5yZW5kZXJUYXJnZXQgPSBkZXNjcmlwdG9yLnJlbmRlclRhcmdldDtcblx0XHRcdFx0XHR0ZXh0dXJlRGF0YS5jYWNoZUtleSA9IGNhY2hlS2V5OyAvLyByZXF1aXJlZCBmb3IgY29weVRleHR1cmVUb1RleHR1cmUoKVxuXG5cdFx0XHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIGdsLkZSQU1FQlVGRkVSLCBkZXB0aFN0eWxlLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlRGF0YS50ZXh0dXJlR1BVLCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc2FtcGxlcyA+IDAgKSB7XG5cblx0XHRcdFx0aWYgKCBtc2FhRmIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGludmFsaWRhdGlvbkFycmF5ID0gW107XG5cblx0XHRcdFx0XHRtc2FhRmIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbXNhYUZiICk7XG5cblx0XHRcdFx0XHRjb25zdCBtc2FhUmVuZGVyYnVmZmVycyA9IFtdO1xuXG5cdFx0XHRcdFx0Y29uc3QgdGV4dHVyZXMgPSBkZXNjcmlwdG9yLnRleHR1cmVzO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRtc2FhUmVuZGVyYnVmZmVyc1sgaSBdID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cblx0XHRcdFx0XHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgbXNhYVJlbmRlcmJ1ZmZlcnNbIGkgXSApO1xuXG5cdFx0XHRcdFx0XHRpbnZhbGlkYXRpb25BcnJheS5wdXNoKCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkZXB0aEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBkZXB0aFN0eWxlID0gc3RlbmNpbEJ1ZmZlciA/IGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA6IGdsLkRFUFRIX0FUVEFDSE1FTlQ7XG5cdFx0XHRcdFx0XHRcdGludmFsaWRhdGlvbkFycmF5LnB1c2goIGRlcHRoU3R5bGUgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gZGVzY3JpcHRvci50ZXh0dXJlc1sgaSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgdGV4dHVyZURhdGEgPSB0aGlzLmdldCggdGV4dHVyZSApO1xuXG5cdFx0XHRcdFx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoIGdsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgdGV4dHVyZURhdGEuZ2xJbnRlcm5hbEZvcm1hdCwgZGVzY3JpcHRvci53aWR0aCwgZGVzY3JpcHRvci5oZWlnaHQgKTtcblx0XHRcdFx0XHRcdGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBnbC5SRU5ERVJCVUZGRVIsIG1zYWFSZW5kZXJidWZmZXJzWyBpIF0gKTtcblxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Q29udGV4dERhdGEubXNhYUZyYW1lQnVmZmVyID0gbXNhYUZiO1xuXHRcdFx0XHRcdHJlbmRlclRhcmdldENvbnRleHREYXRhLm1zYWFSZW5kZXJidWZmZXJzID0gbXNhYVJlbmRlcmJ1ZmZlcnM7XG5cblx0XHRcdFx0XHRpZiAoIGRlcHRoUmVuZGVyYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGRlcHRoUmVuZGVyYnVmZmVyID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHR1cmVVdGlscy5zZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIGRlcHRoUmVuZGVyYnVmZmVyLCBkZXNjcmlwdG9yICk7XG5cblx0XHRcdFx0XHRcdHJlbmRlclRhcmdldENvbnRleHREYXRhLmRlcHRoUmVuZGVyYnVmZmVyID0gZGVwdGhSZW5kZXJidWZmZXI7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGRlcHRoU3R5bGUgPSBzdGVuY2lsQnVmZmVyID8gZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UIDogZ2wuREVQVEhfQVRUQUNITUVOVDtcblx0XHRcdFx0XHRcdGludmFsaWRhdGlvbkFycmF5LnB1c2goIGRlcHRoU3R5bGUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlbmRlclRhcmdldENvbnRleHREYXRhLmludmFsaWRhdGlvbkFycmF5ID0gaW52YWxpZGF0aW9uQXJyYXk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1cnJlbnRGcmFtZUJ1ZmZlciA9IHJlbmRlclRhcmdldENvbnRleHREYXRhLm1zYWFGcmFtZUJ1ZmZlcjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjdXJyZW50RnJhbWVCdWZmZXIgPSBmYjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgY3VycmVudEZyYW1lQnVmZmVyICk7XG5cblx0fVxuXG5cblx0X2dldFZhb0tleSggaW5kZXgsIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRsZXQga2V5ID0gW107XG5cblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBpbmRleERhdGEgPSB0aGlzLmdldCggaW5kZXggKTtcblxuXHRcdFx0a2V5ICs9ICc6JyArIGluZGV4RGF0YS5pZDtcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVEYXRhID0gdGhpcy5nZXQoIGF0dHJpYnV0ZXNbIGkgXSApO1xuXG5cdFx0XHRrZXkgKz0gJzonICsgYXR0cmlidXRlRGF0YS5pZDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBrZXk7XG5cblx0fVxuXG5cdF9jcmVhdGVWYW8oIGluZGV4LCBhdHRyaWJ1dGVzICkge1xuXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcblxuXHRcdGNvbnN0IHZhb0dQVSA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XG5cdFx0bGV0IGtleSA9ICcnO1xuXG5cdFx0bGV0IHN0YXRpY1ZhbyA9IHRydWU7XG5cblx0XHRnbC5iaW5kVmVydGV4QXJyYXkoIHZhb0dQVSApO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgaW5kZXhEYXRhID0gdGhpcy5nZXQoIGluZGV4ICk7XG5cblx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleERhdGEuYnVmZmVyR1BVICk7XG5cblx0XHRcdGtleSArPSAnOicgKyBpbmRleERhdGEuaWQ7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgaSBdO1xuXHRcdFx0Y29uc3QgYXR0cmlidXRlRGF0YSA9IHRoaXMuZ2V0KCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0a2V5ICs9ICc6JyArIGF0dHJpYnV0ZURhdGEuaWQ7XG5cblx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgYXR0cmlidXRlRGF0YS5idWZmZXJHUFUgKTtcblx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XG5cblx0XHRcdGlmICggYXR0cmlidXRlLmlzU3RvcmFnZUJ1ZmZlckF0dHJpYnV0ZSB8fCBhdHRyaWJ1dGUuaXNTdG9yYWdlSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICkgc3RhdGljVmFvID0gZmFsc2U7XG5cblx0XHRcdGxldCBzdHJpZGUsIG9mZnNldDtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRzdHJpZGUgPSBhdHRyaWJ1dGUuZGF0YS5zdHJpZGUgKiBhdHRyaWJ1dGVEYXRhLmJ5dGVzUGVyRWxlbWVudDtcblx0XHRcdFx0b2Zmc2V0ID0gYXR0cmlidXRlLm9mZnNldCAqIGF0dHJpYnV0ZURhdGEuYnl0ZXNQZXJFbGVtZW50O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHN0cmlkZSA9IDA7XG5cdFx0XHRcdG9mZnNldCA9IDA7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVEYXRhLmlzSW50ZWdlciApIHtcblxuXHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJJUG9pbnRlciggaSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGVEYXRhLnR5cGUsIHN0cmlkZSwgb2Zmc2V0ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggaSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGVEYXRhLnR5cGUsIGF0dHJpYnV0ZS5ub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXR0cmlidXRlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICYmICEgYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0Z2wudmVydGV4QXR0cmliRGl2aXNvciggaSwgYXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmRhdGEuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciApIHtcblxuXHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKCBpLCBhdHRyaWJ1dGUuZGF0YS5tZXNoUGVyQXR0cmlidXRlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgbnVsbCApO1xuXG5cdFx0dGhpcy52YW9DYWNoZVsga2V5IF0gPSB2YW9HUFU7XG5cblx0XHRyZXR1cm4geyB2YW9HUFUsIHN0YXRpY1ZhbyB9O1xuXG5cdH1cblxuXHRfZ2V0VHJhbnNmb3JtRmVlZGJhY2soIHRyYW5zZm9ybUJ1ZmZlcnMgKSB7XG5cblx0XHRsZXQga2V5ID0gJyc7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1CdWZmZXJzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0a2V5ICs9ICc6JyArIHRyYW5zZm9ybUJ1ZmZlcnNbIGkgXS5pZDtcblxuXHRcdH1cblxuXHRcdGxldCB0cmFuc2Zvcm1GZWVkYmFja0dQVSA9IHRoaXMudHJhbnNmb3JtRmVlZGJhY2tDYWNoZVsga2V5IF07XG5cblx0XHRpZiAoIHRyYW5zZm9ybUZlZWRiYWNrR1BVICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiB0cmFuc2Zvcm1GZWVkYmFja0dQVTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG5cblx0XHR0cmFuc2Zvcm1GZWVkYmFja0dQVSA9IGdsLmNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrKCk7XG5cblx0XHRnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soIGdsLlRSQU5TRk9STV9GRUVEQkFDSywgdHJhbnNmb3JtRmVlZGJhY2tHUFUgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybUJ1ZmZlcnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVEYXRhID0gdHJhbnNmb3JtQnVmZmVyc1sgaSBdO1xuXG5cdFx0XHRnbC5iaW5kQnVmZmVyQmFzZSggZ2wuVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiwgaSwgYXR0cmlidXRlRGF0YS50cmFuc2Zvcm1CdWZmZXIgKTtcblxuXHRcdH1cblxuXHRcdGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayggZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCBudWxsICk7XG5cblx0XHR0aGlzLnRyYW5zZm9ybUZlZWRiYWNrQ2FjaGVbIGtleSBdID0gdHJhbnNmb3JtRmVlZGJhY2tHUFU7XG5cblx0XHRyZXR1cm4gdHJhbnNmb3JtRmVlZGJhY2tHUFU7XG5cblx0fVxuXG5cblx0X3NldHVwQmluZGluZ3MoIGJpbmRpbmdzLCBwcm9ncmFtR1BVICkge1xuXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXG5cdFx0Zm9yICggY29uc3QgYmluZEdyb3VwIG9mIGJpbmRpbmdzICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCBiaW5kaW5nIG9mIGJpbmRHcm91cC5iaW5kaW5ncyApIHtcblxuXHRcdFx0XHRjb25zdCBiaW5kaW5nRGF0YSA9IHRoaXMuZ2V0KCBiaW5kaW5nICk7XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gYmluZGluZ0RhdGEuaW5kZXg7XG5cblx0XHRcdFx0aWYgKCBiaW5kaW5nLmlzVW5pZm9ybXNHcm91cCB8fCBiaW5kaW5nLmlzVW5pZm9ybUJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgoIHByb2dyYW1HUFUsIGJpbmRpbmcubmFtZSApO1xuXHRcdFx0XHRcdGdsLnVuaWZvcm1CbG9ja0JpbmRpbmcoIHByb2dyYW1HUFUsIGxvY2F0aW9uLCBpbmRleCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTYW1wbGVkVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtR1BVLCBiaW5kaW5nLm5hbWUgKTtcblx0XHRcdFx0XHRnbC51bmlmb3JtMWkoIGxvY2F0aW9uLCBpbmRleCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRfYmluZFVuaWZvcm1zKCBiaW5kaW5ncyApIHtcblxuXHRcdGNvbnN0IHsgZ2wsIHN0YXRlIH0gPSB0aGlzO1xuXG5cdFx0Zm9yICggY29uc3QgYmluZEdyb3VwIG9mIGJpbmRpbmdzICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCBiaW5kaW5nIG9mIGJpbmRHcm91cC5iaW5kaW5ncyApIHtcblxuXHRcdFx0XHRjb25zdCBiaW5kaW5nRGF0YSA9IHRoaXMuZ2V0KCBiaW5kaW5nICk7XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gYmluZGluZ0RhdGEuaW5kZXg7XG5cblx0XHRcdFx0aWYgKCBiaW5kaW5nLmlzVW5pZm9ybXNHcm91cCB8fCBiaW5kaW5nLmlzVW5pZm9ybUJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdC8vIFRPRE8gVVNFIGJpbmRCdWZmZXJSYW5nZSB0byBncm91cCBtdWx0aXBsZSB1bmlmb3JtIGJ1ZmZlcnNcblx0XHRcdFx0XHRzdGF0ZS5iaW5kQnVmZmVyQmFzZSggZ2wuVU5JRk9STV9CVUZGRVIsIGluZGV4LCBiaW5kaW5nRGF0YS5idWZmZXJHUFUgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBiaW5kaW5nLmlzU2FtcGxlZFRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggYmluZGluZ0RhdGEuZ2xUZXh0dXJlVHlwZSwgYmluZGluZ0RhdGEudGV4dHVyZUdQVSwgZ2wuVEVYVFVSRTAgKyBpbmRleCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5yZW5kZXJlci5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5fb25Db250ZXh0TG9zdCApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJHTEJhY2tlbmQ7XG4iLCJleHBvcnQgY29uc3QgR1BVUHJpbWl0aXZlVG9wb2xvZ3kgPSB7XG5cdFBvaW50TGlzdDogJ3BvaW50LWxpc3QnLFxuXHRMaW5lTGlzdDogJ2xpbmUtbGlzdCcsXG5cdExpbmVTdHJpcDogJ2xpbmUtc3RyaXAnLFxuXHRUcmlhbmdsZUxpc3Q6ICd0cmlhbmdsZS1saXN0Jyxcblx0VHJpYW5nbGVTdHJpcDogJ3RyaWFuZ2xlLXN0cmlwJyxcbn07XG5cbmV4cG9ydCBjb25zdCBHUFVDb21wYXJlRnVuY3Rpb24gPSB7XG5cdE5ldmVyOiAnbmV2ZXInLFxuXHRMZXNzOiAnbGVzcycsXG5cdEVxdWFsOiAnZXF1YWwnLFxuXHRMZXNzRXF1YWw6ICdsZXNzLWVxdWFsJyxcblx0R3JlYXRlcjogJ2dyZWF0ZXInLFxuXHROb3RFcXVhbDogJ25vdC1lcXVhbCcsXG5cdEdyZWF0ZXJFcXVhbDogJ2dyZWF0ZXItZXF1YWwnLFxuXHRBbHdheXM6ICdhbHdheXMnXG59O1xuXG5leHBvcnQgY29uc3QgR1BVU3RvcmVPcCA9IHtcblx0U3RvcmU6ICdzdG9yZScsXG5cdERpc2NhcmQ6ICdkaXNjYXJkJ1xufTtcblxuZXhwb3J0IGNvbnN0IEdQVUxvYWRPcCA9IHtcblx0TG9hZDogJ2xvYWQnLFxuXHRDbGVhcjogJ2NsZWFyJ1xufTtcblxuZXhwb3J0IGNvbnN0IEdQVUZyb250RmFjZSA9IHtcblx0Q0NXOiAnY2N3Jyxcblx0Q1c6ICdjdydcbn07XG5cbmV4cG9ydCBjb25zdCBHUFVDdWxsTW9kZSA9IHtcblx0Tm9uZTogJ25vbmUnLFxuXHRGcm9udDogJ2Zyb250Jyxcblx0QmFjazogJ2JhY2snXG59O1xuXG5leHBvcnQgY29uc3QgR1BVSW5kZXhGb3JtYXQgPSB7XG5cdFVpbnQxNjogJ3VpbnQxNicsXG5cdFVpbnQzMjogJ3VpbnQzMidcbn07XG5cbmV4cG9ydCBjb25zdCBHUFVWZXJ0ZXhGb3JtYXQgPSB7XG5cdFVpbnQ4eDI6ICd1aW50OHgyJyxcblx0VWludDh4NDogJ3VpbnQ4eDQnLFxuXHRTaW50OHgyOiAnc2ludDh4MicsXG5cdFNpbnQ4eDQ6ICdzaW50OHg0Jyxcblx0VW5vcm04eDI6ICd1bm9ybTh4MicsXG5cdFVub3JtOHg0OiAndW5vcm04eDQnLFxuXHRTbm9ybTh4MjogJ3Nub3JtOHgyJyxcblx0U25vcm04eDQ6ICdzbm9ybTh4NCcsXG5cdFVpbnQxNngyOiAndWludDE2eDInLFxuXHRVaW50MTZ4NDogJ3VpbnQxNng0Jyxcblx0U2ludDE2eDI6ICdzaW50MTZ4MicsXG5cdFNpbnQxNng0OiAnc2ludDE2eDQnLFxuXHRVbm9ybTE2eDI6ICd1bm9ybTE2eDInLFxuXHRVbm9ybTE2eDQ6ICd1bm9ybTE2eDQnLFxuXHRTbm9ybTE2eDI6ICdzbm9ybTE2eDInLFxuXHRTbm9ybTE2eDQ6ICdzbm9ybTE2eDQnLFxuXHRGbG9hdDE2eDI6ICdmbG9hdDE2eDInLFxuXHRGbG9hdDE2eDQ6ICdmbG9hdDE2eDQnLFxuXHRGbG9hdDMyOiAnZmxvYXQzMicsXG5cdEZsb2F0MzJ4MjogJ2Zsb2F0MzJ4MicsXG5cdEZsb2F0MzJ4MzogJ2Zsb2F0MzJ4MycsXG5cdEZsb2F0MzJ4NDogJ2Zsb2F0MzJ4NCcsXG5cdFVpbnQzMjogJ3VpbnQzMicsXG5cdFVpbnQzMngyOiAndWludDMyeDInLFxuXHRVaW50MzJ4MzogJ3VpbnQzMngzJyxcblx0VWludDMyeDQ6ICd1aW50MzJ4NCcsXG5cdFNpbnQzMjogJ3NpbnQzMicsXG5cdFNpbnQzMngyOiAnc2ludDMyeDInLFxuXHRTaW50MzJ4MzogJ3NpbnQzMngzJyxcblx0U2ludDMyeDQ6ICdzaW50MzJ4NCdcbn07XG5cbmV4cG9ydCBjb25zdCBHUFVUZXh0dXJlRm9ybWF0ID0ge1xuXG5cdC8vIDgtYml0IGZvcm1hdHNcblxuXHRSOFVub3JtOiAncjh1bm9ybScsXG5cdFI4U25vcm06ICdyOHNub3JtJyxcblx0UjhVaW50OiAncjh1aW50Jyxcblx0UjhTaW50OiAncjhzaW50JyxcblxuXHQvLyAxNi1iaXQgZm9ybWF0c1xuXG5cdFIxNlVpbnQ6ICdyMTZ1aW50Jyxcblx0UjE2U2ludDogJ3IxNnNpbnQnLFxuXHRSMTZGbG9hdDogJ3IxNmZsb2F0Jyxcblx0Ukc4VW5vcm06ICdyZzh1bm9ybScsXG5cdFJHOFNub3JtOiAncmc4c25vcm0nLFxuXHRSRzhVaW50OiAncmc4dWludCcsXG5cdFJHOFNpbnQ6ICdyZzhzaW50JyxcblxuXHQvLyAzMi1iaXQgZm9ybWF0c1xuXG5cdFIzMlVpbnQ6ICdyMzJ1aW50Jyxcblx0UjMyU2ludDogJ3IzMnNpbnQnLFxuXHRSMzJGbG9hdDogJ3IzMmZsb2F0Jyxcblx0UkcxNlVpbnQ6ICdyZzE2dWludCcsXG5cdFJHMTZTaW50OiAncmcxNnNpbnQnLFxuXHRSRzE2RmxvYXQ6ICdyZzE2ZmxvYXQnLFxuXHRSR0JBOFVub3JtOiAncmdiYTh1bm9ybScsXG5cdFJHQkE4VW5vcm1TUkdCOiAncmdiYTh1bm9ybS1zcmdiJyxcblx0UkdCQThTbm9ybTogJ3JnYmE4c25vcm0nLFxuXHRSR0JBOFVpbnQ6ICdyZ2JhOHVpbnQnLFxuXHRSR0JBOFNpbnQ6ICdyZ2JhOHNpbnQnLFxuXHRCR1JBOFVub3JtOiAnYmdyYTh1bm9ybScsXG5cdEJHUkE4VW5vcm1TUkdCOiAnYmdyYTh1bm9ybS1zcmdiJyxcblx0Ly8gUGFja2VkIDMyLWJpdCBmb3JtYXRzXG5cdFJHQjlFNVVGbG9hdDogJ3JnYjllNXVmbG9hdCcsXG5cdFJHQjEwQTJVbm9ybTogJ3JnYjEwYTJ1bm9ybScsXG5cdFJHMTFCMTB1RmxvYXQ6ICdyZ2IxMGEydW5vcm0nLFxuXG5cdC8vIDY0LWJpdCBmb3JtYXRzXG5cblx0UkczMlVpbnQ6ICdyZzMydWludCcsXG5cdFJHMzJTaW50OiAncmczMnNpbnQnLFxuXHRSRzMyRmxvYXQ6ICdyZzMyZmxvYXQnLFxuXHRSR0JBMTZVaW50OiAncmdiYTE2dWludCcsXG5cdFJHQkExNlNpbnQ6ICdyZ2JhMTZzaW50Jyxcblx0UkdCQTE2RmxvYXQ6ICdyZ2JhMTZmbG9hdCcsXG5cblx0Ly8gMTI4LWJpdCBmb3JtYXRzXG5cblx0UkdCQTMyVWludDogJ3JnYmEzMnVpbnQnLFxuXHRSR0JBMzJTaW50OiAncmdiYTMyc2ludCcsXG5cdFJHQkEzMkZsb2F0OiAncmdiYTMyZmxvYXQnLFxuXG5cdC8vIERlcHRoIGFuZCBzdGVuY2lsIGZvcm1hdHNcblxuXHRTdGVuY2lsODogJ3N0ZW5jaWw4Jyxcblx0RGVwdGgxNlVub3JtOiAnZGVwdGgxNnVub3JtJyxcblx0RGVwdGgyNFBsdXM6ICdkZXB0aDI0cGx1cycsXG5cdERlcHRoMjRQbHVzU3RlbmNpbDg6ICdkZXB0aDI0cGx1cy1zdGVuY2lsOCcsXG5cdERlcHRoMzJGbG9hdDogJ2RlcHRoMzJmbG9hdCcsXG5cblx0Ly8gJ2RlcHRoMzJmbG9hdC1zdGVuY2lsOCcgZXh0ZW5zaW9uXG5cblx0RGVwdGgzMkZsb2F0U3RlbmNpbDg6ICdkZXB0aDMyZmxvYXQtc3RlbmNpbDgnLFxuXG5cdC8vIEJDIGNvbXByZXNzZWQgZm9ybWF0cyB1c2FibGUgaWYgJ3RleHR1cmUtY29tcHJlc3Npb24tYmMnIGlzIGJvdGhcblx0Ly8gc3VwcG9ydGVkIGJ5IHRoZSBkZXZpY2UvdXNlciBhZ2VudCBhbmQgZW5hYmxlZCBpbiByZXF1ZXN0RGV2aWNlLlxuXG5cdEJDMVJHQkFVbm9ybTogJ2JjMS1yZ2JhLXVub3JtJyxcblx0QkMxUkdCQVVub3JtU1JHQjogJ2JjMS1yZ2JhLXVub3JtLXNyZ2InLFxuXHRCQzJSR0JBVW5vcm06ICdiYzItcmdiYS11bm9ybScsXG5cdEJDMlJHQkFVbm9ybVNSR0I6ICdiYzItcmdiYS11bm9ybS1zcmdiJyxcblx0QkMzUkdCQVVub3JtOiAnYmMzLXJnYmEtdW5vcm0nLFxuXHRCQzNSR0JBVW5vcm1TUkdCOiAnYmMzLXJnYmEtdW5vcm0tc3JnYicsXG5cdEJDNFJVbm9ybTogJ2JjNC1yLXVub3JtJyxcblx0QkM0UlNub3JtOiAnYmM0LXItc25vcm0nLFxuXHRCQzVSR1Vub3JtOiAnYmM1LXJnLXVub3JtJyxcblx0QkM1UkdTbm9ybTogJ2JjNS1yZy1zbm9ybScsXG5cdEJDNkhSR0JVRmxvYXQ6ICdiYzZoLXJnYi11ZmxvYXQnLFxuXHRCQzZIUkdCRmxvYXQ6ICdiYzZoLXJnYi1mbG9hdCcsXG5cdEJDN1JHQkFVbm9ybTogJ2JjNy1yZ2JhLXVub3JtJyxcblx0QkM3UkdCQVVub3JtU1JHQjogJ2JjNy1yZ2JhLXNyZ2InLFxuXG5cdC8vIEVUQzIgY29tcHJlc3NlZCBmb3JtYXRzIHVzYWJsZSBpZiAndGV4dHVyZS1jb21wcmVzc2lvbi1ldGMyJyBpcyBib3RoXG5cdC8vIHN1cHBvcnRlZCBieSB0aGUgZGV2aWNlL3VzZXIgYWdlbnQgYW5kIGVuYWJsZWQgaW4gcmVxdWVzdERldmljZS5cblxuXHRFVEMyUkdCOFVub3JtOiAnZXRjMi1yZ2I4dW5vcm0nLFxuXHRFVEMyUkdCOFVub3JtU1JHQjogJ2V0YzItcmdiOHVub3JtLXNyZ2InLFxuXHRFVEMyUkdCOEExVW5vcm06ICdldGMyLXJnYjhhMXVub3JtJyxcblx0RVRDMlJHQjhBMVVub3JtU1JHQjogJ2V0YzItcmdiOGExdW5vcm0tc3JnYicsXG5cdEVUQzJSR0JBOFVub3JtOiAnZXRjMi1yZ2JhOHVub3JtJyxcblx0RVRDMlJHQkE4VW5vcm1TUkdCOiAnZXRjMi1yZ2JhOHVub3JtLXNyZ2InLFxuXHRFQUNSMTFVbm9ybTogJ2VhYy1yMTF1bm9ybScsXG5cdEVBQ1IxMVNub3JtOiAnZWFjLXIxMXNub3JtJyxcblx0RUFDUkcxMVVub3JtOiAnZWFjLXJnMTF1bm9ybScsXG5cdEVBQ1JHMTFTbm9ybTogJ2VhYy1yZzExc25vcm0nLFxuXG5cdC8vIEFTVEMgY29tcHJlc3NlZCBmb3JtYXRzIHVzYWJsZSBpZiAndGV4dHVyZS1jb21wcmVzc2lvbi1hc3RjJyBpcyBib3RoXG5cdC8vIHN1cHBvcnRlZCBieSB0aGUgZGV2aWNlL3VzZXIgYWdlbnQgYW5kIGVuYWJsZWQgaW4gcmVxdWVzdERldmljZS5cblxuXHRBU1RDNHg0VW5vcm06ICdhc3RjLTR4NC11bm9ybScsXG5cdEFTVEM0eDRVbm9ybVNSR0I6ICdhc3RjLTR4NC11bm9ybS1zcmdiJyxcblx0QVNUQzV4NFVub3JtOiAnYXN0Yy01eDQtdW5vcm0nLFxuXHRBU1RDNXg0VW5vcm1TUkdCOiAnYXN0Yy01eDQtdW5vcm0tc3JnYicsXG5cdEFTVEM1eDVVbm9ybTogJ2FzdGMtNXg1LXVub3JtJyxcblx0QVNUQzV4NVVub3JtU1JHQjogJ2FzdGMtNXg1LXVub3JtLXNyZ2InLFxuXHRBU1RDNng1VW5vcm06ICdhc3RjLTZ4NS11bm9ybScsXG5cdEFTVEM2eDVVbm9ybVNSR0I6ICdhc3RjLTZ4NS11bm9ybS1zcmdiJyxcblx0QVNUQzZ4NlVub3JtOiAnYXN0Yy02eDYtdW5vcm0nLFxuXHRBU1RDNng2VW5vcm1TUkdCOiAnYXN0Yy02eDYtdW5vcm0tc3JnYicsXG5cdEFTVEM4eDVVbm9ybTogJ2FzdGMtOHg1LXVub3JtJyxcblx0QVNUQzh4NVVub3JtU1JHQjogJ2FzdGMtOHg1LXVub3JtLXNyZ2InLFxuXHRBU1RDOHg2VW5vcm06ICdhc3RjLTh4Ni11bm9ybScsXG5cdEFTVEM4eDZVbm9ybVNSR0I6ICdhc3RjLTh4Ni11bm9ybS1zcmdiJyxcblx0QVNUQzh4OFVub3JtOiAnYXN0Yy04eDgtdW5vcm0nLFxuXHRBU1RDOHg4VW5vcm1TUkdCOiAnYXN0Yy04eDgtdW5vcm0tc3JnYicsXG5cdEFTVEMxMHg1VW5vcm06ICdhc3RjLTEweDUtdW5vcm0nLFxuXHRBU1RDMTB4NVVub3JtU1JHQjogJ2FzdGMtMTB4NS11bm9ybS1zcmdiJyxcblx0QVNUQzEweDZVbm9ybTogJ2FzdGMtMTB4Ni11bm9ybScsXG5cdEFTVEMxMHg2VW5vcm1TUkdCOiAnYXN0Yy0xMHg2LXVub3JtLXNyZ2InLFxuXHRBU1RDMTB4OFVub3JtOiAnYXN0Yy0xMHg4LXVub3JtJyxcblx0QVNUQzEweDhVbm9ybVNSR0I6ICdhc3RjLTEweDgtdW5vcm0tc3JnYicsXG5cdEFTVEMxMHgxMFVub3JtOiAnYXN0Yy0xMHgxMC11bm9ybScsXG5cdEFTVEMxMHgxMFVub3JtU1JHQjogJ2FzdGMtMTB4MTAtdW5vcm0tc3JnYicsXG5cdEFTVEMxMngxMFVub3JtOiAnYXN0Yy0xMngxMC11bm9ybScsXG5cdEFTVEMxMngxMFVub3JtU1JHQjogJ2FzdGMtMTJ4MTAtdW5vcm0tc3JnYicsXG5cdEFTVEMxMngxMlVub3JtOiAnYXN0Yy0xMngxMi11bm9ybScsXG5cdEFTVEMxMngxMlVub3JtU1JHQjogJ2FzdGMtMTJ4MTItdW5vcm0tc3JnYicsXG5cbn07XG5cbmV4cG9ydCBjb25zdCBHUFVBZGRyZXNzTW9kZSA9IHtcblx0Q2xhbXBUb0VkZ2U6ICdjbGFtcC10by1lZGdlJyxcblx0UmVwZWF0OiAncmVwZWF0Jyxcblx0TWlycm9yUmVwZWF0OiAnbWlycm9yLXJlcGVhdCdcbn07XG5cbmV4cG9ydCBjb25zdCBHUFVGaWx0ZXJNb2RlID0ge1xuXHRMaW5lYXI6ICdsaW5lYXInLFxuXHROZWFyZXN0OiAnbmVhcmVzdCdcbn07XG5cbmV4cG9ydCBjb25zdCBHUFVCbGVuZEZhY3RvciA9IHtcblx0WmVybzogJ3plcm8nLFxuXHRPbmU6ICdvbmUnLFxuXHRTcmM6ICdzcmMnLFxuXHRPbmVNaW51c1NyYzogJ29uZS1taW51cy1zcmMnLFxuXHRTcmNBbHBoYTogJ3NyYy1hbHBoYScsXG5cdE9uZU1pbnVzU3JjQWxwaGE6ICdvbmUtbWludXMtc3JjLWFscGhhJyxcblx0RHN0OiAnZHN0Jyxcblx0T25lTWludXNEc3RDb2xvcjogJ29uZS1taW51cy1kc3QnLFxuXHREc3RBbHBoYTogJ2RzdC1hbHBoYScsXG5cdE9uZU1pbnVzRHN0QWxwaGE6ICdvbmUtbWludXMtZHN0LWFscGhhJyxcblx0U3JjQWxwaGFTYXR1cmF0ZWQ6ICdzcmMtYWxwaGEtc2F0dXJhdGVkJyxcblx0Q29uc3RhbnQ6ICdjb25zdGFudCcsXG5cdE9uZU1pbnVzQ29uc3RhbnQ6ICdvbmUtbWludXMtY29uc3RhbnQnXG59O1xuXG5leHBvcnQgY29uc3QgR1BVQmxlbmRPcGVyYXRpb24gPSB7XG5cdEFkZDogJ2FkZCcsXG5cdFN1YnRyYWN0OiAnc3VidHJhY3QnLFxuXHRSZXZlcnNlU3VidHJhY3Q6ICdyZXZlcnNlLXN1YnRyYWN0Jyxcblx0TWluOiAnbWluJyxcblx0TWF4OiAnbWF4J1xufTtcblxuZXhwb3J0IGNvbnN0IEdQVUNvbG9yV3JpdGVGbGFncyA9IHtcblx0Tm9uZTogMCxcblx0UmVkOiAweDEsXG5cdEdyZWVuOiAweDIsXG5cdEJsdWU6IDB4NCxcblx0QWxwaGE6IDB4OCxcblx0QWxsOiAweEZcbn07XG5cbmV4cG9ydCBjb25zdCBHUFVTdGVuY2lsT3BlcmF0aW9uID0ge1xuXHRLZWVwOiAna2VlcCcsXG5cdFplcm86ICd6ZXJvJyxcblx0UmVwbGFjZTogJ3JlcGxhY2UnLFxuXHRJbnZlcnQ6ICdpbnZlcnQnLFxuXHRJbmNyZW1lbnRDbGFtcDogJ2luY3JlbWVudC1jbGFtcCcsXG5cdERlY3JlbWVudENsYW1wOiAnZGVjcmVtZW50LWNsYW1wJyxcblx0SW5jcmVtZW50V3JhcDogJ2luY3JlbWVudC13cmFwJyxcblx0RGVjcmVtZW50V3JhcDogJ2RlY3JlbWVudC13cmFwJ1xufTtcblxuZXhwb3J0IGNvbnN0IEdQVUJ1ZmZlckJpbmRpbmdUeXBlID0ge1xuXHRVbmlmb3JtOiAndW5pZm9ybScsXG5cdFN0b3JhZ2U6ICdzdG9yYWdlJyxcblx0UmVhZE9ubHlTdG9yYWdlOiAncmVhZC1vbmx5LXN0b3JhZ2UnXG59O1xuXG5leHBvcnQgY29uc3QgR1BVU3RvcmFnZVRleHR1cmVBY2Nlc3MgPSB7XG5cdFdyaXRlT25seTogJ3dyaXRlLW9ubHknLFxuXHRSZWFkT25seTogJ3JlYWQtb25seScsXG5cdFJlYWRXcml0ZTogJ3JlYWQtd3JpdGUnLFxufTtcblxuZXhwb3J0IGNvbnN0IEdQVVNhbXBsZXJCaW5kaW5nVHlwZSA9IHtcblx0RmlsdGVyaW5nOiAnZmlsdGVyaW5nJyxcblx0Tm9uRmlsdGVyaW5nOiAnbm9uLWZpbHRlcmluZycsXG5cdENvbXBhcmlzb246ICdjb21wYXJpc29uJ1xufTtcblxuZXhwb3J0IGNvbnN0IEdQVVRleHR1cmVTYW1wbGVUeXBlID0ge1xuXHRGbG9hdDogJ2Zsb2F0Jyxcblx0VW5maWx0ZXJhYmxlRmxvYXQ6ICd1bmZpbHRlcmFibGUtZmxvYXQnLFxuXHREZXB0aDogJ2RlcHRoJyxcblx0U0ludDogJ3NpbnQnLFxuXHRVSW50OiAndWludCdcbn07XG5cbmV4cG9ydCBjb25zdCBHUFVUZXh0dXJlRGltZW5zaW9uID0ge1xuXHRPbmVEOiAnMWQnLFxuXHRUd29EOiAnMmQnLFxuXHRUaHJlZUQ6ICczZCdcbn07XG5cbmV4cG9ydCBjb25zdCBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbiA9IHtcblx0T25lRDogJzFkJyxcblx0VHdvRDogJzJkJyxcblx0VHdvREFycmF5OiAnMmQtYXJyYXknLFxuXHRDdWJlOiAnY3ViZScsXG5cdEN1YmVBcnJheTogJ2N1YmUtYXJyYXknLFxuXHRUaHJlZUQ6ICczZCdcbn07XG5cbmV4cG9ydCBjb25zdCBHUFVUZXh0dXJlQXNwZWN0ID0ge1xuXHRBbGw6ICdhbGwnLFxuXHRTdGVuY2lsT25seTogJ3N0ZW5jaWwtb25seScsXG5cdERlcHRoT25seTogJ2RlcHRoLW9ubHknXG59O1xuXG5leHBvcnQgY29uc3QgR1BVSW5wdXRTdGVwTW9kZSA9IHtcblx0VmVydGV4OiAndmVydGV4Jyxcblx0SW5zdGFuY2U6ICdpbnN0YW5jZSdcbn07XG5cbmV4cG9ydCBjb25zdCBHUFVGZWF0dXJlTmFtZSA9IHtcblx0RGVwdGhDbGlwQ29udHJvbDogJ2RlcHRoLWNsaXAtY29udHJvbCcsXG5cdERlcHRoMzJGbG9hdFN0ZW5jaWw4OiAnZGVwdGgzMmZsb2F0LXN0ZW5jaWw4Jyxcblx0VGV4dHVyZUNvbXByZXNzaW9uQkM6ICd0ZXh0dXJlLWNvbXByZXNzaW9uLWJjJyxcblx0VGV4dHVyZUNvbXByZXNzaW9uRVRDMjogJ3RleHR1cmUtY29tcHJlc3Npb24tZXRjMicsXG5cdFRleHR1cmVDb21wcmVzc2lvbkFTVEM6ICd0ZXh0dXJlLWNvbXByZXNzaW9uLWFzdGMnLFxuXHRUaW1lc3RhbXBRdWVyeTogJ3RpbWVzdGFtcC1xdWVyeScsXG5cdEluZGlyZWN0Rmlyc3RJbnN0YW5jZTogJ2luZGlyZWN0LWZpcnN0LWluc3RhbmNlJyxcblx0U2hhZGVyRjE2OiAnc2hhZGVyLWYxNicsXG5cdFJHMTFCMTBVRmxvYXQ6ICdyZzExYjEwdWZsb2F0LXJlbmRlcmFibGUnLFxuXHRCR1JBOFVOb3JtU3RvcmFnZTogJ2JncmE4dW5vcm0tc3RvcmFnZScsXG5cdEZsb2F0MzJGaWx0ZXJhYmxlOiAnZmxvYXQzMi1maWx0ZXJhYmxlJyxcblx0Q2xpcERpc3RhbmNlczogJ2NsaXAtZGlzdGFuY2VzJyxcblx0RHVhbFNvdXJjZUJsZW5kaW5nOiAnZHVhbC1zb3VyY2UtYmxlbmRpbmcnLFxuXHRTdWJncm91cHM6ICdzdWJncm91cHMnXG59O1xuIiwiaW1wb3J0IEJpbmRpbmcgZnJvbSAnLi9CaW5kaW5nLmpzJztcblxuY2xhc3MgU2FtcGxlciBleHRlbmRzIEJpbmRpbmcge1xuXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0ZXh0dXJlICkge1xuXG5cdFx0c3VwZXIoIG5hbWUgKTtcblxuXHRcdHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG5cdFx0dGhpcy52ZXJzaW9uID0gdGV4dHVyZSA/IHRleHR1cmUudmVyc2lvbiA6IDA7XG5cblx0XHR0aGlzLmlzU2FtcGxlciA9IHRydWU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNhbXBsZXI7XG4iLCJpbXBvcnQgU2FtcGxlciBmcm9tICcuLi9TYW1wbGVyLmpzJztcblxuY2xhc3MgTm9kZVNhbXBsZXIgZXh0ZW5kcyBTYW1wbGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdGV4dHVyZU5vZGUsIGdyb3VwTm9kZSApIHtcblxuXHRcdHN1cGVyKCBuYW1lLCB0ZXh0dXJlTm9kZSA/IHRleHR1cmVOb2RlLnZhbHVlIDogbnVsbCApO1xuXG5cdFx0dGhpcy50ZXh0dXJlTm9kZSA9IHRleHR1cmVOb2RlO1xuXHRcdHRoaXMuZ3JvdXBOb2RlID0gZ3JvdXBOb2RlO1xuXG5cdH1cblxuXHR1cGRhdGUoKSB7XG5cblx0XHR0aGlzLnRleHR1cmUgPSB0aGlzLnRleHR1cmVOb2RlLnZhbHVlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlU2FtcGxlcjtcbiIsImltcG9ydCBCdWZmZXIgZnJvbSAnLi9CdWZmZXIuanMnO1xuXG5jbGFzcyBTdG9yYWdlQnVmZmVyIGV4dGVuZHMgQnVmZmVyIHtcblxuXHRjb25zdHJ1Y3RvciggbmFtZSwgYXR0cmlidXRlICkge1xuXG5cdFx0c3VwZXIoIG5hbWUsIGF0dHJpYnV0ZSA/IGF0dHJpYnV0ZS5hcnJheSA6IG51bGwgKTtcblxuXHRcdHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuXG5cdFx0dGhpcy5pc1N0b3JhZ2VCdWZmZXIgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTdG9yYWdlQnVmZmVyO1xuIiwiaW1wb3J0IFN0b3JhZ2VCdWZmZXIgZnJvbSAnLi4vU3RvcmFnZUJ1ZmZlci5qcyc7XG5pbXBvcnQgeyBOb2RlQWNjZXNzIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvY29yZS9jb25zdGFudHMuanMnO1xuXG5sZXQgX2lkID0gMDtcblxuY2xhc3MgTm9kZVN0b3JhZ2VCdWZmZXIgZXh0ZW5kcyBTdG9yYWdlQnVmZmVyIHtcblxuXHRjb25zdHJ1Y3Rvciggbm9kZVVuaWZvcm0sIGdyb3VwTm9kZSApIHtcblxuXHRcdHN1cGVyKCAnU3RvcmFnZUJ1ZmZlcl8nICsgX2lkICsrLCBub2RlVW5pZm9ybSA/IG5vZGVVbmlmb3JtLnZhbHVlIDogbnVsbCApO1xuXG5cdFx0dGhpcy5ub2RlVW5pZm9ybSA9IG5vZGVVbmlmb3JtO1xuXHRcdHRoaXMuYWNjZXNzID0gbm9kZVVuaWZvcm0gPyBub2RlVW5pZm9ybS5hY2Nlc3MgOiBOb2RlQWNjZXNzLlJFQURfV1JJVEU7XG5cdFx0dGhpcy5ncm91cE5vZGUgPSBncm91cE5vZGU7XG5cblx0fVxuXG5cdGdldCBidWZmZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS52YWx1ZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTm9kZVN0b3JhZ2VCdWZmZXI7XG4iLCJpbXBvcnQgRGF0YU1hcCBmcm9tICcuLi8uLi9jb21tb24vRGF0YU1hcC5qcyc7XG5pbXBvcnQgeyBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbiwgR1BVSW5kZXhGb3JtYXQsIEdQVUZpbHRlck1vZGUsIEdQVVByaW1pdGl2ZVRvcG9sb2d5LCBHUFVMb2FkT3AsIEdQVVN0b3JlT3AgfSBmcm9tICcuL1dlYkdQVUNvbnN0YW50cy5qcyc7XG5cbmNsYXNzIFdlYkdQVVRleHR1cmVQYXNzVXRpbHMgZXh0ZW5kcyBEYXRhTWFwIHtcblxuXHRjb25zdHJ1Y3RvciggZGV2aWNlICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuZGV2aWNlID0gZGV2aWNlO1xuXG5cdFx0Y29uc3QgbWlwbWFwVmVydGV4U291cmNlID0gYFxuc3RydWN0IFZhcnlzU3RydWN0IHtcblx0QGJ1aWx0aW4oIHBvc2l0aW9uICkgUG9zaXRpb246IHZlYzQ8ZjMyPixcblx0QGxvY2F0aW9uKCAwICkgdlRleCA6IHZlYzI8ZjMyPlxufTtcblxuQHZlcnRleFxuZm4gbWFpbiggQGJ1aWx0aW4oIHZlcnRleF9pbmRleCApIHZlcnRleEluZGV4IDogdTMyICkgLT4gVmFyeXNTdHJ1Y3Qge1xuXG5cdHZhciBWYXJ5cyA6IFZhcnlzU3RydWN0O1xuXG5cdHZhciBwb3MgPSBhcnJheTwgdmVjMjxmMzI+LCA0ID4oXG5cdFx0dmVjMjxmMzI+KCAtMS4wLCAgMS4wICksXG5cdFx0dmVjMjxmMzI+KCAgMS4wLCAgMS4wICksXG5cdFx0dmVjMjxmMzI+KCAtMS4wLCAtMS4wICksXG5cdFx0dmVjMjxmMzI+KCAgMS4wLCAtMS4wIClcblx0KTtcblxuXHR2YXIgdGV4ID0gYXJyYXk8IHZlYzI8ZjMyPiwgNCA+KFxuXHRcdHZlYzI8ZjMyPiggMC4wLCAwLjAgKSxcblx0XHR2ZWMyPGYzMj4oIDEuMCwgMC4wICksXG5cdFx0dmVjMjxmMzI+KCAwLjAsIDEuMCApLFxuXHRcdHZlYzI8ZjMyPiggMS4wLCAxLjAgKVxuXHQpO1xuXG5cdFZhcnlzLnZUZXggPSB0ZXhbIHZlcnRleEluZGV4IF07XG5cdFZhcnlzLlBvc2l0aW9uID0gdmVjNDxmMzI+KCBwb3NbIHZlcnRleEluZGV4IF0sIDAuMCwgMS4wICk7XG5cblx0cmV0dXJuIFZhcnlzO1xuXG59XG5gO1xuXG5cdFx0Y29uc3QgbWlwbWFwRnJhZ21lbnRTb3VyY2UgPSBgXG5AZ3JvdXAoIDAgKSBAYmluZGluZyggMCApXG52YXIgaW1nU2FtcGxlciA6IHNhbXBsZXI7XG5cbkBncm91cCggMCApIEBiaW5kaW5nKCAxIClcbnZhciBpbWcgOiB0ZXh0dXJlXzJkPGYzMj47XG5cbkBmcmFnbWVudFxuZm4gbWFpbiggQGxvY2F0aW9uKCAwICkgdlRleCA6IHZlYzI8ZjMyPiApIC0+IEBsb2NhdGlvbiggMCApIHZlYzQ8ZjMyPiB7XG5cblx0cmV0dXJuIHRleHR1cmVTYW1wbGUoIGltZywgaW1nU2FtcGxlciwgdlRleCApO1xuXG59XG5gO1xuXG5cdFx0Y29uc3QgZmxpcFlGcmFnbWVudFNvdXJjZSA9IGBcbkBncm91cCggMCApIEBiaW5kaW5nKCAwIClcbnZhciBpbWdTYW1wbGVyIDogc2FtcGxlcjtcblxuQGdyb3VwKCAwICkgQGJpbmRpbmcoIDEgKVxudmFyIGltZyA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuQGZyYWdtZW50XG5mbiBtYWluKCBAbG9jYXRpb24oIDAgKSB2VGV4IDogdmVjMjxmMzI+ICkgLT4gQGxvY2F0aW9uKCAwICkgdmVjNDxmMzI+IHtcblxuXHRyZXR1cm4gdGV4dHVyZVNhbXBsZSggaW1nLCBpbWdTYW1wbGVyLCB2ZWMyKCB2VGV4LngsIDEuMCAtIHZUZXgueSApICk7XG5cbn1cbmA7XG5cdFx0dGhpcy5taXBtYXBTYW1wbGVyID0gZGV2aWNlLmNyZWF0ZVNhbXBsZXIoIHsgbWluRmlsdGVyOiBHUFVGaWx0ZXJNb2RlLkxpbmVhciB9ICk7XG5cdFx0dGhpcy5mbGlwWVNhbXBsZXIgPSBkZXZpY2UuY3JlYXRlU2FtcGxlciggeyBtaW5GaWx0ZXI6IEdQVUZpbHRlck1vZGUuTmVhcmVzdCB9ICk7IC8vQFRPRE8/OiBDb25zaWRlciB1c2luZyB0ZXh0dXJlTG9hZCgpXG5cblx0XHQvLyBXZSdsbCBuZWVkIGEgbmV3IHBpcGVsaW5lIGZvciBldmVyeSB0ZXh0dXJlIGZvcm1hdCB1c2VkLlxuXHRcdHRoaXMudHJhbnNmZXJQaXBlbGluZXMgPSB7fTtcblx0XHR0aGlzLmZsaXBZUGlwZWxpbmVzID0ge307XG5cblx0XHR0aGlzLm1pcG1hcFZlcnRleFNoYWRlck1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoIHtcblx0XHRcdGxhYmVsOiAnbWlwbWFwVmVydGV4Jyxcblx0XHRcdGNvZGU6IG1pcG1hcFZlcnRleFNvdXJjZVxuXHRcdH0gKTtcblxuXHRcdHRoaXMubWlwbWFwRnJhZ21lbnRTaGFkZXJNb2R1bGUgPSBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKCB7XG5cdFx0XHRsYWJlbDogJ21pcG1hcEZyYWdtZW50Jyxcblx0XHRcdGNvZGU6IG1pcG1hcEZyYWdtZW50U291cmNlXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5mbGlwWUZyYWdtZW50U2hhZGVyTW9kdWxlID0gZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSgge1xuXHRcdFx0bGFiZWw6ICdmbGlwWUZyYWdtZW50Jyxcblx0XHRcdGNvZGU6IGZsaXBZRnJhZ21lbnRTb3VyY2Vcblx0XHR9ICk7XG5cblx0fVxuXG5cdGdldFRyYW5zZmVyUGlwZWxpbmUoIGZvcm1hdCApIHtcblxuXHRcdGxldCBwaXBlbGluZSA9IHRoaXMudHJhbnNmZXJQaXBlbGluZXNbIGZvcm1hdCBdO1xuXG5cdFx0aWYgKCBwaXBlbGluZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwaXBlbGluZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKCB7XG5cdFx0XHRcdGxhYmVsOiBgbWlwbWFwLSR7IGZvcm1hdCB9YCxcblx0XHRcdFx0dmVydGV4OiB7XG5cdFx0XHRcdFx0bW9kdWxlOiB0aGlzLm1pcG1hcFZlcnRleFNoYWRlck1vZHVsZSxcblx0XHRcdFx0XHRlbnRyeVBvaW50OiAnbWFpbidcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnJhZ21lbnQ6IHtcblx0XHRcdFx0XHRtb2R1bGU6IHRoaXMubWlwbWFwRnJhZ21lbnRTaGFkZXJNb2R1bGUsXG5cdFx0XHRcdFx0ZW50cnlQb2ludDogJ21haW4nLFxuXHRcdFx0XHRcdHRhcmdldHM6IFsgeyBmb3JtYXQgfSBdXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHByaW1pdGl2ZToge1xuXHRcdFx0XHRcdHRvcG9sb2d5OiBHUFVQcmltaXRpdmVUb3BvbG9neS5UcmlhbmdsZVN0cmlwLFxuXHRcdFx0XHRcdHN0cmlwSW5kZXhGb3JtYXQ6IEdQVUluZGV4Rm9ybWF0LlVpbnQzMlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRsYXlvdXQ6ICdhdXRvJ1xuXHRcdFx0fSApO1xuXG5cdFx0XHR0aGlzLnRyYW5zZmVyUGlwZWxpbmVzWyBmb3JtYXQgXSA9IHBpcGVsaW5lO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBpcGVsaW5lO1xuXG5cdH1cblxuXHRnZXRGbGlwWVBpcGVsaW5lKCBmb3JtYXQgKSB7XG5cblx0XHRsZXQgcGlwZWxpbmUgPSB0aGlzLmZsaXBZUGlwZWxpbmVzWyBmb3JtYXQgXTtcblxuXHRcdGlmICggcGlwZWxpbmUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGlwZWxpbmUgPSB0aGlzLmRldmljZS5jcmVhdGVSZW5kZXJQaXBlbGluZSgge1xuXHRcdFx0XHRsYWJlbDogYGZsaXBZLSR7IGZvcm1hdCB9YCxcblx0XHRcdFx0dmVydGV4OiB7XG5cdFx0XHRcdFx0bW9kdWxlOiB0aGlzLm1pcG1hcFZlcnRleFNoYWRlck1vZHVsZSxcblx0XHRcdFx0XHRlbnRyeVBvaW50OiAnbWFpbidcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnJhZ21lbnQ6IHtcblx0XHRcdFx0XHRtb2R1bGU6IHRoaXMuZmxpcFlGcmFnbWVudFNoYWRlck1vZHVsZSxcblx0XHRcdFx0XHRlbnRyeVBvaW50OiAnbWFpbicsXG5cdFx0XHRcdFx0dGFyZ2V0czogWyB7IGZvcm1hdCB9IF1cblx0XHRcdFx0fSxcblx0XHRcdFx0cHJpbWl0aXZlOiB7XG5cdFx0XHRcdFx0dG9wb2xvZ3k6IEdQVVByaW1pdGl2ZVRvcG9sb2d5LlRyaWFuZ2xlU3RyaXAsXG5cdFx0XHRcdFx0c3RyaXBJbmRleEZvcm1hdDogR1BVSW5kZXhGb3JtYXQuVWludDMyXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxheW91dDogJ2F1dG8nXG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMuZmxpcFlQaXBlbGluZXNbIGZvcm1hdCBdID0gcGlwZWxpbmU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcGlwZWxpbmU7XG5cblx0fVxuXG5cdGZsaXBZKCB0ZXh0dXJlR1BVLCB0ZXh0dXJlR1BVRGVzY3JpcHRvciwgYmFzZUFycmF5TGF5ZXIgPSAwICkge1xuXG5cdFx0Y29uc3QgZm9ybWF0ID0gdGV4dHVyZUdQVURlc2NyaXB0b3IuZm9ybWF0O1xuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGV4dHVyZUdQVURlc2NyaXB0b3Iuc2l6ZTtcblxuXHRcdGNvbnN0IHRyYW5zZmVyUGlwZWxpbmUgPSB0aGlzLmdldFRyYW5zZmVyUGlwZWxpbmUoIGZvcm1hdCApO1xuXHRcdGNvbnN0IGZsaXBZUGlwZWxpbmUgPSB0aGlzLmdldEZsaXBZUGlwZWxpbmUoIGZvcm1hdCApO1xuXG5cdFx0Y29uc3QgdGVtcFRleHR1cmUgPSB0aGlzLmRldmljZS5jcmVhdGVUZXh0dXJlKCB7XG5cdFx0XHRzaXplOiB7IHdpZHRoLCBoZWlnaHQsIGRlcHRoT3JBcnJheUxheWVyczogMSB9LFxuXHRcdFx0Zm9ybWF0LFxuXHRcdFx0dXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCB8IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkdcblx0XHR9ICk7XG5cblx0XHRjb25zdCBzcmNWaWV3ID0gdGV4dHVyZUdQVS5jcmVhdGVWaWV3KCB7XG5cdFx0XHRiYXNlTWlwTGV2ZWw6IDAsXG5cdFx0XHRtaXBMZXZlbENvdW50OiAxLFxuXHRcdFx0ZGltZW5zaW9uOiBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbi5Ud29ELFxuXHRcdFx0YmFzZUFycmF5TGF5ZXJcblx0XHR9ICk7XG5cblx0XHRjb25zdCBkc3RWaWV3ID0gdGVtcFRleHR1cmUuY3JlYXRlVmlldygge1xuXHRcdFx0YmFzZU1pcExldmVsOiAwLFxuXHRcdFx0bWlwTGV2ZWxDb3VudDogMSxcblx0XHRcdGRpbWVuc2lvbjogR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24uVHdvRCxcblx0XHRcdGJhc2VBcnJheUxheWVyOiAwXG5cdFx0fSApO1xuXG5cdFx0Y29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2Rlcigge30gKTtcblxuXHRcdGNvbnN0IHBhc3MgPSAoIHBpcGVsaW5lLCBzb3VyY2VWaWV3LCBkZXN0aW5hdGlvblZpZXcgKSA9PiB7XG5cblx0XHRcdGNvbnN0IGJpbmRHcm91cExheW91dCA9IHBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCggMCApOyAvLyBAVE9ETzogQ29uc2lkZXIgbWFraW5nIHRoaXMgc3RhdGljLlxuXG5cdFx0XHRjb25zdCBiaW5kR3JvdXAgPSB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXAoIHtcblx0XHRcdFx0bGF5b3V0OiBiaW5kR3JvdXBMYXlvdXQsXG5cdFx0XHRcdGVudHJpZXM6IFsge1xuXHRcdFx0XHRcdGJpbmRpbmc6IDAsXG5cdFx0XHRcdFx0cmVzb3VyY2U6IHRoaXMuZmxpcFlTYW1wbGVyXG5cdFx0XHRcdH0sIHtcblx0XHRcdFx0XHRiaW5kaW5nOiAxLFxuXHRcdFx0XHRcdHJlc291cmNlOiBzb3VyY2VWaWV3XG5cdFx0XHRcdH0gXVxuXHRcdFx0fSApO1xuXG5cdFx0XHRjb25zdCBwYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luUmVuZGVyUGFzcygge1xuXHRcdFx0XHRjb2xvckF0dGFjaG1lbnRzOiBbIHtcblx0XHRcdFx0XHR2aWV3OiBkZXN0aW5hdGlvblZpZXcsXG5cdFx0XHRcdFx0bG9hZE9wOiBHUFVMb2FkT3AuQ2xlYXIsXG5cdFx0XHRcdFx0c3RvcmVPcDogR1BVU3RvcmVPcC5TdG9yZSxcblx0XHRcdFx0XHRjbGVhclZhbHVlOiBbIDAsIDAsIDAsIDAgXVxuXHRcdFx0XHR9IF1cblx0XHRcdH0gKTtcblxuXHRcdFx0cGFzc0VuY29kZXIuc2V0UGlwZWxpbmUoIHBpcGVsaW5lICk7XG5cdFx0XHRwYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoIDAsIGJpbmRHcm91cCApO1xuXHRcdFx0cGFzc0VuY29kZXIuZHJhdyggNCwgMSwgMCwgMCApO1xuXHRcdFx0cGFzc0VuY29kZXIuZW5kKCk7XG5cblx0XHR9O1xuXG5cdFx0cGFzcyggdHJhbnNmZXJQaXBlbGluZSwgc3JjVmlldywgZHN0VmlldyApO1xuXHRcdHBhc3MoIGZsaXBZUGlwZWxpbmUsIGRzdFZpZXcsIHNyY1ZpZXcgKTtcblxuXHRcdHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdCggWyBjb21tYW5kRW5jb2Rlci5maW5pc2goKSBdICk7XG5cblx0XHR0ZW1wVGV4dHVyZS5kZXN0cm95KCk7XG5cblx0fVxuXG5cdGdlbmVyYXRlTWlwbWFwcyggdGV4dHVyZUdQVSwgdGV4dHVyZUdQVURlc2NyaXB0b3IsIGJhc2VBcnJheUxheWVyID0gMCApIHtcblxuXHRcdGNvbnN0IHRleHR1cmVEYXRhID0gdGhpcy5nZXQoIHRleHR1cmVHUFUgKTtcblxuXHRcdGlmICggdGV4dHVyZURhdGEudXNlQ291bnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGV4dHVyZURhdGEudXNlQ291bnQgPSAwO1xuXHRcdFx0dGV4dHVyZURhdGEubGF5ZXJzID0gW107XG5cblx0XHR9XG5cblx0XHRjb25zdCBwYXNzZXMgPSB0ZXh0dXJlRGF0YS5sYXllcnNbIGJhc2VBcnJheUxheWVyIF0gfHwgdGhpcy5fbWlwbWFwQ3JlYXRlQnVuZGxlcyggdGV4dHVyZUdQVSwgdGV4dHVyZUdQVURlc2NyaXB0b3IsIGJhc2VBcnJheUxheWVyICk7XG5cblx0XHRjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCB7fSApO1xuXG5cdFx0dGhpcy5fbWlwbWFwUnVuQnVuZGxlcyggY29tbWFuZEVuY29kZXIsIHBhc3NlcyApO1xuXG5cdFx0dGhpcy5kZXZpY2UucXVldWUuc3VibWl0KCBbIGNvbW1hbmRFbmNvZGVyLmZpbmlzaCgpIF0gKTtcblxuXHRcdGlmICggdGV4dHVyZURhdGEudXNlQ291bnQgIT09IDAgKSB0ZXh0dXJlRGF0YS5sYXllcnNbIGJhc2VBcnJheUxheWVyIF0gPSBwYXNzZXM7XG5cblx0XHR0ZXh0dXJlRGF0YS51c2VDb3VudCArKztcblxuXHR9XG5cblx0X21pcG1hcENyZWF0ZUJ1bmRsZXMoIHRleHR1cmVHUFUsIHRleHR1cmVHUFVEZXNjcmlwdG9yLCBiYXNlQXJyYXlMYXllciApIHtcblxuXHRcdGNvbnN0IHBpcGVsaW5lID0gdGhpcy5nZXRUcmFuc2ZlclBpcGVsaW5lKCB0ZXh0dXJlR1BVRGVzY3JpcHRvci5mb3JtYXQgKTtcblxuXHRcdGNvbnN0IGJpbmRHcm91cExheW91dCA9IHBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCggMCApOyAvLyBAVE9ETzogQ29uc2lkZXIgbWFraW5nIHRoaXMgc3RhdGljLlxuXG5cdFx0bGV0IHNyY1ZpZXcgPSB0ZXh0dXJlR1BVLmNyZWF0ZVZpZXcoIHtcblx0XHRcdGJhc2VNaXBMZXZlbDogMCxcblx0XHRcdG1pcExldmVsQ291bnQ6IDEsXG5cdFx0XHRkaW1lbnNpb246IEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLlR3b0QsXG5cdFx0XHRiYXNlQXJyYXlMYXllclxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IHBhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDwgdGV4dHVyZUdQVURlc2NyaXB0b3IubWlwTGV2ZWxDb3VudDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgYmluZEdyb3VwID0gdGhpcy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwKCB7XG5cdFx0XHRcdGxheW91dDogYmluZEdyb3VwTGF5b3V0LFxuXHRcdFx0XHRlbnRyaWVzOiBbIHtcblx0XHRcdFx0XHRiaW5kaW5nOiAwLFxuXHRcdFx0XHRcdHJlc291cmNlOiB0aGlzLm1pcG1hcFNhbXBsZXJcblx0XHRcdFx0fSwge1xuXHRcdFx0XHRcdGJpbmRpbmc6IDEsXG5cdFx0XHRcdFx0cmVzb3VyY2U6IHNyY1ZpZXdcblx0XHRcdFx0fSBdXG5cdFx0XHR9ICk7XG5cblx0XHRcdGNvbnN0IGRzdFZpZXcgPSB0ZXh0dXJlR1BVLmNyZWF0ZVZpZXcoIHtcblx0XHRcdFx0YmFzZU1pcExldmVsOiBpLFxuXHRcdFx0XHRtaXBMZXZlbENvdW50OiAxLFxuXHRcdFx0XHRkaW1lbnNpb246IEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLlR3b0QsXG5cdFx0XHRcdGJhc2VBcnJheUxheWVyXG5cdFx0XHR9ICk7XG5cblx0XHRcdGNvbnN0IHBhc3NEZXNjcmlwdG9yID0ge1xuXHRcdFx0XHRjb2xvckF0dGFjaG1lbnRzOiBbIHtcblx0XHRcdFx0XHR2aWV3OiBkc3RWaWV3LFxuXHRcdFx0XHRcdGxvYWRPcDogR1BVTG9hZE9wLkNsZWFyLFxuXHRcdFx0XHRcdHN0b3JlT3A6IEdQVVN0b3JlT3AuU3RvcmUsXG5cdFx0XHRcdFx0Y2xlYXJWYWx1ZTogWyAwLCAwLCAwLCAwIF1cblx0XHRcdFx0fSBdXG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBwYXNzRW5jb2RlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZVJlbmRlckJ1bmRsZUVuY29kZXIoIHtcblx0XHRcdFx0Y29sb3JGb3JtYXRzOiBbIHRleHR1cmVHUFVEZXNjcmlwdG9yLmZvcm1hdCBdXG5cdFx0XHR9ICk7XG5cblx0XHRcdHBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKCBwaXBlbGluZSApO1xuXHRcdFx0cGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKCAwLCBiaW5kR3JvdXAgKTtcblx0XHRcdHBhc3NFbmNvZGVyLmRyYXcoIDQsIDEsIDAsIDAgKTtcblxuXHRcdFx0cGFzc2VzLnB1c2goIHtcblx0XHRcdFx0cmVuZGVyQnVuZGxlczogWyBwYXNzRW5jb2Rlci5maW5pc2goKSBdLFxuXHRcdFx0XHRwYXNzRGVzY3JpcHRvclxuXHRcdFx0fSApO1xuXG5cdFx0XHRzcmNWaWV3ID0gZHN0VmlldztcblxuXHRcdH1cblxuXHRcdHJldHVybiBwYXNzZXM7XG5cblx0fVxuXG5cdF9taXBtYXBSdW5CdW5kbGVzKCBjb21tYW5kRW5jb2RlciwgcGFzc2VzICkge1xuXG5cdFx0Y29uc3QgbGV2ZWxzID0gcGFzc2VzLmxlbmd0aDtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxldmVsczsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcGFzcyA9IHBhc3Nlc1sgaSBdO1xuXG5cdFx0XHRjb25zdCBwYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyggcGFzcy5wYXNzRGVzY3JpcHRvciApO1xuXG5cdFx0XHRwYXNzRW5jb2Rlci5leGVjdXRlQnVuZGxlcyggcGFzcy5yZW5kZXJCdW5kbGVzICk7XG5cblx0XHRcdHBhc3NFbmNvZGVyLmVuZCgpO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJHUFVUZXh0dXJlUGFzc1V0aWxzO1xuIiwiaW1wb3J0IHtcblx0R1BVVGV4dHVyZUZvcm1hdCwgR1BVQWRkcmVzc01vZGUsIEdQVUZpbHRlck1vZGUsIEdQVVRleHR1cmVEaW1lbnNpb24sIEdQVUZlYXR1cmVOYW1lXG59IGZyb20gJy4vV2ViR1BVQ29uc3RhbnRzLmpzJztcblxuaW1wb3J0IFdlYkdQVVRleHR1cmVQYXNzVXRpbHMgZnJvbSAnLi9XZWJHUFVUZXh0dXJlUGFzc1V0aWxzLmpzJztcblxuaW1wb3J0IHtcblx0Qnl0ZVR5cGUsIFNob3J0VHlwZSxcblx0TmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG5cdFJlcGVhdFdyYXBwaW5nLCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLFxuXHRSR0JfRVRDMl9Gb3JtYXQsIFJHQkFfRVRDMl9FQUNfRm9ybWF0LFxuXHRSR0JBRm9ybWF0LCBSR0JGb3JtYXQsIFJlZEZvcm1hdCwgUkdGb3JtYXQsIFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCwgUkdCQV9TM1RDX0RYVDNfRm9ybWF0LCBSR0JBX1MzVENfRFhUNV9Gb3JtYXQsIFVuc2lnbmVkQnl0ZVR5cGUsIEZsb2F0VHlwZSwgSGFsZkZsb2F0VHlwZSwgU1JHQkNvbG9yU3BhY2UsIERlcHRoRm9ybWF0LCBEZXB0aFN0ZW5jaWxGb3JtYXQsXG5cdFJHQkFfQVNUQ180eDRfRm9ybWF0LCBSR0JBX0FTVENfNXg0X0Zvcm1hdCwgUkdCQV9BU1RDXzV4NV9Gb3JtYXQsIFJHQkFfQVNUQ182eDVfRm9ybWF0LCBSR0JBX0FTVENfNng2X0Zvcm1hdCwgUkdCQV9BU1RDXzh4NV9Gb3JtYXQsIFJHQkFfQVNUQ184eDZfRm9ybWF0LCBSR0JBX0FTVENfOHg4X0Zvcm1hdCwgUkdCQV9BU1RDXzEweDVfRm9ybWF0LFxuXHRSR0JBX0FTVENfMTB4Nl9Gb3JtYXQsIFJHQkFfQVNUQ18xMHg4X0Zvcm1hdCwgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCwgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCwgUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCwgVW5zaWduZWRJbnRUeXBlLCBVbnNpZ25lZFNob3J0VHlwZSwgVW5zaWduZWRJbnQyNDhUeXBlLCBVbnNpZ25lZEludDU5OTlUeXBlLFxuXHROZXZlckNvbXBhcmUsIEFsd2F5c0NvbXBhcmUsIExlc3NDb21wYXJlLCBMZXNzRXF1YWxDb21wYXJlLCBFcXVhbENvbXBhcmUsIEdyZWF0ZXJFcXVhbENvbXBhcmUsIEdyZWF0ZXJDb21wYXJlLCBOb3RFcXVhbENvbXBhcmUsIEludFR5cGUsIFJlZEludGVnZXJGb3JtYXQsIFJHSW50ZWdlckZvcm1hdCwgUkdCQUludGVnZXJGb3JtYXQsXG5cdEN1YmVSZWZsZWN0aW9uTWFwcGluZywgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nLCBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZywgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmdcbn0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IEN1YmVUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vdGV4dHVyZXMvQ3ViZVRleHR1cmUuanMnO1xuaW1wb3J0IHsgRGVwdGhUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vdGV4dHVyZXMvRGVwdGhUZXh0dXJlLmpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi90ZXh0dXJlcy9UZXh0dXJlLmpzJztcblxuY29uc3QgX2NvbXBhcmVUb1dlYkdQVSA9IHtcblx0WyBOZXZlckNvbXBhcmUgXTogJ25ldmVyJyxcblx0WyBMZXNzQ29tcGFyZSBdOiAnbGVzcycsXG5cdFsgRXF1YWxDb21wYXJlIF06ICdlcXVhbCcsXG5cdFsgTGVzc0VxdWFsQ29tcGFyZSBdOiAnbGVzcy1lcXVhbCcsXG5cdFsgR3JlYXRlckNvbXBhcmUgXTogJ2dyZWF0ZXInLFxuXHRbIEdyZWF0ZXJFcXVhbENvbXBhcmUgXTogJ2dyZWF0ZXItZXF1YWwnLFxuXHRbIEFsd2F5c0NvbXBhcmUgXTogJ2Fsd2F5cycsXG5cdFsgTm90RXF1YWxDb21wYXJlIF06ICdub3QtZXF1YWwnXG59O1xuXG5jb25zdCBfZmxpcE1hcCA9IFsgMCwgMSwgMywgMiwgNCwgNSBdO1xuXG5jbGFzcyBXZWJHUFVUZXh0dXJlVXRpbHMge1xuXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xuXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcblxuXHRcdHRoaXMuX3Bhc3NVdGlscyA9IG51bGw7XG5cblx0XHR0aGlzLmRlZmF1bHRUZXh0dXJlID0ge307XG5cdFx0dGhpcy5kZWZhdWx0Q3ViZVRleHR1cmUgPSB7fTtcblx0XHR0aGlzLmRlZmF1bHRWaWRlb0ZyYW1lID0gbnVsbDtcblxuXHRcdHRoaXMuY29sb3JCdWZmZXIgPSBudWxsO1xuXG5cdFx0dGhpcy5kZXB0aFRleHR1cmUgPSBuZXcgRGVwdGhUZXh0dXJlKCk7XG5cdFx0dGhpcy5kZXB0aFRleHR1cmUubmFtZSA9ICdkZXB0aEJ1ZmZlcic7XG5cblx0fVxuXG5cdGNyZWF0ZVNhbXBsZXIoIHRleHR1cmUgKSB7XG5cblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXHRcdGNvbnN0IGRldmljZSA9IGJhY2tlbmQuZGV2aWNlO1xuXG5cdFx0Y29uc3QgdGV4dHVyZUdQVSA9IGJhY2tlbmQuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRjb25zdCBzYW1wbGVyRGVzY3JpcHRvckdQVSA9IHtcblx0XHRcdGFkZHJlc3NNb2RlVTogdGhpcy5fY29udmVydEFkZHJlc3NNb2RlKCB0ZXh0dXJlLndyYXBTICksXG5cdFx0XHRhZGRyZXNzTW9kZVY6IHRoaXMuX2NvbnZlcnRBZGRyZXNzTW9kZSggdGV4dHVyZS53cmFwVCApLFxuXHRcdFx0YWRkcmVzc01vZGVXOiB0aGlzLl9jb252ZXJ0QWRkcmVzc01vZGUoIHRleHR1cmUud3JhcFIgKSxcblx0XHRcdG1hZ0ZpbHRlcjogdGhpcy5fY29udmVydEZpbHRlck1vZGUoIHRleHR1cmUubWFnRmlsdGVyICksXG5cdFx0XHRtaW5GaWx0ZXI6IHRoaXMuX2NvbnZlcnRGaWx0ZXJNb2RlKCB0ZXh0dXJlLm1pbkZpbHRlciApLFxuXHRcdFx0bWlwbWFwRmlsdGVyOiB0aGlzLl9jb252ZXJ0RmlsdGVyTW9kZSggdGV4dHVyZS5taW5GaWx0ZXIgKSxcblx0XHRcdG1heEFuaXNvdHJvcHk6IDFcblx0XHR9O1xuXG5cdFx0Ly8gYW5pc290cm9weSBjYW4gb25seSBiZSB1c2VkIHdoZW4gYWxsIGZpbHRlciBtb2RlcyBhcmUgc2V0IHRvIGxpbmVhci5cblxuXHRcdGlmICggc2FtcGxlckRlc2NyaXB0b3JHUFUubWFnRmlsdGVyID09PSBHUFVGaWx0ZXJNb2RlLkxpbmVhciAmJiBzYW1wbGVyRGVzY3JpcHRvckdQVS5taW5GaWx0ZXIgPT09IEdQVUZpbHRlck1vZGUuTGluZWFyICYmIHNhbXBsZXJEZXNjcmlwdG9yR1BVLm1pcG1hcEZpbHRlciA9PT0gR1BVRmlsdGVyTW9kZS5MaW5lYXIgKSB7XG5cblx0XHRcdHNhbXBsZXJEZXNjcmlwdG9yR1BVLm1heEFuaXNvdHJvcHkgPSB0ZXh0dXJlLmFuaXNvdHJvcHk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRleHR1cmUuaXNEZXB0aFRleHR1cmUgJiYgdGV4dHVyZS5jb21wYXJlRnVuY3Rpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdHNhbXBsZXJEZXNjcmlwdG9yR1BVLmNvbXBhcmUgPSBfY29tcGFyZVRvV2ViR1BVWyB0ZXh0dXJlLmNvbXBhcmVGdW5jdGlvbiBdO1xuXG5cdFx0fVxuXG5cdFx0dGV4dHVyZUdQVS5zYW1wbGVyID0gZGV2aWNlLmNyZWF0ZVNhbXBsZXIoIHNhbXBsZXJEZXNjcmlwdG9yR1BVICk7XG5cblx0fVxuXG5cdGNyZWF0ZURlZmF1bHRUZXh0dXJlKCB0ZXh0dXJlICkge1xuXG5cdFx0bGV0IHRleHR1cmVHUFU7XG5cblx0XHRjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoIHRleHR1cmUgKTtcblxuXHRcdGlmICggdGV4dHVyZS5pc0N1YmVUZXh0dXJlICkge1xuXG5cdFx0XHR0ZXh0dXJlR1BVID0gdGhpcy5fZ2V0RGVmYXVsdEN1YmVUZXh0dXJlR1BVKCBmb3JtYXQgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgKSB7XG5cblx0XHRcdHRoaXMuYmFja2VuZC5nZXQoIHRleHR1cmUgKS5leHRlcm5hbFRleHR1cmUgPSB0aGlzLl9nZXREZWZhdWx0VmlkZW9GcmFtZSgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGV4dHVyZUdQVSA9IHRoaXMuX2dldERlZmF1bHRUZXh0dXJlR1BVKCBmb3JtYXQgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYmFja2VuZC5nZXQoIHRleHR1cmUgKS50ZXh0dXJlID0gdGV4dHVyZUdQVTtcblxuXHR9XG5cblx0Y3JlYXRlVGV4dHVyZSggdGV4dHVyZSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcblx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IGJhY2tlbmQuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRpZiAoIHRleHR1cmVEYXRhLmluaXRpYWxpemVkICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdXZWJHUFVUZXh0dXJlVXRpbHM6IFRleHR1cmUgYWxyZWFkeSBpbml0aWFsaXplZC4nICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMubmVlZHNNaXBtYXBzID09PSB1bmRlZmluZWQgKSBvcHRpb25zLm5lZWRzTWlwbWFwcyA9IGZhbHNlO1xuXHRcdGlmICggb3B0aW9ucy5sZXZlbHMgPT09IHVuZGVmaW5lZCApIG9wdGlvbnMubGV2ZWxzID0gMTtcblx0XHRpZiAoIG9wdGlvbnMuZGVwdGggPT09IHVuZGVmaW5lZCApIG9wdGlvbnMuZGVwdGggPSAxO1xuXG5cdFx0Y29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgbGV2ZWxzIH0gPSBvcHRpb25zO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmlzRnJhbWVidWZmZXJUZXh0dXJlICkge1xuXG5cdFx0XHRpZiAoIG9wdGlvbnMucmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZm9ybWF0ID0gdGhpcy5iYWNrZW5kLnV0aWxzLmdldEN1cnJlbnRDb2xvckZvcm1hdCggb3B0aW9ucy5yZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvcHRpb25zLmZvcm1hdCA9IHRoaXMuYmFja2VuZC51dGlscy5nZXRQcmVmZXJyZWRDYW52YXNGb3JtYXQoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCB0ZXh0dXJlICk7XG5cdFx0Y29uc3QgZm9ybWF0ID0gdGV4dHVyZS5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBnZXRGb3JtYXQoIHRleHR1cmUsIGJhY2tlbmQuZGV2aWNlICk7XG5cblx0XHR0ZXh0dXJlRGF0YS5mb3JtYXQgPSBmb3JtYXQ7XG5cblx0XHRsZXQgc2FtcGxlQ291bnQgPSBvcHRpb25zLnNhbXBsZUNvdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNhbXBsZUNvdW50IDogMTtcblxuXHRcdHNhbXBsZUNvdW50ID0gYmFja2VuZC51dGlscy5nZXRTYW1wbGVDb3VudCggc2FtcGxlQ291bnQgKTtcblxuXHRcdGNvbnN0IHByaW1hcnlTYW1wbGVDb3VudCA9IHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlICYmICEgdGV4dHVyZS5pc011bHRpc2FtcGxlUmVuZGVyVGFyZ2V0VGV4dHVyZSA/IDEgOiBzYW1wbGVDb3VudDtcblxuXHRcdGxldCB1c2FnZSA9IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1QgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9TUkM7XG5cblx0XHRpZiAoIHRleHR1cmUuaXNTdG9yYWdlVGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dXNhZ2UgfD0gR1BVVGV4dHVyZVVzYWdlLlNUT1JBR0VfQklORElORztcblxuXHRcdH1cblxuXHRcdGlmICggdGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlICE9PSB0cnVlICYmIHRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlICE9PSB0cnVlICkge1xuXG5cdFx0XHR1c2FnZSB8PSBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQ7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0ZXh0dXJlRGVzY3JpcHRvckdQVSA9IHtcblx0XHRcdGxhYmVsOiB0ZXh0dXJlLm5hbWUsXG5cdFx0XHRzaXplOiB7XG5cdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRcdGRlcHRoT3JBcnJheUxheWVyczogZGVwdGgsXG5cdFx0XHR9LFxuXHRcdFx0bWlwTGV2ZWxDb3VudDogbGV2ZWxzLFxuXHRcdFx0c2FtcGxlQ291bnQ6IHByaW1hcnlTYW1wbGVDb3VudCxcblx0XHRcdGRpbWVuc2lvbjogZGltZW5zaW9uLFxuXHRcdFx0Zm9ybWF0OiBmb3JtYXQsXG5cdFx0XHR1c2FnZTogdXNhZ2Vcblx0XHR9O1xuXG5cdFx0Ly8gdGV4dHVyZSBjcmVhdGlvblxuXG5cdFx0aWYgKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICkge1xuXG5cdFx0XHRjb25zdCB2aWRlbyA9IHRleHR1cmUuc291cmNlLmRhdGE7XG5cdFx0XHRjb25zdCB2aWRlb0ZyYW1lID0gbmV3IFZpZGVvRnJhbWUoIHZpZGVvICk7XG5cblx0XHRcdHRleHR1cmVEZXNjcmlwdG9yR1BVLnNpemUud2lkdGggPSB2aWRlb0ZyYW1lLmRpc3BsYXlXaWR0aDtcblx0XHRcdHRleHR1cmVEZXNjcmlwdG9yR1BVLnNpemUuaGVpZ2h0ID0gdmlkZW9GcmFtZS5kaXNwbGF5SGVpZ2h0O1xuXG5cdFx0XHR2aWRlb0ZyYW1lLmNsb3NlKCk7XG5cblx0XHRcdHRleHR1cmVEYXRhLmV4dGVybmFsVGV4dHVyZSA9IHZpZGVvO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBmb3JtYXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdXZWJHUFVSZW5kZXJlcjogVGV4dHVyZSBmb3JtYXQgbm90IHN1cHBvcnRlZC4nICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRGVmYXVsdFRleHR1cmUoIHRleHR1cmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0ZXh0dXJlRGF0YS50ZXh0dXJlID0gYmFja2VuZC5kZXZpY2UuY3JlYXRlVGV4dHVyZSggdGV4dHVyZURlc2NyaXB0b3JHUFUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgJiYgc2FtcGxlQ291bnQgPiAxICYmICEgdGV4dHVyZS5pc011bHRpc2FtcGxlUmVuZGVyVGFyZ2V0VGV4dHVyZSApIHtcblxuXHRcdFx0Y29uc3QgbXNhYVRleHR1cmVEZXNjcmlwdG9yR1BVID0gT2JqZWN0LmFzc2lnbigge30sIHRleHR1cmVEZXNjcmlwdG9yR1BVICk7XG5cblx0XHRcdG1zYWFUZXh0dXJlRGVzY3JpcHRvckdQVS5sYWJlbCA9IG1zYWFUZXh0dXJlRGVzY3JpcHRvckdQVS5sYWJlbCArICctbXNhYSc7XG5cdFx0XHRtc2FhVGV4dHVyZURlc2NyaXB0b3JHUFUuc2FtcGxlQ291bnQgPSBzYW1wbGVDb3VudDtcblxuXHRcdFx0dGV4dHVyZURhdGEubXNhYVRleHR1cmUgPSBiYWNrZW5kLmRldmljZS5jcmVhdGVUZXh0dXJlKCBtc2FhVGV4dHVyZURlc2NyaXB0b3JHUFUgKTtcblxuXHRcdH1cblxuXHRcdHRleHR1cmVEYXRhLmluaXRpYWxpemVkID0gdHJ1ZTtcblxuXHRcdHRleHR1cmVEYXRhLnRleHR1cmVEZXNjcmlwdG9yR1BVID0gdGV4dHVyZURlc2NyaXB0b3JHUFU7XG5cblx0fVxuXG5cdGRlc3Ryb3lUZXh0dXJlKCB0ZXh0dXJlICkge1xuXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcblx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IGJhY2tlbmQuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRpZiAoIHRleHR1cmVEYXRhLnRleHR1cmUgIT09IHVuZGVmaW5lZCApIHRleHR1cmVEYXRhLnRleHR1cmUuZGVzdHJveSgpO1xuXG5cdFx0aWYgKCB0ZXh0dXJlRGF0YS5tc2FhVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZURhdGEubXNhYVRleHR1cmUuZGVzdHJveSgpO1xuXG5cdFx0YmFja2VuZC5kZWxldGUoIHRleHR1cmUgKTtcblxuXHR9XG5cblx0ZGVzdHJveVNhbXBsZXIoIHRleHR1cmUgKSB7XG5cblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXHRcdGNvbnN0IHRleHR1cmVEYXRhID0gYmFja2VuZC5nZXQoIHRleHR1cmUgKTtcblxuXHRcdGRlbGV0ZSB0ZXh0dXJlRGF0YS5zYW1wbGVyO1xuXG5cdH1cblxuXHRnZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IHRoaXMuYmFja2VuZC5nZXQoIHRleHR1cmUgKTtcblxuXHRcdGlmICggdGV4dHVyZS5pc0N1YmVUZXh0dXJlICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuX2dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZURhdGEudGV4dHVyZSwgdGV4dHVyZURhdGEudGV4dHVyZURlc2NyaXB0b3JHUFUsIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgZGVwdGggPSB0ZXh0dXJlLmltYWdlLmRlcHRoIHx8IDE7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRlcHRoOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuX2dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZURhdGEudGV4dHVyZSwgdGV4dHVyZURhdGEudGV4dHVyZURlc2NyaXB0b3JHUFUsIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRnZXRDb2xvckJ1ZmZlcigpIHtcblxuXHRcdGlmICggdGhpcy5jb2xvckJ1ZmZlciApIHRoaXMuY29sb3JCdWZmZXIuZGVzdHJveSgpO1xuXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcblx0XHRjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGJhY2tlbmQuZ2V0RHJhd2luZ0J1ZmZlclNpemUoKTtcblxuXHRcdHRoaXMuY29sb3JCdWZmZXIgPSBiYWNrZW5kLmRldmljZS5jcmVhdGVUZXh0dXJlKCB7XG5cdFx0XHRsYWJlbDogJ2NvbG9yQnVmZmVyJyxcblx0XHRcdHNpemU6IHtcblx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdFx0ZGVwdGhPckFycmF5TGF5ZXJzOiAxXG5cdFx0XHR9LFxuXHRcdFx0c2FtcGxlQ291bnQ6IGJhY2tlbmQudXRpbHMuZ2V0U2FtcGxlQ291bnQoIGJhY2tlbmQucmVuZGVyZXIuc2FtcGxlcyApLFxuXHRcdFx0Zm9ybWF0OiBiYWNrZW5kLnV0aWxzLmdldFByZWZlcnJlZENhbnZhc0Zvcm1hdCgpLFxuXHRcdFx0dXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQ1xuXHRcdH0gKTtcblxuXHRcdHJldHVybiB0aGlzLmNvbG9yQnVmZmVyO1xuXG5cdH1cblxuXHRnZXREZXB0aEJ1ZmZlciggZGVwdGggPSB0cnVlLCBzdGVuY2lsID0gZmFsc2UgKSB7XG5cblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYmFja2VuZC5nZXREcmF3aW5nQnVmZmVyU2l6ZSgpO1xuXG5cdFx0Y29uc3QgZGVwdGhUZXh0dXJlID0gdGhpcy5kZXB0aFRleHR1cmU7XG5cdFx0Y29uc3QgZGVwdGhUZXh0dXJlR1BVID0gYmFja2VuZC5nZXQoIGRlcHRoVGV4dHVyZSApLnRleHR1cmU7XG5cblx0XHRsZXQgZm9ybWF0LCB0eXBlO1xuXG5cdFx0aWYgKCBzdGVuY2lsICkge1xuXG5cdFx0XHRmb3JtYXQgPSBEZXB0aFN0ZW5jaWxGb3JtYXQ7XG5cdFx0XHR0eXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xuXG5cdFx0fSBlbHNlIGlmICggZGVwdGggKSB7XG5cblx0XHRcdGZvcm1hdCA9IERlcHRoRm9ybWF0O1xuXHRcdFx0dHlwZSA9IFVuc2lnbmVkSW50VHlwZTtcblxuXHRcdH1cblxuXHRcdGlmICggZGVwdGhUZXh0dXJlR1BVICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoID09PSB3aWR0aCAmJiBkZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0ID09PSBoZWlnaHQgJiYgZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gZm9ybWF0ICYmIGRlcHRoVGV4dHVyZS50eXBlID09PSB0eXBlICkge1xuXG5cdFx0XHRcdHJldHVybiBkZXB0aFRleHR1cmVHUFU7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5kZXN0cm95VGV4dHVyZSggZGVwdGhUZXh0dXJlICk7XG5cblx0XHR9XG5cblx0XHRkZXB0aFRleHR1cmUubmFtZSA9ICdkZXB0aEJ1ZmZlcic7XG5cdFx0ZGVwdGhUZXh0dXJlLmZvcm1hdCA9IGZvcm1hdDtcblx0XHRkZXB0aFRleHR1cmUudHlwZSA9IHR5cGU7XG5cdFx0ZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoID0gd2lkdGg7XG5cdFx0ZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdHRoaXMuY3JlYXRlVGV4dHVyZSggZGVwdGhUZXh0dXJlLCB7IHNhbXBsZUNvdW50OiBiYWNrZW5kLnV0aWxzLmdldFNhbXBsZUNvdW50KCBiYWNrZW5kLnJlbmRlcmVyLnNhbXBsZXMgKSwgd2lkdGgsIGhlaWdodCB9ICk7XG5cblx0XHRyZXR1cm4gYmFja2VuZC5nZXQoIGRlcHRoVGV4dHVyZSApLnRleHR1cmU7XG5cblx0fVxuXG5cdHVwZGF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IHRoaXMuYmFja2VuZC5nZXQoIHRleHR1cmUgKTtcblxuXHRcdGNvbnN0IHsgdGV4dHVyZURlc2NyaXB0b3JHUFUgfSA9IHRleHR1cmVEYXRhO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSB8fCAoIHRleHR1cmVEZXNjcmlwdG9yR1BVID09PSB1bmRlZmluZWQgLyogdW5zdXBwb3J0ZWQgdGV4dHVyZSBmb3JtYXQgKi8gKSApXG5cdFx0XHRyZXR1cm47XG5cblx0XHQvLyB0cmFuc2ZlciB0ZXh0dXJlIGRhdGFcblxuXHRcdGlmICggdGV4dHVyZS5pc0RhdGFUZXh0dXJlICkge1xuXG5cdFx0XHR0aGlzLl9jb3B5QnVmZmVyVG9UZXh0dXJlKCBvcHRpb25zLmltYWdlLCB0ZXh0dXJlRGF0YS50ZXh0dXJlLCB0ZXh0dXJlRGVzY3JpcHRvckdQVSwgMCwgdGV4dHVyZS5mbGlwWSApO1xuXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUgfHwgdGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG9wdGlvbnMuaW1hZ2UuZGVwdGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5fY29weUJ1ZmZlclRvVGV4dHVyZSggb3B0aW9ucy5pbWFnZSwgdGV4dHVyZURhdGEudGV4dHVyZSwgdGV4dHVyZURlc2NyaXB0b3JHUFUsIGksIHRleHR1cmUuZmxpcFksIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlIHx8IHRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlICkge1xuXG5cdFx0XHR0aGlzLl9jb3B5Q29tcHJlc3NlZEJ1ZmZlclRvVGV4dHVyZSggdGV4dHVyZS5taXBtYXBzLCB0ZXh0dXJlRGF0YS50ZXh0dXJlLCB0ZXh0dXJlRGVzY3JpcHRvckdQVSApO1xuXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0N1YmVUZXh0dXJlICkge1xuXG5cdFx0XHR0aGlzLl9jb3B5Q3ViZU1hcFRvVGV4dHVyZSggb3B0aW9ucy5pbWFnZXMsIHRleHR1cmVEYXRhLnRleHR1cmUsIHRleHR1cmVEZXNjcmlwdG9yR1BVLCB0ZXh0dXJlLmZsaXBZICk7XG5cblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICkge1xuXG5cdFx0XHRjb25zdCB2aWRlbyA9IHRleHR1cmUuc291cmNlLmRhdGE7XG5cblx0XHRcdHRleHR1cmVEYXRhLmV4dGVybmFsVGV4dHVyZSA9IHZpZGVvO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5fY29weUltYWdlVG9UZXh0dXJlKCBvcHRpb25zLmltYWdlLCB0ZXh0dXJlRGF0YS50ZXh0dXJlLCB0ZXh0dXJlRGVzY3JpcHRvckdQVSwgMCwgdGV4dHVyZS5mbGlwWSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHRleHR1cmVEYXRhLnZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cblx0XHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XG5cblx0fVxuXG5cdGFzeW5jIGNvcHlUZXh0dXJlVG9CdWZmZXIoIHRleHR1cmUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZhY2VJbmRleCApIHtcblxuXHRcdGNvbnN0IGRldmljZSA9IHRoaXMuYmFja2VuZC5kZXZpY2U7XG5cblx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IHRoaXMuYmFja2VuZC5nZXQoIHRleHR1cmUgKTtcblx0XHRjb25zdCB0ZXh0dXJlR1BVID0gdGV4dHVyZURhdGEudGV4dHVyZTtcblx0XHRjb25zdCBmb3JtYXQgPSB0ZXh0dXJlRGF0YS50ZXh0dXJlRGVzY3JpcHRvckdQVS5mb3JtYXQ7XG5cdFx0Y29uc3QgYnl0ZXNQZXJUZXhlbCA9IHRoaXMuX2dldEJ5dGVzUGVyVGV4ZWwoIGZvcm1hdCApO1xuXG5cdFx0bGV0IGJ5dGVzUGVyUm93ID0gd2lkdGggKiBieXRlc1BlclRleGVsO1xuXHRcdGJ5dGVzUGVyUm93ID0gTWF0aC5jZWlsKCBieXRlc1BlclJvdyAvIDI1NiApICogMjU2OyAvLyBBbGlnbiB0byAyNTYgYnl0ZXNcblxuXHRcdGNvbnN0IHJlYWRCdWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKFxuXHRcdFx0e1xuXHRcdFx0XHRzaXplOiB3aWR0aCAqIGhlaWdodCAqIGJ5dGVzUGVyVGV4ZWwsXG5cdFx0XHRcdHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGNvbnN0IGVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcblxuXHRcdGVuY29kZXIuY29weVRleHR1cmVUb0J1ZmZlcihcblx0XHRcdHtcblx0XHRcdFx0dGV4dHVyZTogdGV4dHVyZUdQVSxcblx0XHRcdFx0b3JpZ2luOiB7IHgsIHksIHo6IGZhY2VJbmRleCB9LFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0YnVmZmVyOiByZWFkQnVmZmVyLFxuXHRcdFx0XHRieXRlc1BlclJvdzogYnl0ZXNQZXJSb3dcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBoZWlnaHRcblx0XHRcdH1cblxuXHRcdCk7XG5cblx0XHRjb25zdCB0eXBlZEFycmF5VHlwZSA9IHRoaXMuX2dldFR5cGVkQXJyYXlUeXBlKCBmb3JtYXQgKTtcblxuXHRcdGRldmljZS5xdWV1ZS5zdWJtaXQoIFsgZW5jb2Rlci5maW5pc2goKSBdICk7XG5cblx0XHRhd2FpdCByZWFkQnVmZmVyLm1hcEFzeW5jKCBHUFVNYXBNb2RlLlJFQUQgKTtcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IHJlYWRCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKTtcblxuXHRcdHJldHVybiBuZXcgdHlwZWRBcnJheVR5cGUoIGJ1ZmZlciApO1xuXG5cdH1cblxuXHRfaXNFbnZpcm9ubWVudFRleHR1cmUoIHRleHR1cmUgKSB7XG5cblx0XHRjb25zdCBtYXBwaW5nID0gdGV4dHVyZS5tYXBwaW5nO1xuXG5cdFx0cmV0dXJuICggbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgKSB8fCAoIG1hcHBpbmcgPT09IEN1YmVSZWZsZWN0aW9uTWFwcGluZyB8fCBtYXBwaW5nID09PSBDdWJlUmVmcmFjdGlvbk1hcHBpbmcgKTtcblxuXHR9XG5cblx0X2dldERlZmF1bHRUZXh0dXJlR1BVKCBmb3JtYXQgKSB7XG5cblx0XHRsZXQgZGVmYXVsdFRleHR1cmUgPSB0aGlzLmRlZmF1bHRUZXh0dXJlWyBmb3JtYXQgXTtcblxuXHRcdGlmICggZGVmYXVsdFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG5cdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cblx0XHRcdHRoaXMuY3JlYXRlVGV4dHVyZSggdGV4dHVyZSwgeyB3aWR0aDogMSwgaGVpZ2h0OiAxLCBmb3JtYXQgfSApO1xuXG5cdFx0XHR0aGlzLmRlZmF1bHRUZXh0dXJlWyBmb3JtYXQgXSA9IGRlZmF1bHRUZXh0dXJlID0gdGV4dHVyZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmJhY2tlbmQuZ2V0KCBkZWZhdWx0VGV4dHVyZSApLnRleHR1cmU7XG5cblx0fVxuXG5cdF9nZXREZWZhdWx0Q3ViZVRleHR1cmVHUFUoIGZvcm1hdCApIHtcblxuXHRcdGxldCBkZWZhdWx0Q3ViZVRleHR1cmUgPSB0aGlzLmRlZmF1bHRUZXh0dXJlWyBmb3JtYXQgXTtcblxuXHRcdGlmICggZGVmYXVsdEN1YmVUZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcblx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblxuXHRcdFx0dGhpcy5jcmVhdGVUZXh0dXJlKCB0ZXh0dXJlLCB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEsIGRlcHRoOiA2IH0gKTtcblxuXHRcdFx0dGhpcy5kZWZhdWx0Q3ViZVRleHR1cmVbIGZvcm1hdCBdID0gZGVmYXVsdEN1YmVUZXh0dXJlID0gdGV4dHVyZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmJhY2tlbmQuZ2V0KCBkZWZhdWx0Q3ViZVRleHR1cmUgKS50ZXh0dXJlO1xuXG5cdH1cblxuXHRfZ2V0RGVmYXVsdFZpZGVvRnJhbWUoKSB7XG5cblx0XHRsZXQgZGVmYXVsdFZpZGVvRnJhbWUgPSB0aGlzLmRlZmF1bHRWaWRlb0ZyYW1lO1xuXG5cdFx0aWYgKCBkZWZhdWx0VmlkZW9GcmFtZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgaW5pdCA9IHtcblx0XHRcdFx0dGltZXN0YW1wOiAwLFxuXHRcdFx0XHRjb2RlZFdpZHRoOiAxLFxuXHRcdFx0XHRjb2RlZEhlaWdodDogMSxcblx0XHRcdFx0Zm9ybWF0OiAnUkdCQScsXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmRlZmF1bHRWaWRlb0ZyYW1lID0gZGVmYXVsdFZpZGVvRnJhbWUgPSBuZXcgVmlkZW9GcmFtZSggbmV3IFVpbnQ4QXJyYXkoIFsgMCwgMCwgMCwgMHhmZiBdICksIGluaXQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkZWZhdWx0VmlkZW9GcmFtZTtcblxuXHR9XG5cblx0X2NvcHlDdWJlTWFwVG9UZXh0dXJlKCBpbWFnZXMsIHRleHR1cmVHUFUsIHRleHR1cmVEZXNjcmlwdG9yR1BVLCBmbGlwWSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGltYWdlID0gaW1hZ2VzWyBpIF07XG5cblx0XHRcdGNvbnN0IGZsaXBJbmRleCA9IGZsaXBZID09PSB0cnVlID8gX2ZsaXBNYXBbIGkgXSA6IGk7XG5cblx0XHRcdGlmICggaW1hZ2UuaXNEYXRhVGV4dHVyZSApIHtcblxuXHRcdFx0XHR0aGlzLl9jb3B5QnVmZmVyVG9UZXh0dXJlKCBpbWFnZS5pbWFnZSwgdGV4dHVyZUdQVSwgdGV4dHVyZURlc2NyaXB0b3JHUFUsIGZsaXBJbmRleCwgZmxpcFkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl9jb3B5SW1hZ2VUb1RleHR1cmUoIGltYWdlLCB0ZXh0dXJlR1BVLCB0ZXh0dXJlRGVzY3JpcHRvckdQVSwgZmxpcEluZGV4LCBmbGlwWSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdF9jb3B5SW1hZ2VUb1RleHR1cmUoIGltYWdlLCB0ZXh0dXJlR1BVLCB0ZXh0dXJlRGVzY3JpcHRvckdQVSwgb3JpZ2luRGVwdGgsIGZsaXBZICkge1xuXG5cdFx0Y29uc3QgZGV2aWNlID0gdGhpcy5iYWNrZW5kLmRldmljZTtcblxuXHRcdGRldmljZS5xdWV1ZS5jb3B5RXh0ZXJuYWxJbWFnZVRvVGV4dHVyZShcblx0XHRcdHtcblx0XHRcdFx0c291cmNlOiBpbWFnZVxuXHRcdFx0fSwge1xuXHRcdFx0XHR0ZXh0dXJlOiB0ZXh0dXJlR1BVLFxuXHRcdFx0XHRtaXBMZXZlbDogMCxcblx0XHRcdFx0b3JpZ2luOiB7IHg6IDAsIHk6IDAsIHo6IG9yaWdpbkRlcHRoIH1cblx0XHRcdH0sIHtcblx0XHRcdFx0d2lkdGg6IGltYWdlLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGltYWdlLmhlaWdodCxcblx0XHRcdFx0ZGVwdGhPckFycmF5TGF5ZXJzOiAxXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGlmICggZmxpcFkgPT09IHRydWUgKSB7XG5cblx0XHRcdHRoaXMuX2ZsaXBZKCB0ZXh0dXJlR1BVLCB0ZXh0dXJlRGVzY3JpcHRvckdQVSwgb3JpZ2luRGVwdGggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0X2dldFBhc3NVdGlscygpIHtcblxuXHRcdGxldCBwYXNzVXRpbHMgPSB0aGlzLl9wYXNzVXRpbHM7XG5cblx0XHRpZiAoIHBhc3NVdGlscyA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fcGFzc1V0aWxzID0gcGFzc1V0aWxzID0gbmV3IFdlYkdQVVRleHR1cmVQYXNzVXRpbHMoIHRoaXMuYmFja2VuZC5kZXZpY2UgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwYXNzVXRpbHM7XG5cblx0fVxuXG5cdF9nZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmVHUFUsIHRleHR1cmVEZXNjcmlwdG9yR1BVLCBiYXNlQXJyYXlMYXllciA9IDAgKSB7XG5cblx0XHR0aGlzLl9nZXRQYXNzVXRpbHMoKS5nZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmVHUFUsIHRleHR1cmVEZXNjcmlwdG9yR1BVLCBiYXNlQXJyYXlMYXllciApO1xuXG5cdH1cblxuXHRfZmxpcFkoIHRleHR1cmVHUFUsIHRleHR1cmVEZXNjcmlwdG9yR1BVLCBvcmlnaW5EZXB0aCA9IDAgKSB7XG5cblx0XHR0aGlzLl9nZXRQYXNzVXRpbHMoKS5mbGlwWSggdGV4dHVyZUdQVSwgdGV4dHVyZURlc2NyaXB0b3JHUFUsIG9yaWdpbkRlcHRoICk7XG5cblx0fVxuXG5cdF9jb3B5QnVmZmVyVG9UZXh0dXJlKCBpbWFnZSwgdGV4dHVyZUdQVSwgdGV4dHVyZURlc2NyaXB0b3JHUFUsIG9yaWdpbkRlcHRoLCBmbGlwWSwgZGVwdGggPSAwICkge1xuXG5cdFx0Ly8gQFRPRE86IENvbnNpZGVyIHRvIHVzZSBHUFVDb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9UZXh0dXJlKClcblx0XHQvLyBAVE9ETzogQ29uc2lkZXIgdG8gc3VwcG9ydCB2YWxpZCBidWZmZXIgbGF5b3V0cyB3aXRoIG90aGVyIGZvcm1hdHMgbGlrZSBSR0JcblxuXHRcdGNvbnN0IGRldmljZSA9IHRoaXMuYmFja2VuZC5kZXZpY2U7XG5cblx0XHRjb25zdCBkYXRhID0gaW1hZ2UuZGF0YTtcblxuXHRcdGNvbnN0IGJ5dGVzUGVyVGV4ZWwgPSB0aGlzLl9nZXRCeXRlc1BlclRleGVsKCB0ZXh0dXJlRGVzY3JpcHRvckdQVS5mb3JtYXQgKTtcblx0XHRjb25zdCBieXRlc1BlclJvdyA9IGltYWdlLndpZHRoICogYnl0ZXNQZXJUZXhlbDtcblxuXHRcdGRldmljZS5xdWV1ZS53cml0ZVRleHR1cmUoXG5cdFx0XHR7XG5cdFx0XHRcdHRleHR1cmU6IHRleHR1cmVHUFUsXG5cdFx0XHRcdG1pcExldmVsOiAwLFxuXHRcdFx0XHRvcmlnaW46IHsgeDogMCwgeTogMCwgejogb3JpZ2luRGVwdGggfVxuXHRcdFx0fSxcblx0XHRcdGRhdGEsXG5cdFx0XHR7XG5cdFx0XHRcdG9mZnNldDogaW1hZ2Uud2lkdGggKiBpbWFnZS5oZWlnaHQgKiBieXRlc1BlclRleGVsICogZGVwdGgsXG5cdFx0XHRcdGJ5dGVzUGVyUm93XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHR3aWR0aDogaW1hZ2Uud2lkdGgsXG5cdFx0XHRcdGhlaWdodDogaW1hZ2UuaGVpZ2h0LFxuXHRcdFx0XHRkZXB0aE9yQXJyYXlMYXllcnM6IDFcblx0XHRcdH0gKTtcblxuXHRcdGlmICggZmxpcFkgPT09IHRydWUgKSB7XG5cblx0XHRcdHRoaXMuX2ZsaXBZKCB0ZXh0dXJlR1BVLCB0ZXh0dXJlRGVzY3JpcHRvckdQVSwgb3JpZ2luRGVwdGggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0X2NvcHlDb21wcmVzc2VkQnVmZmVyVG9UZXh0dXJlKCBtaXBtYXBzLCB0ZXh0dXJlR1BVLCB0ZXh0dXJlRGVzY3JpcHRvckdQVSApIHtcblxuXHRcdC8vIEBUT0RPOiBDb25zaWRlciB0byB1c2UgR1BVQ29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvVGV4dHVyZSgpXG5cblx0XHRjb25zdCBkZXZpY2UgPSB0aGlzLmJhY2tlbmQuZGV2aWNlO1xuXG5cdFx0Y29uc3QgYmxvY2tEYXRhID0gdGhpcy5fZ2V0QmxvY2tEYXRhKCB0ZXh0dXJlRGVzY3JpcHRvckdQVS5mb3JtYXQgKTtcblx0XHRjb25zdCBpc1RleHR1cmVBcnJheSA9IHRleHR1cmVEZXNjcmlwdG9yR1BVLnNpemUuZGVwdGhPckFycmF5TGF5ZXJzID4gMTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG1pcG1hcHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cblx0XHRcdGNvbnN0IHdpZHRoID0gbWlwbWFwLndpZHRoO1xuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gbWlwbWFwLmhlaWdodDtcblx0XHRcdGNvbnN0IGRlcHRoID0gaXNUZXh0dXJlQXJyYXkgPyB0ZXh0dXJlRGVzY3JpcHRvckdQVS5zaXplLmRlcHRoT3JBcnJheUxheWVycyA6IDE7XG5cblx0XHRcdGNvbnN0IGJ5dGVzUGVyUm93ID0gTWF0aC5jZWlsKCB3aWR0aCAvIGJsb2NrRGF0YS53aWR0aCApICogYmxvY2tEYXRhLmJ5dGVMZW5ndGg7XG5cdFx0XHRjb25zdCBieXRlc1BlckltYWdlID0gYnl0ZXNQZXJSb3cgKiBNYXRoLmNlaWwoIGhlaWdodCAvIGJsb2NrRGF0YS5oZWlnaHQgKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgZGVwdGg7IGogKysgKSB7XG5cblx0XHRcdFx0ZGV2aWNlLnF1ZXVlLndyaXRlVGV4dHVyZShcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlOiB0ZXh0dXJlR1BVLFxuXHRcdFx0XHRcdFx0bWlwTGV2ZWw6IGksXG5cdFx0XHRcdFx0XHRvcmlnaW46IHsgeDogMCwgeTogMCwgejogaiB9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRtaXBtYXAuZGF0YSxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRvZmZzZXQ6IGogKiBieXRlc1BlckltYWdlLFxuXHRcdFx0XHRcdFx0Ynl0ZXNQZXJSb3csXG5cdFx0XHRcdFx0XHRyb3dzUGVySW1hZ2U6IE1hdGguY2VpbCggaGVpZ2h0IC8gYmxvY2tEYXRhLmhlaWdodCApXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR3aWR0aDogTWF0aC5jZWlsKCB3aWR0aCAvIGJsb2NrRGF0YS53aWR0aCApICogYmxvY2tEYXRhLndpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBNYXRoLmNlaWwoIGhlaWdodCAvIGJsb2NrRGF0YS5oZWlnaHQgKSAqIGJsb2NrRGF0YS5oZWlnaHQsXG5cdFx0XHRcdFx0XHRkZXB0aE9yQXJyYXlMYXllcnM6IDFcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0X2dldEJsb2NrRGF0YSggZm9ybWF0ICkge1xuXG5cdFx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSByZWxldmFudCBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcblxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkJDMVJHQkFVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkMxUkdCQVVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDgsIHdpZHRoOiA0LCBoZWlnaHQ6IDQgfTsgLy8gRFhUMVxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkJDMlJHQkFVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkMyUkdCQVVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07IC8vIERYVDNcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5CQzNSR0JBVW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkJDM1JHQkFVbm9ybVNSR0IgKSByZXR1cm4geyBieXRlTGVuZ3RoOiAxNiwgd2lkdGg6IDQsIGhlaWdodDogNCB9OyAvLyBEWFQ1XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkM0UlVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5CQzRSU05vcm0gKSByZXR1cm4geyBieXRlTGVuZ3RoOiA4LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07IC8vIFJHVEMxXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkM1UkdVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkM1UkdTbm9ybSApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07IC8vIFJHVEMyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkM2SFJHQlVGbG9hdCB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkM2SFJHQkZsb2F0ICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiA0LCBoZWlnaHQ6IDQgfTsgLy8gQlBUQyAoZmxvYXQpXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkM3UkdCQVVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5CQzdSR0JBVW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiA0LCBoZWlnaHQ6IDQgfTsgLy8gQlBUQyAodW5vcm0pXG5cblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5FVEMyUkdCOFVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5FVEMyUkdCOFVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDgsIHdpZHRoOiA0LCBoZWlnaHQ6IDQgfTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5FVEMyUkdCOEExVW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkVUQzJSR0I4QTFVbm9ybVNSR0IgKSByZXR1cm4geyBieXRlTGVuZ3RoOiA4LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuRVRDMlJHQkE4VW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkVUQzJSR0JBOFVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuRUFDUjExVW5vcm0gKSByZXR1cm4geyBieXRlTGVuZ3RoOiA4LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuRUFDUjExU25vcm0gKSByZXR1cm4geyBieXRlTGVuZ3RoOiA4LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuRUFDUkcxMVVub3JtICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiA0LCBoZWlnaHQ6IDQgfTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5FQUNSRzExU25vcm0gKSByZXR1cm4geyBieXRlTGVuZ3RoOiAxNiwgd2lkdGg6IDQsIGhlaWdodDogNCB9O1xuXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzR4NFVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDNHg0VW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiA0LCBoZWlnaHQ6IDQgfTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDNXg0VW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEM1eDRVbm9ybVNSR0IgKSByZXR1cm4geyBieXRlTGVuZ3RoOiAxNiwgd2lkdGg6IDUsIGhlaWdodDogNCB9O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEM1eDVVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzV4NVVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogNSwgaGVpZ2h0OiA1IH07XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzZ4NVVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDNng1VW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiA2LCBoZWlnaHQ6IDUgfTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDNng2VW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEM2eDZVbm9ybVNSR0IgKSByZXR1cm4geyBieXRlTGVuZ3RoOiAxNiwgd2lkdGg6IDYsIGhlaWdodDogNiB9O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEM4eDVVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzh4NVVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogOCwgaGVpZ2h0OiA1IH07XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzh4NlVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDOHg2VW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiA4LCBoZWlnaHQ6IDYgfTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDOHg4VW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEM4eDhVbm9ybVNSR0IgKSByZXR1cm4geyBieXRlTGVuZ3RoOiAxNiwgd2lkdGg6IDgsIGhlaWdodDogOCB9O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMHg1VW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMHg1VW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiAxMCwgaGVpZ2h0OiA1IH07XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEweDZVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEweDZVbm9ybVNSR0IgKSByZXR1cm4geyBieXRlTGVuZ3RoOiAxNiwgd2lkdGg6IDEwLCBoZWlnaHQ6IDYgfTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTB4OFVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTB4OFVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogMTAsIGhlaWdodDogOCB9O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMHgxMFVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTB4MTBVbm9ybVNSR0IgKSByZXR1cm4geyBieXRlTGVuZ3RoOiAxNiwgd2lkdGg6IDEwLCBoZWlnaHQ6IDEwIH07XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEyeDEwVW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMngxMFVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogMTIsIGhlaWdodDogMTAgfTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTJ4MTJVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEyeDEyVW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiAxMiwgaGVpZ2h0OiAxMiB9O1xuXG5cdH1cblxuXHRfY29udmVydEFkZHJlc3NNb2RlKCB2YWx1ZSApIHtcblxuXHRcdGxldCBhZGRyZXNzTW9kZSA9IEdQVUFkZHJlc3NNb2RlLkNsYW1wVG9FZGdlO1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gUmVwZWF0V3JhcHBpbmcgKSB7XG5cblx0XHRcdGFkZHJlc3NNb2RlID0gR1BVQWRkcmVzc01vZGUuUmVwZWF0O1xuXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgKSB7XG5cblx0XHRcdGFkZHJlc3NNb2RlID0gR1BVQWRkcmVzc01vZGUuTWlycm9yUmVwZWF0O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFkZHJlc3NNb2RlO1xuXG5cdH1cblxuXHRfY29udmVydEZpbHRlck1vZGUoIHZhbHVlICkge1xuXG5cdFx0bGV0IGZpbHRlck1vZGUgPSBHUFVGaWx0ZXJNb2RlLkxpbmVhcjtcblxuXHRcdGlmICggdmFsdWUgPT09IE5lYXJlc3RGaWx0ZXIgfHwgdmFsdWUgPT09IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyIHx8IHZhbHVlID09PSBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyICkge1xuXG5cdFx0XHRmaWx0ZXJNb2RlID0gR1BVRmlsdGVyTW9kZS5OZWFyZXN0O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZpbHRlck1vZGU7XG5cblx0fVxuXG5cdF9nZXRCeXRlc1BlclRleGVsKCBmb3JtYXQgKSB7XG5cblx0XHQvLyA4LWJpdCBmb3JtYXRzXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUjhVbm9ybSB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlI4U25vcm0gfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SOFVpbnQgfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SOFNpbnQgKSByZXR1cm4gMTtcblxuXHRcdC8vIDE2LWJpdCBmb3JtYXRzXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUjE2VWludCB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlIxNlNpbnQgfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SMTZGbG9hdCB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHOFVub3JtIHx8XG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkc4U25vcm0gfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzhVaW50IHx8XG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkc4U2ludCApIHJldHVybiAyO1xuXG5cdFx0Ly8gMzItYml0IGZvcm1hdHNcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SMzJVaW50IHx8XG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUjMyU2ludCB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlIzMkZsb2F0IHx8XG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkcxNlVpbnQgfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzE2U2ludCB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHMTZGbG9hdCB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkE4VW5vcm0gfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBOFVub3JtU1JHQiB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkE4U25vcm0gfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBOFVpbnQgfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBOFNpbnQgfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5CR1JBOFVub3JtIHx8XG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkdSQThVbm9ybVNSR0IgfHxcblx0XHRcdC8vIFBhY2tlZCAzMi1iaXQgZm9ybWF0c1xuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQjlFNVVGbG9hdCB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQjEwQTJVbm9ybSB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHMTFCMTBVRmxvYXQgfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDMyRmxvYXQgfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDI0UGx1cyB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkRlcHRoMjRQbHVzU3RlbmNpbDggfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDMyRmxvYXRTdGVuY2lsOCApIHJldHVybiA0O1xuXG5cdFx0Ly8gNjQtYml0IGZvcm1hdHNcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzMyVWludCB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHMzJTaW50IHx8XG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkczMkZsb2F0IHx8XG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQTE2VWludCB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkExNlNpbnQgfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBMTZGbG9hdCApIHJldHVybiA4O1xuXG5cdFx0Ly8gMTI4LWJpdCBmb3JtYXRzXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQTMyVWludCB8fFxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkEzMlNpbnQgfHxcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBMzJGbG9hdCApIHJldHVybiAxNjtcblxuXG5cdH1cblxuXHRfZ2V0VHlwZWRBcnJheVR5cGUoIGZvcm1hdCApIHtcblxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlI4VWludCApIHJldHVybiBVaW50OEFycmF5O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlI4U2ludCApIHJldHVybiBJbnQ4QXJyYXk7XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUjhVbm9ybSApIHJldHVybiBVaW50OEFycmF5O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlI4U25vcm0gKSByZXR1cm4gSW50OEFycmF5O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHOFVpbnQgKSByZXR1cm4gVWludDhBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzhTaW50ICkgcmV0dXJuIEludDhBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzhVbm9ybSApIHJldHVybiBVaW50OEFycmF5O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHOFNub3JtICkgcmV0dXJuIEludDhBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBOFVpbnQgKSByZXR1cm4gVWludDhBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBOFNpbnQgKSByZXR1cm4gSW50OEFycmF5O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkE4VW5vcm0gKSByZXR1cm4gVWludDhBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBOFNub3JtICkgcmV0dXJuIEludDhBcnJheTtcblxuXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUjE2VWludCApIHJldHVybiBVaW50MTZBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SMTZTaW50ICkgcmV0dXJuIEludDE2QXJyYXk7XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkcxNlVpbnQgKSByZXR1cm4gVWludDE2QXJyYXk7XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkcxNlNpbnQgKSByZXR1cm4gSW50MTZBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBMTZVaW50ICkgcmV0dXJuIFVpbnQxNkFycmF5O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkExNlNpbnQgKSByZXR1cm4gSW50MTZBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SMTZGbG9hdCApIHJldHVybiBVaW50MTZBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzE2RmxvYXQgKSByZXR1cm4gVWludDE2QXJyYXk7XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQTE2RmxvYXQgKSByZXR1cm4gVWludDE2QXJyYXk7XG5cblxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlIzMlVpbnQgKSByZXR1cm4gVWludDMyQXJyYXk7XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUjMyU2ludCApIHJldHVybiBJbnQzMkFycmF5O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlIzMkZsb2F0ICkgcmV0dXJuIEZsb2F0MzJBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzMyVWludCApIHJldHVybiBVaW50MzJBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzMyU2ludCApIHJldHVybiBJbnQzMkFycmF5O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHMzJGbG9hdCApIHJldHVybiBGbG9hdDMyQXJyYXk7XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQTMyVWludCApIHJldHVybiBVaW50MzJBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBMzJTaW50ICkgcmV0dXJuIEludDMyQXJyYXk7XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQTMyRmxvYXQgKSByZXR1cm4gRmxvYXQzMkFycmF5O1xuXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkdSQThVbm9ybSApIHJldHVybiBVaW50OEFycmF5O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkJHUkE4VW5vcm1TUkdCICkgcmV0dXJuIFVpbnQ4QXJyYXk7XG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCMTBBMlVub3JtICkgcmV0dXJuIFVpbnQzMkFycmF5O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQjlFNVVGbG9hdCApIHJldHVybiBVaW50MzJBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzExQjEwVUZsb2F0ICkgcmV0dXJuIFVpbnQzMkFycmF5O1xuXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuRGVwdGgzMkZsb2F0ICkgcmV0dXJuIEZsb2F0MzJBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDI0UGx1cyApIHJldHVybiBVaW50MzJBcnJheTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDI0UGx1c1N0ZW5jaWw4ICkgcmV0dXJuIFVpbnQzMkFycmF5O1xuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkRlcHRoMzJGbG9hdFN0ZW5jaWw4ICkgcmV0dXJuIEZsb2F0MzJBcnJheTtcblxuXHR9XG5cblx0X2dldERpbWVuc2lvbiggdGV4dHVyZSApIHtcblxuXHRcdGxldCBkaW1lbnNpb247XG5cblx0XHRpZiAoIHRleHR1cmUuaXNEYXRhM0RUZXh0dXJlICkge1xuXG5cdFx0XHRkaW1lbnNpb24gPSBHUFVUZXh0dXJlRGltZW5zaW9uLlRocmVlRDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGRpbWVuc2lvbiA9IEdQVVRleHR1cmVEaW1lbnNpb24uVHdvRDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkaW1lbnNpb247XG5cblx0fVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3JtYXQoIHRleHR1cmUsIGRldmljZSA9IG51bGwgKSB7XG5cblx0Y29uc3QgZm9ybWF0ID0gdGV4dHVyZS5mb3JtYXQ7XG5cdGNvbnN0IHR5cGUgPSB0ZXh0dXJlLnR5cGU7XG5cdGNvbnN0IGNvbG9yU3BhY2UgPSB0ZXh0dXJlLmNvbG9yU3BhY2U7XG5cblx0bGV0IGZvcm1hdEdQVTtcblxuXHRpZiAoIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSA9PT0gdHJ1ZSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGZvcm1hdCApIHtcblxuXHRcdFx0Y2FzZSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQ6XG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQkMxUkdCQVVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQkMxUkdCQVVub3JtO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBSR0JBX1MzVENfRFhUM19Gb3JtYXQ6XG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQkMyUkdCQVVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQkMyUkdCQVVub3JtO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQ6XG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQkMzUkdCQVVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQkMzUkdCQVVub3JtO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBSR0JfRVRDMl9Gb3JtYXQ6XG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuRVRDMlJHQjhVbm9ybVNSR0IgOiBHUFVUZXh0dXJlRm9ybWF0LkVUQzJSR0I4VW5vcm07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFJHQkFfRVRDMl9FQUNfRm9ybWF0OlxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkVUQzJSR0JBOFVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuRVRDMlJHQkE4VW5vcm07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFJHQkFfQVNUQ180eDRfRm9ybWF0OlxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkFTVEM0eDRVbm9ybVNSR0IgOiBHUFVUZXh0dXJlRm9ybWF0LkFTVEM0eDRVbm9ybTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUkdCQV9BU1RDXzV4NF9Gb3JtYXQ6XG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQVNUQzV4NFVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQVNUQzV4NFVub3JtO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBSR0JBX0FTVENfNXg1X0Zvcm1hdDpcblx0XHRcdFx0Zm9ybWF0R1BVID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gR1BVVGV4dHVyZUZvcm1hdC5BU1RDNXg1VW5vcm1TUkdCIDogR1BVVGV4dHVyZUZvcm1hdC5BU1RDNXg1VW5vcm07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFJHQkFfQVNUQ182eDVfRm9ybWF0OlxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkFTVEM2eDVVbm9ybVNSR0IgOiBHUFVUZXh0dXJlRm9ybWF0LkFTVEM2eDVVbm9ybTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQ6XG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQVNUQzZ4NlVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQVNUQzZ4NlVub3JtO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBSR0JBX0FTVENfOHg1X0Zvcm1hdDpcblx0XHRcdFx0Zm9ybWF0R1BVID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gR1BVVGV4dHVyZUZvcm1hdC5BU1RDOHg1VW5vcm1TUkdCIDogR1BVVGV4dHVyZUZvcm1hdC5BU1RDOHg1VW5vcm07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFJHQkFfQVNUQ184eDZfRm9ybWF0OlxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkFTVEM4eDZVbm9ybVNSR0IgOiBHUFVUZXh0dXJlRm9ybWF0LkFTVEM4eDZVbm9ybTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUkdCQV9BU1RDXzh4OF9Gb3JtYXQ6XG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQVNUQzh4OFVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQVNUQzh4OFVub3JtO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBSR0JBX0FTVENfMTB4NV9Gb3JtYXQ6XG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEweDVVbm9ybVNSR0IgOiBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMHg1VW5vcm07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFJHQkFfQVNUQ18xMHg2X0Zvcm1hdDpcblx0XHRcdFx0Zm9ybWF0R1BVID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTB4NlVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEweDZVbm9ybTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUkdCQV9BU1RDXzEweDhfRm9ybWF0OlxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMHg4VW5vcm1TUkdCIDogR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTB4OFVub3JtO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBSR0JBX0FTVENfMTB4MTBfRm9ybWF0OlxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMHgxMFVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEweDEwVW5vcm07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQ6XG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEyeDEwVW5vcm1TUkdCIDogR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTJ4MTBVbm9ybTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdDpcblx0XHRcdFx0Zm9ybWF0R1BVID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTJ4MTJVbm9ybVNSR0IgOiBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMngxMlVub3JtO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBSR0JBRm9ybWF0OlxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LlJHQkE4VW5vcm1TUkdCIDogR1BVVGV4dHVyZUZvcm1hdC5SR0JBOFVub3JtO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1dlYkdQVVJlbmRlcmVyOiBVbnN1cHBvcnRlZCB0ZXh0dXJlIGZvcm1hdC4nLCBmb3JtYXQgKTtcblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0c3dpdGNoICggZm9ybWF0ICkge1xuXG5cdFx0XHRjYXNlIFJHQkFGb3JtYXQ6XG5cblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgQnl0ZVR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHQkE4U25vcm07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgU2hvcnRUeXBlOlxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBMTZTaW50O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFVuc2lnbmVkU2hvcnRUeXBlOlxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBMTZVaW50O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZEludFR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHQkEzMlVpbnQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgSW50VHlwZTpcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUkdCQTMyU2ludDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZEJ5dGVUeXBlOlxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gR1BVVGV4dHVyZUZvcm1hdC5SR0JBOFVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuUkdCQThVbm9ybTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBIYWxmRmxvYXRUeXBlOlxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBMTZGbG9hdDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBGbG9hdFR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHQkEzMkZsb2F0O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1dlYkdQVVJlbmRlcmVyOiBVbnN1cHBvcnRlZCB0ZXh0dXJlIHR5cGUgd2l0aCBSR0JBRm9ybWF0LicsIHR5cGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUkdCRm9ybWF0OlxuXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIFVuc2lnbmVkSW50NTk5OVR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHQjlFNVVGbG9hdDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdGV4dHVyZSB0eXBlIHdpdGggUkdCRm9ybWF0LicsIHR5cGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUmVkRm9ybWF0OlxuXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIEJ5dGVUeXBlOlxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SOFNub3JtO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFNob3J0VHlwZTpcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUjE2U2ludDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZFNob3J0VHlwZTpcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUjE2VWludDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZEludFR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlIzMlVpbnQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgSW50VHlwZTpcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUjMyU2ludDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZEJ5dGVUeXBlOlxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SOFVub3JtO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIEhhbGZGbG9hdFR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlIxNkZsb2F0O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIEZsb2F0VHlwZTpcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUjMyRmxvYXQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnV2ViR1BVUmVuZGVyZXI6IFVuc3VwcG9ydGVkIHRleHR1cmUgdHlwZSB3aXRoIFJlZEZvcm1hdC4nLCB0eXBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFJHRm9ybWF0OlxuXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIEJ5dGVUeXBlOlxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SRzhTbm9ybTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBTaG9ydFR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHMTZTaW50O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFVuc2lnbmVkU2hvcnRUeXBlOlxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SRzE2VWludDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZEludFR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHMzJVaW50O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIEludFR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHMzJTaW50O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFVuc2lnbmVkQnl0ZVR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHOFVub3JtO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIEhhbGZGbG9hdFR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHMTZGbG9hdDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBGbG9hdFR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHMzJGbG9hdDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdGV4dHVyZSB0eXBlIHdpdGggUkdGb3JtYXQuJywgdHlwZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBEZXB0aEZvcm1hdDpcblxuXHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZFNob3J0VHlwZTpcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuRGVwdGgxNlVub3JtO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFVuc2lnbmVkSW50VHlwZTpcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuRGVwdGgyNFBsdXM7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgRmxvYXRUeXBlOlxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDMyRmxvYXQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnV2ViR1BVUmVuZGVyZXI6IFVuc3VwcG9ydGVkIHRleHR1cmUgdHlwZSB3aXRoIERlcHRoRm9ybWF0LicsIHR5cGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgRGVwdGhTdGVuY2lsRm9ybWF0OlxuXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIFVuc2lnbmVkSW50MjQ4VHlwZTpcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuRGVwdGgyNFBsdXNTdGVuY2lsODtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBGbG9hdFR5cGU6XG5cblx0XHRcdFx0XHRcdGlmICggZGV2aWNlICYmIGRldmljZS5mZWF0dXJlcy5oYXMoIEdQVUZlYXR1cmVOYW1lLkRlcHRoMzJGbG9hdFN0ZW5jaWw4ICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVSZW5kZXJlcjogRGVwdGggdGV4dHVyZXMgd2l0aCBEZXB0aFN0ZW5jaWxGb3JtYXQgKyBGbG9hdFR5cGUgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHRoZSBcImRlcHRoMzJmbG9hdC1zdGVuY2lsOFwiIEdQVSBmZWF0dXJlLicgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LkRlcHRoMzJGbG9hdFN0ZW5jaWw4O1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnV2ViR1BVUmVuZGVyZXI6IFVuc3VwcG9ydGVkIHRleHR1cmUgdHlwZSB3aXRoIERlcHRoU3RlbmNpbEZvcm1hdC4nLCB0eXBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFJlZEludGVnZXJGb3JtYXQ6XG5cblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgSW50VHlwZTpcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUjMyU2ludDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZEludFR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlIzMlVpbnQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnV2ViR1BVUmVuZGVyZXI6IFVuc3VwcG9ydGVkIHRleHR1cmUgdHlwZSB3aXRoIFJlZEludGVnZXJGb3JtYXQuJywgdHlwZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBSR0ludGVnZXJGb3JtYXQ6XG5cblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgSW50VHlwZTpcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUkczMlNpbnQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgVW5zaWduZWRJbnRUeXBlOlxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SRzMyVWludDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdGV4dHVyZSB0eXBlIHdpdGggUkdJbnRlZ2VyRm9ybWF0LicsIHR5cGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUkdCQUludGVnZXJGb3JtYXQ6XG5cblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgSW50VHlwZTpcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUkdCQTMyU2ludDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZEludFR5cGU6XG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHQkEzMlVpbnQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnV2ViR1BVUmVuZGVyZXI6IFVuc3VwcG9ydGVkIHRleHR1cmUgdHlwZSB3aXRoIFJHQkFJbnRlZ2VyRm9ybWF0LicsIHR5cGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdGV4dHVyZSBmb3JtYXQuJywgZm9ybWF0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBmb3JtYXRHUFU7XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgV2ViR1BVVGV4dHVyZVV0aWxzO1xuIiwiaW1wb3J0IE5vZGVGdW5jdGlvbiBmcm9tICcuLi8uLi8uLi9ub2Rlcy9jb3JlL05vZGVGdW5jdGlvbi5qcyc7XG5pbXBvcnQgTm9kZUZ1bmN0aW9uSW5wdXQgZnJvbSAnLi4vLi4vLi4vbm9kZXMvY29yZS9Ob2RlRnVuY3Rpb25JbnB1dC5qcyc7XG5cbmNvbnN0IGRlY2xhcmF0aW9uUmVnZXhwID0gL15bZm5dKlxccyooW2Etel8wLTldKyk/XFxzKlxcKChbXFxzXFxTXSo/KVxcKVxccypbXFwtXFw+XSpcXHMqKFthLXpfMC05XSsoPzo8W1xcc1xcU10rPz4pPykvaTtcbmNvbnN0IHByb3BlcnRpZXNSZWdleHAgPSAvKFthLXpfMC05XSspXFxzKjpcXHMqKFthLXpfMC05XSsoPzo8W1xcc1xcU10rPz4pPykvaWc7XG5cbmNvbnN0IHdnc2xUeXBlTGliID0ge1xuXHQnZjMyJzogJ2Zsb2F0Jyxcblx0J2kzMic6ICdpbnQnLFxuXHQndTMyJzogJ3VpbnQnLFxuXHQnYm9vbCc6ICdib29sJyxcblxuXHQndmVjMjxmMzI+JzogJ3ZlYzInLFxuIFx0J3ZlYzI8aTMyPic6ICdpdmVjMicsXG4gXHQndmVjMjx1MzI+JzogJ3V2ZWMyJyxcbiBcdCd2ZWMyPGJvb2w+JzogJ2J2ZWMyJyxcblxuXHQndmVjMmYnOiAndmVjMicsXG5cdCd2ZWMyaSc6ICdpdmVjMicsXG5cdCd2ZWMydSc6ICd1dmVjMicsXG5cdCd2ZWMyYic6ICdidmVjMicsXG5cblx0J3ZlYzM8ZjMyPic6ICd2ZWMzJyxcblx0J3ZlYzM8aTMyPic6ICdpdmVjMycsXG5cdCd2ZWMzPHUzMj4nOiAndXZlYzMnLFxuXHQndmVjMzxib29sPic6ICdidmVjMycsXG5cblx0J3ZlYzNmJzogJ3ZlYzMnLFxuXHQndmVjM2knOiAnaXZlYzMnLFxuXHQndmVjM3UnOiAndXZlYzMnLFxuXHQndmVjM2InOiAnYnZlYzMnLFxuXG5cdCd2ZWM0PGYzMj4nOiAndmVjNCcsXG5cdCd2ZWM0PGkzMj4nOiAnaXZlYzQnLFxuXHQndmVjNDx1MzI+JzogJ3V2ZWM0Jyxcblx0J3ZlYzQ8Ym9vbD4nOiAnYnZlYzQnLFxuXG5cdCd2ZWM0Zic6ICd2ZWM0Jyxcblx0J3ZlYzRpJzogJ2l2ZWM0Jyxcblx0J3ZlYzR1JzogJ3V2ZWM0Jyxcblx0J3ZlYzRiJzogJ2J2ZWM0JyxcblxuXHQnbWF0MngyPGYzMj4nOiAnbWF0MicsXG5cdCdtYXQyeDJmJzogJ21hdDInLFxuXG5cdCdtYXQzeDM8ZjMyPic6ICdtYXQzJyxcblx0J21hdDN4M2YnOiAnbWF0MycsXG5cblx0J21hdDR4NDxmMzI+JzogJ21hdDQnLFxuXHQnbWF0NHg0Zic6ICdtYXQ0JyxcblxuXHQnc2FtcGxlcic6ICdzYW1wbGVyJyxcblxuXHQndGV4dHVyZV8xZCc6ICd0ZXh0dXJlJyxcblxuXHQndGV4dHVyZV8yZCc6ICd0ZXh0dXJlJyxcblx0J3RleHR1cmVfMmRfYXJyYXknOiAndGV4dHVyZScsXG5cdCd0ZXh0dXJlX211bHRpc2FtcGxlZF8yZCc6ICdjdWJlVGV4dHVyZScsXG5cblx0J3RleHR1cmVfZGVwdGhfMmQnOiAnZGVwdGhUZXh0dXJlJyxcblxuXHQndGV4dHVyZV8zZCc6ICd0ZXh0dXJlM0QnLFxuXG5cdCd0ZXh0dXJlX2N1YmUnOiAnY3ViZVRleHR1cmUnLFxuXHQndGV4dHVyZV9jdWJlX2FycmF5JzogJ2N1YmVUZXh0dXJlJyxcblxuXHQndGV4dHVyZV9zdG9yYWdlXzFkJzogJ3N0b3JhZ2VUZXh0dXJlJyxcblx0J3RleHR1cmVfc3RvcmFnZV8yZCc6ICdzdG9yYWdlVGV4dHVyZScsXG5cdCd0ZXh0dXJlX3N0b3JhZ2VfMmRfYXJyYXknOiAnc3RvcmFnZVRleHR1cmUnLFxuXHQndGV4dHVyZV9zdG9yYWdlXzNkJzogJ3N0b3JhZ2VUZXh0dXJlJ1xuXG59O1xuXG5jb25zdCBwYXJzZSA9ICggc291cmNlICkgPT4ge1xuXG5cdHNvdXJjZSA9IHNvdXJjZS50cmltKCk7XG5cblx0Y29uc3QgZGVjbGFyYXRpb24gPSBzb3VyY2UubWF0Y2goIGRlY2xhcmF0aW9uUmVnZXhwICk7XG5cblx0aWYgKCBkZWNsYXJhdGlvbiAhPT0gbnVsbCAmJiBkZWNsYXJhdGlvbi5sZW5ndGggPT09IDQgKSB7XG5cblx0XHRjb25zdCBpbnB1dHNDb2RlID0gZGVjbGFyYXRpb25bIDIgXTtcblx0XHRjb25zdCBwcm9wc01hdGNoZXMgPSBbXTtcblx0XHRsZXQgbWF0Y2ggPSBudWxsO1xuXG5cdFx0d2hpbGUgKCAoIG1hdGNoID0gcHJvcGVydGllc1JlZ2V4cC5leGVjKCBpbnB1dHNDb2RlICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0cHJvcHNNYXRjaGVzLnB1c2goIHsgbmFtZTogbWF0Y2hbIDEgXSwgdHlwZTogbWF0Y2hbIDIgXSB9ICk7XG5cblx0XHR9XG5cblx0XHQvLyBQcm9jZXNzIG1hdGNoZXMgdG8gY29ycmVjdGx5IHBhaXIgbmFtZXMgYW5kIHR5cGVzXG5cdFx0Y29uc3QgaW5wdXRzID0gW107XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcHJvcHNNYXRjaGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgeyBuYW1lLCB0eXBlIH0gPSBwcm9wc01hdGNoZXNbIGkgXTtcblxuXHRcdFx0bGV0IHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cblx0XHRcdGlmICggcmVzb2x2ZWRUeXBlLnN0YXJ0c1dpdGgoICdwdHInICkgKSB7XG5cblx0XHRcdFx0cmVzb2x2ZWRUeXBlID0gJ3BvaW50ZXInO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggcmVzb2x2ZWRUeXBlLnN0YXJ0c1dpdGgoICd0ZXh0dXJlJyApICkge1xuXG5cdFx0XHRcdFx0cmVzb2x2ZWRUeXBlID0gdHlwZS5zcGxpdCggJzwnIClbIDAgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzb2x2ZWRUeXBlID0gd2dzbFR5cGVMaWJbIHJlc29sdmVkVHlwZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlucHV0cy5wdXNoKCBuZXcgTm9kZUZ1bmN0aW9uSW5wdXQoIHJlc29sdmVkVHlwZSwgbmFtZSApICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBibG9ja0NvZGUgPSBzb3VyY2Uuc3Vic3RyaW5nKCBkZWNsYXJhdGlvblsgMCBdLmxlbmd0aCApO1xuXHRcdGNvbnN0IG91dHB1dFR5cGUgPSBkZWNsYXJhdGlvblsgMyBdIHx8ICd2b2lkJztcblxuXHRcdGNvbnN0IG5hbWUgPSBkZWNsYXJhdGlvblsgMSBdICE9PSB1bmRlZmluZWQgPyBkZWNsYXJhdGlvblsgMSBdIDogJyc7XG5cdFx0Y29uc3QgdHlwZSA9IHdnc2xUeXBlTGliWyBvdXRwdXRUeXBlIF0gfHwgb3V0cHV0VHlwZTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlLFxuXHRcdFx0aW5wdXRzLFxuXHRcdFx0bmFtZSxcblx0XHRcdGlucHV0c0NvZGUsXG5cdFx0XHRibG9ja0NvZGUsXG5cdFx0XHRvdXRwdXRUeXBlXG5cdFx0fTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnRnVuY3Rpb25Ob2RlOiBGdW5jdGlvbiBpcyBub3QgYSBXR1NMIGNvZGUuJyApO1xuXG5cdH1cblxufTtcblxuY2xhc3MgV0dTTE5vZGVGdW5jdGlvbiBleHRlbmRzIE5vZGVGdW5jdGlvbiB7XG5cblx0Y29uc3RydWN0b3IoIHNvdXJjZSApIHtcblxuXHRcdGNvbnN0IHsgdHlwZSwgaW5wdXRzLCBuYW1lLCBpbnB1dHNDb2RlLCBibG9ja0NvZGUsIG91dHB1dFR5cGUgfSA9IHBhcnNlKCBzb3VyY2UgKTtcblxuXHRcdHN1cGVyKCB0eXBlLCBpbnB1dHMsIG5hbWUgKTtcblxuXHRcdHRoaXMuaW5wdXRzQ29kZSA9IGlucHV0c0NvZGU7XG5cdFx0dGhpcy5ibG9ja0NvZGUgPSBibG9ja0NvZGU7XG5cdFx0dGhpcy5vdXRwdXRUeXBlID0gb3V0cHV0VHlwZTtcblxuXHR9XG5cblx0Z2V0Q29kZSggbmFtZSA9IHRoaXMubmFtZSApIHtcblxuXHRcdGNvbnN0IG91dHB1dFR5cGUgPSB0aGlzLm91dHB1dFR5cGUgIT09ICd2b2lkJyA/ICctPiAnICsgdGhpcy5vdXRwdXRUeXBlIDogJyc7XG5cblx0XHRyZXR1cm4gYGZuICR7IG5hbWUgfSAoICR7IHRoaXMuaW5wdXRzQ29kZS50cmltKCkgfSApICR7IG91dHB1dFR5cGUgfWAgKyB0aGlzLmJsb2NrQ29kZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgV0dTTE5vZGVGdW5jdGlvbjtcbiIsImltcG9ydCBOb2RlUGFyc2VyIGZyb20gJy4uLy4uLy4uL25vZGVzL2NvcmUvTm9kZVBhcnNlci5qcyc7XG5pbXBvcnQgV0dTTE5vZGVGdW5jdGlvbiBmcm9tICcuL1dHU0xOb2RlRnVuY3Rpb24uanMnO1xuXG5jbGFzcyBXR1NMTm9kZVBhcnNlciBleHRlbmRzIE5vZGVQYXJzZXIge1xuXG5cdHBhcnNlRnVuY3Rpb24oIHNvdXJjZSApIHtcblxuXHRcdHJldHVybiBuZXcgV0dTTE5vZGVGdW5jdGlvbiggc291cmNlICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdHU0xOb2RlUGFyc2VyO1xuIiwiaW1wb3J0IE5vZGVVbmlmb3Jtc0dyb3VwIGZyb20gJy4uLy4uL2NvbW1vbi9ub2Rlcy9Ob2RlVW5pZm9ybXNHcm91cC5qcyc7XG5cbmltcG9ydCBOb2RlU2FtcGxlciBmcm9tICcuLi8uLi9jb21tb24vbm9kZXMvTm9kZVNhbXBsZXIuanMnO1xuaW1wb3J0IHsgTm9kZVNhbXBsZWRUZXh0dXJlLCBOb2RlU2FtcGxlZEN1YmVUZXh0dXJlLCBOb2RlU2FtcGxlZFRleHR1cmUzRCB9IGZyb20gJy4uLy4uL2NvbW1vbi9ub2Rlcy9Ob2RlU2FtcGxlZFRleHR1cmUuanMnO1xuXG5pbXBvcnQgTm9kZVVuaWZvcm1CdWZmZXIgZnJvbSAnLi4vLi4vY29tbW9uL25vZGVzL05vZGVVbmlmb3JtQnVmZmVyLmpzJztcbmltcG9ydCBOb2RlU3RvcmFnZUJ1ZmZlciBmcm9tICcuLi8uLi9jb21tb24vbm9kZXMvTm9kZVN0b3JhZ2VCdWZmZXIuanMnO1xuXG5pbXBvcnQgeyBOb2RlQnVpbGRlciwgQ29kZU5vZGUgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9Ob2Rlcy5qcyc7XG5cbmltcG9ydCB7IGdldEZvcm1hdCB9IGZyb20gJy4uL3V0aWxzL1dlYkdQVVRleHR1cmVVdGlscy5qcyc7XG5cbmltcG9ydCBXR1NMTm9kZVBhcnNlciBmcm9tICcuL1dHU0xOb2RlUGFyc2VyLmpzJztcbmltcG9ydCB7IE5vZGVBY2Nlc3MgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9jb3JlL2NvbnN0YW50cy5qcyc7XG5cbmltcG9ydCBWYXJOb2RlIGZyb20gJy4uLy4uLy4uL25vZGVzL2NvcmUvVmFyTm9kZS5qcyc7XG5pbXBvcnQgRXhwcmVzc2lvbk5vZGUgZnJvbSAnLi4vLi4vLi4vbm9kZXMvY29kZS9FeHByZXNzaW9uTm9kZS5qcyc7XG5cbmltcG9ydCB7IE5vQ29sb3JTcGFjZSwgRmxvYXRUeXBlLCBSZXBlYXRXcmFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgTWlycm9yZWRSZXBlYXRXcmFwcGluZywgTmVhcmVzdEZpbHRlciB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbi8vIEdQVVNoYWRlclN0YWdlIGlzIG5vdCBkZWZpbmVkIGluIGJyb3dzZXJzIG5vdCBzdXBwb3J0aW5nIFdlYkdQVVxuY29uc3QgR1BVU2hhZGVyU3RhZ2UgPSAoIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyApID8gc2VsZi5HUFVTaGFkZXJTdGFnZSA6IHsgVkVSVEVYOiAxLCBGUkFHTUVOVDogMiwgQ09NUFVURTogNCB9O1xuXG5jb25zdCBhY2Nlc3NOYW1lcyA9IHtcblx0WyBOb2RlQWNjZXNzLlJFQURfT05MWSBdOiAncmVhZCcsXG5cdFsgTm9kZUFjY2Vzcy5XUklURV9PTkxZIF06ICd3cml0ZScsXG5cdFsgTm9kZUFjY2Vzcy5SRUFEX1dSSVRFIF06ICdyZWFkX3dyaXRlJ1xufTtcblxuY29uc3Qgd3JhcE5hbWVzID0ge1xuXHRbIFJlcGVhdFdyYXBwaW5nIF06ICdyZXBlYXQnLFxuXHRbIENsYW1wVG9FZGdlV3JhcHBpbmcgXTogJ2NsYW1wJyxcblx0WyBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nIF06ICdtaXJyb3InXG59O1xuXG5jb25zdCBncHVTaGFkZXJTdGFnZUxpYiA9IHtcblx0J3ZlcnRleCc6IEdQVVNoYWRlclN0YWdlID8gR1BVU2hhZGVyU3RhZ2UuVkVSVEVYIDogMSxcblx0J2ZyYWdtZW50JzogR1BVU2hhZGVyU3RhZ2UgPyBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCA6IDIsXG5cdCdjb21wdXRlJzogR1BVU2hhZGVyU3RhZ2UgPyBHUFVTaGFkZXJTdGFnZS5DT01QVVRFIDogNFxufTtcblxuY29uc3Qgc3VwcG9ydHMgPSB7XG5cdGluc3RhbmNlOiB0cnVlLFxuXHRzd2l6emxlQXNzaWduOiBmYWxzZSxcblx0c3RvcmFnZUJ1ZmZlcjogdHJ1ZVxufTtcblxuY29uc3Qgd2dzbEZuT3BMaWIgPSB7XG5cdCdeXic6ICd0c2xfeG9yJ1xufTtcblxuY29uc3Qgd2dzbFR5cGVMaWIgPSB7XG5cdGZsb2F0OiAnZjMyJyxcblx0aW50OiAnaTMyJyxcblx0dWludDogJ3UzMicsXG5cdGJvb2w6ICdib29sJyxcblx0Y29sb3I6ICd2ZWMzPGYzMj4nLFxuXG5cdHZlYzI6ICd2ZWMyPGYzMj4nLFxuXHRpdmVjMjogJ3ZlYzI8aTMyPicsXG5cdHV2ZWMyOiAndmVjMjx1MzI+Jyxcblx0YnZlYzI6ICd2ZWMyPGJvb2w+JyxcblxuXHR2ZWMzOiAndmVjMzxmMzI+Jyxcblx0aXZlYzM6ICd2ZWMzPGkzMj4nLFxuXHR1dmVjMzogJ3ZlYzM8dTMyPicsXG5cdGJ2ZWMzOiAndmVjMzxib29sPicsXG5cblx0dmVjNDogJ3ZlYzQ8ZjMyPicsXG5cdGl2ZWM0OiAndmVjNDxpMzI+Jyxcblx0dXZlYzQ6ICd2ZWM0PHUzMj4nLFxuXHRidmVjNDogJ3ZlYzQ8Ym9vbD4nLFxuXG5cdG1hdDI6ICdtYXQyeDI8ZjMyPicsXG5cdG1hdDM6ICdtYXQzeDM8ZjMyPicsXG5cdG1hdDQ6ICdtYXQ0eDQ8ZjMyPidcbn07XG5cbmNvbnN0IHdnc2xDb2RlQ2FjaGUgPSB7fTtcblxuY29uc3Qgd2dzbFBvbHlmaWxsID0ge1xuXHR0c2xfeG9yOiBuZXcgQ29kZU5vZGUoICdmbiB0c2xfeG9yKCBhIDogYm9vbCwgYiA6IGJvb2wgKSAtPiBib29sIHsgcmV0dXJuICggYSB8fCBiICkgJiYgISggYSAmJiBiICk7IH0nICksXG5cdG1vZF9mbG9hdDogbmV3IENvZGVOb2RlKCAnZm4gdHNsX21vZF9mbG9hdCggeCA6IGYzMiwgeSA6IGYzMiApIC0+IGYzMiB7IHJldHVybiB4IC0geSAqIGZsb29yKCB4IC8geSApOyB9JyApLFxuXHRtb2RfdmVjMjogbmV3IENvZGVOb2RlKCAnZm4gdHNsX21vZF92ZWMyKCB4IDogdmVjMmYsIHkgOiB2ZWMyZiApIC0+IHZlYzJmIHsgcmV0dXJuIHggLSB5ICogZmxvb3IoIHggLyB5ICk7IH0nICksXG5cdG1vZF92ZWMzOiBuZXcgQ29kZU5vZGUoICdmbiB0c2xfbW9kX3ZlYzMoIHggOiB2ZWMzZiwgeSA6IHZlYzNmICkgLT4gdmVjM2YgeyByZXR1cm4geCAtIHkgKiBmbG9vciggeCAvIHkgKTsgfScgKSxcblx0bW9kX3ZlYzQ6IG5ldyBDb2RlTm9kZSggJ2ZuIHRzbF9tb2RfdmVjNCggeCA6IHZlYzRmLCB5IDogdmVjNGYgKSAtPiB2ZWM0ZiB7IHJldHVybiB4IC0geSAqIGZsb29yKCB4IC8geSApOyB9JyApLFxuXHRlcXVhbHNfYm9vbDogbmV3IENvZGVOb2RlKCAnZm4gdHNsX2VxdWFsc19ib29sKCBhIDogYm9vbCwgYiA6IGJvb2wgKSAtPiBib29sIHsgcmV0dXJuIGEgPT0gYjsgfScgKSxcblx0ZXF1YWxzX2J2ZWMyOiBuZXcgQ29kZU5vZGUoICdmbiB0c2xfZXF1YWxzX2J2ZWMyKCBhIDogdmVjMmYsIGIgOiB2ZWMyZiApIC0+IHZlYzI8Ym9vbD4geyByZXR1cm4gdmVjMjxib29sPiggYS54ID09IGIueCwgYS55ID09IGIueSApOyB9JyApLFxuXHRlcXVhbHNfYnZlYzM6IG5ldyBDb2RlTm9kZSggJ2ZuIHRzbF9lcXVhbHNfYnZlYzMoIGEgOiB2ZWMzZiwgYiA6IHZlYzNmICkgLT4gdmVjMzxib29sPiB7IHJldHVybiB2ZWMzPGJvb2w+KCBhLnggPT0gYi54LCBhLnkgPT0gYi55LCBhLnogPT0gYi56ICk7IH0nICksXG5cdGVxdWFsc19idmVjNDogbmV3IENvZGVOb2RlKCAnZm4gdHNsX2VxdWFsc19idmVjNCggYSA6IHZlYzRmLCBiIDogdmVjNGYgKSAtPiB2ZWM0PGJvb2w+IHsgcmV0dXJuIHZlYzQ8Ym9vbD4oIGEueCA9PSBiLngsIGEueSA9PSBiLnksIGEueiA9PSBiLnosIGEudyA9PSBiLncgKTsgfScgKSxcblx0cmVwZWF0V3JhcHBpbmdfZmxvYXQ6IG5ldyBDb2RlTm9kZSggJ2ZuIHRzbF9yZXBlYXRXcmFwcGluZ19mbG9hdCggY29vcmQ6IGYzMiApIC0+IGYzMiB7IHJldHVybiBmcmFjdCggY29vcmQgKTsgfScgKSxcblx0bWlycm9yV3JhcHBpbmdfZmxvYXQ6IG5ldyBDb2RlTm9kZSggJ2ZuIHRzbF9taXJyb3JXcmFwcGluZ19mbG9hdCggY29vcmQ6IGYzMiApIC0+IGYzMiB7IGxldCBtaXJyb3JlZCA9IGZyYWN0KCBjb29yZCAqIDAuNSApICogMi4wOyByZXR1cm4gMS4wIC0gYWJzKCAxLjAgLSBtaXJyb3JlZCApOyB9JyApLFxuXHRjbGFtcFdyYXBwaW5nX2Zsb2F0OiBuZXcgQ29kZU5vZGUoICdmbiB0c2xfY2xhbXBXcmFwcGluZ19mbG9hdCggY29vcmQ6IGYzMiApIC0+IGYzMiB7IHJldHVybiBjbGFtcCggY29vcmQsIDAuMCwgMS4wICk7IH0nICksXG5cdGJpcXVhZHJhdGljVGV4dHVyZTogbmV3IENvZGVOb2RlKCAvKiB3Z3NsICovYFxuZm4gdHNsX2JpcXVhZHJhdGljVGV4dHVyZSggbWFwIDogdGV4dHVyZV8yZDxmMzI+LCBjb29yZCA6IHZlYzJmLCBpUmVzIDogdmVjMnUsIGxldmVsIDogdTMyICkgLT4gdmVjNGYge1xuXG5cdGxldCByZXMgPSB2ZWMyZiggaVJlcyApO1xuXG5cdGxldCB1dlNjYWxlZCA9IGNvb3JkICogcmVzO1xuXHRsZXQgdXZXcmFwcGluZyA9ICggKCB1dlNjYWxlZCAlIHJlcyApICsgcmVzICkgJSByZXM7XG5cblx0Ly8gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L1d0eVhSeVxuXG5cdGxldCB1diA9IHV2V3JhcHBpbmcgLSAwLjU7XG5cdGxldCBpdXYgPSBmbG9vciggdXYgKTtcblx0bGV0IGYgPSBmcmFjdCggdXYgKTtcblxuXHRsZXQgcmcxID0gdGV4dHVyZUxvYWQoIG1hcCwgdmVjMnUoIGl1diArIHZlYzIoIDAuNSwgMC41ICkgKSAlIGlSZXMsIGxldmVsICk7XG5cdGxldCByZzIgPSB0ZXh0dXJlTG9hZCggbWFwLCB2ZWMydSggaXV2ICsgdmVjMiggMS41LCAwLjUgKSApICUgaVJlcywgbGV2ZWwgKTtcblx0bGV0IHJnMyA9IHRleHR1cmVMb2FkKCBtYXAsIHZlYzJ1KCBpdXYgKyB2ZWMyKCAwLjUsIDEuNSApICkgJSBpUmVzLCBsZXZlbCApO1xuXHRsZXQgcmc0ID0gdGV4dHVyZUxvYWQoIG1hcCwgdmVjMnUoIGl1diArIHZlYzIoIDEuNSwgMS41ICkgKSAlIGlSZXMsIGxldmVsICk7XG5cblx0cmV0dXJuIG1peCggbWl4KCByZzEsIHJnMiwgZi54ICksIG1peCggcmczLCByZzQsIGYueCApLCBmLnkgKTtcblxufVxuYCApXG59O1xuXG5jb25zdCB3Z3NsTWV0aG9kcyA9IHtcblx0ZEZkeDogJ2RwZHgnLFxuXHRkRmR5OiAnLSBkcGR5Jyxcblx0bW9kX2Zsb2F0OiAndHNsX21vZF9mbG9hdCcsXG5cdG1vZF92ZWMyOiAndHNsX21vZF92ZWMyJyxcblx0bW9kX3ZlYzM6ICd0c2xfbW9kX3ZlYzMnLFxuXHRtb2RfdmVjNDogJ3RzbF9tb2RfdmVjNCcsXG5cdGVxdWFsc19ib29sOiAndHNsX2VxdWFsc19ib29sJyxcblx0ZXF1YWxzX2J2ZWMyOiAndHNsX2VxdWFsc19idmVjMicsXG5cdGVxdWFsc19idmVjMzogJ3RzbF9lcXVhbHNfYnZlYzMnLFxuXHRlcXVhbHNfYnZlYzQ6ICd0c2xfZXF1YWxzX2J2ZWM0Jyxcblx0aW52ZXJzZXNxcnQ6ICdpbnZlcnNlU3FydCcsXG5cdGJpdGNhc3Q6ICdiaXRjYXN0PGYzMj4nXG59O1xuXG4vLyBXZWJHUFUgaXNzdWU6IGRvZXMgbm90IHN1cHBvcnQgcG93KCkgd2l0aCBuZWdhdGl2ZSBiYXNlIG9uIFdpbmRvd3NcblxuaWYgKCB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvV2luZG93cy9nLnRlc3QoIG5hdmlnYXRvci51c2VyQWdlbnQgKSApIHtcblxuXHR3Z3NsUG9seWZpbGwucG93X2Zsb2F0ID0gbmV3IENvZGVOb2RlKCAnZm4gdHNsX3Bvd19mbG9hdCggYSA6IGYzMiwgYiA6IGYzMiApIC0+IGYzMiB7IHJldHVybiBzZWxlY3QoIC1wb3coIC1hLCBiICksIHBvdyggYSwgYiApLCBhID4gMC4wICk7IH0nICk7XG5cdHdnc2xQb2x5ZmlsbC5wb3dfdmVjMiA9IG5ldyBDb2RlTm9kZSggJ2ZuIHRzbF9wb3dfdmVjMiggYSA6IHZlYzJmLCBiIDogdmVjMmYgKSAtPiB2ZWMyZiB7IHJldHVybiB2ZWMyZiggdHNsX3Bvd19mbG9hdCggYS54LCBiLnggKSwgdHNsX3Bvd19mbG9hdCggYS55LCBiLnkgKSApOyB9JywgWyB3Z3NsUG9seWZpbGwucG93X2Zsb2F0IF0gKTtcblx0d2dzbFBvbHlmaWxsLnBvd192ZWMzID0gbmV3IENvZGVOb2RlKCAnZm4gdHNsX3Bvd192ZWMzKCBhIDogdmVjM2YsIGIgOiB2ZWMzZiApIC0+IHZlYzNmIHsgcmV0dXJuIHZlYzNmKCB0c2xfcG93X2Zsb2F0KCBhLngsIGIueCApLCB0c2xfcG93X2Zsb2F0KCBhLnksIGIueSApLCB0c2xfcG93X2Zsb2F0KCBhLnosIGIueiApICk7IH0nLCBbIHdnc2xQb2x5ZmlsbC5wb3dfZmxvYXQgXSApO1xuXHR3Z3NsUG9seWZpbGwucG93X3ZlYzQgPSBuZXcgQ29kZU5vZGUoICdmbiB0c2xfcG93X3ZlYzQoIGEgOiB2ZWM0ZiwgYiA6IHZlYzRmICkgLT4gdmVjNGYgeyByZXR1cm4gdmVjNGYoIHRzbF9wb3dfZmxvYXQoIGEueCwgYi54ICksIHRzbF9wb3dfZmxvYXQoIGEueSwgYi55ICksIHRzbF9wb3dfZmxvYXQoIGEueiwgYi56ICksIHRzbF9wb3dfZmxvYXQoIGEudywgYi53ICkgKTsgfScsIFsgd2dzbFBvbHlmaWxsLnBvd19mbG9hdCBdICk7XG5cblx0d2dzbE1ldGhvZHMucG93X2Zsb2F0ID0gJ3RzbF9wb3dfZmxvYXQnO1xuXHR3Z3NsTWV0aG9kcy5wb3dfdmVjMiA9ICd0c2xfcG93X3ZlYzInO1xuXHR3Z3NsTWV0aG9kcy5wb3dfdmVjMyA9ICd0c2xfcG93X3ZlYzMnO1xuXHR3Z3NsTWV0aG9kcy5wb3dfdmVjNCA9ICd0c2xfcG93X3ZlYzQnO1xuXG59XG5cbi8vXG5cbmxldCBkaWFnbm9zdGljcyA9ICcnO1xuXG5pZiAoICggdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0ZpcmVmb3h8RGVuby9nLnRlc3QoIG5hdmlnYXRvci51c2VyQWdlbnQgKSApICE9PSB0cnVlICkge1xuXG5cdGRpYWdub3N0aWNzICs9ICdkaWFnbm9zdGljKCBvZmYsIGRlcml2YXRpdmVfdW5pZm9ybWl0eSApO1xcbic7XG5cbn1cblxuLy9cblxuY2xhc3MgV0dTTE5vZGVCdWlsZGVyIGV4dGVuZHMgTm9kZUJ1aWxkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBvYmplY3QsIHJlbmRlcmVyICkge1xuXG5cdFx0c3VwZXIoIG9iamVjdCwgcmVuZGVyZXIsIG5ldyBXR1NMTm9kZVBhcnNlcigpICk7XG5cblx0XHR0aGlzLnVuaWZvcm1Hcm91cHMgPSB7fTtcblxuXHRcdHRoaXMuYnVpbHRpbnMgPSB7fTtcblxuXHRcdHRoaXMuZGlyZWN0aXZlcyA9IHt9O1xuXG5cdFx0dGhpcy5zY29wZWRBcnJheXMgPSBuZXcgTWFwKCk7XG5cblx0fVxuXG5cdG5lZWRzVG9Xb3JraW5nQ29sb3JTcGFjZSggdGV4dHVyZSApIHtcblxuXHRcdHJldHVybiB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlID09PSB0cnVlICYmIHRleHR1cmUuY29sb3JTcGFjZSAhPT0gTm9Db2xvclNwYWNlO1xuXG5cdH1cblxuXHRfZ2VuZXJhdGVUZXh0dXJlU2FtcGxlKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgZGVwdGhTbmlwcGV0LCBzaGFkZXJTdGFnZSA9IHRoaXMuc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAnZnJhZ21lbnQnICkge1xuXG5cdFx0XHRpZiAoIGRlcHRoU25pcHBldCApIHtcblxuXHRcdFx0XHRyZXR1cm4gYHRleHR1cmVTYW1wbGUoICR7IHRleHR1cmVQcm9wZXJ0eSB9LCAkeyB0ZXh0dXJlUHJvcGVydHkgfV9zYW1wbGVyLCAkeyB1dlNuaXBwZXQgfSwgJHsgZGVwdGhTbmlwcGV0IH0gKWA7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIGB0ZXh0dXJlU2FtcGxlKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdGV4dHVyZVByb3BlcnR5IH1fc2FtcGxlciwgJHsgdXZTbmlwcGV0IH0gKWA7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXNGaWx0ZXJlZFRleHR1cmUoIHRleHR1cmUgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVGaWx0ZXJlZFRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZVRleHR1cmVMb2QoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBkZXB0aFNuaXBwZXQsICcwJyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfZ2VuZXJhdGVWaWRlb1NhbXBsZSggdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcblxuXHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgKSB7XG5cblx0XHRcdHJldHVybiBgdGV4dHVyZVNhbXBsZUJhc2VDbGFtcFRvRWRnZSggJHsgdGV4dHVyZVByb3BlcnR5IH0sICR7IHRleHR1cmVQcm9wZXJ0eSB9X3NhbXBsZXIsIHZlYzI8ZjMyPiggJHsgdXZTbmlwcGV0IH0ueCwgMS4wIC0gJHsgdXZTbmlwcGV0IH0ueSApIClgO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggYFdlYkdQVVJlbmRlcmVyOiBUSFJFRS5WaWRlb1RleHR1cmUgZG9lcyBub3Qgc3VwcG9ydCAkeyBzaGFkZXJTdGFnZSB9IHNoYWRlci5gICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9nZW5lcmF0ZVRleHR1cmVTYW1wbGVMZXZlbCggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGxldmVsU25pcHBldCwgZGVwdGhTbmlwcGV0LCBzaGFkZXJTdGFnZSA9IHRoaXMuc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAnZnJhZ21lbnQnICYmIHRoaXMuaXNVbmZpbHRlcmFibGUoIHRleHR1cmUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHJldHVybiBgdGV4dHVyZVNhbXBsZUxldmVsKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdGV4dHVyZVByb3BlcnR5IH1fc2FtcGxlciwgJHsgdXZTbmlwcGV0IH0sICR7IGxldmVsU25pcHBldCB9IClgO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5pc0ZpbHRlcmVkVGV4dHVyZSggdGV4dHVyZSApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUZpbHRlcmVkVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGxldmVsU25pcHBldCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVUZXh0dXJlTG9kKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgZGVwdGhTbmlwcGV0LCBsZXZlbFNuaXBwZXQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2VuZXJhdGVXcmFwRnVuY3Rpb24oIHRleHR1cmUgKSB7XG5cblx0XHRjb25zdCBmdW5jdGlvbk5hbWUgPSBgdHNsX2Nvb3JkXyR7IHdyYXBOYW1lc1sgdGV4dHVyZS53cmFwUyBdIH1TXyR7IHdyYXBOYW1lc1sgdGV4dHVyZS53cmFwVCBdIH1UYDtcblxuXHRcdGxldCBub2RlQ29kZSA9IHdnc2xDb2RlQ2FjaGVbIGZ1bmN0aW9uTmFtZSBdO1xuXG5cdFx0aWYgKCBub2RlQ29kZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBpbmNsdWRlcyA9IFtdO1xuXG5cdFx0XHRsZXQgY29kZSA9IGBmbiAkeyBmdW5jdGlvbk5hbWUgfSggY29vcmQgOiB2ZWMyZiApIC0+IHZlYzJmIHtcXG5cXG5cXHRyZXR1cm4gdmVjMmYoXFxuYDtcblxuXHRcdFx0Y29uc3QgYWRkV3JhcFNuaXBwZXQgPSAoIHdyYXAsIGF4aXMgKSA9PiB7XG5cblx0XHRcdFx0aWYgKCB3cmFwID09PSBSZXBlYXRXcmFwcGluZyApIHtcblxuXHRcdFx0XHRcdGluY2x1ZGVzLnB1c2goIHdnc2xQb2x5ZmlsbC5yZXBlYXRXcmFwcGluZ19mbG9hdCApO1xuXG5cdFx0XHRcdFx0Y29kZSArPSBgXFx0XFx0dHNsX3JlcGVhdFdyYXBwaW5nX2Zsb2F0KCBjb29yZC4keyBheGlzIH0gKWA7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggd3JhcCA9PT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHtcblxuXHRcdFx0XHRcdGluY2x1ZGVzLnB1c2goIHdnc2xQb2x5ZmlsbC5jbGFtcFdyYXBwaW5nX2Zsb2F0ICk7XG5cblx0XHRcdFx0XHRjb2RlICs9IGBcXHRcXHR0c2xfY2xhbXBXcmFwcGluZ19mbG9hdCggY29vcmQuJHsgYXhpcyB9IClgO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHdyYXAgPT09IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgKSB7XG5cblx0XHRcdFx0XHRpbmNsdWRlcy5wdXNoKCB3Z3NsUG9seWZpbGwubWlycm9yV3JhcHBpbmdfZmxvYXQgKTtcblxuXHRcdFx0XHRcdGNvZGUgKz0gYFxcdFxcdHRzbF9taXJyb3JXcmFwcGluZ19mbG9hdCggY29vcmQuJHsgYXhpcyB9IClgO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb2RlICs9IGBcXHRcXHRjb29yZC4keyBheGlzIH1gO1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCBgV2ViR1BVUmVuZGVyZXI6IFVuc3VwcG9ydGVkIHRleHR1cmUgd3JhcCB0eXBlIFwiJHsgd3JhcCB9XCIgZm9yIHZlcnRleCBzaGFkZXIuYCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdFx0YWRkV3JhcFNuaXBwZXQoIHRleHR1cmUud3JhcFMsICd4JyApO1xuXG5cdFx0XHRjb2RlICs9ICcsXFxuJztcblxuXHRcdFx0YWRkV3JhcFNuaXBwZXQoIHRleHR1cmUud3JhcFQsICd5JyApO1xuXG5cdFx0XHRjb2RlICs9ICdcXG5cXHQpO1xcblxcbn1cXG4nO1xuXG5cdFx0XHR3Z3NsQ29kZUNhY2hlWyBmdW5jdGlvbk5hbWUgXSA9IG5vZGVDb2RlID0gbmV3IENvZGVOb2RlKCBjb2RlLCBpbmNsdWRlcyApO1xuXG5cdFx0fVxuXG5cdFx0bm9kZUNvZGUuYnVpbGQoIHRoaXMgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbk5hbWU7XG5cblx0fVxuXG5cdGdlbmVyYXRlVGV4dHVyZURpbWVuc2lvbiggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCBsZXZlbFNuaXBwZXQgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCB0ZXh0dXJlLCB0aGlzLnNoYWRlclN0YWdlLCB0aGlzLmdsb2JhbENhY2hlICk7XG5cblx0XHRpZiAoIHRleHR1cmVEYXRhLmRpbWVuc2lvbnNTbmlwcGV0ID09PSB1bmRlZmluZWQgKSB0ZXh0dXJlRGF0YS5kaW1lbnNpb25zU25pcHBldCA9IHt9O1xuXG5cdFx0bGV0IHRleHR1cmVEaW1lbnNpb25Ob2RlID0gdGV4dHVyZURhdGEuZGltZW5zaW9uc1NuaXBwZXRbIGxldmVsU25pcHBldCBdO1xuXG5cdFx0aWYgKCB0ZXh0dXJlRGF0YS5kaW1lbnNpb25zU25pcHBldFsgbGV2ZWxTbmlwcGV0IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bGV0IHRleHR1cmVEaW1lbnNpb25zUGFyYW1zO1xuXG5cdFx0XHRpZiAoIHRleHR1cmUuaXNNdWx0aXNhbXBsZVJlbmRlclRhcmdldFRleHR1cmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dGV4dHVyZURpbWVuc2lvbnNQYXJhbXMgPSB0ZXh0dXJlUHJvcGVydHk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGV4dHVyZURpbWVuc2lvbnNQYXJhbXMgPSBgJHsgdGV4dHVyZVByb3BlcnR5IH0sIHUzMiggJHsgbGV2ZWxTbmlwcGV0IH0gKWA7XG5cblx0XHRcdH1cblxuXHRcdFx0dGV4dHVyZURpbWVuc2lvbk5vZGUgPSBuZXcgVmFyTm9kZSggbmV3IEV4cHJlc3Npb25Ob2RlKCBgdGV4dHVyZURpbWVuc2lvbnMoICR7IHRleHR1cmVEaW1lbnNpb25zUGFyYW1zIH0gKWAsICd1dmVjMicgKSApO1xuXG5cdFx0XHR0ZXh0dXJlRGF0YS5kaW1lbnNpb25zU25pcHBldFsgbGV2ZWxTbmlwcGV0IF0gPSB0ZXh0dXJlRGltZW5zaW9uTm9kZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0ZXh0dXJlRGltZW5zaW9uTm9kZS5idWlsZCggdGhpcyApO1xuXG5cdH1cblxuXHRnZW5lcmF0ZUZpbHRlcmVkVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGxldmVsU25pcHBldCA9ICcwdScgKSB7XG5cblx0XHR0aGlzLl9pbmNsdWRlKCAnYmlxdWFkcmF0aWNUZXh0dXJlJyApO1xuXG5cdFx0Y29uc3Qgd3JhcEZ1bmN0aW9uID0gdGhpcy5nZW5lcmF0ZVdyYXBGdW5jdGlvbiggdGV4dHVyZSApO1xuXHRcdGNvbnN0IHRleHR1cmVEaW1lbnNpb24gPSB0aGlzLmdlbmVyYXRlVGV4dHVyZURpbWVuc2lvbiggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCBsZXZlbFNuaXBwZXQgKTtcblxuXHRcdHJldHVybiBgdHNsX2JpcXVhZHJhdGljVGV4dHVyZSggJHsgdGV4dHVyZVByb3BlcnR5IH0sICR7IHdyYXBGdW5jdGlvbiB9KCAkeyB1dlNuaXBwZXQgfSApLCAkeyB0ZXh0dXJlRGltZW5zaW9uIH0sIHUzMiggJHsgbGV2ZWxTbmlwcGV0IH0gKSApYDtcblxuXHR9XG5cblx0Z2VuZXJhdGVUZXh0dXJlTG9kKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgZGVwdGhTbmlwcGV0LCBsZXZlbFNuaXBwZXQgPSAnMHUnICkge1xuXG5cdFx0Y29uc3Qgd3JhcEZ1bmN0aW9uID0gdGhpcy5nZW5lcmF0ZVdyYXBGdW5jdGlvbiggdGV4dHVyZSApO1xuXHRcdGNvbnN0IHRleHR1cmVEaW1lbnNpb24gPSB0aGlzLmdlbmVyYXRlVGV4dHVyZURpbWVuc2lvbiggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCBsZXZlbFNuaXBwZXQgKTtcblxuXHRcdGNvbnN0IGNvb3JkU25pcHBldCA9IGB2ZWMydSggJHsgd3JhcEZ1bmN0aW9uIH0oICR7IHV2U25pcHBldCB9ICkgKiB2ZWMyZiggJHsgdGV4dHVyZURpbWVuc2lvbiB9ICkgKWA7XG5cblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZVRleHR1cmVMb2FkKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIGNvb3JkU25pcHBldCwgZGVwdGhTbmlwcGV0LCBsZXZlbFNuaXBwZXQgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGVUZXh0dXJlTG9hZCggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dkluZGV4U25pcHBldCwgZGVwdGhTbmlwcGV0LCBsZXZlbFNuaXBwZXQgPSAnMHUnICkge1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlID09PSB0cnVlIHx8IHRleHR1cmUuaXNTdG9yYWdlVGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0cmV0dXJuIGB0ZXh0dXJlTG9hZCggJHsgdGV4dHVyZVByb3BlcnR5IH0sICR7IHV2SW5kZXhTbmlwcGV0IH0gKWA7XG5cblx0XHR9IGVsc2UgaWYgKCBkZXB0aFNuaXBwZXQgKSB7XG5cblx0XHRcdHJldHVybiBgdGV4dHVyZUxvYWQoICR7IHRleHR1cmVQcm9wZXJ0eSB9LCAkeyB1dkluZGV4U25pcHBldCB9LCAkeyBkZXB0aFNuaXBwZXQgfSwgdTMyKCAkeyBsZXZlbFNuaXBwZXQgfSApIClgO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIGB0ZXh0dXJlTG9hZCggJHsgdGV4dHVyZVByb3BlcnR5IH0sICR7IHV2SW5kZXhTbmlwcGV0IH0sIHUzMiggJHsgbGV2ZWxTbmlwcGV0IH0gKSApYDtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2VuZXJhdGVUZXh0dXJlU3RvcmUoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZJbmRleFNuaXBwZXQsIHZhbHVlU25pcHBldCApIHtcblxuXHRcdHJldHVybiBgdGV4dHVyZVN0b3JlKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdXZJbmRleFNuaXBwZXQgfSwgJHsgdmFsdWVTbmlwcGV0IH0gKWA7XG5cblx0fVxuXG5cdGlzU2FtcGxlQ29tcGFyZSggdGV4dHVyZSApIHtcblxuXHRcdHJldHVybiB0ZXh0dXJlLmlzRGVwdGhUZXh0dXJlID09PSB0cnVlICYmIHRleHR1cmUuY29tcGFyZUZ1bmN0aW9uICE9PSBudWxsO1xuXG5cdH1cblxuXHRpc1VuZmlsdGVyYWJsZSggdGV4dHVyZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmdldENvbXBvbmVudFR5cGVGcm9tVGV4dHVyZSggdGV4dHVyZSApICE9PSAnZmxvYXQnIHx8XG5cdFx0XHQoICEgdGhpcy5pc0F2YWlsYWJsZSggJ2Zsb2F0MzJGaWx0ZXJhYmxlJyApICYmIHRleHR1cmUuaXNEYXRhVGV4dHVyZSA9PT0gdHJ1ZSAmJiB0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSApIHx8XG5cdFx0XHQoIHRoaXMuaXNTYW1wbGVDb21wYXJlKCB0ZXh0dXJlICkgPT09IGZhbHNlICYmIHRleHR1cmUubWluRmlsdGVyID09PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWFnRmlsdGVyID09PSBOZWFyZXN0RmlsdGVyICkgfHxcblx0XHRcdHRleHR1cmUuaXNNdWx0aXNhbXBsZVJlbmRlclRhcmdldFRleHR1cmUgPT09IHRydWU7XG5cblx0fVxuXG5cdGdlbmVyYXRlVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGRlcHRoU25pcHBldCwgc2hhZGVyU3RhZ2UgPSB0aGlzLnNoYWRlclN0YWdlICkge1xuXG5cdFx0bGV0IHNuaXBwZXQgPSBudWxsO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRzbmlwcGV0ID0gdGhpcy5fZ2VuZXJhdGVWaWRlb1NhbXBsZSggdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIHNoYWRlclN0YWdlICk7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLmlzVW5maWx0ZXJhYmxlKCB0ZXh0dXJlICkgKSB7XG5cblx0XHRcdHNuaXBwZXQgPSB0aGlzLmdlbmVyYXRlVGV4dHVyZUxvZCggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGRlcHRoU25pcHBldCwgJzAnLCBzaGFkZXJTdGFnZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0c25pcHBldCA9IHRoaXMuX2dlbmVyYXRlVGV4dHVyZVNhbXBsZSggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGRlcHRoU25pcHBldCwgc2hhZGVyU3RhZ2UgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBzbmlwcGV0O1xuXG5cdH1cblxuXHRnZW5lcmF0ZVRleHR1cmVHcmFkKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgZ3JhZFNuaXBwZXQsIGRlcHRoU25pcHBldCwgc2hhZGVyU3RhZ2UgPSB0aGlzLnNoYWRlclN0YWdlICkge1xuXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSA9PT0gJ2ZyYWdtZW50JyApIHtcblxuXHRcdFx0Ly8gVE9ETyBoYW5kbGUgaTMyIG9yIHUzMiAtLT4gdXZTbmlwcGV0LCBhcnJheV9pbmRleDogQSwgZGR4LCBkZHlcblx0XHRcdHJldHVybiBgdGV4dHVyZVNhbXBsZUdyYWQoICR7IHRleHR1cmVQcm9wZXJ0eSB9LCAkeyB0ZXh0dXJlUHJvcGVydHkgfV9zYW1wbGVyLCAkeyB1dlNuaXBwZXQgfSwgICR7IGdyYWRTbmlwcGV0WyAwIF0gfSwgJHsgZ3JhZFNuaXBwZXRbIDEgXSB9IClgO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggYFdlYkdQVVJlbmRlcmVyOiBUSFJFRS5UZXh0dXJlTm9kZS5ncmFkaWVudCgpIGRvZXMgbm90IHN1cHBvcnQgJHsgc2hhZGVyU3RhZ2UgfSBzaGFkZXIuYCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRnZW5lcmF0ZVRleHR1cmVDb21wYXJlKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgY29tcGFyZVNuaXBwZXQsIGRlcHRoU25pcHBldCwgc2hhZGVyU3RhZ2UgPSB0aGlzLnNoYWRlclN0YWdlICkge1xuXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSA9PT0gJ2ZyYWdtZW50JyApIHtcblxuXHRcdFx0cmV0dXJuIGB0ZXh0dXJlU2FtcGxlQ29tcGFyZSggJHsgdGV4dHVyZVByb3BlcnR5IH0sICR7IHRleHR1cmVQcm9wZXJ0eSB9X3NhbXBsZXIsICR7IHV2U25pcHBldCB9LCAkeyBjb21wYXJlU25pcHBldCB9IClgO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggYFdlYkdQVVJlbmRlcmVyOiBUSFJFRS5EZXB0aFRleHR1cmUuY29tcGFyZUZ1bmN0aW9uKCkgZG9lcyBub3Qgc3VwcG9ydCAkeyBzaGFkZXJTdGFnZSB9IHNoYWRlci5gICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdlbmVyYXRlVGV4dHVyZUxldmVsKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgbGV2ZWxTbmlwcGV0LCBkZXB0aFNuaXBwZXQsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcblxuXHRcdGxldCBzbmlwcGV0ID0gbnVsbDtcblxuXHRcdGlmICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0c25pcHBldCA9IHRoaXMuX2dlbmVyYXRlVmlkZW9TYW1wbGUoIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBzaGFkZXJTdGFnZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0c25pcHBldCA9IHRoaXMuX2dlbmVyYXRlVGV4dHVyZVNhbXBsZUxldmVsKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgbGV2ZWxTbmlwcGV0LCBkZXB0aFNuaXBwZXQsIHNoYWRlclN0YWdlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc25pcHBldDtcblxuXHR9XG5cblx0Z2VuZXJhdGVUZXh0dXJlQmlhcyggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGJpYXNTbmlwcGV0LCBkZXB0aFNuaXBwZXQsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcblxuXHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgKSB7XG5cblx0XHRcdHJldHVybiBgdGV4dHVyZVNhbXBsZUJpYXMoICR7IHRleHR1cmVQcm9wZXJ0eSB9LCAkeyB0ZXh0dXJlUHJvcGVydHkgfV9zYW1wbGVyLCAkeyB1dlNuaXBwZXQgfSwgJHsgYmlhc1NuaXBwZXQgfSApYDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIGBXZWJHUFVSZW5kZXJlcjogVEhSRUUuVGV4dHVyZU5vZGUuYmlhc05vZGUgZG9lcyBub3Qgc3VwcG9ydCAkeyBzaGFkZXJTdGFnZSB9IHNoYWRlci5gICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldFByb3BlcnR5TmFtZSggbm9kZSwgc2hhZGVyU3RhZ2UgPSB0aGlzLnNoYWRlclN0YWdlICkge1xuXG5cdFx0aWYgKCBub2RlLmlzTm9kZVZhcnlpbmcgPT09IHRydWUgJiYgbm9kZS5uZWVkc0ludGVycG9sYXRpb24gPT09IHRydWUgKSB7XG5cblx0XHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICd2ZXJ0ZXgnICkge1xuXG5cdFx0XHRcdHJldHVybiBgdmFyeWluZ3MuJHsgbm9kZS5uYW1lIH1gO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBub2RlLmlzTm9kZVVuaWZvcm0gPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG5cdFx0XHRjb25zdCB0eXBlID0gbm9kZS50eXBlO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09ICd0ZXh0dXJlJyB8fCB0eXBlID09PSAnY3ViZVRleHR1cmUnIHx8IHR5cGUgPT09ICdzdG9yYWdlVGV4dHVyZScgfHwgdHlwZSA9PT0gJ3RleHR1cmUzRCcgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG5hbWU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdidWZmZXInIHx8IHR5cGUgPT09ICdzdG9yYWdlQnVmZmVyJyB8fCB0eXBlID09PSAnaW5kaXJlY3RTdG9yYWdlQnVmZmVyJyApIHtcblxuXHRcdFx0XHRyZXR1cm4gYE5vZGVCdWZmZXJfJHsgbm9kZS5pZCB9LiR7bmFtZX1gO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBub2RlLmdyb3VwTm9kZS5uYW1lICsgJy4nICsgbmFtZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1cGVyLmdldFByb3BlcnR5TmFtZSggbm9kZSApO1xuXG5cdH1cblxuXHRnZXRPdXRwdXRTdHJ1Y3ROYW1lKCkge1xuXG5cdFx0cmV0dXJuICdvdXRwdXQnO1xuXG5cdH1cblxuXHRfZ2V0VW5pZm9ybUdyb3VwQ291bnQoIHNoYWRlclN0YWdlICkge1xuXG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKCB0aGlzLnVuaWZvcm1zWyBzaGFkZXJTdGFnZSBdICkubGVuZ3RoO1xuXG5cdH1cblxuXHRnZXRGdW5jdGlvbk9wZXJhdG9yKCBvcCApIHtcblxuXHRcdGNvbnN0IGZuT3AgPSB3Z3NsRm5PcExpYlsgb3AgXTtcblxuXHRcdGlmICggZm5PcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLl9pbmNsdWRlKCBmbk9wICk7XG5cblx0XHRcdHJldHVybiBmbk9wO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG5cdGdldE5vZGVBY2Nlc3MoIG5vZGUsIHNoYWRlclN0YWdlICkge1xuXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSAhPT0gJ2NvbXB1dGUnIClcblx0XHRcdHJldHVybiBOb2RlQWNjZXNzLlJFQURfT05MWTtcblxuXHRcdHJldHVybiBub2RlLmFjY2VzcztcblxuXHR9XG5cblx0Z2V0U3RvcmFnZUFjY2Vzcyggbm9kZSwgc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRyZXR1cm4gYWNjZXNzTmFtZXNbIHRoaXMuZ2V0Tm9kZUFjY2Vzcyggbm9kZSwgc2hhZGVyU3RhZ2UgKSBdO1xuXG5cdH1cblxuXHRnZXRVbmlmb3JtRnJvbU5vZGUoIG5vZGUsIHR5cGUsIHNoYWRlclN0YWdlLCBuYW1lID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IHVuaWZvcm1Ob2RlID0gc3VwZXIuZ2V0VW5pZm9ybUZyb21Ob2RlKCBub2RlLCB0eXBlLCBzaGFkZXJTdGFnZSwgbmFtZSApO1xuXHRcdGNvbnN0IG5vZGVEYXRhID0gdGhpcy5nZXREYXRhRnJvbU5vZGUoIG5vZGUsIHNoYWRlclN0YWdlLCB0aGlzLmdsb2JhbENhY2hlICk7XG5cblx0XHRpZiAoIG5vZGVEYXRhLnVuaWZvcm1HUFUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bGV0IHVuaWZvcm1HUFU7XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gbm9kZS5ncm91cE5vZGU7XG5cdFx0XHRjb25zdCBncm91cE5hbWUgPSBncm91cC5uYW1lO1xuXG5cdFx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuZ2V0QmluZEdyb3VwQXJyYXkoIGdyb3VwTmFtZSwgc2hhZGVyU3RhZ2UgKTtcblxuXHRcdFx0aWYgKCB0eXBlID09PSAndGV4dHVyZScgfHwgdHlwZSA9PT0gJ2N1YmVUZXh0dXJlJyB8fCB0eXBlID09PSAnc3RvcmFnZVRleHR1cmUnIHx8IHR5cGUgPT09ICd0ZXh0dXJlM0QnICkge1xuXG5cdFx0XHRcdGxldCB0ZXh0dXJlID0gbnVsbDtcblxuXHRcdFx0XHRjb25zdCBhY2Nlc3MgPSB0aGlzLmdldE5vZGVBY2Nlc3MoIG5vZGUsIHNoYWRlclN0YWdlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSAndGV4dHVyZScgfHwgdHlwZSA9PT0gJ3N0b3JhZ2VUZXh0dXJlJyApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgTm9kZVNhbXBsZWRUZXh0dXJlKCB1bmlmb3JtTm9kZS5uYW1lLCB1bmlmb3JtTm9kZS5ub2RlLCBncm91cCwgYWNjZXNzICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ2N1YmVUZXh0dXJlJyApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgTm9kZVNhbXBsZWRDdWJlVGV4dHVyZSggdW5pZm9ybU5vZGUubmFtZSwgdW5pZm9ybU5vZGUubm9kZSwgZ3JvdXAsIGFjY2VzcyApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICd0ZXh0dXJlM0QnICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZSA9IG5ldyBOb2RlU2FtcGxlZFRleHR1cmUzRCggdW5pZm9ybU5vZGUubmFtZSwgdW5pZm9ybU5vZGUubm9kZSwgZ3JvdXAsIGFjY2VzcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlLnN0b3JlID0gbm9kZS5pc1N0b3JhZ2VUZXh0dXJlTm9kZSA9PT0gdHJ1ZTtcblx0XHRcdFx0dGV4dHVyZS5zZXRWaXNpYmlsaXR5KCBncHVTaGFkZXJTdGFnZUxpYlsgc2hhZGVyU3RhZ2UgXSApO1xuXG5cdFx0XHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgJiYgdGhpcy5pc1VuZmlsdGVyYWJsZSggbm9kZS52YWx1ZSApID09PSBmYWxzZSAmJiB0ZXh0dXJlLnN0b3JlID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHNhbXBsZXIgPSBuZXcgTm9kZVNhbXBsZXIoIGAke3VuaWZvcm1Ob2RlLm5hbWV9X3NhbXBsZXJgLCB1bmlmb3JtTm9kZS5ub2RlLCBncm91cCApO1xuXHRcdFx0XHRcdHNhbXBsZXIuc2V0VmlzaWJpbGl0eSggZ3B1U2hhZGVyU3RhZ2VMaWJbIHNoYWRlclN0YWdlIF0gKTtcblxuXHRcdFx0XHRcdGJpbmRpbmdzLnB1c2goIHNhbXBsZXIsIHRleHR1cmUgKTtcblxuXHRcdFx0XHRcdHVuaWZvcm1HUFUgPSBbIHNhbXBsZXIsIHRleHR1cmUgXTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YmluZGluZ3MucHVzaCggdGV4dHVyZSApO1xuXG5cdFx0XHRcdFx0dW5pZm9ybUdQVSA9IFsgdGV4dHVyZSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ2J1ZmZlcicgfHwgdHlwZSA9PT0gJ3N0b3JhZ2VCdWZmZXInIHx8IHR5cGUgPT09ICdpbmRpcmVjdFN0b3JhZ2VCdWZmZXInICkge1xuXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlckNsYXNzID0gdHlwZSA9PT0gJ2J1ZmZlcicgPyBOb2RlVW5pZm9ybUJ1ZmZlciA6IE5vZGVTdG9yYWdlQnVmZmVyO1xuXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IG5ldyBidWZmZXJDbGFzcyggbm9kZSwgZ3JvdXAgKTtcblx0XHRcdFx0YnVmZmVyLnNldFZpc2liaWxpdHkoIGdwdVNoYWRlclN0YWdlTGliWyBzaGFkZXJTdGFnZSBdICk7XG5cblx0XHRcdFx0YmluZGluZ3MucHVzaCggYnVmZmVyICk7XG5cblx0XHRcdFx0dW5pZm9ybUdQVSA9IGJ1ZmZlcjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCB1bmlmb3Jtc1N0YWdlID0gdGhpcy51bmlmb3JtR3JvdXBzWyBzaGFkZXJTdGFnZSBdIHx8ICggdGhpcy51bmlmb3JtR3JvdXBzWyBzaGFkZXJTdGFnZSBdID0ge30gKTtcblxuXHRcdFx0XHRsZXQgdW5pZm9ybXNHcm91cCA9IHVuaWZvcm1zU3RhZ2VbIGdyb3VwTmFtZSBdO1xuXG5cdFx0XHRcdGlmICggdW5pZm9ybXNHcm91cCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXNHcm91cCA9IG5ldyBOb2RlVW5pZm9ybXNHcm91cCggZ3JvdXBOYW1lLCBncm91cCApO1xuXHRcdFx0XHRcdHVuaWZvcm1zR3JvdXAuc2V0VmlzaWJpbGl0eSggZ3B1U2hhZGVyU3RhZ2VMaWJbIHNoYWRlclN0YWdlIF0gKTtcblxuXHRcdFx0XHRcdHVuaWZvcm1zU3RhZ2VbIGdyb3VwTmFtZSBdID0gdW5pZm9ybXNHcm91cDtcblxuXHRcdFx0XHRcdGJpbmRpbmdzLnB1c2goIHVuaWZvcm1zR3JvdXAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dW5pZm9ybUdQVSA9IHRoaXMuZ2V0Tm9kZVVuaWZvcm0oIHVuaWZvcm1Ob2RlLCB0eXBlICk7XG5cblx0XHRcdFx0dW5pZm9ybXNHcm91cC5hZGRVbmlmb3JtKCB1bmlmb3JtR1BVICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bm9kZURhdGEudW5pZm9ybUdQVSA9IHVuaWZvcm1HUFU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdW5pZm9ybU5vZGU7XG5cblx0fVxuXG5cdGdldEJ1aWx0aW4oIG5hbWUsIHByb3BlcnR5LCB0eXBlLCBzaGFkZXJTdGFnZSA9IHRoaXMuc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRjb25zdCBtYXAgPSB0aGlzLmJ1aWx0aW5zWyBzaGFkZXJTdGFnZSBdIHx8ICggdGhpcy5idWlsdGluc1sgc2hhZGVyU3RhZ2UgXSA9IG5ldyBNYXAoKSApO1xuXG5cdFx0aWYgKCBtYXAuaGFzKCBuYW1lICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRtYXAuc2V0KCBuYW1lLCB7XG5cdFx0XHRcdG5hbWUsXG5cdFx0XHRcdHByb3BlcnR5LFxuXHRcdFx0XHR0eXBlXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvcGVydHk7XG5cblx0fVxuXG5cdGhhc0J1aWx0aW4oIG5hbWUsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcblxuXHRcdHJldHVybiAoIHRoaXMuYnVpbHRpbnNbIHNoYWRlclN0YWdlIF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJ1aWx0aW5zWyBzaGFkZXJTdGFnZSBdLmhhcyggbmFtZSApICk7XG5cblx0fVxuXG5cdGdldFZlcnRleEluZGV4KCkge1xuXG5cdFx0aWYgKCB0aGlzLnNoYWRlclN0YWdlID09PSAndmVydGV4JyApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0QnVpbHRpbiggJ3ZlcnRleF9pbmRleCcsICd2ZXJ0ZXhJbmRleCcsICd1MzInLCAnYXR0cmlidXRlJyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuICd2ZXJ0ZXhJbmRleCc7XG5cblx0fVxuXG5cdGJ1aWxkRnVuY3Rpb25Db2RlKCBzaGFkZXJOb2RlICkge1xuXG5cdFx0Y29uc3QgbGF5b3V0ID0gc2hhZGVyTm9kZS5sYXlvdXQ7XG5cdFx0Y29uc3QgZmxvd0RhdGEgPSB0aGlzLmZsb3dTaGFkZXJOb2RlKCBzaGFkZXJOb2RlICk7XG5cblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gW107XG5cblx0XHRmb3IgKCBjb25zdCBpbnB1dCBvZiBsYXlvdXQuaW5wdXRzICkge1xuXG5cdFx0XHRwYXJhbWV0ZXJzLnB1c2goIGlucHV0Lm5hbWUgKyAnIDogJyArIHRoaXMuZ2V0VHlwZSggaW5wdXQudHlwZSApICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0bGV0IGNvZGUgPSBgZm4gJHsgbGF5b3V0Lm5hbWUgfSggJHsgcGFyYW1ldGVycy5qb2luKCAnLCAnICkgfSApIC0+ICR7IHRoaXMuZ2V0VHlwZSggbGF5b3V0LnR5cGUgKSB9IHtcbiR7IGZsb3dEYXRhLnZhcnMgfVxuJHsgZmxvd0RhdGEuY29kZSB9XG5gO1xuXG5cdFx0aWYgKCBmbG93RGF0YS5yZXN1bHQgKSB7XG5cblx0XHRcdGNvZGUgKz0gYFxcdHJldHVybiAkeyBmbG93RGF0YS5yZXN1bHQgfTtcXG5gO1xuXG5cdFx0fVxuXG5cdFx0Y29kZSArPSAnXFxufVxcbic7XG5cblx0XHQvL1xuXG5cdFx0cmV0dXJuIGNvZGU7XG5cblx0fVxuXG5cdGdldEluc3RhbmNlSW5kZXgoKSB7XG5cblx0XHRpZiAoIHRoaXMuc2hhZGVyU3RhZ2UgPT09ICd2ZXJ0ZXgnICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRCdWlsdGluKCAnaW5zdGFuY2VfaW5kZXgnLCAnaW5zdGFuY2VJbmRleCcsICd1MzInLCAnYXR0cmlidXRlJyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuICdpbnN0YW5jZUluZGV4JztcblxuXHR9XG5cblx0Z2V0SW52b2NhdGlvbkxvY2FsSW5kZXgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRCdWlsdGluKCAnbG9jYWxfaW52b2NhdGlvbl9pbmRleCcsICdpbnZvY2F0aW9uTG9jYWxJbmRleCcsICd1MzInLCAnYXR0cmlidXRlJyApO1xuXG5cdH1cblxuXHRnZXRTdWJncm91cFNpemUoKSB7XG5cblx0XHR0aGlzLmVuYWJsZVN1Ykdyb3VwcygpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0QnVpbHRpbiggJ3N1Ymdyb3VwX3NpemUnLCAnc3ViZ3JvdXBTaXplJywgJ3UzMicsICdhdHRyaWJ1dGUnICk7XG5cblx0fVxuXG5cdGdldEludm9jYXRpb25TdWJncm91cEluZGV4KCkge1xuXG5cdFx0dGhpcy5lbmFibGVTdWJHcm91cHMoKTtcblxuXHRcdHJldHVybiB0aGlzLmdldEJ1aWx0aW4oICdzdWJncm91cF9pbnZvY2F0aW9uX2lkJywgJ2ludm9jYXRpb25TdWJncm91cEluZGV4JywgJ3UzMicsICdhdHRyaWJ1dGUnICk7XG5cblx0fVxuXG5cdGdldFN1Ymdyb3VwSW5kZXgoKSB7XG5cblx0XHR0aGlzLmVuYWJsZVN1Ykdyb3VwcygpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0QnVpbHRpbiggJ3N1Ymdyb3VwX2lkJywgJ3N1Ymdyb3VwSW5kZXgnLCAndTMyJywgJ2F0dHJpYnV0ZScgKTtcblxuXHR9XG5cblx0Z2V0RHJhd0luZGV4KCkge1xuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG5cdGdldEZyb250RmFjaW5nKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0QnVpbHRpbiggJ2Zyb250X2ZhY2luZycsICdpc0Zyb250JywgJ2Jvb2wnICk7XG5cblx0fVxuXG5cdGdldEZyYWdDb29yZCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmdldEJ1aWx0aW4oICdwb3NpdGlvbicsICdmcmFnQ29vcmQnLCAndmVjNDxmMzI+JyApICsgJy54eSc7XG5cblx0fVxuXG5cdGdldEZyYWdEZXB0aCgpIHtcblxuXHRcdHJldHVybiAnb3V0cHV0LicgKyB0aGlzLmdldEJ1aWx0aW4oICdmcmFnX2RlcHRoJywgJ2RlcHRoJywgJ2YzMicsICdvdXRwdXQnICk7XG5cblx0fVxuXG5cdGdldENsaXBEaXN0YW5jZSgpIHtcblxuXHRcdHJldHVybiAndmFyeWluZ3MuaHdfY2xpcF9kaXN0YW5jZXMnO1xuXG5cdH1cblxuXHRpc0ZsaXBZKCkge1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRlbmFibGVEaXJlY3RpdmUoIG5hbWUsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcblxuXHRcdGNvbnN0IHN0YWdlID0gdGhpcy5kaXJlY3RpdmVzWyBzaGFkZXJTdGFnZSBdIHx8ICggdGhpcy5kaXJlY3RpdmVzWyBzaGFkZXJTdGFnZSBdID0gbmV3IFNldCgpICk7XG5cdFx0c3RhZ2UuYWRkKCBuYW1lICk7XG5cblx0fVxuXG5cdGdldERpcmVjdGl2ZXMoIHNoYWRlclN0YWdlICkge1xuXG5cdFx0Y29uc3Qgc25pcHBldHMgPSBbXTtcblx0XHRjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5kaXJlY3RpdmVzWyBzaGFkZXJTdGFnZSBdO1xuXG5cdFx0aWYgKCBkaXJlY3RpdmVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IGRpcmVjdGl2ZSBvZiBkaXJlY3RpdmVzICkge1xuXG5cdFx0XHRcdHNuaXBwZXRzLnB1c2goIGBlbmFibGUgJHtkaXJlY3RpdmV9O2AgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNuaXBwZXRzLmpvaW4oICdcXG4nICk7XG5cblx0fVxuXG5cdGVuYWJsZVN1Ykdyb3VwcygpIHtcblxuXHRcdHRoaXMuZW5hYmxlRGlyZWN0aXZlKCAnc3ViZ3JvdXBzJyApO1xuXG5cdH1cblxuXHRlbmFibGVTdWJncm91cHNGMTYoKSB7XG5cblx0XHR0aGlzLmVuYWJsZURpcmVjdGl2ZSggJ3N1Ymdyb3Vwcy1mMTYnICk7XG5cblx0fVxuXG5cdGVuYWJsZUNsaXBEaXN0YW5jZXMoKSB7XG5cblx0XHR0aGlzLmVuYWJsZURpcmVjdGl2ZSggJ2NsaXBfZGlzdGFuY2VzJyApO1xuXG5cdH1cblxuXHRlbmFibGVTaGFkZXJGMTYoKSB7XG5cblx0XHR0aGlzLmVuYWJsZURpcmVjdGl2ZSggJ2YxNicgKTtcblxuXHR9XG5cblx0ZW5hYmxlRHVhbFNvdXJjZUJsZW5kaW5nKCkge1xuXG5cdFx0dGhpcy5lbmFibGVEaXJlY3RpdmUoICdkdWFsX3NvdXJjZV9ibGVuZGluZycgKTtcblxuXHR9XG5cblx0ZW5hYmxlSGFyZHdhcmVDbGlwcGluZyggcGxhbmVDb3VudCApIHtcblxuXHRcdHRoaXMuZW5hYmxlQ2xpcERpc3RhbmNlcygpO1xuXHRcdHRoaXMuZ2V0QnVpbHRpbiggJ2NsaXBfZGlzdGFuY2VzJywgJ2h3X2NsaXBfZGlzdGFuY2VzJywgYGFycmF5PGYzMiwgJHsgcGxhbmVDb3VudCB9ID5gLCAndmVydGV4JyApO1xuXG5cdH1cblxuXHRnZXRCdWlsdGlucyggc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRjb25zdCBzbmlwcGV0cyA9IFtdO1xuXHRcdGNvbnN0IGJ1aWx0aW5zID0gdGhpcy5idWlsdGluc1sgc2hhZGVyU3RhZ2UgXTtcblxuXHRcdGlmICggYnVpbHRpbnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggY29uc3QgeyBuYW1lLCBwcm9wZXJ0eSwgdHlwZSB9IG9mIGJ1aWx0aW5zLnZhbHVlcygpICkge1xuXG5cdFx0XHRcdHNuaXBwZXRzLnB1c2goIGBAYnVpbHRpbiggJHtuYW1lfSApICR7cHJvcGVydHl9IDogJHt0eXBlfWAgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNuaXBwZXRzLmpvaW4oICcsXFxuXFx0JyApO1xuXG5cdH1cblxuXHRnZXRTY29wZWRBcnJheSggbmFtZSwgc2NvcGUsIGJ1ZmZlclR5cGUsIGJ1ZmZlckNvdW50ICkge1xuXG5cdFx0aWYgKCB0aGlzLnNjb3BlZEFycmF5cy5oYXMoIG5hbWUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRoaXMuc2NvcGVkQXJyYXlzLnNldCggbmFtZSwge1xuXHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRzY29wZSxcblx0XHRcdFx0YnVmZmVyVHlwZSxcblx0XHRcdFx0YnVmZmVyQ291bnRcblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuYW1lO1xuXG5cdH1cblxuXHRnZXRTY29wZWRBcnJheXMoIHNoYWRlclN0YWdlICkge1xuXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSAhPT0gJ2NvbXB1dGUnICkge1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRjb25zdCBzbmlwcGV0cyA9IFtdO1xuXG5cdFx0Zm9yICggY29uc3QgeyBuYW1lLCBzY29wZSwgYnVmZmVyVHlwZSwgYnVmZmVyQ291bnQgfSBvZiB0aGlzLnNjb3BlZEFycmF5cy52YWx1ZXMoKSApIHtcblxuXHRcdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSggYnVmZmVyVHlwZSApO1xuXG5cdFx0XHRzbmlwcGV0cy5wdXNoKCBgdmFyPCR7c2NvcGV9PiAke25hbWV9OiBhcnJheTwgJHt0eXBlfSwgJHtidWZmZXJDb3VudH0gPjtgICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc25pcHBldHMuam9pbiggJ1xcbicgKTtcblxuXHR9XG5cblx0Z2V0QXR0cmlidXRlcyggc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRjb25zdCBzbmlwcGV0cyA9IFtdO1xuXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSA9PT0gJ2NvbXB1dGUnICkge1xuXG5cdFx0XHR0aGlzLmdldEJ1aWx0aW4oICdnbG9iYWxfaW52b2NhdGlvbl9pZCcsICdpZCcsICd2ZWMzPHUzMj4nLCAnYXR0cmlidXRlJyApO1xuXHRcdFx0dGhpcy5nZXRCdWlsdGluKCAnd29ya2dyb3VwX2lkJywgJ3dvcmtncm91cElkJywgJ3ZlYzM8dTMyPicsICdhdHRyaWJ1dGUnICk7XG5cdFx0XHR0aGlzLmdldEJ1aWx0aW4oICdsb2NhbF9pbnZvY2F0aW9uX2lkJywgJ2xvY2FsSWQnLCAndmVjMzx1MzI+JywgJ2F0dHJpYnV0ZScgKTtcblx0XHRcdHRoaXMuZ2V0QnVpbHRpbiggJ251bV93b3JrZ3JvdXBzJywgJ251bVdvcmtncm91cHMnLCAndmVjMzx1MzI+JywgJ2F0dHJpYnV0ZScgKTtcblxuXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVyLmhhc0ZlYXR1cmUoICdzdWJncm91cHMnICkgKSB7XG5cblx0XHRcdFx0dGhpcy5lbmFibGVEaXJlY3RpdmUoICdzdWJncm91cHMnLCBzaGFkZXJTdGFnZSApO1xuXHRcdFx0XHR0aGlzLmdldEJ1aWx0aW4oICdzdWJncm91cF9zaXplJywgJ3N1Ymdyb3VwU2l6ZScsICd1MzInLCAnYXR0cmlidXRlJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAndmVydGV4JyB8fCBzaGFkZXJTdGFnZSA9PT0gJ2NvbXB1dGUnICkge1xuXG5cdFx0XHRjb25zdCBidWlsdGlucyA9IHRoaXMuZ2V0QnVpbHRpbnMoICdhdHRyaWJ1dGUnICk7XG5cblx0XHRcdGlmICggYnVpbHRpbnMgKSBzbmlwcGV0cy5wdXNoKCBidWlsdGlucyApO1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5nZXRBdHRyaWJ1dGVzQXJyYXkoKTtcblxuXHRcdFx0Zm9yICggbGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gYXR0cmlidXRlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBpbmRleCBdO1xuXHRcdFx0XHRjb25zdCBuYW1lID0gYXR0cmlidXRlLm5hbWU7XG5cdFx0XHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoIGF0dHJpYnV0ZS50eXBlICk7XG5cblx0XHRcdFx0c25pcHBldHMucHVzaCggYEBsb2NhdGlvbiggJHtpbmRleH0gKSAkeyBuYW1lIH0gOiAkeyB0eXBlIH1gICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBzbmlwcGV0cy5qb2luKCAnLFxcblxcdCcgKTtcblxuXHR9XG5cblx0Z2V0U3RydWN0TWVtYmVycyggc3RydWN0ICkge1xuXG5cdFx0Y29uc3Qgc25pcHBldHMgPSBbXTtcblx0XHRjb25zdCBtZW1iZXJzID0gc3RydWN0LmdldE1lbWJlclR5cGVzKCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBtZW1iZXJzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgbWVtYmVyID0gbWVtYmVyc1sgaSBdO1xuXHRcdFx0c25pcHBldHMucHVzaCggYFxcdEBsb2NhdGlvbiggJHtpfSApIG0ke2l9IDogJHsgbWVtYmVyIH08ZjMyPmAgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGJ1aWx0aW5zID0gdGhpcy5nZXRCdWlsdGlucyggJ291dHB1dCcgKTtcblxuXHRcdGlmICggYnVpbHRpbnMgKSBzbmlwcGV0cy5wdXNoKCAnXFx0JyArIGJ1aWx0aW5zICk7XG5cblx0XHRyZXR1cm4gc25pcHBldHMuam9pbiggJyxcXG4nICk7XG5cblx0fVxuXG5cdGdldFN0cnVjdHMoIHNoYWRlclN0YWdlICkge1xuXG5cdFx0Y29uc3Qgc25pcHBldHMgPSBbXTtcblx0XHRjb25zdCBzdHJ1Y3RzID0gdGhpcy5zdHJ1Y3RzWyBzaGFkZXJTdGFnZSBdO1xuXG5cdFx0Zm9yICggbGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gc3RydWN0cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArKyApIHtcblxuXHRcdFx0Y29uc3Qgc3RydWN0ID0gc3RydWN0c1sgaW5kZXggXTtcblx0XHRcdGNvbnN0IG5hbWUgPSBzdHJ1Y3QubmFtZTtcblxuXHRcdFx0bGV0IHNuaXBwZXQgPSBgXFxzdHJ1Y3QgJHsgbmFtZSB9IHtcXG5gO1xuXHRcdFx0c25pcHBldCArPSB0aGlzLmdldFN0cnVjdE1lbWJlcnMoIHN0cnVjdCApO1xuXHRcdFx0c25pcHBldCArPSAnXFxufSc7XG5cblxuXHRcdFx0c25pcHBldHMucHVzaCggc25pcHBldCApO1xuXG5cdFx0XHRzbmlwcGV0cy5wdXNoKCBgXFxudmFyPHByaXZhdGU+IG91dHB1dCA6ICR7IG5hbWUgfTtcXG5cXG5gICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc25pcHBldHMuam9pbiggJ1xcblxcbicgKTtcblxuXHR9XG5cblx0Z2V0VmFyKCB0eXBlLCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIGB2YXIgJHsgbmFtZSB9IDogJHsgdGhpcy5nZXRUeXBlKCB0eXBlICkgfWA7XG5cblx0fVxuXG5cdGdldFZhcnMoIHNoYWRlclN0YWdlICkge1xuXG5cdFx0Y29uc3Qgc25pcHBldHMgPSBbXTtcblx0XHRjb25zdCB2YXJzID0gdGhpcy52YXJzWyBzaGFkZXJTdGFnZSBdO1xuXG5cdFx0aWYgKCB2YXJzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IHZhcmlhYmxlIG9mIHZhcnMgKSB7XG5cblx0XHRcdFx0c25pcHBldHMucHVzaCggYFxcdCR7IHRoaXMuZ2V0VmFyKCB2YXJpYWJsZS50eXBlLCB2YXJpYWJsZS5uYW1lICkgfTtgICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBgXFxuJHsgc25pcHBldHMuam9pbiggJ1xcbicgKSB9XFxuYDtcblxuXHR9XG5cblx0Z2V0VmFyeWluZ3MoIHNoYWRlclN0YWdlICkge1xuXG5cdFx0Y29uc3Qgc25pcHBldHMgPSBbXTtcblxuXHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICd2ZXJ0ZXgnICkge1xuXG5cdFx0XHR0aGlzLmdldEJ1aWx0aW4oICdwb3NpdGlvbicsICdWZXJ0ZXgnLCAndmVjNDxmMzI+JywgJ3ZlcnRleCcgKTtcblxuXHRcdH1cblxuXHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICd2ZXJ0ZXgnIHx8IHNoYWRlclN0YWdlID09PSAnZnJhZ21lbnQnICkge1xuXG5cdFx0XHRjb25zdCB2YXJ5aW5ncyA9IHRoaXMudmFyeWluZ3M7XG5cdFx0XHRjb25zdCB2YXJzID0gdGhpcy52YXJzWyBzaGFkZXJTdGFnZSBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZhcnlpbmdzLmxlbmd0aDsgaW5kZXggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdmFyeWluZyA9IHZhcnlpbmdzWyBpbmRleCBdO1xuXG5cdFx0XHRcdGlmICggdmFyeWluZy5uZWVkc0ludGVycG9sYXRpb24gKSB7XG5cblx0XHRcdFx0XHRsZXQgYXR0cmlidXRlc1NuaXBwZXQgPSBgQGxvY2F0aW9uKCAke2luZGV4fSApYDtcblxuXHRcdFx0XHRcdGlmICggL14oaW50fHVpbnR8aXZlY3x1dmVjKS8udGVzdCggdmFyeWluZy50eXBlICkgKSB7XG5cblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXNTbmlwcGV0ICs9ICcgQGludGVycG9sYXRlKCBmbGF0ICknO1xuXG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzbmlwcGV0cy5wdXNoKCBgJHsgYXR0cmlidXRlc1NuaXBwZXQgfSAkeyB2YXJ5aW5nLm5hbWUgfSA6ICR7IHRoaXMuZ2V0VHlwZSggdmFyeWluZy50eXBlICkgfWAgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzaGFkZXJTdGFnZSA9PT0gJ3ZlcnRleCcgJiYgdmFycy5pbmNsdWRlcyggdmFyeWluZyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdHZhcnMucHVzaCggdmFyeWluZyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYnVpbHRpbnMgPSB0aGlzLmdldEJ1aWx0aW5zKCBzaGFkZXJTdGFnZSApO1xuXG5cdFx0aWYgKCBidWlsdGlucyApIHNuaXBwZXRzLnB1c2goIGJ1aWx0aW5zICk7XG5cblx0XHRjb25zdCBjb2RlID0gc25pcHBldHMuam9pbiggJyxcXG5cXHQnICk7XG5cblx0XHRyZXR1cm4gc2hhZGVyU3RhZ2UgPT09ICd2ZXJ0ZXgnID8gdGhpcy5fZ2V0V0dTTFN0cnVjdCggJ1ZhcnlpbmdzU3RydWN0JywgJ1xcdCcgKyBjb2RlICkgOiBjb2RlO1xuXG5cdH1cblxuXHRnZXRVbmlmb3Jtcyggc2hhZGVyU3RhZ2UgKSB7XG5cblx0XHRjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXNbIHNoYWRlclN0YWdlIF07XG5cblx0XHRjb25zdCBiaW5kaW5nU25pcHBldHMgPSBbXTtcblx0XHRjb25zdCBidWZmZXJTbmlwcGV0cyA9IFtdO1xuXHRcdGNvbnN0IHN0cnVjdFNuaXBwZXRzID0gW107XG5cdFx0Y29uc3QgdW5pZm9ybUdyb3VwcyA9IHt9O1xuXG5cdFx0Zm9yICggY29uc3QgdW5pZm9ybSBvZiB1bmlmb3JtcyApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXBOYW1lID0gdW5pZm9ybS5ncm91cE5vZGUubmFtZTtcblx0XHRcdGNvbnN0IHVuaWZvcm1JbmRleGVzID0gdGhpcy5iaW5kaW5nc0luZGV4ZXNbIGdyb3VwTmFtZSBdO1xuXG5cdFx0XHRpZiAoIHVuaWZvcm0udHlwZSA9PT0gJ3RleHR1cmUnIHx8IHVuaWZvcm0udHlwZSA9PT0gJ2N1YmVUZXh0dXJlJyB8fCB1bmlmb3JtLnR5cGUgPT09ICdzdG9yYWdlVGV4dHVyZScgfHwgdW5pZm9ybS50eXBlID09PSAndGV4dHVyZTNEJyApIHtcblxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gdW5pZm9ybS5ub2RlLnZhbHVlO1xuXG5cdFx0XHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgJiYgdGhpcy5pc1VuZmlsdGVyYWJsZSggdGV4dHVyZSApID09PSBmYWxzZSAmJiB1bmlmb3JtLm5vZGUuaXNTdG9yYWdlVGV4dHVyZU5vZGUgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMuaXNTYW1wbGVDb21wYXJlKCB0ZXh0dXJlICkgKSB7XG5cblx0XHRcdFx0XHRcdGJpbmRpbmdTbmlwcGV0cy5wdXNoKCBgQGJpbmRpbmcoICR7IHVuaWZvcm1JbmRleGVzLmJpbmRpbmcgKysgfSApIEBncm91cCggJHsgdW5pZm9ybUluZGV4ZXMuZ3JvdXAgfSApIHZhciAkeyB1bmlmb3JtLm5hbWUgfV9zYW1wbGVyIDogc2FtcGxlcl9jb21wYXJpc29uO2AgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGJpbmRpbmdTbmlwcGV0cy5wdXNoKCBgQGJpbmRpbmcoICR7IHVuaWZvcm1JbmRleGVzLmJpbmRpbmcgKysgfSApIEBncm91cCggJHsgdW5pZm9ybUluZGV4ZXMuZ3JvdXAgfSApIHZhciAkeyB1bmlmb3JtLm5hbWUgfV9zYW1wbGVyIDogc2FtcGxlcjtgICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCB0ZXh0dXJlVHlwZTtcblxuXHRcdFx0XHRsZXQgbXVsdGlzYW1wbGVkID0gJyc7XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmlzTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXRUZXh0dXJlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0bXVsdGlzYW1wbGVkID0gJ19tdWx0aXNhbXBsZWQnO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRleHR1cmUuaXNDdWJlVGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmVUeXBlID0gJ3RleHR1cmVfY3ViZTxmMzI+JztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSA9PT0gdHJ1ZSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmVUeXBlID0gJ3RleHR1cmVfMmRfYXJyYXk8ZjMyPic7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RlcHRoVGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmVUeXBlID0gYHRleHR1cmVfZGVwdGgke211bHRpc2FtcGxlZH1fMmRgO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlVHlwZSA9ICd0ZXh0dXJlX2V4dGVybmFsJztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YTNEVGV4dHVyZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmVUeXBlID0gJ3RleHR1cmVfM2Q8ZjMyPic7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdW5pZm9ybS5ub2RlLmlzU3RvcmFnZVRleHR1cmVOb2RlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KCB0ZXh0dXJlICk7XG5cdFx0XHRcdFx0Y29uc3QgYWNjZXNzID0gdGhpcy5nZXRTdG9yYWdlQWNjZXNzKCB1bmlmb3JtLm5vZGUsIHNoYWRlclN0YWdlICk7XG5cblx0XHRcdFx0XHR0ZXh0dXJlVHlwZSA9IGB0ZXh0dXJlX3N0b3JhZ2VfMmQ8JHsgZm9ybWF0IH0sICR7IGFjY2VzcyB9PmA7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNvbXBvbmVudFByZWZpeCA9IHRoaXMuZ2V0Q29tcG9uZW50VHlwZUZyb21UZXh0dXJlKCB0ZXh0dXJlICkuY2hhckF0KCAwICk7XG5cblx0XHRcdFx0XHR0ZXh0dXJlVHlwZSA9IGB0ZXh0dXJlJHttdWx0aXNhbXBsZWR9XzJkPCR7IGNvbXBvbmVudFByZWZpeCB9MzI+YDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmluZGluZ1NuaXBwZXRzLnB1c2goIGBAYmluZGluZyggJHsgdW5pZm9ybUluZGV4ZXMuYmluZGluZyArKyB9ICkgQGdyb3VwKCAkeyB1bmlmb3JtSW5kZXhlcy5ncm91cCB9ICkgdmFyICR7IHVuaWZvcm0ubmFtZSB9IDogJHsgdGV4dHVyZVR5cGUgfTtgICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHVuaWZvcm0udHlwZSA9PT0gJ2J1ZmZlcicgfHwgdW5pZm9ybS50eXBlID09PSAnc3RvcmFnZUJ1ZmZlcicgfHwgdW5pZm9ybS50eXBlID09PSAnaW5kaXJlY3RTdG9yYWdlQnVmZmVyJyApIHtcblxuXHRcdFx0XHRjb25zdCBidWZmZXJOb2RlID0gdW5pZm9ybS5ub2RlO1xuXHRcdFx0XHRjb25zdCBidWZmZXJUeXBlID0gdGhpcy5nZXRUeXBlKCBidWZmZXJOb2RlLmJ1ZmZlclR5cGUgKTtcblx0XHRcdFx0Y29uc3QgYnVmZmVyQ291bnQgPSBidWZmZXJOb2RlLmJ1ZmZlckNvdW50O1xuXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlckNvdW50U25pcHBldCA9IGJ1ZmZlckNvdW50ID4gMCAmJiB1bmlmb3JtLnR5cGUgPT09ICdidWZmZXInID8gJywgJyArIGJ1ZmZlckNvdW50IDogJyc7XG5cdFx0XHRcdGNvbnN0IGJ1ZmZlclR5cGVTbmlwcGV0ID0gYnVmZmVyTm9kZS5pc0F0b21pYyA/IGBhdG9taWM8JHtidWZmZXJUeXBlfT5gIDogYCR7YnVmZmVyVHlwZX1gO1xuXHRcdFx0XHRjb25zdCBidWZmZXJTbmlwcGV0ID0gYFxcdCR7IHVuaWZvcm0ubmFtZSB9IDogYXJyYXk8ICR7IGJ1ZmZlclR5cGVTbmlwcGV0IH0keyBidWZmZXJDb3VudFNuaXBwZXQgfSA+XFxuYDtcblx0XHRcdFx0Y29uc3QgYnVmZmVyQWNjZXNzTW9kZSA9IGJ1ZmZlck5vZGUuaXNTdG9yYWdlQnVmZmVyTm9kZSA/IGBzdG9yYWdlLCAkeyB0aGlzLmdldFN0b3JhZ2VBY2Nlc3MoIGJ1ZmZlck5vZGUsIHNoYWRlclN0YWdlICkgfWAgOiAndW5pZm9ybSc7XG5cblx0XHRcdFx0YnVmZmVyU25pcHBldHMucHVzaCggdGhpcy5fZ2V0V0dTTFN0cnVjdEJpbmRpbmcoICdOb2RlQnVmZmVyXycgKyBidWZmZXJOb2RlLmlkLCBidWZmZXJTbmlwcGV0LCBidWZmZXJBY2Nlc3NNb2RlLCB1bmlmb3JtSW5kZXhlcy5iaW5kaW5nICsrLCB1bmlmb3JtSW5kZXhlcy5ncm91cCApICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgdmVjdG9yVHlwZSA9IHRoaXMuZ2V0VHlwZSggdGhpcy5nZXRWZWN0b3JUeXBlKCB1bmlmb3JtLnR5cGUgKSApO1xuXHRcdFx0XHRjb25zdCBncm91cE5hbWUgPSB1bmlmb3JtLmdyb3VwTm9kZS5uYW1lO1xuXG5cdFx0XHRcdGNvbnN0IGdyb3VwID0gdW5pZm9ybUdyb3Vwc1sgZ3JvdXBOYW1lIF0gfHwgKCB1bmlmb3JtR3JvdXBzWyBncm91cE5hbWUgXSA9IHtcblx0XHRcdFx0XHRpbmRleDogdW5pZm9ybUluZGV4ZXMuYmluZGluZyArKyxcblx0XHRcdFx0XHRpZDogdW5pZm9ybUluZGV4ZXMuZ3JvdXAsXG5cdFx0XHRcdFx0c25pcHBldHM6IFtdXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRncm91cC5zbmlwcGV0cy5wdXNoKCBgXFx0JHsgdW5pZm9ybS5uYW1lIH0gOiAkeyB2ZWN0b3JUeXBlIH1gICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gdW5pZm9ybUdyb3VwcyApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSB1bmlmb3JtR3JvdXBzWyBuYW1lIF07XG5cblx0XHRcdHN0cnVjdFNuaXBwZXRzLnB1c2goIHRoaXMuX2dldFdHU0xTdHJ1Y3RCaW5kaW5nKCBuYW1lLCBncm91cC5zbmlwcGV0cy5qb2luKCAnLFxcbicgKSwgJ3VuaWZvcm0nLCBncm91cC5pbmRleCwgZ3JvdXAuaWQgKSApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGNvZGUgPSBiaW5kaW5nU25pcHBldHMuam9pbiggJ1xcbicgKTtcblx0XHRjb2RlICs9IGJ1ZmZlclNuaXBwZXRzLmpvaW4oICdcXG4nICk7XG5cdFx0Y29kZSArPSBzdHJ1Y3RTbmlwcGV0cy5qb2luKCAnXFxuJyApO1xuXG5cdFx0cmV0dXJuIGNvZGU7XG5cblx0fVxuXG5cdGJ1aWxkQ29kZSgpIHtcblxuXHRcdGNvbnN0IHNoYWRlcnNEYXRhID0gdGhpcy5tYXRlcmlhbCAhPT0gbnVsbCA/IHsgZnJhZ21lbnQ6IHt9LCB2ZXJ0ZXg6IHt9IH0gOiB7IGNvbXB1dGU6IHt9IH07XG5cblx0XHR0aGlzLnNvcnRCaW5kaW5nR3JvdXBzKCk7XG5cblx0XHRmb3IgKCBjb25zdCBzaGFkZXJTdGFnZSBpbiBzaGFkZXJzRGF0YSApIHtcblxuXHRcdFx0Y29uc3Qgc3RhZ2VEYXRhID0gc2hhZGVyc0RhdGFbIHNoYWRlclN0YWdlIF07XG5cdFx0XHRzdGFnZURhdGEudW5pZm9ybXMgPSB0aGlzLmdldFVuaWZvcm1zKCBzaGFkZXJTdGFnZSApO1xuXHRcdFx0c3RhZ2VEYXRhLmF0dHJpYnV0ZXMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoIHNoYWRlclN0YWdlICk7XG5cdFx0XHRzdGFnZURhdGEudmFyeWluZ3MgPSB0aGlzLmdldFZhcnlpbmdzKCBzaGFkZXJTdGFnZSApO1xuXHRcdFx0c3RhZ2VEYXRhLnN0cnVjdHMgPSB0aGlzLmdldFN0cnVjdHMoIHNoYWRlclN0YWdlICk7XG5cdFx0XHRzdGFnZURhdGEudmFycyA9IHRoaXMuZ2V0VmFycyggc2hhZGVyU3RhZ2UgKTtcblx0XHRcdHN0YWdlRGF0YS5jb2RlcyA9IHRoaXMuZ2V0Q29kZXMoIHNoYWRlclN0YWdlICk7XG5cdFx0XHRzdGFnZURhdGEuZGlyZWN0aXZlcyA9IHRoaXMuZ2V0RGlyZWN0aXZlcyggc2hhZGVyU3RhZ2UgKTtcblx0XHRcdHN0YWdlRGF0YS5zY29wZWRBcnJheXMgPSB0aGlzLmdldFNjb3BlZEFycmF5cyggc2hhZGVyU3RhZ2UgKTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0bGV0IGZsb3cgPSAnLy8gY29kZVxcblxcbic7XG5cdFx0XHRmbG93ICs9IHRoaXMuZmxvd0NvZGVbIHNoYWRlclN0YWdlIF07XG5cblx0XHRcdGNvbnN0IGZsb3dOb2RlcyA9IHRoaXMuZmxvd05vZGVzWyBzaGFkZXJTdGFnZSBdO1xuXHRcdFx0Y29uc3QgbWFpbk5vZGUgPSBmbG93Tm9kZXNbIGZsb3dOb2Rlcy5sZW5ndGggLSAxIF07XG5cblx0XHRcdGNvbnN0IG91dHB1dE5vZGUgPSBtYWluTm9kZS5vdXRwdXROb2RlO1xuXHRcdFx0Y29uc3QgaXNPdXRwdXRTdHJ1Y3QgPSAoIG91dHB1dE5vZGUgIT09IHVuZGVmaW5lZCAmJiBvdXRwdXROb2RlLmlzT3V0cHV0U3RydWN0Tm9kZSA9PT0gdHJ1ZSApO1xuXG5cdFx0XHRmb3IgKCBjb25zdCBub2RlIG9mIGZsb3dOb2RlcyApIHtcblxuXHRcdFx0XHRjb25zdCBmbG93U2xvdERhdGEgPSB0aGlzLmdldEZsb3dEYXRhKCBub2RlLyosIHNoYWRlclN0YWdlKi8gKTtcblx0XHRcdFx0Y29uc3Qgc2xvdE5hbWUgPSBub2RlLm5hbWU7XG5cblx0XHRcdFx0aWYgKCBzbG90TmFtZSApIHtcblxuXHRcdFx0XHRcdGlmICggZmxvdy5sZW5ndGggPiAwICkgZmxvdyArPSAnXFxuJztcblxuXHRcdFx0XHRcdGZsb3cgKz0gYFxcdC8vIGZsb3cgLT4gJHsgc2xvdE5hbWUgfVxcblxcdGA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZsb3cgKz0gYCR7IGZsb3dTbG90RGF0YS5jb2RlIH1cXG5cXHRgO1xuXG5cdFx0XHRcdGlmICggbm9kZSA9PT0gbWFpbk5vZGUgJiYgc2hhZGVyU3RhZ2UgIT09ICdjb21wdXRlJyApIHtcblxuXHRcdFx0XHRcdGZsb3cgKz0gJy8vIHJlc3VsdFxcblxcblxcdCc7XG5cblx0XHRcdFx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAndmVydGV4JyApIHtcblxuXHRcdFx0XHRcdFx0ZmxvdyArPSBgdmFyeWluZ3MuVmVydGV4ID0gJHsgZmxvd1Nsb3REYXRhLnJlc3VsdCB9O2A7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBzaGFkZXJTdGFnZSA9PT0gJ2ZyYWdtZW50JyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpc091dHB1dFN0cnVjdCApIHtcblxuXHRcdFx0XHRcdFx0XHRzdGFnZURhdGEucmV0dXJuVHlwZSA9IG91dHB1dE5vZGUubm9kZVR5cGU7XG5cblx0XHRcdFx0XHRcdFx0ZmxvdyArPSBgcmV0dXJuICR7IGZsb3dTbG90RGF0YS5yZXN1bHQgfTtgO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGxldCBzdHJ1Y3RTbmlwcGV0ID0gJ1xcdEBsb2NhdGlvbigwKSBjb2xvcjogdmVjNDxmMzI+JztcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBidWlsdGlucyA9IHRoaXMuZ2V0QnVpbHRpbnMoICdvdXRwdXQnICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBidWlsdGlucyApIHN0cnVjdFNuaXBwZXQgKz0gJyxcXG5cXHQnICsgYnVpbHRpbnM7XG5cblx0XHRcdFx0XHRcdFx0c3RhZ2VEYXRhLnJldHVyblR5cGUgPSAnT3V0cHV0U3RydWN0Jztcblx0XHRcdFx0XHRcdFx0c3RhZ2VEYXRhLnN0cnVjdHMgKz0gdGhpcy5fZ2V0V0dTTFN0cnVjdCggJ091dHB1dFN0cnVjdCcsIHN0cnVjdFNuaXBwZXQgKTtcblx0XHRcdFx0XHRcdFx0c3RhZ2VEYXRhLnN0cnVjdHMgKz0gJ1xcbnZhcjxwcml2YXRlPiBvdXRwdXQgOiBPdXRwdXRTdHJ1Y3Q7XFxuXFxuJztcblxuXHRcdFx0XHRcdFx0XHRmbG93ICs9IGBvdXRwdXQuY29sb3IgPSAkeyBmbG93U2xvdERhdGEucmVzdWx0IH07XFxuXFxuXFx0cmV0dXJuIG91dHB1dDtgO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHN0YWdlRGF0YS5mbG93ID0gZmxvdztcblxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm1hdGVyaWFsICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLnZlcnRleFNoYWRlciA9IHRoaXMuX2dldFdHU0xWZXJ0ZXhDb2RlKCBzaGFkZXJzRGF0YS52ZXJ0ZXggKTtcblx0XHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLl9nZXRXR1NMRnJhZ21lbnRDb2RlKCBzaGFkZXJzRGF0YS5mcmFnbWVudCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlU2hhZGVyID0gdGhpcy5fZ2V0V0dTTENvbXB1dGVDb2RlKCBzaGFkZXJzRGF0YS5jb21wdXRlLCAoIHRoaXMub2JqZWN0Lndvcmtncm91cFNpemUgfHwgWyA2NCBdICkuam9pbiggJywgJyApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldE1ldGhvZCggbWV0aG9kLCBvdXRwdXQgPSBudWxsICkge1xuXG5cdFx0bGV0IHdnc2xNZXRob2Q7XG5cblx0XHRpZiAoIG91dHB1dCAhPT0gbnVsbCApIHtcblxuXHRcdFx0d2dzbE1ldGhvZCA9IHRoaXMuX2dldFdHU0xNZXRob2QoIG1ldGhvZCArICdfJyArIG91dHB1dCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB3Z3NsTWV0aG9kID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHdnc2xNZXRob2QgPSB0aGlzLl9nZXRXR1NMTWV0aG9kKCBtZXRob2QgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB3Z3NsTWV0aG9kIHx8IG1ldGhvZDtcblxuXHR9XG5cblx0Z2V0VHlwZSggdHlwZSApIHtcblxuXHRcdHJldHVybiB3Z3NsVHlwZUxpYlsgdHlwZSBdIHx8IHR5cGU7XG5cblx0fVxuXG5cdGlzQXZhaWxhYmxlKCBuYW1lICkge1xuXG5cdFx0bGV0IHJlc3VsdCA9IHN1cHBvcnRzWyBuYW1lIF07XG5cblx0XHRpZiAoIHJlc3VsdCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIG5hbWUgPT09ICdmbG9hdDMyRmlsdGVyYWJsZScgKSB7XG5cblx0XHRcdFx0cmVzdWx0ID0gdGhpcy5yZW5kZXJlci5oYXNGZWF0dXJlKCAnZmxvYXQzMi1maWx0ZXJhYmxlJyApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSAnY2xpcERpc3RhbmNlJyApIHtcblxuXHRcdFx0XHRyZXN1bHQgPSB0aGlzLnJlbmRlcmVyLmhhc0ZlYXR1cmUoICdjbGlwLWRpc3RhbmNlcycgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzdXBwb3J0c1sgbmFtZSBdID0gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0X2dldFdHU0xNZXRob2QoIG1ldGhvZCApIHtcblxuXHRcdGlmICggd2dzbFBvbHlmaWxsWyBtZXRob2QgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLl9pbmNsdWRlKCBtZXRob2QgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB3Z3NsTWV0aG9kc1sgbWV0aG9kIF07XG5cblx0fVxuXG5cdF9pbmNsdWRlKCBuYW1lICkge1xuXG5cdFx0Y29uc3QgY29kZU5vZGUgPSB3Z3NsUG9seWZpbGxbIG5hbWUgXTtcblx0XHRjb2RlTm9kZS5idWlsZCggdGhpcyApO1xuXG5cdFx0aWYgKCB0aGlzLmN1cnJlbnRGdW5jdGlvbk5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuY3VycmVudEZ1bmN0aW9uTm9kZS5pbmNsdWRlcy5wdXNoKCBjb2RlTm9kZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvZGVOb2RlO1xuXG5cdH1cblxuXHRfZ2V0V0dTTFZlcnRleENvZGUoIHNoYWRlckRhdGEgKSB7XG5cblx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0U2lnbmF0dXJlKCkgfVxuLy8gZGlyZWN0aXZlc1xuJHtzaGFkZXJEYXRhLmRpcmVjdGl2ZXN9XG5cbi8vIHVuaWZvcm1zXG4ke3NoYWRlckRhdGEudW5pZm9ybXN9XG5cbi8vIHZhcnlpbmdzXG4ke3NoYWRlckRhdGEudmFyeWluZ3N9XG52YXI8cHJpdmF0ZT4gdmFyeWluZ3MgOiBWYXJ5aW5nc1N0cnVjdDtcblxuLy8gY29kZXNcbiR7c2hhZGVyRGF0YS5jb2Rlc31cblxuQHZlcnRleFxuZm4gbWFpbiggJHtzaGFkZXJEYXRhLmF0dHJpYnV0ZXN9ICkgLT4gVmFyeWluZ3NTdHJ1Y3Qge1xuXG5cdC8vIHZhcnNcblx0JHtzaGFkZXJEYXRhLnZhcnN9XG5cblx0Ly8gZmxvd1xuXHQke3NoYWRlckRhdGEuZmxvd31cblxuXHRyZXR1cm4gdmFyeWluZ3M7XG5cbn1cbmA7XG5cblx0fVxuXG5cdF9nZXRXR1NMRnJhZ21lbnRDb2RlKCBzaGFkZXJEYXRhICkge1xuXG5cdFx0cmV0dXJuIGAkeyB0aGlzLmdldFNpZ25hdHVyZSgpIH1cbi8vIGdsb2JhbFxuJHsgZGlhZ25vc3RpY3MgfVxuXG4vLyB1bmlmb3Jtc1xuJHtzaGFkZXJEYXRhLnVuaWZvcm1zfVxuXG4vLyBzdHJ1Y3RzXG4ke3NoYWRlckRhdGEuc3RydWN0c31cblxuLy8gY29kZXNcbiR7c2hhZGVyRGF0YS5jb2Rlc31cblxuQGZyYWdtZW50XG5mbiBtYWluKCAke3NoYWRlckRhdGEudmFyeWluZ3N9ICkgLT4gJHtzaGFkZXJEYXRhLnJldHVyblR5cGV9IHtcblxuXHQvLyB2YXJzXG5cdCR7c2hhZGVyRGF0YS52YXJzfVxuXG5cdC8vIGZsb3dcblx0JHtzaGFkZXJEYXRhLmZsb3d9XG5cbn1cbmA7XG5cblx0fVxuXG5cdF9nZXRXR1NMQ29tcHV0ZUNvZGUoIHNoYWRlckRhdGEsIHdvcmtncm91cFNpemUgKSB7XG5cblx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0U2lnbmF0dXJlKCkgfVxuLy8gZGlyZWN0aXZlc1xuJHtzaGFkZXJEYXRhLmRpcmVjdGl2ZXN9XG5cbi8vIHN5c3RlbVxudmFyPHByaXZhdGU+IGluc3RhbmNlSW5kZXggOiB1MzI7XG5cbi8vIGxvY2Fsc1xuJHtzaGFkZXJEYXRhLnNjb3BlZEFycmF5c31cblxuLy8gdW5pZm9ybXNcbiR7c2hhZGVyRGF0YS51bmlmb3Jtc31cblxuLy8gY29kZXNcbiR7c2hhZGVyRGF0YS5jb2Rlc31cblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCAke3dvcmtncm91cFNpemV9IClcbmZuIG1haW4oICR7c2hhZGVyRGF0YS5hdHRyaWJ1dGVzfSApIHtcblxuXHQvLyBzeXN0ZW1cblx0aW5zdGFuY2VJbmRleCA9IGlkLnggKyBpZC55ICogbnVtV29ya2dyb3Vwcy54ICogdTMyKCR7d29ya2dyb3VwU2l6ZX0pICsgaWQueiAqIG51bVdvcmtncm91cHMueCAqIG51bVdvcmtncm91cHMueSAqIHUzMigke3dvcmtncm91cFNpemV9KTtcblxuXHQvLyB2YXJzXG5cdCR7c2hhZGVyRGF0YS52YXJzfVxuXG5cdC8vIGZsb3dcblx0JHtzaGFkZXJEYXRhLmZsb3d9XG5cbn1cbmA7XG5cblx0fVxuXG5cdF9nZXRXR1NMU3RydWN0KCBuYW1lLCB2YXJzICkge1xuXG5cdFx0cmV0dXJuIGBcbnN0cnVjdCAke25hbWV9IHtcbiR7dmFyc31cbn07YDtcblxuXHR9XG5cblx0X2dldFdHU0xTdHJ1Y3RCaW5kaW5nKCBuYW1lLCB2YXJzLCBhY2Nlc3MsIGJpbmRpbmcgPSAwLCBncm91cCA9IDAgKSB7XG5cblx0XHRjb25zdCBzdHJ1Y3ROYW1lID0gbmFtZSArICdTdHJ1Y3QnO1xuXHRcdGNvbnN0IHN0cnVjdFNuaXBwZXQgPSB0aGlzLl9nZXRXR1NMU3RydWN0KCBzdHJ1Y3ROYW1lLCB2YXJzICk7XG5cblx0XHRyZXR1cm4gYCR7c3RydWN0U25pcHBldH1cbkBiaW5kaW5nKCAke2JpbmRpbmd9ICkgQGdyb3VwKCAke2dyb3VwfSApXG52YXI8JHthY2Nlc3N9PiAke25hbWV9IDogJHtzdHJ1Y3ROYW1lfTtgO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBXR1NMTm9kZUJ1aWxkZXI7XG4iLCJpbXBvcnQgeyBHUFVQcmltaXRpdmVUb3BvbG9neSwgR1BVVGV4dHVyZUZvcm1hdCB9IGZyb20gJy4vV2ViR1BVQ29uc3RhbnRzLmpzJztcblxuY2xhc3MgV2ViR1BVVXRpbHMge1xuXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xuXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcblxuXHR9XG5cblx0Z2V0Q3VycmVudERlcHRoU3RlbmNpbEZvcm1hdCggcmVuZGVyQ29udGV4dCApIHtcblxuXHRcdGxldCBmb3JtYXQ7XG5cblx0XHRpZiAoIHJlbmRlckNvbnRleHQuZGVwdGhUZXh0dXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRmb3JtYXQgPSB0aGlzLmdldFRleHR1cmVGb3JtYXRHUFUoIHJlbmRlckNvbnRleHQuZGVwdGhUZXh0dXJlICk7XG5cblx0XHR9IGVsc2UgaWYgKCByZW5kZXJDb250ZXh0LmRlcHRoICYmIHJlbmRlckNvbnRleHQuc3RlbmNpbCApIHtcblxuXHRcdFx0Zm9ybWF0ID0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDI0UGx1c1N0ZW5jaWw4O1xuXG5cdFx0fSBlbHNlIGlmICggcmVuZGVyQ29udGV4dC5kZXB0aCApIHtcblxuXHRcdFx0Zm9ybWF0ID0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDI0UGx1cztcblxuXHRcdH1cblxuXHRcdHJldHVybiBmb3JtYXQ7XG5cblx0fVxuXG5cdGdldFRleHR1cmVGb3JtYXRHUFUoIHRleHR1cmUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5iYWNrZW5kLmdldCggdGV4dHVyZSApLmZvcm1hdDtcblxuXHR9XG5cblx0Z2V0Q3VycmVudENvbG9yRm9ybWF0KCByZW5kZXJDb250ZXh0ICkge1xuXG5cdFx0bGV0IGZvcm1hdDtcblxuXHRcdGlmICggcmVuZGVyQ29udGV4dC50ZXh0dXJlcyAhPT0gbnVsbCApIHtcblxuXHRcdFx0Zm9ybWF0ID0gdGhpcy5nZXRUZXh0dXJlRm9ybWF0R1BVKCByZW5kZXJDb250ZXh0LnRleHR1cmVzWyAwIF0gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGZvcm1hdCA9IHRoaXMuZ2V0UHJlZmVycmVkQ2FudmFzRm9ybWF0KCk7IC8vIGRlZmF1bHQgY29udGV4dCBmb3JtYXRcblxuXHRcdH1cblxuXHRcdHJldHVybiBmb3JtYXQ7XG5cblx0fVxuXG5cdGdldEN1cnJlbnRDb2xvclNwYWNlKCByZW5kZXJDb250ZXh0ICkge1xuXG5cdFx0aWYgKCByZW5kZXJDb250ZXh0LnRleHR1cmVzICE9PSBudWxsICkge1xuXG5cdFx0XHRyZXR1cm4gcmVuZGVyQ29udGV4dC50ZXh0dXJlc1sgMCBdLmNvbG9yU3BhY2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5iYWNrZW5kLnJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2U7XG5cblx0fVxuXG5cdGdldFByaW1pdGl2ZVRvcG9sb2d5KCBvYmplY3QsIG1hdGVyaWFsICkge1xuXG5cdFx0aWYgKCBvYmplY3QuaXNQb2ludHMgKSByZXR1cm4gR1BVUHJpbWl0aXZlVG9wb2xvZ3kuUG9pbnRMaXN0O1xuXHRcdGVsc2UgaWYgKCBvYmplY3QuaXNMaW5lU2VnbWVudHMgfHwgKCBvYmplY3QuaXNNZXNoICYmIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApICkgcmV0dXJuIEdQVVByaW1pdGl2ZVRvcG9sb2d5LkxpbmVMaXN0O1xuXHRcdGVsc2UgaWYgKCBvYmplY3QuaXNMaW5lICkgcmV0dXJuIEdQVVByaW1pdGl2ZVRvcG9sb2d5LkxpbmVTdHJpcDtcblx0XHRlbHNlIGlmICggb2JqZWN0LmlzTWVzaCApIHJldHVybiBHUFVQcmltaXRpdmVUb3BvbG9neS5UcmlhbmdsZUxpc3Q7XG5cblx0fVxuXG5cdGdldFNhbXBsZUNvdW50KCBzYW1wbGVDb3VudCApIHtcblxuXHRcdGxldCBjb3VudCA9IDE7XG5cblx0XHRpZiAoIHNhbXBsZUNvdW50ID4gMSApIHtcblxuXHRcdFx0Ly8gV2ViR1BVIG9ubHkgc3VwcG9ydHMgcG93ZXItb2YtdHdvIHNhbXBsZSBjb3VudHMgYW5kIDIgaXMgbm90IGEgdmFsaWQgdmFsdWVcblx0XHRcdGNvdW50ID0gTWF0aC5wb3coIDIsIE1hdGguZmxvb3IoIE1hdGgubG9nMiggc2FtcGxlQ291bnQgKSApICk7XG5cblx0XHRcdGlmICggY291bnQgPT09IDIgKSB7XG5cblx0XHRcdFx0Y291bnQgPSA0O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY291bnQ7XG5cblx0fVxuXG5cdGdldFNhbXBsZUNvdW50UmVuZGVyQ29udGV4dCggcmVuZGVyQ29udGV4dCApIHtcblxuXHRcdGlmICggcmVuZGVyQ29udGV4dC50ZXh0dXJlcyAhPT0gbnVsbCApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0U2FtcGxlQ291bnQoIHJlbmRlckNvbnRleHQuc2FtcGxlQ291bnQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmdldFNhbXBsZUNvdW50KCB0aGlzLmJhY2tlbmQucmVuZGVyZXIuc2FtcGxlcyApO1xuXG5cdH1cblxuXHRnZXRQcmVmZXJyZWRDYW52YXNGb3JtYXQoKSB7XG5cblx0XHQvLyBUT0RPOiBSZW1vdmUgdGhpcyBjaGVjayB3aGVuIFF1ZXN0IDM0LjUgaXMgb3V0XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzI5MjIxL2ZpbGVzI3IxNzMxODMzOTQ5XG5cblx0XHRpZiAoIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoICdRdWVzdCcgKSApIHtcblxuXHRcdFx0cmV0dXJuIEdQVVRleHR1cmVGb3JtYXQuQkdSQThVbm9ybTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBuYXZpZ2F0b3IuZ3B1LmdldFByZWZlcnJlZENhbnZhc0Zvcm1hdCgpO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJHUFVVdGlscztcbiIsImltcG9ydCB7IEdQVUlucHV0U3RlcE1vZGUgfSBmcm9tICcuL1dlYkdQVUNvbnN0YW50cy5qcyc7XG5cbmltcG9ydCB7IEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi8uLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5cbmNvbnN0IHR5cGVkQXJyYXlzVG9WZXJ0ZXhGb3JtYXRQcmVmaXggPSBuZXcgTWFwKCBbXG5cdFsgSW50OEFycmF5LCBbICdzaW50OCcsICdzbm9ybTgnIF1dLFxuXHRbIFVpbnQ4QXJyYXksIFsgJ3VpbnQ4JywgJ3Vub3JtOCcgXV0sXG5cdFsgSW50MTZBcnJheSwgWyAnc2ludDE2JywgJ3Nub3JtMTYnIF1dLFxuXHRbIFVpbnQxNkFycmF5LCBbICd1aW50MTYnLCAndW5vcm0xNicgXV0sXG5cdFsgSW50MzJBcnJheSwgWyAnc2ludDMyJywgJ3Nub3JtMzInIF1dLFxuXHRbIFVpbnQzMkFycmF5LCBbICd1aW50MzInLCAndW5vcm0zMicgXV0sXG5cdFsgRmxvYXQzMkFycmF5LCBbICdmbG9hdDMyJywgXV0sXG5dICk7XG5cbmNvbnN0IHR5cGVkQXR0cmlidXRlVG9WZXJ0ZXhGb3JtYXRQcmVmaXggPSBuZXcgTWFwKCBbXG5cdFsgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSwgWyAnZmxvYXQxNicsIF1dLFxuXSApO1xuXG5jb25zdCB0eXBlQXJyYXlzVG9WZXJ0ZXhGb3JtYXRQcmVmaXhGb3JJdGVtU2l6ZTEgPSBuZXcgTWFwKCBbXG5cdFsgSW50MzJBcnJheSwgJ3NpbnQzMicgXSxcblx0WyBJbnQxNkFycmF5LCAnc2ludDMyJyBdLCAvLyBwYXRjaCBmb3IgSU5UMTZcblx0WyBVaW50MzJBcnJheSwgJ3VpbnQzMicgXSxcblx0WyBVaW50MTZBcnJheSwgJ3VpbnQzMicgXSwgLy8gcGF0Y2ggZm9yIFVJTlQxNlxuXHRbIEZsb2F0MzJBcnJheSwgJ2Zsb2F0MzInIF1cbl0gKTtcblxuY2xhc3MgV2ViR1BVQXR0cmlidXRlVXRpbHMge1xuXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xuXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcblxuXHR9XG5cblx0Y3JlYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIHVzYWdlICkge1xuXG5cdFx0Y29uc3QgYnVmZmVyQXR0cmlidXRlID0gdGhpcy5fZ2V0QnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKTtcblxuXHRcdGNvbnN0IGJhY2tlbmQgPSB0aGlzLmJhY2tlbmQ7XG5cdFx0Y29uc3QgYnVmZmVyRGF0YSA9IGJhY2tlbmQuZ2V0KCBidWZmZXJBdHRyaWJ1dGUgKTtcblxuXHRcdGxldCBidWZmZXIgPSBidWZmZXJEYXRhLmJ1ZmZlcjtcblxuXHRcdGlmICggYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGRldmljZSA9IGJhY2tlbmQuZGV2aWNlO1xuXG5cdFx0XHRsZXQgYXJyYXkgPSBidWZmZXJBdHRyaWJ1dGUuYXJyYXk7XG5cblx0XHRcdC8vIHBhdGNoIGZvciBJTlQxNiBhbmQgVUlOVDE2XG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5ub3JtYWxpemVkID09PSBmYWxzZSAmJiAoIGFycmF5LmNvbnN0cnVjdG9yID09PSBJbnQxNkFycmF5IHx8IGFycmF5LmNvbnN0cnVjdG9yID09PSBVaW50MTZBcnJheSApICkge1xuXG5cdFx0XHRcdGNvbnN0IHRlbXBBcnJheSA9IG5ldyBVaW50MzJBcnJheSggYXJyYXkubGVuZ3RoICk7XG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHRlbXBBcnJheVsgaSBdID0gYXJyYXlbIGkgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXJyYXkgPSB0ZW1wQXJyYXk7XG5cblx0XHRcdH1cblxuXHRcdFx0YnVmZmVyQXR0cmlidXRlLmFycmF5ID0gYXJyYXk7XG5cblx0XHRcdGlmICggKCBidWZmZXJBdHRyaWJ1dGUuaXNTdG9yYWdlQnVmZmVyQXR0cmlidXRlIHx8IGJ1ZmZlckF0dHJpYnV0ZS5pc1N0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSAmJiBidWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUgPT09IDMgKSB7XG5cblx0XHRcdFx0YXJyYXkgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IoIGJ1ZmZlckF0dHJpYnV0ZS5jb3VudCAqIDQgKTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBidWZmZXJBdHRyaWJ1dGUuY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRhcnJheS5zZXQoIGJ1ZmZlckF0dHJpYnV0ZS5hcnJheS5zdWJhcnJheSggaSAqIDMsIGkgKiAzICsgMyApLCBpICogNCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVcGRhdGUgQnVmZmVyQXR0cmlidXRlXG5cdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZS5pdGVtU2l6ZSA9IDQ7XG5cdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZS5hcnJheSA9IGFycmF5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNpemUgPSBhcnJheS5ieXRlTGVuZ3RoICsgKCAoIDQgLSAoIGFycmF5LmJ5dGVMZW5ndGggJSA0ICkgKSAlIDQgKTsgLy8gZW5zdXJlIDQgYnl0ZSBhbGlnbm1lbnQsIHNlZSAjMjA0NDFcblxuXHRcdFx0YnVmZmVyID0gZGV2aWNlLmNyZWF0ZUJ1ZmZlcigge1xuXHRcdFx0XHRsYWJlbDogYnVmZmVyQXR0cmlidXRlLm5hbWUsXG5cdFx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRcdHVzYWdlOiB1c2FnZSxcblx0XHRcdFx0bWFwcGVkQXRDcmVhdGlvbjogdHJ1ZVxuXHRcdFx0fSApO1xuXG5cdFx0XHRuZXcgYXJyYXkuY29uc3RydWN0b3IoIGJ1ZmZlci5nZXRNYXBwZWRSYW5nZSgpICkuc2V0KCBhcnJheSApO1xuXG5cdFx0XHRidWZmZXIudW5tYXAoKTtcblxuXHRcdFx0YnVmZmVyRGF0YS5idWZmZXIgPSBidWZmZXI7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0Y29uc3QgYnVmZmVyQXR0cmlidXRlID0gdGhpcy5fZ2V0QnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKTtcblxuXHRcdGNvbnN0IGJhY2tlbmQgPSB0aGlzLmJhY2tlbmQ7XG5cdFx0Y29uc3QgZGV2aWNlID0gYmFja2VuZC5kZXZpY2U7XG5cblx0XHRjb25zdCBidWZmZXIgPSBiYWNrZW5kLmdldCggYnVmZmVyQXR0cmlidXRlICkuYnVmZmVyO1xuXG5cdFx0Y29uc3QgYXJyYXkgPSBidWZmZXJBdHRyaWJ1dGUuYXJyYXk7XG5cdFx0Y29uc3QgaXNUeXBlZEFycmF5ID0gdGhpcy5faXNUeXBlZEFycmF5KCBhcnJheSApO1xuXHRcdGNvbnN0IHVwZGF0ZVJhbmdlcyA9IGJ1ZmZlckF0dHJpYnV0ZS51cGRhdGVSYW5nZXM7XG5cblx0XHRpZiAoIHVwZGF0ZVJhbmdlcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXG5cblx0XHRcdGRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihcblx0XHRcdFx0YnVmZmVyLFxuXHRcdFx0XHQwLFxuXHRcdFx0XHRhcnJheSxcblx0XHRcdFx0MFxuXHRcdFx0KTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGJ5dGVPZmZzZXRGYWN0b3IgPSBpc1R5cGVkQXJyYXkgPyAxIDogYXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHVwZGF0ZVJhbmdlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHJhbmdlID0gdXBkYXRlUmFuZ2VzWyBpIF07XG5cblx0XHRcdFx0Y29uc3QgZGF0YU9mZnNldCA9IHJhbmdlLnN0YXJ0ICogYnl0ZU9mZnNldEZhY3Rvcjtcblx0XHRcdFx0Y29uc3Qgc2l6ZSA9IHJhbmdlLmNvdW50ICogYnl0ZU9mZnNldEZhY3RvcjtcblxuXHRcdFx0XHRkZXZpY2UucXVldWUud3JpdGVCdWZmZXIoXG5cdFx0XHRcdFx0YnVmZmVyLFxuXHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0YXJyYXksXG5cdFx0XHRcdFx0ZGF0YU9mZnNldCxcblx0XHRcdFx0XHRzaXplXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdFx0YnVmZmVyQXR0cmlidXRlLmNsZWFyVXBkYXRlUmFuZ2VzKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNyZWF0ZVNoYWRlclZlcnRleEJ1ZmZlcnMoIHJlbmRlck9iamVjdCApIHtcblxuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSByZW5kZXJPYmplY3QuZ2V0QXR0cmlidXRlcygpO1xuXHRcdGNvbnN0IHZlcnRleEJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG5cblx0XHRmb3IgKCBsZXQgc2xvdCA9IDA7IHNsb3QgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgc2xvdCArKyApIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBzbG90IF07XG5cdFx0XHRjb25zdCBieXRlc1BlckVsZW1lbnQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHRcdGNvbnN0IGJ1ZmZlckF0dHJpYnV0ZSA9IHRoaXMuX2dldEJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnlBdHRyaWJ1dGUgKTtcblxuXHRcdFx0bGV0IHZlcnRleEJ1ZmZlckxheW91dCA9IHZlcnRleEJ1ZmZlcnMuZ2V0KCBidWZmZXJBdHRyaWJ1dGUgKTtcblxuXHRcdFx0aWYgKCB2ZXJ0ZXhCdWZmZXJMYXlvdXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRsZXQgYXJyYXlTdHJpZGUsIHN0ZXBNb2RlO1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGFycmF5U3RyaWRlID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YS5zdHJpZGUgKiBieXRlc1BlckVsZW1lbnQ7XG5cdFx0XHRcdFx0c3RlcE1vZGUgPSBnZW9tZXRyeUF0dHJpYnV0ZS5kYXRhLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPyBHUFVJbnB1dFN0ZXBNb2RlLkluc3RhbmNlIDogR1BVSW5wdXRTdGVwTW9kZS5WZXJ0ZXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGFycmF5U3RyaWRlID0gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemUgKiBieXRlc1BlckVsZW1lbnQ7XG5cdFx0XHRcdFx0c3RlcE1vZGUgPSBnZW9tZXRyeUF0dHJpYnV0ZS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA/IEdQVUlucHV0U3RlcE1vZGUuSW5zdGFuY2UgOiBHUFVJbnB1dFN0ZXBNb2RlLlZlcnRleDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcGF0Y2ggZm9yIElOVDE2IGFuZCBVSU5UMTZcblx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZS5ub3JtYWxpemVkID09PSBmYWxzZSAmJiAoIGdlb21ldHJ5QXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yID09PSBJbnQxNkFycmF5IHx8IGdlb21ldHJ5QXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yID09PSBVaW50MTZBcnJheSApICkge1xuXG5cdFx0XHRcdFx0YXJyYXlTdHJpZGUgPSA0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJMYXlvdXQgPSB7XG5cdFx0XHRcdFx0YXJyYXlTdHJpZGUsXG5cdFx0XHRcdFx0YXR0cmlidXRlczogW10sXG5cdFx0XHRcdFx0c3RlcE1vZGVcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJzLnNldCggYnVmZmVyQXR0cmlidXRlLCB2ZXJ0ZXhCdWZmZXJMYXlvdXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmb3JtYXQgPSB0aGlzLl9nZXRWZXJ0ZXhGb3JtYXQoIGdlb21ldHJ5QXR0cmlidXRlICk7XG5cdFx0XHRjb25zdCBvZmZzZXQgPSAoIGdlb21ldHJ5QXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPT09IHRydWUgKSA/IGdlb21ldHJ5QXR0cmlidXRlLm9mZnNldCAqIGJ5dGVzUGVyRWxlbWVudCA6IDA7XG5cblx0XHRcdHZlcnRleEJ1ZmZlckxheW91dC5hdHRyaWJ1dGVzLnB1c2goIHtcblx0XHRcdFx0c2hhZGVyTG9jYXRpb246IHNsb3QsXG5cdFx0XHRcdG9mZnNldCxcblx0XHRcdFx0Zm9ybWF0XG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gQXJyYXkuZnJvbSggdmVydGV4QnVmZmVycy52YWx1ZXMoKSApO1xuXG5cdH1cblxuXHRkZXN0cm95QXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXHRcdGNvbnN0IGRhdGEgPSBiYWNrZW5kLmdldCggdGhpcy5fZ2V0QnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSApO1xuXG5cdFx0ZGF0YS5idWZmZXIuZGVzdHJveSgpO1xuXG5cdFx0YmFja2VuZC5kZWxldGUoIGF0dHJpYnV0ZSApO1xuXG5cdH1cblxuXHRhc3luYyBnZXRBcnJheUJ1ZmZlckFzeW5jKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXHRcdGNvbnN0IGRldmljZSA9IGJhY2tlbmQuZGV2aWNlO1xuXG5cdFx0Y29uc3QgZGF0YSA9IGJhY2tlbmQuZ2V0KCB0aGlzLl9nZXRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApICk7XG5cblx0XHRjb25zdCBidWZmZXJHUFUgPSBkYXRhLmJ1ZmZlcjtcblx0XHRjb25zdCBzaXplID0gYnVmZmVyR1BVLnNpemU7XG5cblx0XHRjb25zdCByZWFkQnVmZmVyR1BVID0gZGV2aWNlLmNyZWF0ZUJ1ZmZlcigge1xuXHRcdFx0bGFiZWw6IGF0dHJpYnV0ZS5uYW1lLFxuXHRcdFx0c2l6ZSxcblx0XHRcdHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEXG5cdFx0fSApO1xuXG5cblx0XHRjb25zdCBjbWRFbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCB7fSApO1xuXG5cdFx0Y21kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXG5cdFx0XHRidWZmZXJHUFUsXG5cdFx0XHQwLFxuXHRcdFx0cmVhZEJ1ZmZlckdQVSxcblx0XHRcdDAsXG5cdFx0XHRzaXplXG5cdFx0KTtcblxuXHRcdHJlYWRCdWZmZXJHUFUudW5tYXAoKTtcblxuXHRcdGNvbnN0IGdwdUNvbW1hbmRzID0gY21kRW5jb2Rlci5maW5pc2goKTtcblx0XHRkZXZpY2UucXVldWUuc3VibWl0KCBbIGdwdUNvbW1hbmRzIF0gKTtcblxuXHRcdGF3YWl0IHJlYWRCdWZmZXJHUFUubWFwQXN5bmMoIEdQVU1hcE1vZGUuUkVBRCApO1xuXG5cdFx0Y29uc3QgYXJyYXlCdWZmZXIgPSByZWFkQnVmZmVyR1BVLmdldE1hcHBlZFJhbmdlKCk7XG5cblx0XHRyZXR1cm4gYXJyYXlCdWZmZXI7XG5cblx0fVxuXG5cdF9nZXRWZXJ0ZXhGb3JtYXQoIGdlb21ldHJ5QXR0cmlidXRlICkge1xuXG5cdFx0Y29uc3QgeyBpdGVtU2l6ZSwgbm9ybWFsaXplZCB9ID0gZ2VvbWV0cnlBdHRyaWJ1dGU7XG5cdFx0Y29uc3QgQXJyYXlUeXBlID0gZ2VvbWV0cnlBdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3I7XG5cdFx0Y29uc3QgQXR0cmlidXRlVHlwZSA9IGdlb21ldHJ5QXR0cmlidXRlLmNvbnN0cnVjdG9yO1xuXG5cdFx0bGV0IGZvcm1hdDtcblxuXHRcdGlmICggaXRlbVNpemUgPT0gMSApIHtcblxuXHRcdFx0Zm9ybWF0ID0gdHlwZUFycmF5c1RvVmVydGV4Rm9ybWF0UHJlZml4Rm9ySXRlbVNpemUxLmdldCggQXJyYXlUeXBlICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBwcmVmaXhPcHRpb25zID0gdHlwZWRBdHRyaWJ1dGVUb1ZlcnRleEZvcm1hdFByZWZpeC5nZXQoIEF0dHJpYnV0ZVR5cGUgKSB8fCB0eXBlZEFycmF5c1RvVmVydGV4Rm9ybWF0UHJlZml4LmdldCggQXJyYXlUeXBlICk7XG5cdFx0XHRjb25zdCBwcmVmaXggPSBwcmVmaXhPcHRpb25zWyBub3JtYWxpemVkID8gMSA6IDAgXTtcblxuXHRcdFx0aWYgKCBwcmVmaXggKSB7XG5cblx0XHRcdFx0Y29uc3QgYnl0ZXNQZXJVbml0ID0gQXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UICogaXRlbVNpemU7XG5cdFx0XHRcdGNvbnN0IHBhZGRlZEJ5dGVzUGVyVW5pdCA9IE1hdGguZmxvb3IoICggYnl0ZXNQZXJVbml0ICsgMyApIC8gNCApICogNDtcblx0XHRcdFx0Y29uc3QgcGFkZGVkSXRlbVNpemUgPSBwYWRkZWRCeXRlc1BlclVuaXQgLyBBcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG5cblx0XHRcdFx0aWYgKCBwYWRkZWRJdGVtU2l6ZSAlIDEgKSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5XZWJHUFVBdHRyaWJ1dGVVdGlsczogQmFkIHZlcnRleCBmb3JtYXQgaXRlbSBzaXplLicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9ybWF0ID0gYCR7cHJlZml4fXgke3BhZGRlZEl0ZW1TaXplfWA7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggISBmb3JtYXQgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHUFVBdHRyaWJ1dGVVdGlsczogVmVydGV4IGZvcm1hdCBub3Qgc3VwcG9ydGVkIHlldC4nICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZm9ybWF0O1xuXG5cdH1cblxuXHRfaXNUeXBlZEFycmF5KCBhcnJheSApIHtcblxuXHRcdHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoIGFycmF5ICkgJiYgISAoIGFycmF5IGluc3RhbmNlb2YgRGF0YVZpZXcgKTtcblxuXHR9XG5cblx0X2dldEJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5kYXRhO1xuXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgV2ViR1BVQXR0cmlidXRlVXRpbHM7XG4iLCJpbXBvcnQge1xuXHRHUFVUZXh0dXJlQXNwZWN0LCBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbiwgR1BVVGV4dHVyZVNhbXBsZVR5cGUsIEdQVUJ1ZmZlckJpbmRpbmdUeXBlLCBHUFVTdG9yYWdlVGV4dHVyZUFjY2Vzc1xufSBmcm9tICcuL1dlYkdQVUNvbnN0YW50cy5qcyc7XG5cbmltcG9ydCB7IEZsb2F0VHlwZSwgSW50VHlwZSwgVW5zaWduZWRJbnRUeXBlIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IE5vZGVBY2Nlc3MgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9jb3JlL2NvbnN0YW50cy5qcyc7XG5cbmNsYXNzIFdlYkdQVUJpbmRpbmdVdGlscyB7XG5cblx0Y29uc3RydWN0b3IoIGJhY2tlbmQgKSB7XG5cblx0XHR0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xuXHRcdHRoaXMuYmluZEdyb3VwTGF5b3V0Q2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG5cdH1cblxuXHRjcmVhdGVCaW5kaW5nc0xheW91dCggYmluZEdyb3VwICkge1xuXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcblx0XHRjb25zdCBkZXZpY2UgPSBiYWNrZW5kLmRldmljZTtcblxuXHRcdGNvbnN0IGVudHJpZXMgPSBbXTtcblxuXHRcdGxldCBpbmRleCA9IDA7XG5cblx0XHRmb3IgKCBjb25zdCBiaW5kaW5nIG9mIGJpbmRHcm91cC5iaW5kaW5ncyApIHtcblxuXHRcdFx0Y29uc3QgYmluZGluZ0dQVSA9IHtcblx0XHRcdFx0YmluZGluZzogaW5kZXggKyssXG5cdFx0XHRcdHZpc2liaWxpdHk6IGJpbmRpbmcudmlzaWJpbGl0eVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCBiaW5kaW5nLmlzVW5pZm9ybUJ1ZmZlciB8fCBiaW5kaW5nLmlzU3RvcmFnZUJ1ZmZlciApIHtcblxuXHRcdFx0XHRjb25zdCBidWZmZXIgPSB7fTsgLy8gR1BVQnVmZmVyQmluZGluZ0xheW91dFxuXG5cdFx0XHRcdGlmICggYmluZGluZy5pc1N0b3JhZ2VCdWZmZXIgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcudmlzaWJpbGl0eSAmIDQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGNvbXB1dGVcblxuXHRcdFx0XHRcdFx0aWYgKCBiaW5kaW5nLmFjY2VzcyA9PT0gTm9kZUFjY2Vzcy5SRUFEX1dSSVRFIHx8IGJpbmRpbmcuYWNjZXNzID09PSBOb2RlQWNjZXNzLldSSVRFX09OTFkgKSB7XG5cblx0XHRcdFx0XHRcdFx0YnVmZmVyLnR5cGUgPSBHUFVCdWZmZXJCaW5kaW5nVHlwZS5TdG9yYWdlO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGJ1ZmZlci50eXBlID0gR1BVQnVmZmVyQmluZGluZ1R5cGUuUmVhZE9ubHlTdG9yYWdlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRidWZmZXIudHlwZSA9IEdQVUJ1ZmZlckJpbmRpbmdUeXBlLlJlYWRPbmx5U3RvcmFnZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmluZGluZ0dQVS5idWZmZXIgPSBidWZmZXI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTYW1wbGVyICkge1xuXG5cdFx0XHRcdGNvbnN0IHNhbXBsZXIgPSB7fTsgLy8gR1BVU2FtcGxlckJpbmRpbmdMYXlvdXRcblxuXHRcdFx0XHRpZiAoIGJpbmRpbmcudGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdGlmICggYmluZGluZy50ZXh0dXJlLmNvbXBhcmVGdW5jdGlvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0c2FtcGxlci50eXBlID0gJ2NvbXBhcmlzb24nO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiaW5kaW5nR1BVLnNhbXBsZXIgPSBzYW1wbGVyO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBiaW5kaW5nLmlzU2FtcGxlZFRleHR1cmUgJiYgYmluZGluZy50ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICkge1xuXG5cdFx0XHRcdGJpbmRpbmdHUFUuZXh0ZXJuYWxUZXh0dXJlID0ge307IC8vIEdQVUV4dGVybmFsVGV4dHVyZUJpbmRpbmdMYXlvdXRcblxuXHRcdFx0fSBlbHNlIGlmICggYmluZGluZy5pc1NhbXBsZWRUZXh0dXJlICYmIGJpbmRpbmcuc3RvcmUgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc3RvcmFnZVRleHR1cmUgPSB7fTsgLy8gR1BVU3RvcmFnZVRleHR1cmVCaW5kaW5nTGF5b3V0XG5cdFx0XHRcdHN0b3JhZ2VUZXh0dXJlLmZvcm1hdCA9IHRoaXMuYmFja2VuZC5nZXQoIGJpbmRpbmcudGV4dHVyZSApLnRleHR1cmUuZm9ybWF0O1xuXG5cdFx0XHRcdGNvbnN0IGFjY2VzcyA9IGJpbmRpbmcuYWNjZXNzO1xuXG5cdFx0XHRcdGlmICggYWNjZXNzID09PSBOb2RlQWNjZXNzLlJFQURfV1JJVEUgKSB7XG5cblx0XHRcdFx0XHRzdG9yYWdlVGV4dHVyZS5hY2Nlc3MgPSBHUFVTdG9yYWdlVGV4dHVyZUFjY2Vzcy5SZWFkV3JpdGU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggYWNjZXNzID09PSBOb2RlQWNjZXNzLldSSVRFX09OTFkgKSB7XG5cblx0XHRcdFx0XHRzdG9yYWdlVGV4dHVyZS5hY2Nlc3MgPSBHUFVTdG9yYWdlVGV4dHVyZUFjY2Vzcy5Xcml0ZU9ubHk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHN0b3JhZ2VUZXh0dXJlLmFjY2VzcyA9IEdQVVN0b3JhZ2VUZXh0dXJlQWNjZXNzLlJlYWRPbmx5O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiaW5kaW5nR1BVLnN0b3JhZ2VUZXh0dXJlID0gc3RvcmFnZVRleHR1cmU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTYW1wbGVkVGV4dHVyZSApIHtcblxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlID0ge307IC8vIEdQVVRleHR1cmVCaW5kaW5nTGF5b3V0XG5cblx0XHRcdFx0aWYgKCBiaW5kaW5nLnRleHR1cmUuaXNNdWx0aXNhbXBsZVJlbmRlclRhcmdldFRleHR1cmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLm11bHRpc2FtcGxlZCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggYmluZGluZy50ZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5zYW1wbGVUeXBlID0gR1BVVGV4dHVyZVNhbXBsZVR5cGUuRGVwdGg7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggYmluZGluZy50ZXh0dXJlLmlzRGF0YVRleHR1cmUgfHwgYmluZGluZy50ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCBiaW5kaW5nLnRleHR1cmUuaXNEYXRhM0RUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdHlwZSA9IGJpbmRpbmcudGV4dHVyZS50eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSBJbnRUeXBlICkge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLnNhbXBsZVR5cGUgPSBHUFVUZXh0dXJlU2FtcGxlVHlwZS5TSW50O1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gVW5zaWduZWRJbnRUeXBlICkge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLnNhbXBsZVR5cGUgPSBHUFVUZXh0dXJlU2FtcGxlVHlwZS5VSW50O1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gRmxvYXRUeXBlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuYmFja2VuZC5oYXNGZWF0dXJlKCAnZmxvYXQzMi1maWx0ZXJhYmxlJyApICkge1xuXG5cdFx0XHRcdFx0XHRcdHRleHR1cmUuc2FtcGxlVHlwZSA9IEdQVVRleHR1cmVTYW1wbGVUeXBlLkZsb2F0O1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHRleHR1cmUuc2FtcGxlVHlwZSA9IEdQVVRleHR1cmVTYW1wbGVUeXBlLlVuZmlsdGVyYWJsZUZsb2F0O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggYmluZGluZy5pc1NhbXBsZWRDdWJlVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUudmlld0RpbWVuc2lvbiA9IEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLkN1YmU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggYmluZGluZy50ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCBiaW5kaW5nLnRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS52aWV3RGltZW5zaW9uID0gR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24uVHdvREFycmF5O1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTYW1wbGVkVGV4dHVyZTNEICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS52aWV3RGltZW5zaW9uID0gR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24uVGhyZWVEO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiaW5kaW5nR1BVLnRleHR1cmUgPSB0ZXh0dXJlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGBXZWJHUFVCaW5kaW5nVXRpbHM6IFVuc3VwcG9ydGVkIGJpbmRpbmcgXCIkeyBiaW5kaW5nIH1cIi5gICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZW50cmllcy5wdXNoKCBiaW5kaW5nR1BVICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCggeyBlbnRyaWVzIH0gKTtcblxuXHR9XG5cblx0Y3JlYXRlQmluZGluZ3MoIGJpbmRHcm91cCwgYmluZGluZ3MsIGNhY2hlSW5kZXgsIHZlcnNpb24gPSAwICkge1xuXG5cdFx0Y29uc3QgeyBiYWNrZW5kLCBiaW5kR3JvdXBMYXlvdXRDYWNoZSB9ID0gdGhpcztcblx0XHRjb25zdCBiaW5kaW5nc0RhdGEgPSBiYWNrZW5kLmdldCggYmluZEdyb3VwICk7XG5cblx0XHQvLyBzZXR1cCAoc3RhdGljKSBiaW5kaW5nIGxheW91dCBhbmQgKGR5bmFtaWMpIGJpbmRpbmcgZ3JvdXBcblxuXHRcdGxldCBiaW5kTGF5b3V0R1BVID0gYmluZEdyb3VwTGF5b3V0Q2FjaGUuZ2V0KCBiaW5kR3JvdXAuYmluZGluZ3NSZWZlcmVuY2UgKTtcblxuXHRcdGlmICggYmluZExheW91dEdQVSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRiaW5kTGF5b3V0R1BVID0gdGhpcy5jcmVhdGVCaW5kaW5nc0xheW91dCggYmluZEdyb3VwICk7XG5cdFx0XHRiaW5kR3JvdXBMYXlvdXRDYWNoZS5zZXQoIGJpbmRHcm91cC5iaW5kaW5nc1JlZmVyZW5jZSwgYmluZExheW91dEdQVSApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGJpbmRHcm91cEdQVTtcblxuXHRcdGlmICggY2FjaGVJbmRleCA+IDAgKSB7XG5cblx0XHRcdGlmICggYmluZGluZ3NEYXRhLmdyb3VwcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGJpbmRpbmdzRGF0YS5ncm91cHMgPSBbXTtcblx0XHRcdFx0YmluZGluZ3NEYXRhLnZlcnNpb25zID0gW107XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBiaW5kaW5nc0RhdGEudmVyc2lvbnNbIGNhY2hlSW5kZXggXSA9PT0gdmVyc2lvbiApIHtcblxuXHRcdFx0XHRiaW5kR3JvdXBHUFUgPSBiaW5kaW5nc0RhdGEuZ3JvdXBzWyBjYWNoZUluZGV4IF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggYmluZEdyb3VwR1BVID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJpbmRHcm91cEdQVSA9IHRoaXMuY3JlYXRlQmluZEdyb3VwKCBiaW5kR3JvdXAsIGJpbmRMYXlvdXRHUFUgKTtcblxuXHRcdFx0aWYgKCBjYWNoZUluZGV4ID4gMCApIHtcblxuXHRcdFx0XHRiaW5kaW5nc0RhdGEuZ3JvdXBzWyBjYWNoZUluZGV4IF0gPSBiaW5kR3JvdXBHUFU7XG5cdFx0XHRcdGJpbmRpbmdzRGF0YS52ZXJzaW9uc1sgY2FjaGVJbmRleCBdID0gdmVyc2lvbjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0YmluZGluZ3NEYXRhLmdyb3VwID0gYmluZEdyb3VwR1BVO1xuXHRcdGJpbmRpbmdzRGF0YS5sYXlvdXQgPSBiaW5kTGF5b3V0R1BVO1xuXG5cdH1cblxuXHR1cGRhdGVCaW5kaW5nKCBiaW5kaW5nICkge1xuXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcblx0XHRjb25zdCBkZXZpY2UgPSBiYWNrZW5kLmRldmljZTtcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IGJpbmRpbmcuYnVmZmVyO1xuXHRcdGNvbnN0IGJ1ZmZlckdQVSA9IGJhY2tlbmQuZ2V0KCBiaW5kaW5nICkuYnVmZmVyO1xuXG5cdFx0ZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKCBidWZmZXJHUFUsIDAsIGJ1ZmZlciwgMCApO1xuXG5cdH1cblxuXHRjcmVhdGVCaW5kR3JvdXAoIGJpbmRHcm91cCwgbGF5b3V0R1BVICkge1xuXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcblx0XHRjb25zdCBkZXZpY2UgPSBiYWNrZW5kLmRldmljZTtcblxuXHRcdGxldCBiaW5kaW5nUG9pbnQgPSAwO1xuXHRcdGNvbnN0IGVudHJpZXNHUFUgPSBbXTtcblxuXHRcdGZvciAoIGNvbnN0IGJpbmRpbmcgb2YgYmluZEdyb3VwLmJpbmRpbmdzICkge1xuXG5cdFx0XHRpZiAoIGJpbmRpbmcuaXNVbmlmb3JtQnVmZmVyICkge1xuXG5cdFx0XHRcdGNvbnN0IGJpbmRpbmdEYXRhID0gYmFja2VuZC5nZXQoIGJpbmRpbmcgKTtcblxuXHRcdFx0XHRpZiAoIGJpbmRpbmdEYXRhLmJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYnl0ZUxlbmd0aCA9IGJpbmRpbmcuYnl0ZUxlbmd0aDtcblxuXHRcdFx0XHRcdGNvbnN0IHVzYWdlID0gR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xuXG5cdFx0XHRcdFx0Y29uc3QgYnVmZmVyR1BVID0gZGV2aWNlLmNyZWF0ZUJ1ZmZlcigge1xuXHRcdFx0XHRcdFx0bGFiZWw6ICdiaW5kaW5nQnVmZmVyXycgKyBiaW5kaW5nLm5hbWUsXG5cdFx0XHRcdFx0XHRzaXplOiBieXRlTGVuZ3RoLFxuXHRcdFx0XHRcdFx0dXNhZ2U6IHVzYWdlXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0YmluZGluZ0RhdGEuYnVmZmVyID0gYnVmZmVyR1BVO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbnRyaWVzR1BVLnB1c2goIHsgYmluZGluZzogYmluZGluZ1BvaW50LCByZXNvdXJjZTogeyBidWZmZXI6IGJpbmRpbmdEYXRhLmJ1ZmZlciB9IH0gKTtcblxuXHRcdFx0fSBlbHNlIGlmICggYmluZGluZy5pc1N0b3JhZ2VCdWZmZXIgKSB7XG5cblx0XHRcdFx0Y29uc3QgYmluZGluZ0RhdGEgPSBiYWNrZW5kLmdldCggYmluZGluZyApO1xuXG5cdFx0XHRcdGlmICggYmluZGluZ0RhdGEuYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBiaW5kaW5nLmF0dHJpYnV0ZTtcblx0XHRcdFx0XHQvL2NvbnN0IHVzYWdlID0gR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSB8IEdQVUJ1ZmZlclVzYWdlLlZFUlRFWCB8IC8qR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfCovIEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xuXG5cdFx0XHRcdFx0Ly9iYWNrZW5kLmF0dHJpYnV0ZVV0aWxzLmNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCB1c2FnZSApOyAvLyBAVE9ETzogTW92ZSBpdCB0byB1bml2ZXJzYWwgcmVuZGVyZXJcblxuXHRcdFx0XHRcdGJpbmRpbmdEYXRhLmJ1ZmZlciA9IGJhY2tlbmQuZ2V0KCBhdHRyaWJ1dGUgKS5idWZmZXI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVudHJpZXNHUFUucHVzaCggeyBiaW5kaW5nOiBiaW5kaW5nUG9pbnQsIHJlc291cmNlOiB7IGJ1ZmZlcjogYmluZGluZ0RhdGEuYnVmZmVyIH0gfSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBiaW5kaW5nLmlzU2FtcGxlciApIHtcblxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlR1BVID0gYmFja2VuZC5nZXQoIGJpbmRpbmcudGV4dHVyZSApO1xuXG5cdFx0XHRcdGVudHJpZXNHUFUucHVzaCggeyBiaW5kaW5nOiBiaW5kaW5nUG9pbnQsIHJlc291cmNlOiB0ZXh0dXJlR1BVLnNhbXBsZXIgfSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBiaW5kaW5nLmlzU2FtcGxlZFRleHR1cmUgKSB7XG5cblx0XHRcdFx0Y29uc3QgdGV4dHVyZURhdGEgPSBiYWNrZW5kLmdldCggYmluZGluZy50ZXh0dXJlICk7XG5cblx0XHRcdFx0bGV0IHJlc291cmNlR1BVO1xuXG5cdFx0XHRcdGlmICggdGV4dHVyZURhdGEuZXh0ZXJuYWxUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRyZXNvdXJjZUdQVSA9IGRldmljZS5pbXBvcnRFeHRlcm5hbFRleHR1cmUoIHsgc291cmNlOiB0ZXh0dXJlRGF0YS5leHRlcm5hbFRleHR1cmUgfSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zdCBtaXBMZXZlbENvdW50ID0gYmluZGluZy5zdG9yZSA/IDEgOiB0ZXh0dXJlRGF0YS50ZXh0dXJlLm1pcExldmVsQ291bnQ7XG5cdFx0XHRcdFx0Y29uc3QgcHJvcGVydHlOYW1lID0gYHZpZXctJHsgdGV4dHVyZURhdGEudGV4dHVyZS53aWR0aCB9LSR7IHRleHR1cmVEYXRhLnRleHR1cmUuaGVpZ2h0IH0tJHsgbWlwTGV2ZWxDb3VudCB9YDtcblxuXHRcdFx0XHRcdHJlc291cmNlR1BVID0gdGV4dHVyZURhdGFbIHByb3BlcnR5TmFtZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCByZXNvdXJjZUdQVSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhc3BlY3RHUFUgPSBHUFVUZXh0dXJlQXNwZWN0LkFsbDtcblxuXHRcdFx0XHRcdFx0bGV0IGRpbWVuc2lvblZpZXdHUFU7XG5cblx0XHRcdFx0XHRcdGlmICggYmluZGluZy5pc1NhbXBsZWRDdWJlVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdFx0XHRkaW1lbnNpb25WaWV3R1BVID0gR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24uQ3ViZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYmluZGluZy5pc1NhbXBsZWRUZXh0dXJlM0QgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZGltZW5zaW9uVmlld0dQVSA9IEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLlRocmVlRDtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYmluZGluZy50ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCBiaW5kaW5nLnRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0XHRcdGRpbWVuc2lvblZpZXdHUFUgPSBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbi5Ud29EQXJyYXk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0ZGltZW5zaW9uVmlld0dQVSA9IEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLlR3b0Q7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmVzb3VyY2VHUFUgPSB0ZXh0dXJlRGF0YVsgcHJvcGVydHlOYW1lIF0gPSB0ZXh0dXJlRGF0YS50ZXh0dXJlLmNyZWF0ZVZpZXcoIHsgYXNwZWN0OiBhc3BlY3RHUFUsIGRpbWVuc2lvbjogZGltZW5zaW9uVmlld0dQVSwgbWlwTGV2ZWxDb3VudCB9ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVudHJpZXNHUFUucHVzaCggeyBiaW5kaW5nOiBiaW5kaW5nUG9pbnQsIHJlc291cmNlOiByZXNvdXJjZUdQVSB9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YmluZGluZ1BvaW50ICsrO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRldmljZS5jcmVhdGVCaW5kR3JvdXAoIHtcblx0XHRcdGxhYmVsOiAnYmluZEdyb3VwXycgKyBiaW5kR3JvdXAubmFtZSxcblx0XHRcdGxheW91dDogbGF5b3V0R1BVLFxuXHRcdFx0ZW50cmllczogZW50cmllc0dQVVxuXHRcdH0gKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgV2ViR1BVQmluZGluZ1V0aWxzO1xuIiwiaW1wb3J0IHsgQmxlbmRDb2xvckZhY3RvciwgT25lTWludXNCbGVuZENvbG9yRmFjdG9yLCB9IGZyb20gJy4uLy4uL2NvbW1vbi9Db25zdGFudHMuanMnO1xuXG5pbXBvcnQge1xuXHRHUFVGcm9udEZhY2UsIEdQVUN1bGxNb2RlLCBHUFVDb2xvcldyaXRlRmxhZ3MsIEdQVUNvbXBhcmVGdW5jdGlvbiwgR1BVQmxlbmRGYWN0b3IsIEdQVUJsZW5kT3BlcmF0aW9uLCBHUFVJbmRleEZvcm1hdCwgR1BVU3RlbmNpbE9wZXJhdGlvblxufSBmcm9tICcuL1dlYkdQVUNvbnN0YW50cy5qcyc7XG5cbmltcG9ydCB7XG5cdEZyb250U2lkZSwgQmFja1NpZGUsIERvdWJsZVNpZGUsXG5cdE5ldmVyRGVwdGgsIEFsd2F5c0RlcHRoLCBMZXNzRGVwdGgsIExlc3NFcXVhbERlcHRoLCBFcXVhbERlcHRoLCBHcmVhdGVyRXF1YWxEZXB0aCwgR3JlYXRlckRlcHRoLCBOb3RFcXVhbERlcHRoLFxuXHROb0JsZW5kaW5nLCBOb3JtYWxCbGVuZGluZywgQWRkaXRpdmVCbGVuZGluZywgU3VidHJhY3RpdmVCbGVuZGluZywgTXVsdGlwbHlCbGVuZGluZywgQ3VzdG9tQmxlbmRpbmcsXG5cdFplcm9GYWN0b3IsIE9uZUZhY3RvciwgU3JjQ29sb3JGYWN0b3IsIE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IsIFNyY0FscGhhRmFjdG9yLCBPbmVNaW51c1NyY0FscGhhRmFjdG9yLCBEc3RDb2xvckZhY3Rvcixcblx0T25lTWludXNEc3RDb2xvckZhY3RvciwgRHN0QWxwaGFGYWN0b3IsIE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IsIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IsXG5cdEFkZEVxdWF0aW9uLCBTdWJ0cmFjdEVxdWF0aW9uLCBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiwgTWluRXF1YXRpb24sIE1heEVxdWF0aW9uLFxuXHRLZWVwU3RlbmNpbE9wLCBaZXJvU3RlbmNpbE9wLCBSZXBsYWNlU3RlbmNpbE9wLCBJbnZlcnRTdGVuY2lsT3AsIEluY3JlbWVudFN0ZW5jaWxPcCwgRGVjcmVtZW50U3RlbmNpbE9wLCBJbmNyZW1lbnRXcmFwU3RlbmNpbE9wLCBEZWNyZW1lbnRXcmFwU3RlbmNpbE9wLFxuXHROZXZlclN0ZW5jaWxGdW5jLCBBbHdheXNTdGVuY2lsRnVuYywgTGVzc1N0ZW5jaWxGdW5jLCBMZXNzRXF1YWxTdGVuY2lsRnVuYywgRXF1YWxTdGVuY2lsRnVuYywgR3JlYXRlckVxdWFsU3RlbmNpbEZ1bmMsIEdyZWF0ZXJTdGVuY2lsRnVuYywgTm90RXF1YWxTdGVuY2lsRnVuY1xufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuXG5jbGFzcyBXZWJHUFVQaXBlbGluZVV0aWxzIHtcblxuXHRjb25zdHJ1Y3RvciggYmFja2VuZCApIHtcblxuXHRcdHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XG5cblx0fVxuXG5cdF9nZXRTYW1wbGVDb3VudCggcmVuZGVyT2JqZWN0Q29udGV4dCApIHtcblxuXHRcdHJldHVybiB0aGlzLmJhY2tlbmQudXRpbHMuZ2V0U2FtcGxlQ291bnRSZW5kZXJDb250ZXh0KCByZW5kZXJPYmplY3RDb250ZXh0ICk7XG5cblx0fVxuXG5cdGNyZWF0ZVJlbmRlclBpcGVsaW5lKCByZW5kZXJPYmplY3QsIHByb21pc2VzICkge1xuXG5cdFx0Y29uc3QgeyBvYmplY3QsIG1hdGVyaWFsLCBnZW9tZXRyeSwgcGlwZWxpbmUgfSA9IHJlbmRlck9iamVjdDtcblx0XHRjb25zdCB7IHZlcnRleFByb2dyYW0sIGZyYWdtZW50UHJvZ3JhbSB9ID0gcGlwZWxpbmU7XG5cblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXHRcdGNvbnN0IGRldmljZSA9IGJhY2tlbmQuZGV2aWNlO1xuXHRcdGNvbnN0IHV0aWxzID0gYmFja2VuZC51dGlscztcblxuXHRcdGNvbnN0IHBpcGVsaW5lRGF0YSA9IGJhY2tlbmQuZ2V0KCBwaXBlbGluZSApO1xuXG5cdFx0Ly8gYmluZCBncm91cCBsYXlvdXRzXG5cblx0XHRjb25zdCBiaW5kR3JvdXBMYXlvdXRzID0gW107XG5cblx0XHRmb3IgKCBjb25zdCBiaW5kR3JvdXAgb2YgcmVuZGVyT2JqZWN0LmdldEJpbmRpbmdzKCkgKSB7XG5cblx0XHRcdGNvbnN0IGJpbmRpbmdzRGF0YSA9IGJhY2tlbmQuZ2V0KCBiaW5kR3JvdXAgKTtcblxuXHRcdFx0YmluZEdyb3VwTGF5b3V0cy5wdXNoKCBiaW5kaW5nc0RhdGEubGF5b3V0ICk7XG5cblx0XHR9XG5cblx0XHQvLyB2ZXJ0ZXggYnVmZmVyc1xuXG5cdFx0Y29uc3QgdmVydGV4QnVmZmVycyA9IGJhY2tlbmQuYXR0cmlidXRlVXRpbHMuY3JlYXRlU2hhZGVyVmVydGV4QnVmZmVycyggcmVuZGVyT2JqZWN0ICk7XG5cblx0XHQvLyBibGVuZGluZ1xuXG5cdFx0bGV0IGJsZW5kaW5nO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSAmJiBtYXRlcmlhbC5ibGVuZGluZyAhPT0gTm9CbGVuZGluZyApIHtcblxuXHRcdFx0YmxlbmRpbmcgPSB0aGlzLl9nZXRCbGVuZGluZyggbWF0ZXJpYWwgKTtcblxuXHRcdH1cblxuXHRcdC8vIHN0ZW5jaWxcblxuXHRcdGxldCBzdGVuY2lsRnJvbnQgPSB7fTtcblxuXHRcdGlmICggbWF0ZXJpYWwuc3RlbmNpbFdyaXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRzdGVuY2lsRnJvbnQgPSB7XG5cdFx0XHRcdGNvbXBhcmU6IHRoaXMuX2dldFN0ZW5jaWxDb21wYXJlKCBtYXRlcmlhbCApLFxuXHRcdFx0XHRmYWlsT3A6IHRoaXMuX2dldFN0ZW5jaWxPcGVyYXRpb24oIG1hdGVyaWFsLnN0ZW5jaWxGYWlsICksXG5cdFx0XHRcdGRlcHRoRmFpbE9wOiB0aGlzLl9nZXRTdGVuY2lsT3BlcmF0aW9uKCBtYXRlcmlhbC5zdGVuY2lsWkZhaWwgKSxcblx0XHRcdFx0cGFzc09wOiB0aGlzLl9nZXRTdGVuY2lsT3BlcmF0aW9uKCBtYXRlcmlhbC5zdGVuY2lsWlBhc3MgKVxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGNvbG9yV3JpdGVNYXNrID0gdGhpcy5fZ2V0Q29sb3JXcml0ZU1hc2soIG1hdGVyaWFsICk7XG5cblx0XHRjb25zdCB0YXJnZXRzID0gW107XG5cblx0XHRpZiAoIHJlbmRlck9iamVjdC5jb250ZXh0LnRleHR1cmVzICE9PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlck9iamVjdC5jb250ZXh0LnRleHR1cmVzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY29sb3JGb3JtYXQgPSB1dGlscy5nZXRUZXh0dXJlRm9ybWF0R1BVKCB0ZXh0dXJlc1sgaSBdICk7XG5cblx0XHRcdFx0dGFyZ2V0cy5wdXNoKCB7XG5cdFx0XHRcdFx0Zm9ybWF0OiBjb2xvckZvcm1hdCxcblx0XHRcdFx0XHRibGVuZDogYmxlbmRpbmcsXG5cdFx0XHRcdFx0d3JpdGVNYXNrOiBjb2xvcldyaXRlTWFza1xuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGNvbG9yRm9ybWF0ID0gdXRpbHMuZ2V0Q3VycmVudENvbG9yRm9ybWF0KCByZW5kZXJPYmplY3QuY29udGV4dCApO1xuXG5cdFx0XHR0YXJnZXRzLnB1c2goIHtcblx0XHRcdFx0Zm9ybWF0OiBjb2xvckZvcm1hdCxcblx0XHRcdFx0YmxlbmQ6IGJsZW5kaW5nLFxuXHRcdFx0XHR3cml0ZU1hc2s6IGNvbG9yV3JpdGVNYXNrXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2ZXJ0ZXhNb2R1bGUgPSBiYWNrZW5kLmdldCggdmVydGV4UHJvZ3JhbSApLm1vZHVsZTtcblx0XHRjb25zdCBmcmFnbWVudE1vZHVsZSA9IGJhY2tlbmQuZ2V0KCBmcmFnbWVudFByb2dyYW0gKS5tb2R1bGU7XG5cblx0XHRjb25zdCBwcmltaXRpdmVTdGF0ZSA9IHRoaXMuX2dldFByaW1pdGl2ZVN0YXRlKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHRcdGNvbnN0IGRlcHRoQ29tcGFyZSA9IHRoaXMuX2dldERlcHRoQ29tcGFyZSggbWF0ZXJpYWwgKTtcblx0XHRjb25zdCBkZXB0aFN0ZW5jaWxGb3JtYXQgPSB1dGlscy5nZXRDdXJyZW50RGVwdGhTdGVuY2lsRm9ybWF0KCByZW5kZXJPYmplY3QuY29udGV4dCApO1xuXG5cdFx0Y29uc3Qgc2FtcGxlQ291bnQgPSB0aGlzLl9nZXRTYW1wbGVDb3VudCggcmVuZGVyT2JqZWN0LmNvbnRleHQgKTtcblxuXHRcdGNvbnN0IHBpcGVsaW5lRGVzY3JpcHRvciA9IHtcblx0XHRcdGxhYmVsOiBgcmVuZGVyUGlwZWxpbmVfJHsgbWF0ZXJpYWwubmFtZSB8fCBtYXRlcmlhbC50eXBlIH1fJHsgbWF0ZXJpYWwuaWQgfWAsXG5cdFx0XHR2ZXJ0ZXg6IE9iamVjdC5hc3NpZ24oIHt9LCB2ZXJ0ZXhNb2R1bGUsIHsgYnVmZmVyczogdmVydGV4QnVmZmVycyB9ICksXG5cdFx0XHRmcmFnbWVudDogT2JqZWN0LmFzc2lnbigge30sIGZyYWdtZW50TW9kdWxlLCB7IHRhcmdldHMgfSApLFxuXHRcdFx0cHJpbWl0aXZlOiBwcmltaXRpdmVTdGF0ZSxcblx0XHRcdG11bHRpc2FtcGxlOiB7XG5cdFx0XHRcdGNvdW50OiBzYW1wbGVDb3VudCxcblx0XHRcdFx0YWxwaGFUb0NvdmVyYWdlRW5hYmxlZDogbWF0ZXJpYWwuYWxwaGFUb0NvdmVyYWdlICYmIHNhbXBsZUNvdW50ID4gMVxuXHRcdFx0fSxcblx0XHRcdGxheW91dDogZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KCB7XG5cdFx0XHRcdGJpbmRHcm91cExheW91dHNcblx0XHRcdH0gKVxuXHRcdH07XG5cblxuXHRcdGNvbnN0IGRlcHRoU3RlbmNpbCA9IHt9O1xuXHRcdGNvbnN0IHJlbmRlckRlcHRoID0gcmVuZGVyT2JqZWN0LmNvbnRleHQuZGVwdGg7XG5cdFx0Y29uc3QgcmVuZGVyU3RlbmNpbCA9IHJlbmRlck9iamVjdC5jb250ZXh0LnN0ZW5jaWw7XG5cblx0XHRpZiAoIHJlbmRlckRlcHRoID09PSB0cnVlIHx8IHJlbmRlclN0ZW5jaWwgPT09IHRydWUgKSB7XG5cblx0XHRcdGlmICggcmVuZGVyRGVwdGggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0ZGVwdGhTdGVuY2lsLmZvcm1hdCA9IGRlcHRoU3RlbmNpbEZvcm1hdDtcblx0XHRcdFx0ZGVwdGhTdGVuY2lsLmRlcHRoV3JpdGVFbmFibGVkID0gbWF0ZXJpYWwuZGVwdGhXcml0ZTtcblx0XHRcdFx0ZGVwdGhTdGVuY2lsLmRlcHRoQ29tcGFyZSA9IGRlcHRoQ29tcGFyZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHJlbmRlclN0ZW5jaWwgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0ZGVwdGhTdGVuY2lsLnN0ZW5jaWxGcm9udCA9IHN0ZW5jaWxGcm9udDtcblx0XHRcdFx0ZGVwdGhTdGVuY2lsLnN0ZW5jaWxCYWNrID0ge307IC8vIHRocmVlLmpzIGRvZXMgbm90IHByb3ZpZGUgYW4gQVBJIHRvIGNvbmZpZ3VyZSB0aGUgYmFjayBmdW5jdGlvbiAoZ2wuc3RlbmNpbEZ1bmNTZXBhcmF0ZSgpIHdhcyBuZXZlciB1c2VkKVxuXHRcdFx0XHRkZXB0aFN0ZW5jaWwuc3RlbmNpbFJlYWRNYXNrID0gbWF0ZXJpYWwuc3RlbmNpbEZ1bmNNYXNrO1xuXHRcdFx0XHRkZXB0aFN0ZW5jaWwuc3RlbmNpbFdyaXRlTWFzayA9IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2s7XG5cblx0XHRcdH1cblxuXHRcdFx0cGlwZWxpbmVEZXNjcmlwdG9yLmRlcHRoU3RlbmNpbCA9IGRlcHRoU3RlbmNpbDtcblxuXHRcdH1cblxuXG5cdFx0aWYgKCBwcm9taXNlcyA9PT0gbnVsbCApIHtcblxuXHRcdFx0cGlwZWxpbmVEYXRhLnBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKCBwaXBlbGluZURlc2NyaXB0b3IgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHAgPSBuZXcgUHJvbWlzZSggKCByZXNvbHZlIC8qLCByZWplY3QqLyApID0+IHtcblxuXHRcdFx0XHRkZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmVBc3luYyggcGlwZWxpbmVEZXNjcmlwdG9yICkudGhlbiggcGlwZWxpbmUgPT4ge1xuXG5cdFx0XHRcdFx0cGlwZWxpbmVEYXRhLnBpcGVsaW5lID0gcGlwZWxpbmU7XG5cdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRwcm9taXNlcy5wdXNoKCBwICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNyZWF0ZUJ1bmRsZUVuY29kZXIoIHJlbmRlckNvbnRleHQgKSB7XG5cblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXHRcdGNvbnN0IHsgdXRpbHMsIGRldmljZSB9ID0gYmFja2VuZDtcblxuXHRcdGNvbnN0IGRlcHRoU3RlbmNpbEZvcm1hdCA9IHV0aWxzLmdldEN1cnJlbnREZXB0aFN0ZW5jaWxGb3JtYXQoIHJlbmRlckNvbnRleHQgKTtcblx0XHRjb25zdCBjb2xvckZvcm1hdCA9IHV0aWxzLmdldEN1cnJlbnRDb2xvckZvcm1hdCggcmVuZGVyQ29udGV4dCApO1xuXHRcdGNvbnN0IHNhbXBsZUNvdW50ID0gdGhpcy5fZ2V0U2FtcGxlQ291bnQoIHJlbmRlckNvbnRleHQgKTtcblxuXHRcdGNvbnN0IGRlc2NyaXB0b3IgPSB7XG5cdFx0XHRsYWJlbDogJ3JlbmRlckJ1bmRsZUVuY29kZXInLFxuXHRcdFx0Y29sb3JGb3JtYXRzOiBbIGNvbG9yRm9ybWF0IF0sXG5cdFx0XHRkZXB0aFN0ZW5jaWxGb3JtYXQsXG5cdFx0XHRzYW1wbGVDb3VudFxuXHRcdH07XG5cblx0XHRyZXR1cm4gZGV2aWNlLmNyZWF0ZVJlbmRlckJ1bmRsZUVuY29kZXIoIGRlc2NyaXB0b3IgKTtcblxuXHR9XG5cblx0Y3JlYXRlQ29tcHV0ZVBpcGVsaW5lKCBwaXBlbGluZSwgYmluZGluZ3MgKSB7XG5cblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xuXHRcdGNvbnN0IGRldmljZSA9IGJhY2tlbmQuZGV2aWNlO1xuXG5cdFx0Y29uc3QgY29tcHV0ZVByb2dyYW0gPSBiYWNrZW5kLmdldCggcGlwZWxpbmUuY29tcHV0ZVByb2dyYW0gKS5tb2R1bGU7XG5cblx0XHRjb25zdCBwaXBlbGluZUdQVSA9IGJhY2tlbmQuZ2V0KCBwaXBlbGluZSApO1xuXG5cdFx0Ly8gYmluZCBncm91cCBsYXlvdXRzXG5cblx0XHRjb25zdCBiaW5kR3JvdXBMYXlvdXRzID0gW107XG5cblx0XHRmb3IgKCBjb25zdCBiaW5kaW5nc0dyb3VwIG9mIGJpbmRpbmdzICkge1xuXG5cdFx0XHRjb25zdCBiaW5kaW5nc0RhdGEgPSBiYWNrZW5kLmdldCggYmluZGluZ3NHcm91cCApO1xuXG5cdFx0XHRiaW5kR3JvdXBMYXlvdXRzLnB1c2goIGJpbmRpbmdzRGF0YS5sYXlvdXQgKTtcblxuXHRcdH1cblxuXHRcdHBpcGVsaW5lR1BVLnBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSgge1xuXHRcdFx0Y29tcHV0ZTogY29tcHV0ZVByb2dyYW0sXG5cdFx0XHRsYXlvdXQ6IGRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dCgge1xuXHRcdFx0XHRiaW5kR3JvdXBMYXlvdXRzXG5cdFx0XHR9IClcblx0XHR9ICk7XG5cblx0fVxuXG5cdF9nZXRCbGVuZGluZyggbWF0ZXJpYWwgKSB7XG5cblx0XHRsZXQgY29sb3IsIGFscGhhO1xuXG5cdFx0Y29uc3QgYmxlbmRpbmcgPSBtYXRlcmlhbC5ibGVuZGluZztcblx0XHRjb25zdCBibGVuZFNyYyA9IG1hdGVyaWFsLmJsZW5kU3JjO1xuXHRcdGNvbnN0IGJsZW5kRHN0ID0gbWF0ZXJpYWwuYmxlbmREc3Q7XG5cdFx0Y29uc3QgYmxlbmRFcXVhdGlvbiA9IG1hdGVyaWFsLmJsZW5kRXF1YXRpb247XG5cblxuXHRcdGlmICggYmxlbmRpbmcgPT09IEN1c3RvbUJsZW5kaW5nICkge1xuXG5cdFx0XHRjb25zdCBibGVuZFNyY0FscGhhID0gbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSAhPT0gbnVsbCA/IG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEgOiBibGVuZFNyYztcblx0XHRcdGNvbnN0IGJsZW5kRHN0QWxwaGEgPSBtYXRlcmlhbC5ibGVuZERzdEFscGhhICE9PSBudWxsID8gbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSA6IGJsZW5kRHN0O1xuXHRcdFx0Y29uc3QgYmxlbmRFcXVhdGlvbkFscGhhID0gbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhICE9PSBudWxsID8gbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhIDogYmxlbmRFcXVhdGlvbjtcblxuXHRcdFx0Y29sb3IgPSB7XG5cdFx0XHRcdHNyY0ZhY3RvcjogdGhpcy5fZ2V0QmxlbmRGYWN0b3IoIGJsZW5kU3JjICksXG5cdFx0XHRcdGRzdEZhY3RvcjogdGhpcy5fZ2V0QmxlbmRGYWN0b3IoIGJsZW5kRHN0ICksXG5cdFx0XHRcdG9wZXJhdGlvbjogdGhpcy5fZ2V0QmxlbmRPcGVyYXRpb24oIGJsZW5kRXF1YXRpb24gKVxuXHRcdFx0fTtcblxuXHRcdFx0YWxwaGEgPSB7XG5cdFx0XHRcdHNyY0ZhY3RvcjogdGhpcy5fZ2V0QmxlbmRGYWN0b3IoIGJsZW5kU3JjQWxwaGEgKSxcblx0XHRcdFx0ZHN0RmFjdG9yOiB0aGlzLl9nZXRCbGVuZEZhY3RvciggYmxlbmREc3RBbHBoYSApLFxuXHRcdFx0XHRvcGVyYXRpb246IHRoaXMuX2dldEJsZW5kT3BlcmF0aW9uKCBibGVuZEVxdWF0aW9uQWxwaGEgKVxuXHRcdFx0fTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHByZW11bHRpcGxpZWRBbHBoYSA9IG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYTtcblxuXHRcdFx0Y29uc3Qgc2V0QmxlbmQgPSAoIHNyY1JHQiwgZHN0UkdCLCBzcmNBbHBoYSwgZHN0QWxwaGEgKSA9PiB7XG5cblx0XHRcdFx0Y29sb3IgPSB7XG5cdFx0XHRcdFx0c3JjRmFjdG9yOiBzcmNSR0IsXG5cdFx0XHRcdFx0ZHN0RmFjdG9yOiBkc3RSR0IsXG5cdFx0XHRcdFx0b3BlcmF0aW9uOiBHUFVCbGVuZE9wZXJhdGlvbi5BZGRcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRhbHBoYSA9IHtcblx0XHRcdFx0XHRzcmNGYWN0b3I6IHNyY0FscGhhLFxuXHRcdFx0XHRcdGRzdEZhY3RvcjogZHN0QWxwaGEsXG5cdFx0XHRcdFx0b3BlcmF0aW9uOiBHUFVCbGVuZE9wZXJhdGlvbi5BZGRcblx0XHRcdFx0fTtcblxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XG5cblx0XHRcdFx0c3dpdGNoICggYmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0XHRjYXNlIE5vcm1hbEJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0c2V0QmxlbmQoIEdQVUJsZW5kRmFjdG9yLk9uZSwgR1BVQmxlbmRGYWN0b3IuT25lTWludXNTcmNBbHBoYSwgR1BVQmxlbmRGYWN0b3IuT25lLCBHUFVCbGVuZEZhY3Rvci5PbmVNaW51c1NyY0FscGhhICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcblx0XHRcdFx0XHRcdHNldEJsZW5kKCBHUFVCbGVuZEZhY3Rvci5PbmUsIEdQVUJsZW5kRmFjdG9yLk9uZSwgR1BVQmxlbmRGYWN0b3IuT25lLCBHUFVCbGVuZEZhY3Rvci5PbmUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBTdWJ0cmFjdGl2ZUJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0c2V0QmxlbmQoIEdQVUJsZW5kRmFjdG9yLlplcm8sIEdQVUJsZW5kRmFjdG9yLk9uZU1pbnVzU3JjLCBHUFVCbGVuZEZhY3Rvci5aZXJvLCBHUFVCbGVuZEZhY3Rvci5PbmUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBNdWx0aXBseUJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0c2V0QmxlbmQoIEdQVUJsZW5kRmFjdG9yLlplcm8sIEdQVUJsZW5kRmFjdG9yLlNyYywgR1BVQmxlbmRGYWN0b3IuWmVybywgR1BVQmxlbmRGYWN0b3IuU3JjQWxwaGEgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzd2l0Y2ggKCBibGVuZGluZyApIHtcblxuXHRcdFx0XHRcdGNhc2UgTm9ybWFsQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRzZXRCbGVuZCggR1BVQmxlbmRGYWN0b3IuU3JjQWxwaGEsIEdQVUJsZW5kRmFjdG9yLk9uZU1pbnVzU3JjQWxwaGEsIEdQVUJsZW5kRmFjdG9yLk9uZSwgR1BVQmxlbmRGYWN0b3IuT25lTWludXNTcmNBbHBoYSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIEFkZGl0aXZlQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRzZXRCbGVuZCggR1BVQmxlbmRGYWN0b3IuU3JjQWxwaGEsIEdQVUJsZW5kRmFjdG9yLk9uZSwgR1BVQmxlbmRGYWN0b3IuU3JjQWxwaGEsIEdQVUJsZW5kRmFjdG9yLk9uZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFN1YnRyYWN0aXZlQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRzZXRCbGVuZCggR1BVQmxlbmRGYWN0b3IuWmVybywgR1BVQmxlbmRGYWN0b3IuT25lTWludXNTcmMsIEdQVUJsZW5kRmFjdG9yLlplcm8sIEdQVUJsZW5kRmFjdG9yLk9uZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIE11bHRpcGx5QmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRzZXRCbGVuZCggR1BVQmxlbmRGYWN0b3IuWmVybywgR1BVQmxlbmRGYWN0b3IuU3JjLCBHUFVCbGVuZEZhY3Rvci5aZXJvLCBHUFVCbGVuZEZhY3Rvci5TcmMgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBjb2xvciAhPT0gdW5kZWZpbmVkICYmIGFscGhhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiB7IGNvbG9yLCBhbHBoYSB9O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdQVVJlbmRlcmVyOiBJbnZhbGlkIGJsZW5kaW5nOiAnLCBibGVuZGluZyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfZ2V0QmxlbmRGYWN0b3IoIGJsZW5kICkge1xuXG5cdFx0bGV0IGJsZW5kRmFjdG9yO1xuXG5cdFx0c3dpdGNoICggYmxlbmQgKSB7XG5cblx0XHRcdGNhc2UgWmVyb0ZhY3Rvcjpcblx0XHRcdFx0YmxlbmRGYWN0b3IgPSBHUFVCbGVuZEZhY3Rvci5aZXJvO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBPbmVGYWN0b3I6XG5cdFx0XHRcdGJsZW5kRmFjdG9yID0gR1BVQmxlbmRGYWN0b3IuT25lO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBTcmNDb2xvckZhY3Rvcjpcblx0XHRcdFx0YmxlbmRGYWN0b3IgPSBHUFVCbGVuZEZhY3Rvci5TcmM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIE9uZU1pbnVzU3JjQ29sb3JGYWN0b3I6XG5cdFx0XHRcdGJsZW5kRmFjdG9yID0gR1BVQmxlbmRGYWN0b3IuT25lTWludXNTcmM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFNyY0FscGhhRmFjdG9yOlxuXHRcdFx0XHRibGVuZEZhY3RvciA9IEdQVUJsZW5kRmFjdG9yLlNyY0FscGhhO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBPbmVNaW51c1NyY0FscGhhRmFjdG9yOlxuXHRcdFx0XHRibGVuZEZhY3RvciA9IEdQVUJsZW5kRmFjdG9yLk9uZU1pbnVzU3JjQWxwaGE7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIERzdENvbG9yRmFjdG9yOlxuXHRcdFx0XHRibGVuZEZhY3RvciA9IEdQVUJsZW5kRmFjdG9yLkRzdDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgT25lTWludXNEc3RDb2xvckZhY3Rvcjpcblx0XHRcdFx0YmxlbmRGYWN0b3IgPSBHUFVCbGVuZEZhY3Rvci5PbmVNaW51c0RzdENvbG9yO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBEc3RBbHBoYUZhY3Rvcjpcblx0XHRcdFx0YmxlbmRGYWN0b3IgPSBHUFVCbGVuZEZhY3Rvci5Ec3RBbHBoYTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgT25lTWludXNEc3RBbHBoYUZhY3Rvcjpcblx0XHRcdFx0YmxlbmRGYWN0b3IgPSBHUFVCbGVuZEZhY3Rvci5PbmVNaW51c0RzdEFscGhhO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yOlxuXHRcdFx0XHRibGVuZEZhY3RvciA9IEdQVUJsZW5kRmFjdG9yLlNyY0FscGhhU2F0dXJhdGVkO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBCbGVuZENvbG9yRmFjdG9yOlxuXHRcdFx0XHRibGVuZEZhY3RvciA9IEdQVUJsZW5kRmFjdG9yLkNvbnN0YW50O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBPbmVNaW51c0JsZW5kQ29sb3JGYWN0b3I6XG5cdFx0XHRcdGJsZW5kRmFjdG9yID0gR1BVQmxlbmRGYWN0b3IuT25lTWludXNDb25zdGFudDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHUFVSZW5kZXJlcjogQmxlbmQgZmFjdG9yIG5vdCBzdXBwb3J0ZWQuJywgYmxlbmQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBibGVuZEZhY3RvcjtcblxuXHR9XG5cblx0X2dldFN0ZW5jaWxDb21wYXJlKCBtYXRlcmlhbCApIHtcblxuXHRcdGxldCBzdGVuY2lsQ29tcGFyZTtcblxuXHRcdGNvbnN0IHN0ZW5jaWxGdW5jID0gbWF0ZXJpYWwuc3RlbmNpbEZ1bmM7XG5cblx0XHRzd2l0Y2ggKCBzdGVuY2lsRnVuYyApIHtcblxuXHRcdFx0Y2FzZSBOZXZlclN0ZW5jaWxGdW5jOlxuXHRcdFx0XHRzdGVuY2lsQ29tcGFyZSA9IEdQVUNvbXBhcmVGdW5jdGlvbi5OZXZlcjtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgQWx3YXlzU3RlbmNpbEZ1bmM6XG5cdFx0XHRcdHN0ZW5jaWxDb21wYXJlID0gR1BVQ29tcGFyZUZ1bmN0aW9uLkFsd2F5cztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgTGVzc1N0ZW5jaWxGdW5jOlxuXHRcdFx0XHRzdGVuY2lsQ29tcGFyZSA9IEdQVUNvbXBhcmVGdW5jdGlvbi5MZXNzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBMZXNzRXF1YWxTdGVuY2lsRnVuYzpcblx0XHRcdFx0c3RlbmNpbENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uTGVzc0VxdWFsO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBFcXVhbFN0ZW5jaWxGdW5jOlxuXHRcdFx0XHRzdGVuY2lsQ29tcGFyZSA9IEdQVUNvbXBhcmVGdW5jdGlvbi5FcXVhbDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgR3JlYXRlckVxdWFsU3RlbmNpbEZ1bmM6XG5cdFx0XHRcdHN0ZW5jaWxDb21wYXJlID0gR1BVQ29tcGFyZUZ1bmN0aW9uLkdyZWF0ZXJFcXVhbDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgR3JlYXRlclN0ZW5jaWxGdW5jOlxuXHRcdFx0XHRzdGVuY2lsQ29tcGFyZSA9IEdQVUNvbXBhcmVGdW5jdGlvbi5HcmVhdGVyO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBOb3RFcXVhbFN0ZW5jaWxGdW5jOlxuXHRcdFx0XHRzdGVuY2lsQ29tcGFyZSA9IEdQVUNvbXBhcmVGdW5jdGlvbi5Ob3RFcXVhbDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHUFVSZW5kZXJlcjogSW52YWxpZCBzdGVuY2lsIGZ1bmN0aW9uLicsIHN0ZW5jaWxGdW5jICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc3RlbmNpbENvbXBhcmU7XG5cblx0fVxuXG5cdF9nZXRTdGVuY2lsT3BlcmF0aW9uKCBvcCApIHtcblxuXHRcdGxldCBzdGVuY2lsT3BlcmF0aW9uO1xuXG5cdFx0c3dpdGNoICggb3AgKSB7XG5cblx0XHRcdGNhc2UgS2VlcFN0ZW5jaWxPcDpcblx0XHRcdFx0c3RlbmNpbE9wZXJhdGlvbiA9IEdQVVN0ZW5jaWxPcGVyYXRpb24uS2VlcDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgWmVyb1N0ZW5jaWxPcDpcblx0XHRcdFx0c3RlbmNpbE9wZXJhdGlvbiA9IEdQVVN0ZW5jaWxPcGVyYXRpb24uWmVybztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUmVwbGFjZVN0ZW5jaWxPcDpcblx0XHRcdFx0c3RlbmNpbE9wZXJhdGlvbiA9IEdQVVN0ZW5jaWxPcGVyYXRpb24uUmVwbGFjZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgSW52ZXJ0U3RlbmNpbE9wOlxuXHRcdFx0XHRzdGVuY2lsT3BlcmF0aW9uID0gR1BVU3RlbmNpbE9wZXJhdGlvbi5JbnZlcnQ7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIEluY3JlbWVudFN0ZW5jaWxPcDpcblx0XHRcdFx0c3RlbmNpbE9wZXJhdGlvbiA9IEdQVVN0ZW5jaWxPcGVyYXRpb24uSW5jcmVtZW50Q2xhbXA7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIERlY3JlbWVudFN0ZW5jaWxPcDpcblx0XHRcdFx0c3RlbmNpbE9wZXJhdGlvbiA9IEdQVVN0ZW5jaWxPcGVyYXRpb24uRGVjcmVtZW50Q2xhbXA7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIEluY3JlbWVudFdyYXBTdGVuY2lsT3A6XG5cdFx0XHRcdHN0ZW5jaWxPcGVyYXRpb24gPSBHUFVTdGVuY2lsT3BlcmF0aW9uLkluY3JlbWVudFdyYXA7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIERlY3JlbWVudFdyYXBTdGVuY2lsT3A6XG5cdFx0XHRcdHN0ZW5jaWxPcGVyYXRpb24gPSBHUFVTdGVuY2lsT3BlcmF0aW9uLkRlY3JlbWVudFdyYXA7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR1BVUmVuZGVyZXI6IEludmFsaWQgc3RlbmNpbCBvcGVyYXRpb24uJywgc3RlbmNpbE9wZXJhdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0ZW5jaWxPcGVyYXRpb247XG5cblx0fVxuXG5cdF9nZXRCbGVuZE9wZXJhdGlvbiggYmxlbmRFcXVhdGlvbiApIHtcblxuXHRcdGxldCBibGVuZE9wZXJhdGlvbjtcblxuXHRcdHN3aXRjaCAoIGJsZW5kRXF1YXRpb24gKSB7XG5cblx0XHRcdGNhc2UgQWRkRXF1YXRpb246XG5cdFx0XHRcdGJsZW5kT3BlcmF0aW9uID0gR1BVQmxlbmRPcGVyYXRpb24uQWRkO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBTdWJ0cmFjdEVxdWF0aW9uOlxuXHRcdFx0XHRibGVuZE9wZXJhdGlvbiA9IEdQVUJsZW5kT3BlcmF0aW9uLlN1YnRyYWN0O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbjpcblx0XHRcdFx0YmxlbmRPcGVyYXRpb24gPSBHUFVCbGVuZE9wZXJhdGlvbi5SZXZlcnNlU3VidHJhY3Q7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIE1pbkVxdWF0aW9uOlxuXHRcdFx0XHRibGVuZE9wZXJhdGlvbiA9IEdQVUJsZW5kT3BlcmF0aW9uLk1pbjtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgTWF4RXF1YXRpb246XG5cdFx0XHRcdGJsZW5kT3BlcmF0aW9uID0gR1BVQmxlbmRPcGVyYXRpb24uTWF4O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdQVVBpcGVsaW5lVXRpbHM6IEJsZW5kIGVxdWF0aW9uIG5vdCBzdXBwb3J0ZWQuJywgYmxlbmRFcXVhdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJsZW5kT3BlcmF0aW9uO1xuXG5cdH1cblxuXHRfZ2V0UHJpbWl0aXZlU3RhdGUoIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFx0Y29uc3QgZGVzY3JpcHRvciA9IHt9O1xuXHRcdGNvbnN0IHV0aWxzID0gdGhpcy5iYWNrZW5kLnV0aWxzO1xuXG5cdFx0ZGVzY3JpcHRvci50b3BvbG9neSA9IHV0aWxzLmdldFByaW1pdGl2ZVRvcG9sb2d5KCBvYmplY3QsIG1hdGVyaWFsICk7XG5cblx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICYmIG9iamVjdC5pc0xpbmUgPT09IHRydWUgJiYgb2JqZWN0LmlzTGluZVNlZ21lbnRzICE9PSB0cnVlICkge1xuXG5cdFx0XHRkZXNjcmlwdG9yLnN0cmlwSW5kZXhGb3JtYXQgPSAoIGdlb21ldHJ5LmluZGV4LmFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkgKSA/IEdQVUluZGV4Rm9ybWF0LlVpbnQxNiA6IEdQVUluZGV4Rm9ybWF0LlVpbnQzMjtcblxuXHRcdH1cblxuXHRcdHN3aXRjaCAoIG1hdGVyaWFsLnNpZGUgKSB7XG5cblx0XHRcdGNhc2UgRnJvbnRTaWRlOlxuXHRcdFx0XHRkZXNjcmlwdG9yLmZyb250RmFjZSA9IEdQVUZyb250RmFjZS5DQ1c7XG5cdFx0XHRcdGRlc2NyaXB0b3IuY3VsbE1vZGUgPSBHUFVDdWxsTW9kZS5CYWNrO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBCYWNrU2lkZTpcblx0XHRcdFx0ZGVzY3JpcHRvci5mcm9udEZhY2UgPSBHUFVGcm9udEZhY2UuQ0NXO1xuXHRcdFx0XHRkZXNjcmlwdG9yLmN1bGxNb2RlID0gR1BVQ3VsbE1vZGUuRnJvbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIERvdWJsZVNpZGU6XG5cdFx0XHRcdGRlc2NyaXB0b3IuZnJvbnRGYWNlID0gR1BVRnJvbnRGYWNlLkNDVztcblx0XHRcdFx0ZGVzY3JpcHRvci5jdWxsTW9kZSA9IEdQVUN1bGxNb2RlLk5vbmU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR1BVUGlwZWxpbmVVdGlsczogVW5rbm93biBtYXRlcmlhbC5zaWRlIHZhbHVlLicsIG1hdGVyaWFsLnNpZGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGVzY3JpcHRvcjtcblxuXHR9XG5cblx0X2dldENvbG9yV3JpdGVNYXNrKCBtYXRlcmlhbCApIHtcblxuXHRcdHJldHVybiAoIG1hdGVyaWFsLmNvbG9yV3JpdGUgPT09IHRydWUgKSA/IEdQVUNvbG9yV3JpdGVGbGFncy5BbGwgOiBHUFVDb2xvcldyaXRlRmxhZ3MuTm9uZTtcblxuXHR9XG5cblx0X2dldERlcHRoQ29tcGFyZSggbWF0ZXJpYWwgKSB7XG5cblx0XHRsZXQgZGVwdGhDb21wYXJlO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5kZXB0aFRlc3QgPT09IGZhbHNlICkge1xuXG5cdFx0XHRkZXB0aENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uQWx3YXlzO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgZGVwdGhGdW5jID0gbWF0ZXJpYWwuZGVwdGhGdW5jO1xuXG5cdFx0XHRzd2l0Y2ggKCBkZXB0aEZ1bmMgKSB7XG5cblx0XHRcdFx0Y2FzZSBOZXZlckRlcHRoOlxuXHRcdFx0XHRcdGRlcHRoQ29tcGFyZSA9IEdQVUNvbXBhcmVGdW5jdGlvbi5OZXZlcjtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIEFsd2F5c0RlcHRoOlxuXHRcdFx0XHRcdGRlcHRoQ29tcGFyZSA9IEdQVUNvbXBhcmVGdW5jdGlvbi5BbHdheXM7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBMZXNzRGVwdGg6XG5cdFx0XHRcdFx0ZGVwdGhDb21wYXJlID0gR1BVQ29tcGFyZUZ1bmN0aW9uLkxlc3M7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBMZXNzRXF1YWxEZXB0aDpcblx0XHRcdFx0XHRkZXB0aENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uTGVzc0VxdWFsO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgRXF1YWxEZXB0aDpcblx0XHRcdFx0XHRkZXB0aENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uRXF1YWw7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBHcmVhdGVyRXF1YWxEZXB0aDpcblx0XHRcdFx0XHRkZXB0aENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uR3JlYXRlckVxdWFsO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgR3JlYXRlckRlcHRoOlxuXHRcdFx0XHRcdGRlcHRoQ29tcGFyZSA9IEdQVUNvbXBhcmVGdW5jdGlvbi5HcmVhdGVyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgTm90RXF1YWxEZXB0aDpcblx0XHRcdFx0XHRkZXB0aENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uTm90RXF1YWw7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR1BVUGlwZWxpbmVVdGlsczogSW52YWxpZCBkZXB0aCBmdW5jdGlvbi4nLCBkZXB0aEZ1bmMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlcHRoQ29tcGFyZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgV2ViR1BVUGlwZWxpbmVVdGlscztcbiIsIi8qLy8gZGVidWdnZXIgdG9vbHNcbmltcG9ydCAnaHR0cHM6Ly9ncmVnZ21hbi5naXRodWIuaW8vd2ViZ3B1LWF2b2lkLXJlZHVuZGFudC1zdGF0ZS1zZXR0aW5nL3dlYmdwdS1jaGVjay1yZWR1bmRhbnQtc3RhdGUtc2V0dGluZy5qcyc7XG4vLyovXG5cbmltcG9ydCB7IEdQVUZlYXR1cmVOYW1lLCBHUFVMb2FkT3AsIEdQVVN0b3JlT3AsIEdQVUluZGV4Rm9ybWF0LCBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbiB9IGZyb20gJy4vdXRpbHMvV2ViR1BVQ29uc3RhbnRzLmpzJztcblxuaW1wb3J0IFdHU0xOb2RlQnVpbGRlciBmcm9tICcuL25vZGVzL1dHU0xOb2RlQnVpbGRlci5qcyc7XG5pbXBvcnQgQmFja2VuZCBmcm9tICcuLi9jb21tb24vQmFja2VuZC5qcyc7XG5cbmltcG9ydCBXZWJHUFVVdGlscyBmcm9tICcuL3V0aWxzL1dlYkdQVVV0aWxzLmpzJztcbmltcG9ydCBXZWJHUFVBdHRyaWJ1dGVVdGlscyBmcm9tICcuL3V0aWxzL1dlYkdQVUF0dHJpYnV0ZVV0aWxzLmpzJztcbmltcG9ydCBXZWJHUFVCaW5kaW5nVXRpbHMgZnJvbSAnLi91dGlscy9XZWJHUFVCaW5kaW5nVXRpbHMuanMnO1xuaW1wb3J0IFdlYkdQVVBpcGVsaW5lVXRpbHMgZnJvbSAnLi91dGlscy9XZWJHUFVQaXBlbGluZVV0aWxzLmpzJztcbmltcG9ydCBXZWJHUFVUZXh0dXJlVXRpbHMgZnJvbSAnLi91dGlscy9XZWJHUFVUZXh0dXJlVXRpbHMuanMnO1xuXG5pbXBvcnQgeyBXZWJHUFVDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcblxuLy9cblxuY2xhc3MgV2ViR1BVQmFja2VuZCBleHRlbmRzIEJhY2tlbmQge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzID0ge30gKSB7XG5cblx0XHRzdXBlciggcGFyYW1ldGVycyApO1xuXG5cdFx0dGhpcy5pc1dlYkdQVUJhY2tlbmQgPSB0cnVlO1xuXG5cdFx0Ly8gc29tZSBwYXJhbWV0ZXJzIHJlcXVpcmUgZGVmYXVsdCB2YWx1ZXMgb3RoZXIgdGhhbiBcInVuZGVmaW5lZFwiXG5cdFx0dGhpcy5wYXJhbWV0ZXJzLmFscGhhID0gKCBwYXJhbWV0ZXJzLmFscGhhID09PSB1bmRlZmluZWQgKSA/IHRydWUgOiBwYXJhbWV0ZXJzLmFscGhhO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzLnJlcXVpcmVkTGltaXRzID0gKCBwYXJhbWV0ZXJzLnJlcXVpcmVkTGltaXRzID09PSB1bmRlZmluZWQgKSA/IHt9IDogcGFyYW1ldGVycy5yZXF1aXJlZExpbWl0cztcblxuXHRcdHRoaXMudHJhY2tUaW1lc3RhbXAgPSAoIHBhcmFtZXRlcnMudHJhY2tUaW1lc3RhbXAgPT09IHRydWUgKTtcblxuXHRcdHRoaXMuZGV2aWNlID0gbnVsbDtcblx0XHR0aGlzLmNvbnRleHQgPSBudWxsO1xuXHRcdHRoaXMuY29sb3JCdWZmZXIgPSBudWxsO1xuXHRcdHRoaXMuZGVmYXVsdFJlbmRlclBhc3NkZXNjcmlwdG9yID0gbnVsbDtcblxuXHRcdHRoaXMudXRpbHMgPSBuZXcgV2ViR1BVVXRpbHMoIHRoaXMgKTtcblx0XHR0aGlzLmF0dHJpYnV0ZVV0aWxzID0gbmV3IFdlYkdQVUF0dHJpYnV0ZVV0aWxzKCB0aGlzICk7XG5cdFx0dGhpcy5iaW5kaW5nVXRpbHMgPSBuZXcgV2ViR1BVQmluZGluZ1V0aWxzKCB0aGlzICk7XG5cdFx0dGhpcy5waXBlbGluZVV0aWxzID0gbmV3IFdlYkdQVVBpcGVsaW5lVXRpbHMoIHRoaXMgKTtcblx0XHR0aGlzLnRleHR1cmVVdGlscyA9IG5ldyBXZWJHUFVUZXh0dXJlVXRpbHMoIHRoaXMgKTtcblx0XHR0aGlzLm9jY2x1ZGVkUmVzb2x2ZUNhY2hlID0gbmV3IE1hcCgpO1xuXG5cdH1cblxuXHRhc3luYyBpbml0KCByZW5kZXJlciApIHtcblxuXHRcdGF3YWl0IHN1cGVyLmluaXQoIHJlbmRlcmVyICk7XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdC8vIGNyZWF0ZSB0aGUgZGV2aWNlIGlmIGl0IGlzIG5vdCBwYXNzZWQgd2l0aCBwYXJhbWV0ZXJzXG5cblx0XHRsZXQgZGV2aWNlO1xuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmRldmljZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBhZGFwdGVyT3B0aW9ucyA9IHtcblx0XHRcdFx0cG93ZXJQcmVmZXJlbmNlOiBwYXJhbWV0ZXJzLnBvd2VyUHJlZmVyZW5jZVxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgYWRhcHRlciA9ICggdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgKSA/IGF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoIGFkYXB0ZXJPcHRpb25zICkgOiBudWxsO1xuXG5cdFx0XHRpZiAoIGFkYXB0ZXIgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnV2ViR1BVQmFja2VuZDogVW5hYmxlIHRvIGNyZWF0ZSBXZWJHUFUgYWRhcHRlci4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZmVhdHVyZSBzdXBwb3J0XG5cblx0XHRcdGNvbnN0IGZlYXR1cmVzID0gT2JqZWN0LnZhbHVlcyggR1BVRmVhdHVyZU5hbWUgKTtcblxuXHRcdFx0Y29uc3Qgc3VwcG9ydGVkRmVhdHVyZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggY29uc3QgbmFtZSBvZiBmZWF0dXJlcyApIHtcblxuXHRcdFx0XHRpZiAoIGFkYXB0ZXIuZmVhdHVyZXMuaGFzKCBuYW1lICkgKSB7XG5cblx0XHRcdFx0XHRzdXBwb3J0ZWRGZWF0dXJlcy5wdXNoKCBuYW1lICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRldmljZURlc2NyaXB0b3IgPSB7XG5cdFx0XHRcdHJlcXVpcmVkRmVhdHVyZXM6IHN1cHBvcnRlZEZlYXR1cmVzLFxuXHRcdFx0XHRyZXF1aXJlZExpbWl0czogcGFyYW1ldGVycy5yZXF1aXJlZExpbWl0c1xuXHRcdFx0fTtcblxuXHRcdFx0ZGV2aWNlID0gYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKCBkZXZpY2VEZXNjcmlwdG9yICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRkZXZpY2UgPSBwYXJhbWV0ZXJzLmRldmljZTtcblxuXHRcdH1cblxuXHRcdGRldmljZS5sb3N0LnRoZW4oICggaW5mbyApID0+IHtcblxuXHRcdFx0Y29uc3QgZGV2aWNlTG9zc0luZm8gPSB7XG5cdFx0XHRcdGFwaTogJ1dlYkdQVScsXG5cdFx0XHRcdG1lc3NhZ2U6IGluZm8ubWVzc2FnZSB8fCAnVW5rbm93biByZWFzb24nLFxuXHRcdFx0XHRyZWFzb246IGluZm8ucmVhc29uIHx8IG51bGwsXG5cdFx0XHRcdG9yaWdpbmFsRXZlbnQ6IGluZm9cblx0XHRcdH07XG5cblx0XHRcdHJlbmRlcmVyLm9uRGV2aWNlTG9zdCggZGV2aWNlTG9zc0luZm8gKTtcblxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IGNvbnRleHQgPSAoIHBhcmFtZXRlcnMuY29udGV4dCAhPT0gdW5kZWZpbmVkICkgPyBwYXJhbWV0ZXJzLmNvbnRleHQgOiByZW5kZXJlci5kb21FbGVtZW50LmdldENvbnRleHQoICd3ZWJncHUnICk7XG5cblx0XHR0aGlzLmRldmljZSA9IGRldmljZTtcblx0XHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0Y29uc3QgYWxwaGFNb2RlID0gcGFyYW1ldGVycy5hbHBoYSA/ICdwcmVtdWx0aXBsaWVkJyA6ICdvcGFxdWUnO1xuXG5cdFx0dGhpcy50cmFja1RpbWVzdGFtcCA9IHRoaXMudHJhY2tUaW1lc3RhbXAgJiYgdGhpcy5oYXNGZWF0dXJlKCBHUFVGZWF0dXJlTmFtZS5UaW1lc3RhbXBRdWVyeSApO1xuXG5cdFx0dGhpcy5jb250ZXh0LmNvbmZpZ3VyZSgge1xuXHRcdFx0ZGV2aWNlOiB0aGlzLmRldmljZSxcblx0XHRcdGZvcm1hdDogdGhpcy51dGlscy5nZXRQcmVmZXJyZWRDYW52YXNGb3JtYXQoKSxcblx0XHRcdHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9TUkMsXG5cdFx0XHRhbHBoYU1vZGU6IGFscGhhTW9kZVxuXHRcdH0gKTtcblxuXHRcdHRoaXMudXBkYXRlU2l6ZSgpO1xuXG5cdH1cblxuXHRnZXQgY29vcmRpbmF0ZVN5c3RlbSgpIHtcblxuXHRcdHJldHVybiBXZWJHUFVDb29yZGluYXRlU3lzdGVtO1xuXG5cdH1cblxuXHRhc3luYyBnZXRBcnJheUJ1ZmZlckFzeW5jKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5hdHRyaWJ1dGVVdGlscy5nZXRBcnJheUJ1ZmZlckFzeW5jKCBhdHRyaWJ1dGUgKTtcblxuXHR9XG5cblx0Z2V0Q29udGV4dCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbnRleHQ7XG5cblx0fVxuXG5cdF9nZXREZWZhdWx0UmVuZGVyUGFzc0Rlc2NyaXB0b3IoKSB7XG5cblx0XHRsZXQgZGVzY3JpcHRvciA9IHRoaXMuZGVmYXVsdFJlbmRlclBhc3NkZXNjcmlwdG9yO1xuXG5cdFx0aWYgKCBkZXNjcmlwdG9yID09PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cblx0XHRcdGRlc2NyaXB0b3IgPSB7XG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudHM6IFsge1xuXHRcdFx0XHRcdHZpZXc6IG51bGxcblx0XHRcdFx0fSBdLFxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVyLmRlcHRoID09PSB0cnVlIHx8IHRoaXMucmVuZGVyZXIuc3RlbmNpbCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRkZXNjcmlwdG9yLmRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSB7XG5cdFx0XHRcdFx0dmlldzogdGhpcy50ZXh0dXJlVXRpbHMuZ2V0RGVwdGhCdWZmZXIoIHJlbmRlcmVyLmRlcHRoLCByZW5kZXJlci5zdGVuY2lsICkuY3JlYXRlVmlldygpXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY29sb3JBdHRhY2htZW50ID0gZGVzY3JpcHRvci5jb2xvckF0dGFjaG1lbnRzWyAwIF07XG5cblx0XHRcdGlmICggdGhpcy5yZW5kZXJlci5zYW1wbGVzID4gMCApIHtcblxuXHRcdFx0XHRjb2xvckF0dGFjaG1lbnQudmlldyA9IHRoaXMuY29sb3JCdWZmZXIuY3JlYXRlVmlldygpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudC5yZXNvbHZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZGVmYXVsdFJlbmRlclBhc3NkZXNjcmlwdG9yID0gZGVzY3JpcHRvcjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGNvbG9yQXR0YWNobWVudCA9IGRlc2NyaXB0b3IuY29sb3JBdHRhY2htZW50c1sgMCBdO1xuXG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVyLnNhbXBsZXMgPiAwICkge1xuXG5cdFx0XHRjb2xvckF0dGFjaG1lbnQucmVzb2x2ZVRhcmdldCA9IHRoaXMuY29udGV4dC5nZXRDdXJyZW50VGV4dHVyZSgpLmNyZWF0ZVZpZXcoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbG9yQXR0YWNobWVudC52aWV3ID0gdGhpcy5jb250ZXh0LmdldEN1cnJlbnRUZXh0dXJlKCkuY3JlYXRlVmlldygpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlc2NyaXB0b3I7XG5cblx0fVxuXG5cdF9nZXRSZW5kZXJQYXNzRGVzY3JpcHRvciggcmVuZGVyQ29udGV4dCApIHtcblxuXHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IHJlbmRlckNvbnRleHQucmVuZGVyVGFyZ2V0O1xuXHRcdGNvbnN0IHJlbmRlclRhcmdldERhdGEgPSB0aGlzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRsZXQgZGVzY3JpcHRvcnMgPSByZW5kZXJUYXJnZXREYXRhLmRlc2NyaXB0b3JzO1xuXG5cdFx0aWYgKCBkZXNjcmlwdG9ycyA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRyZW5kZXJUYXJnZXREYXRhLndpZHRoICE9PSByZW5kZXJUYXJnZXQud2lkdGggfHxcblx0XHRcdHJlbmRlclRhcmdldERhdGEuaGVpZ2h0ICE9PSByZW5kZXJUYXJnZXQuaGVpZ2h0IHx8XG5cdFx0XHRyZW5kZXJUYXJnZXREYXRhLmFjdGl2ZU1pcG1hcExldmVsICE9PSByZW5kZXJUYXJnZXQuYWN0aXZlTWlwbWFwTGV2ZWwgfHxcblx0XHRcdHJlbmRlclRhcmdldERhdGEuc2FtcGxlcyAhPT0gcmVuZGVyVGFyZ2V0LnNhbXBsZXNcblx0XHQpIHtcblxuXHRcdFx0ZGVzY3JpcHRvcnMgPSB7fTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0RGF0YS5kZXNjcmlwdG9ycyA9IGRlc2NyaXB0b3JzO1xuXG5cdFx0XHQvLyBkaXNwb3NlXG5cblx0XHRcdGNvbnN0IG9uRGlzcG9zZSA9ICgpID0+IHtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UgKTtcblxuXHRcdFx0XHR0aGlzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdH07XG5cblx0XHRcdHJlbmRlclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uRGlzcG9zZSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSByZW5kZXJDb250ZXh0LmdldENhY2hlS2V5KCk7XG5cblx0XHRsZXQgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JzWyBjYWNoZUtleSBdO1xuXG5cdFx0aWYgKCBkZXNjcmlwdG9yID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyQ29udGV4dC50ZXh0dXJlcztcblx0XHRcdGNvbnN0IGNvbG9yQXR0YWNobWVudHMgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHRleHR1cmVEYXRhID0gdGhpcy5nZXQoIHRleHR1cmVzWyBpIF0gKTtcblxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlVmlldyA9IHRleHR1cmVEYXRhLnRleHR1cmUuY3JlYXRlVmlldygge1xuXHRcdFx0XHRcdGJhc2VNaXBMZXZlbDogcmVuZGVyQ29udGV4dC5hY3RpdmVNaXBtYXBMZXZlbCxcblx0XHRcdFx0XHRtaXBMZXZlbENvdW50OiAxLFxuXHRcdFx0XHRcdGJhc2VBcnJheUxheWVyOiByZW5kZXJDb250ZXh0LmFjdGl2ZUN1YmVGYWNlLFxuXHRcdFx0XHRcdGRpbWVuc2lvbjogR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24uVHdvRFxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0bGV0IHZpZXcsIHJlc29sdmVUYXJnZXQ7XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlRGF0YS5tc2FhVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dmlldyA9IHRleHR1cmVEYXRhLm1zYWFUZXh0dXJlLmNyZWF0ZVZpZXcoKTtcblx0XHRcdFx0XHRyZXNvbHZlVGFyZ2V0ID0gdGV4dHVyZVZpZXc7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHZpZXcgPSB0ZXh0dXJlVmlldztcblx0XHRcdFx0XHRyZXNvbHZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb2xvckF0dGFjaG1lbnRzLnB1c2goIHtcblx0XHRcdFx0XHR2aWV3LFxuXHRcdFx0XHRcdHJlc29sdmVUYXJnZXQsXG5cdFx0XHRcdFx0bG9hZE9wOiBHUFVMb2FkT3AuTG9hZCxcblx0XHRcdFx0XHRzdG9yZU9wOiBHUFVTdG9yZU9wLlN0b3JlXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGRlc2NyaXB0b3IgPSB7XG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudHMsXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIHJlbmRlckNvbnRleHQuZGVwdGggKSB7XG5cblx0XHRcdFx0Y29uc3QgZGVwdGhUZXh0dXJlRGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0LmRlcHRoVGV4dHVyZSApO1xuXG5cdFx0XHRcdGNvbnN0IGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSB7XG5cdFx0XHRcdFx0dmlldzogZGVwdGhUZXh0dXJlRGF0YS50ZXh0dXJlLmNyZWF0ZVZpZXcoKVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRkZXNjcmlwdG9yLmRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSBkZXB0aFN0ZW5jaWxBdHRhY2htZW50O1xuXG5cdFx0XHR9XG5cblx0XHRcdGRlc2NyaXB0b3JzWyBjYWNoZUtleSBdID0gZGVzY3JpcHRvcjtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0RGF0YS53aWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcblx0XHRcdHJlbmRlclRhcmdldERhdGEuaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcblx0XHRcdHJlbmRlclRhcmdldERhdGEuc2FtcGxlcyA9IHJlbmRlclRhcmdldC5zYW1wbGVzO1xuXHRcdFx0cmVuZGVyVGFyZ2V0RGF0YS5hY3RpdmVNaXBtYXBMZXZlbCA9IHJlbmRlclRhcmdldC5hY3RpdmVNaXBtYXBMZXZlbDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkZXNjcmlwdG9yO1xuXG5cdH1cblxuXHRiZWdpblJlbmRlciggcmVuZGVyQ29udGV4dCApIHtcblxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcblxuXHRcdGNvbnN0IGRldmljZSA9IHRoaXMuZGV2aWNlO1xuXHRcdGNvbnN0IG9jY2x1c2lvblF1ZXJ5Q291bnQgPSByZW5kZXJDb250ZXh0Lm9jY2x1c2lvblF1ZXJ5Q291bnQ7XG5cblx0XHRsZXQgb2NjbHVzaW9uUXVlcnlTZXQ7XG5cblx0XHRpZiAoIG9jY2x1c2lvblF1ZXJ5Q291bnQgPiAwICkge1xuXG5cdFx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRPY2NsdXNpb25RdWVyeVNldCApIHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRPY2NsdXNpb25RdWVyeVNldC5kZXN0cm95KCk7XG5cdFx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRPY2NsdXNpb25RdWVyeUJ1ZmZlciApIHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRPY2NsdXNpb25RdWVyeUJ1ZmZlci5kZXN0cm95KCk7XG5cblx0XHRcdC8vIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHF1ZXJpZXMuIFRoZSByZW5kZXJDb250ZXh0RGF0YSBwcm9wZXJ0eVxuXHRcdFx0Ly8gY2FuIGJlIGNoYW5nZWQgYnkgYW5vdGhlciByZW5kZXIgcGFzcyBiZWZvcmUgdGhlIGJ1ZmZlci5tYXBBc3ljKCkgY29tcGxldGVzLlxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudE9jY2x1c2lvblF1ZXJ5U2V0ID0gcmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlTZXQ7XG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50T2NjbHVzaW9uUXVlcnlCdWZmZXIgPSByZW5kZXJDb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeUJ1ZmZlcjtcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRPY2NsdXNpb25RdWVyeU9iamVjdHMgPSByZW5kZXJDb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeU9iamVjdHM7XG5cblx0XHRcdC8vXG5cblx0XHRcdG9jY2x1c2lvblF1ZXJ5U2V0ID0gZGV2aWNlLmNyZWF0ZVF1ZXJ5U2V0KCB7IHR5cGU6ICdvY2NsdXNpb24nLCBjb3VudDogb2NjbHVzaW9uUXVlcnlDb3VudCwgbGFiZWw6IGBvY2NsdXNpb25RdWVyeVNldF8keyByZW5kZXJDb250ZXh0LmlkIH1gIH0gKTtcblxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlTZXQgPSBvY2NsdXNpb25RdWVyeVNldDtcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLm9jY2x1c2lvblF1ZXJ5SW5kZXggPSAwO1xuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlPYmplY3RzID0gbmV3IEFycmF5KCBvY2NsdXNpb25RdWVyeUNvdW50ICk7XG5cblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmxhc3RPY2NsdXNpb25PYmplY3QgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGRlc2NyaXB0b3I7XG5cblx0XHRpZiAoIHJlbmRlckNvbnRleHQudGV4dHVyZXMgPT09IG51bGwgKSB7XG5cblx0XHRcdGRlc2NyaXB0b3IgPSB0aGlzLl9nZXREZWZhdWx0UmVuZGVyUGFzc0Rlc2NyaXB0b3IoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGRlc2NyaXB0b3IgPSB0aGlzLl9nZXRSZW5kZXJQYXNzRGVzY3JpcHRvciggcmVuZGVyQ29udGV4dCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5pbml0VGltZXN0YW1wUXVlcnkoIHJlbmRlckNvbnRleHQsIGRlc2NyaXB0b3IgKTtcblxuXHRcdGRlc2NyaXB0b3Iub2NjbHVzaW9uUXVlcnlTZXQgPSBvY2NsdXNpb25RdWVyeVNldDtcblxuXHRcdGNvbnN0IGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSBkZXNjcmlwdG9yLmRlcHRoU3RlbmNpbEF0dGFjaG1lbnQ7XG5cblx0XHRpZiAoIHJlbmRlckNvbnRleHQudGV4dHVyZXMgIT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IGNvbG9yQXR0YWNobWVudHMgPSBkZXNjcmlwdG9yLmNvbG9yQXR0YWNobWVudHM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvbG9yQXR0YWNobWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNvbG9yQXR0YWNobWVudCA9IGNvbG9yQXR0YWNobWVudHNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIHJlbmRlckNvbnRleHQuY2xlYXJDb2xvciApIHtcblxuXHRcdFx0XHRcdGNvbG9yQXR0YWNobWVudC5jbGVhclZhbHVlID0gaSA9PT0gMCA/IHJlbmRlckNvbnRleHQuY2xlYXJDb2xvclZhbHVlIDogeyByOiAwLCBnOiAwLCBiOiAwLCBhOiAxIH07XG5cdFx0XHRcdFx0Y29sb3JBdHRhY2htZW50LmxvYWRPcCA9IEdQVUxvYWRPcC5DbGVhcjtcblx0XHRcdFx0XHRjb2xvckF0dGFjaG1lbnQuc3RvcmVPcCA9IEdQVVN0b3JlT3AuU3RvcmU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbG9yQXR0YWNobWVudC5sb2FkT3AgPSBHUFVMb2FkT3AuTG9hZDtcblx0XHRcdFx0XHRjb2xvckF0dGFjaG1lbnQuc3RvcmVPcCA9IEdQVVN0b3JlT3AuU3RvcmU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBjb2xvckF0dGFjaG1lbnQgPSBkZXNjcmlwdG9yLmNvbG9yQXR0YWNobWVudHNbIDAgXTtcblxuXHRcdFx0aWYgKCByZW5kZXJDb250ZXh0LmNsZWFyQ29sb3IgKSB7XG5cblx0XHRcdFx0Y29sb3JBdHRhY2htZW50LmNsZWFyVmFsdWUgPSByZW5kZXJDb250ZXh0LmNsZWFyQ29sb3JWYWx1ZTtcblx0XHRcdFx0Y29sb3JBdHRhY2htZW50LmxvYWRPcCA9IEdQVUxvYWRPcC5DbGVhcjtcblx0XHRcdFx0Y29sb3JBdHRhY2htZW50LnN0b3JlT3AgPSBHUFVTdG9yZU9wLlN0b3JlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudC5sb2FkT3AgPSBHUFVMb2FkT3AuTG9hZDtcblx0XHRcdFx0Y29sb3JBdHRhY2htZW50LnN0b3JlT3AgPSBHUFVTdG9yZU9wLlN0b3JlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKCByZW5kZXJDb250ZXh0LmRlcHRoICkge1xuXG5cdFx0XHRpZiAoIHJlbmRlckNvbnRleHQuY2xlYXJEZXB0aCApIHtcblxuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LmRlcHRoQ2xlYXJWYWx1ZSA9IHJlbmRlckNvbnRleHQuY2xlYXJEZXB0aFZhbHVlO1xuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LmRlcHRoTG9hZE9wID0gR1BVTG9hZE9wLkNsZWFyO1xuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LmRlcHRoU3RvcmVPcCA9IEdQVVN0b3JlT3AuU3RvcmU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudC5kZXB0aExvYWRPcCA9IEdQVUxvYWRPcC5Mb2FkO1xuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LmRlcHRoU3RvcmVPcCA9IEdQVVN0b3JlT3AuU3RvcmU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggcmVuZGVyQ29udGV4dC5zdGVuY2lsICkge1xuXG5cdFx0XHRpZiAoIHJlbmRlckNvbnRleHQuY2xlYXJTdGVuY2lsICkge1xuXG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuc3RlbmNpbENsZWFyVmFsdWUgPSByZW5kZXJDb250ZXh0LmNsZWFyU3RlbmNpbFZhbHVlO1xuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnN0ZW5jaWxMb2FkT3AgPSBHUFVMb2FkT3AuQ2xlYXI7XG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuc3RlbmNpbFN0b3JlT3AgPSBHUFVTdG9yZU9wLlN0b3JlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuc3RlbmNpbExvYWRPcCA9IEdQVUxvYWRPcC5Mb2FkO1xuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnN0ZW5jaWxTdG9yZU9wID0gR1BVU3RvcmVPcC5TdG9yZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoIHsgbGFiZWw6ICdyZW5kZXJDb250ZXh0XycgKyByZW5kZXJDb250ZXh0LmlkIH0gKTtcblx0XHRjb25zdCBjdXJyZW50UGFzcyA9IGVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKCBkZXNjcmlwdG9yICk7XG5cblx0XHQvL1xuXG5cdFx0cmVuZGVyQ29udGV4dERhdGEuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3I7XG5cdFx0cmVuZGVyQ29udGV4dERhdGEuZW5jb2RlciA9IGVuY29kZXI7XG5cdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3MgPSBjdXJyZW50UGFzcztcblx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50U2V0cyA9IHsgYXR0cmlidXRlczoge30sIGJpbmRpbmdHcm91cHM6IFtdLCBwaXBlbGluZTogbnVsbCwgaW5kZXg6IG51bGwgfTtcblx0XHRyZW5kZXJDb250ZXh0RGF0YS5yZW5kZXJCdW5kbGVzID0gW107XG5cblx0XHQvL1xuXG5cdFx0aWYgKCByZW5kZXJDb250ZXh0LnZpZXdwb3J0ICkge1xuXG5cdFx0XHR0aGlzLnVwZGF0ZVZpZXdwb3J0KCByZW5kZXJDb250ZXh0ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHJlbmRlckNvbnRleHQuc2Npc3NvciApIHtcblxuXHRcdFx0Y29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZW5kZXJDb250ZXh0LnNjaXNzb3JWYWx1ZTtcblxuXHRcdFx0Y3VycmVudFBhc3Muc2V0U2Npc3NvclJlY3QoIHgsIHksIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZmluaXNoUmVuZGVyKCByZW5kZXJDb250ZXh0ICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dCApO1xuXHRcdGNvbnN0IG9jY2x1c2lvblF1ZXJ5Q291bnQgPSByZW5kZXJDb250ZXh0Lm9jY2x1c2lvblF1ZXJ5Q291bnQ7XG5cblx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLnJlbmRlckJ1bmRsZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3MuZXhlY3V0ZUJ1bmRsZXMoIHJlbmRlckNvbnRleHREYXRhLnJlbmRlckJ1bmRsZXMgKTtcblxuXHRcdH1cblxuXHRcdGlmICggb2NjbHVzaW9uUXVlcnlDb3VudCA+IHJlbmRlckNvbnRleHREYXRhLm9jY2x1c2lvblF1ZXJ5SW5kZXggKSB7XG5cblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRQYXNzLmVuZE9jY2x1c2lvblF1ZXJ5KCk7XG5cblx0XHR9XG5cblx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50UGFzcy5lbmQoKTtcblxuXHRcdGlmICggb2NjbHVzaW9uUXVlcnlDb3VudCA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IGJ1ZmZlclNpemUgPSBvY2NsdXNpb25RdWVyeUNvdW50ICogODsgLy8gOCBieXRlIGVudHJpZXMgZm9yIHF1ZXJ5IHJlc3VsdHNcblxuXHRcdFx0Ly9cblxuXHRcdFx0bGV0IHF1ZXJ5UmVzb2x2ZUJ1ZmZlciA9IHRoaXMub2NjbHVkZWRSZXNvbHZlQ2FjaGUuZ2V0KCBidWZmZXJTaXplICk7XG5cblx0XHRcdGlmICggcXVlcnlSZXNvbHZlQnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cXVlcnlSZXNvbHZlQnVmZmVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHNpemU6IGJ1ZmZlclNpemUsXG5cdFx0XHRcdFx0XHR1c2FnZTogR1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdHRoaXMub2NjbHVkZWRSZXNvbHZlQ2FjaGUuc2V0KCBidWZmZXJTaXplLCBxdWVyeVJlc29sdmVCdWZmZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHRjb25zdCByZWFkQnVmZmVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c2l6ZTogYnVmZmVyU2l6ZSxcblx0XHRcdFx0XHR1c2FnZTogR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgfCBHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRFxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXG5cdFx0XHQvLyB0d28gYnVmZmVycyByZXF1aXJlZCBoZXJlIC0gV2ViR1BVIGRvZXNuJ3QgYWxsb3cgdXNhZ2Ugb2YgUVVFUllfUkVTT0xWRSAmIE1BUF9SRUFEIHRvIGJlIGNvbWJpbmVkXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5lbmNvZGVyLnJlc29sdmVRdWVyeVNldCggcmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlTZXQsIDAsIG9jY2x1c2lvblF1ZXJ5Q291bnQsIHF1ZXJ5UmVzb2x2ZUJ1ZmZlciwgMCApO1xuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEuZW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoIHF1ZXJ5UmVzb2x2ZUJ1ZmZlciwgMCwgcmVhZEJ1ZmZlciwgMCwgYnVmZmVyU2l6ZSApO1xuXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeUJ1ZmZlciA9IHJlYWRCdWZmZXI7XG5cblx0XHRcdC8vXG5cblx0XHRcdHRoaXMucmVzb2x2ZU9jY2x1ZGVkQXN5bmMoIHJlbmRlckNvbnRleHQgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMucHJlcGFyZVRpbWVzdGFtcEJ1ZmZlciggcmVuZGVyQ29udGV4dCwgcmVuZGVyQ29udGV4dERhdGEuZW5jb2RlciApO1xuXG5cdFx0dGhpcy5kZXZpY2UucXVldWUuc3VibWl0KCBbIHJlbmRlckNvbnRleHREYXRhLmVuY29kZXIuZmluaXNoKCkgXSApO1xuXG5cblx0XHQvL1xuXG5cdFx0aWYgKCByZW5kZXJDb250ZXh0LnRleHR1cmVzICE9PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlckNvbnRleHQudGV4dHVyZXM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gdGV4dHVyZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0dGhpcy50ZXh0dXJlVXRpbHMuZ2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGlzT2NjbHVkZWQoIHJlbmRlckNvbnRleHQsIG9iamVjdCApIHtcblxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcblxuXHRcdHJldHVybiByZW5kZXJDb250ZXh0RGF0YS5vY2NsdWRlZCAmJiByZW5kZXJDb250ZXh0RGF0YS5vY2NsdWRlZC5oYXMoIG9iamVjdCApO1xuXG5cdH1cblxuXHRhc3luYyByZXNvbHZlT2NjbHVkZWRBc3luYyggcmVuZGVyQ29udGV4dCApIHtcblxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcblxuXHRcdC8vIGhhbmRsZSBvY2NsdXNpb24gcXVlcnkgcmVzdWx0c1xuXG5cdFx0Y29uc3QgeyBjdXJyZW50T2NjbHVzaW9uUXVlcnlCdWZmZXIsIGN1cnJlbnRPY2NsdXNpb25RdWVyeU9iamVjdHMgfSA9IHJlbmRlckNvbnRleHREYXRhO1xuXG5cdFx0aWYgKCBjdXJyZW50T2NjbHVzaW9uUXVlcnlCdWZmZXIgJiYgY3VycmVudE9jY2x1c2lvblF1ZXJ5T2JqZWN0cyApIHtcblxuXHRcdFx0Y29uc3Qgb2NjbHVkZWQgPSBuZXcgV2Vha1NldCgpO1xuXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50T2NjbHVzaW9uUXVlcnlPYmplY3RzID0gbnVsbDtcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRPY2NsdXNpb25RdWVyeUJ1ZmZlciA9IG51bGw7XG5cblx0XHRcdGF3YWl0IGN1cnJlbnRPY2NsdXNpb25RdWVyeUJ1ZmZlci5tYXBBc3luYyggR1BVTWFwTW9kZS5SRUFEICk7XG5cblx0XHRcdGNvbnN0IGJ1ZmZlciA9IGN1cnJlbnRPY2NsdXNpb25RdWVyeUJ1ZmZlci5nZXRNYXBwZWRSYW5nZSgpO1xuXHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBCaWdVaW50NjRBcnJheSggYnVmZmVyICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGN1cnJlbnRPY2NsdXNpb25RdWVyeU9iamVjdHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggcmVzdWx0c1sgaSBdICE9PSBCaWdJbnQoIDAgKSApIHtcblxuXHRcdFx0XHRcdG9jY2x1ZGVkLmFkZCggY3VycmVudE9jY2x1c2lvblF1ZXJ5T2JqZWN0c1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRPY2NsdXNpb25RdWVyeUJ1ZmZlci5kZXN0cm95KCk7XG5cblx0XHRcdHJlbmRlckNvbnRleHREYXRhLm9jY2x1ZGVkID0gb2NjbHVkZWQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZVZpZXdwb3J0KCByZW5kZXJDb250ZXh0ICkge1xuXG5cdFx0Y29uc3QgeyBjdXJyZW50UGFzcyB9ID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcblx0XHRjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIG1pbkRlcHRoLCBtYXhEZXB0aCB9ID0gcmVuZGVyQ29udGV4dC52aWV3cG9ydFZhbHVlO1xuXG5cdFx0Y3VycmVudFBhc3Muc2V0Vmlld3BvcnQoIHgsIHksIHdpZHRoLCBoZWlnaHQsIG1pbkRlcHRoLCBtYXhEZXB0aCApO1xuXG5cdH1cblxuXHRjbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsLCByZW5kZXJUYXJnZXREYXRhID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IGRldmljZSA9IHRoaXMuZGV2aWNlO1xuXHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcblxuXHRcdGxldCBjb2xvckF0dGFjaG1lbnRzID0gW107XG5cblx0XHRsZXQgZGVwdGhTdGVuY2lsQXR0YWNobWVudDtcblx0XHRsZXQgY2xlYXJWYWx1ZTtcblxuXHRcdGxldCBzdXBwb3J0c0RlcHRoO1xuXHRcdGxldCBzdXBwb3J0c1N0ZW5jaWw7XG5cblx0XHRpZiAoIGNvbG9yICkge1xuXG5cdFx0XHRjb25zdCBjbGVhckNvbG9yID0gdGhpcy5nZXRDbGVhckNvbG9yKCk7XG5cblx0XHRcdGlmICggdGhpcy5yZW5kZXJlci5hbHBoYSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHQvLyBwcmVtdWx0aXBseSBhbHBoYVxuXG5cdFx0XHRcdGNvbnN0IGEgPSBjbGVhckNvbG9yLmE7XG5cblx0XHRcdFx0Y2xlYXJWYWx1ZSA9IHsgcjogY2xlYXJDb2xvci5yICogYSwgZzogY2xlYXJDb2xvci5nICogYSwgYjogY2xlYXJDb2xvci5iICogYSwgYTogYSB9O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNsZWFyVmFsdWUgPSB7IHI6IGNsZWFyQ29sb3IuciwgZzogY2xlYXJDb2xvci5nLCBiOiBjbGVhckNvbG9yLmIsIGE6IGNsZWFyQ29sb3IuYSB9O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldERhdGEgPT09IG51bGwgKSB7XG5cblx0XHRcdHN1cHBvcnRzRGVwdGggPSByZW5kZXJlci5kZXB0aDtcblx0XHRcdHN1cHBvcnRzU3RlbmNpbCA9IHJlbmRlcmVyLnN0ZW5jaWw7XG5cblx0XHRcdGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLl9nZXREZWZhdWx0UmVuZGVyUGFzc0Rlc2NyaXB0b3IoKTtcblxuXHRcdFx0aWYgKCBjb2xvciApIHtcblxuXHRcdFx0XHRjb2xvckF0dGFjaG1lbnRzID0gZGVzY3JpcHRvci5jb2xvckF0dGFjaG1lbnRzO1xuXG5cdFx0XHRcdGNvbnN0IGNvbG9yQXR0YWNobWVudCA9IGNvbG9yQXR0YWNobWVudHNbIDAgXTtcblxuXHRcdFx0XHRjb2xvckF0dGFjaG1lbnQuY2xlYXJWYWx1ZSA9IGNsZWFyVmFsdWU7XG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudC5sb2FkT3AgPSBHUFVMb2FkT3AuQ2xlYXI7XG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudC5zdG9yZU9wID0gR1BVU3RvcmVPcC5TdG9yZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHN1cHBvcnRzRGVwdGggfHwgc3VwcG9ydHNTdGVuY2lsICkge1xuXG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSBkZXNjcmlwdG9yLmRlcHRoU3RlbmNpbEF0dGFjaG1lbnQ7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHN1cHBvcnRzRGVwdGggPSByZW5kZXJUYXJnZXREYXRhLmRlcHRoO1xuXHRcdFx0c3VwcG9ydHNTdGVuY2lsID0gcmVuZGVyVGFyZ2V0RGF0YS5zdGVuY2lsO1xuXG5cdFx0XHRpZiAoIGNvbG9yICkge1xuXG5cdFx0XHRcdGZvciAoIGNvbnN0IHRleHR1cmUgb2YgcmVuZGVyVGFyZ2V0RGF0YS50ZXh0dXJlcyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmVEYXRhID0gdGhpcy5nZXQoIHRleHR1cmUgKTtcblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlVmlldyA9IHRleHR1cmVEYXRhLnRleHR1cmUuY3JlYXRlVmlldygpO1xuXG5cdFx0XHRcdFx0bGV0IHZpZXcsIHJlc29sdmVUYXJnZXQ7XG5cblx0XHRcdFx0XHRpZiAoIHRleHR1cmVEYXRhLm1zYWFUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHZpZXcgPSB0ZXh0dXJlRGF0YS5tc2FhVGV4dHVyZS5jcmVhdGVWaWV3KCk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlVGFyZ2V0ID0gdGV4dHVyZVZpZXc7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2aWV3ID0gdGV4dHVyZVZpZXc7XG5cdFx0XHRcdFx0XHRyZXNvbHZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29sb3JBdHRhY2htZW50cy5wdXNoKCB7XG5cdFx0XHRcdFx0XHR2aWV3LFxuXHRcdFx0XHRcdFx0cmVzb2x2ZVRhcmdldCxcblx0XHRcdFx0XHRcdGNsZWFyVmFsdWUsXG5cdFx0XHRcdFx0XHRsb2FkT3A6IEdQVUxvYWRPcC5DbGVhcixcblx0XHRcdFx0XHRcdHN0b3JlT3A6IEdQVVN0b3JlT3AuU3RvcmVcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3VwcG9ydHNEZXB0aCB8fCBzdXBwb3J0c1N0ZW5jaWwgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGVwdGhUZXh0dXJlRGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJUYXJnZXREYXRhLmRlcHRoVGV4dHVyZSApO1xuXG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSB7XG5cdFx0XHRcdFx0dmlldzogZGVwdGhUZXh0dXJlRGF0YS50ZXh0dXJlLmNyZWF0ZVZpZXcoKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKCBzdXBwb3J0c0RlcHRoICkge1xuXG5cdFx0XHRpZiAoIGRlcHRoICkge1xuXG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuZGVwdGhMb2FkT3AgPSBHUFVMb2FkT3AuQ2xlYXI7XG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuZGVwdGhDbGVhclZhbHVlID0gcmVuZGVyZXIuZ2V0Q2xlYXJEZXB0aCgpO1xuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LmRlcHRoU3RvcmVPcCA9IEdQVVN0b3JlT3AuU3RvcmU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudC5kZXB0aExvYWRPcCA9IEdQVUxvYWRPcC5Mb2FkO1xuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LmRlcHRoU3RvcmVPcCA9IEdQVVN0b3JlT3AuU3RvcmU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHN1cHBvcnRzU3RlbmNpbCApIHtcblxuXHRcdFx0aWYgKCBzdGVuY2lsICkge1xuXG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuc3RlbmNpbExvYWRPcCA9IEdQVUxvYWRPcC5DbGVhcjtcblx0XHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudC5zdGVuY2lsQ2xlYXJWYWx1ZSA9IHJlbmRlcmVyLmdldENsZWFyU3RlbmNpbCgpO1xuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnN0ZW5jaWxTdG9yZU9wID0gR1BVU3RvcmVPcC5TdG9yZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnN0ZW5jaWxMb2FkT3AgPSBHUFVMb2FkT3AuTG9hZDtcblx0XHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudC5zdGVuY2lsU3RvcmVPcCA9IEdQVVN0b3JlT3AuU3RvcmU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRjb25zdCBlbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCB7fSApO1xuXHRcdGNvbnN0IGN1cnJlbnRQYXNzID0gZW5jb2Rlci5iZWdpblJlbmRlclBhc3MoIHtcblx0XHRcdGNvbG9yQXR0YWNobWVudHMsXG5cdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50XG5cdFx0fSApO1xuXG5cdFx0Y3VycmVudFBhc3MuZW5kKCk7XG5cblx0XHRkZXZpY2UucXVldWUuc3VibWl0KCBbIGVuY29kZXIuZmluaXNoKCkgXSApO1xuXG5cdH1cblxuXHQvLyBjb21wdXRlXG5cblx0YmVnaW5Db21wdXRlKCBjb21wdXRlR3JvdXAgKSB7XG5cblx0XHRjb25zdCBncm91cEdQVSA9IHRoaXMuZ2V0KCBjb21wdXRlR3JvdXAgKTtcblxuXG5cdFx0Y29uc3QgZGVzY3JpcHRvciA9IHt9O1xuXG5cdFx0dGhpcy5pbml0VGltZXN0YW1wUXVlcnkoIGNvbXB1dGVHcm91cCwgZGVzY3JpcHRvciApO1xuXG5cdFx0Z3JvdXBHUFUuY21kRW5jb2RlckdQVSA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG5cblx0XHRncm91cEdQVS5wYXNzRW5jb2RlckdQVSA9IGdyb3VwR1BVLmNtZEVuY29kZXJHUFUuYmVnaW5Db21wdXRlUGFzcyggZGVzY3JpcHRvciApO1xuXG5cdH1cblxuXHRjb21wdXRlKCBjb21wdXRlR3JvdXAsIGNvbXB1dGVOb2RlLCBiaW5kaW5ncywgcGlwZWxpbmUgKSB7XG5cblx0XHRjb25zdCB7IHBhc3NFbmNvZGVyR1BVIH0gPSB0aGlzLmdldCggY29tcHV0ZUdyb3VwICk7XG5cblx0XHQvLyBwaXBlbGluZVxuXG5cdFx0Y29uc3QgcGlwZWxpbmVHUFUgPSB0aGlzLmdldCggcGlwZWxpbmUgKS5waXBlbGluZTtcblx0XHRwYXNzRW5jb2RlckdQVS5zZXRQaXBlbGluZSggcGlwZWxpbmVHUFUgKTtcblxuXHRcdC8vIGJpbmQgZ3JvdXBzXG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBiaW5kaW5ncy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBiaW5kR3JvdXAgPSBiaW5kaW5nc1sgaSBdO1xuXHRcdFx0Y29uc3QgYmluZGluZ3NEYXRhID0gdGhpcy5nZXQoIGJpbmRHcm91cCApO1xuXG5cdFx0XHRwYXNzRW5jb2RlckdQVS5zZXRCaW5kR3JvdXAoIGksIGJpbmRpbmdzRGF0YS5ncm91cCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24gPSB0aGlzLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb247XG5cblx0XHRjb25zdCBjb21wdXRlTm9kZURhdGEgPSB0aGlzLmdldCggY29tcHV0ZU5vZGUgKTtcblxuXHRcdGlmICggY29tcHV0ZU5vZGVEYXRhLmRpc3BhdGNoU2l6ZSA9PT0gdW5kZWZpbmVkICkgY29tcHV0ZU5vZGVEYXRhLmRpc3BhdGNoU2l6ZSA9IHsgeDogMCwgeTogMSwgejogMSB9O1xuXG5cdFx0Y29uc3QgeyBkaXNwYXRjaFNpemUgfSA9IGNvbXB1dGVOb2RlRGF0YTtcblxuXHRcdGlmICggY29tcHV0ZU5vZGUuZGlzcGF0Y2hDb3VudCA+IG1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uICkge1xuXG5cdFx0XHRkaXNwYXRjaFNpemUueCA9IE1hdGgubWluKCBjb21wdXRlTm9kZS5kaXNwYXRjaENvdW50LCBtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbiApO1xuXHRcdFx0ZGlzcGF0Y2hTaXplLnkgPSBNYXRoLmNlaWwoIGNvbXB1dGVOb2RlLmRpc3BhdGNoQ291bnQgLyBtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZGlzcGF0Y2hTaXplLnggPSBjb21wdXRlTm9kZS5kaXNwYXRjaENvdW50O1xuXG5cdFx0fVxuXG5cdFx0cGFzc0VuY29kZXJHUFUuZGlzcGF0Y2hXb3JrZ3JvdXBzKFxuXHRcdFx0ZGlzcGF0Y2hTaXplLngsXG5cdFx0XHRkaXNwYXRjaFNpemUueSxcblx0XHRcdGRpc3BhdGNoU2l6ZS56XG5cdFx0KTtcblxuXHR9XG5cblx0ZmluaXNoQ29tcHV0ZSggY29tcHV0ZUdyb3VwICkge1xuXG5cdFx0Y29uc3QgZ3JvdXBEYXRhID0gdGhpcy5nZXQoIGNvbXB1dGVHcm91cCApO1xuXG5cdFx0Z3JvdXBEYXRhLnBhc3NFbmNvZGVyR1BVLmVuZCgpO1xuXG5cdFx0dGhpcy5wcmVwYXJlVGltZXN0YW1wQnVmZmVyKCBjb21wdXRlR3JvdXAsIGdyb3VwRGF0YS5jbWRFbmNvZGVyR1BVICk7XG5cblx0XHR0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoIFsgZ3JvdXBEYXRhLmNtZEVuY29kZXJHUFUuZmluaXNoKCkgXSApO1xuXG5cdH1cblxuXHRhc3luYyB3YWl0Rm9yR1BVKCkge1xuXG5cdFx0YXdhaXQgdGhpcy5kZXZpY2UucXVldWUub25TdWJtaXR0ZWRXb3JrRG9uZSgpO1xuXG5cdH1cblxuXHQvLyByZW5kZXIgb2JqZWN0XG5cblx0ZHJhdyggcmVuZGVyT2JqZWN0LCBpbmZvICkge1xuXG5cdFx0Y29uc3QgeyBvYmplY3QsIGNvbnRleHQsIHBpcGVsaW5lIH0gPSByZW5kZXJPYmplY3Q7XG5cdFx0Y29uc3QgYmluZGluZ3MgPSByZW5kZXJPYmplY3QuZ2V0QmluZGluZ3MoKTtcblx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCBjb250ZXh0ICk7XG5cdFx0Y29uc3QgcGlwZWxpbmVHUFUgPSB0aGlzLmdldCggcGlwZWxpbmUgKS5waXBlbGluZTtcblx0XHRjb25zdCBjdXJyZW50U2V0cyA9IHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRTZXRzO1xuXHRcdGNvbnN0IHBhc3NFbmNvZGVyR1BVID0gcmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3M7XG5cblx0XHRjb25zdCBkcmF3UGFyYW1zID0gcmVuZGVyT2JqZWN0LmdldERyYXdQYXJhbWV0ZXJzKCk7XG5cblx0XHRpZiAoIGRyYXdQYXJhbXMgPT09IG51bGwgKSByZXR1cm47XG5cblx0XHQvLyBwaXBlbGluZVxuXG5cdFx0aWYgKCBjdXJyZW50U2V0cy5waXBlbGluZSAhPT0gcGlwZWxpbmVHUFUgKSB7XG5cblx0XHRcdHBhc3NFbmNvZGVyR1BVLnNldFBpcGVsaW5lKCBwaXBlbGluZUdQVSApO1xuXG5cdFx0XHRjdXJyZW50U2V0cy5waXBlbGluZSA9IHBpcGVsaW5lR1BVO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYmluZCBncm91cHNcblxuXHRcdGNvbnN0IGN1cnJlbnRCaW5kaW5nR3JvdXBzID0gY3VycmVudFNldHMuYmluZGluZ0dyb3VwcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGJpbmRpbmdzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGJpbmRHcm91cCA9IGJpbmRpbmdzWyBpIF07XG5cdFx0XHRjb25zdCBiaW5kaW5nc0RhdGEgPSB0aGlzLmdldCggYmluZEdyb3VwICk7XG5cblx0XHRcdGlmICggY3VycmVudEJpbmRpbmdHcm91cHNbIGJpbmRHcm91cC5pbmRleCBdICE9PSBiaW5kR3JvdXAuaWQgKSB7XG5cblx0XHRcdFx0cGFzc0VuY29kZXJHUFUuc2V0QmluZEdyb3VwKCBiaW5kR3JvdXAuaW5kZXgsIGJpbmRpbmdzRGF0YS5ncm91cCApO1xuXHRcdFx0XHRjdXJyZW50QmluZGluZ0dyb3Vwc1sgYmluZEdyb3VwLmluZGV4IF0gPSBiaW5kR3JvdXAuaWQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IGluZGV4ID0gcmVuZGVyT2JqZWN0LmdldEluZGV4KCk7XG5cblx0XHRjb25zdCBoYXNJbmRleCA9ICggaW5kZXggIT09IG51bGwgKTtcblxuXHRcdC8vIGluZGV4XG5cblx0XHRpZiAoIGhhc0luZGV4ID09PSB0cnVlICkge1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRTZXRzLmluZGV4ICE9PSBpbmRleCApIHtcblxuXHRcdFx0XHRjb25zdCBidWZmZXIgPSB0aGlzLmdldCggaW5kZXggKS5idWZmZXI7XG5cdFx0XHRcdGNvbnN0IGluZGV4Rm9ybWF0ID0gKCBpbmRleC5hcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ICkgPyBHUFVJbmRleEZvcm1hdC5VaW50MTYgOiBHUFVJbmRleEZvcm1hdC5VaW50MzI7XG5cblx0XHRcdFx0cGFzc0VuY29kZXJHUFUuc2V0SW5kZXhCdWZmZXIoIGJ1ZmZlciwgaW5kZXhGb3JtYXQgKTtcblxuXHRcdFx0XHRjdXJyZW50U2V0cy5pbmRleCA9IGluZGV4O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyB2ZXJ0ZXggYnVmZmVyc1xuXG5cdFx0Y29uc3QgdmVydGV4QnVmZmVycyA9IHJlbmRlck9iamVjdC5nZXRWZXJ0ZXhCdWZmZXJzKCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB2ZXJ0ZXhCdWZmZXJzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHZlcnRleEJ1ZmZlciA9IHZlcnRleEJ1ZmZlcnNbIGkgXTtcblxuXHRcdFx0aWYgKCBjdXJyZW50U2V0cy5hdHRyaWJ1dGVzWyBpIF0gIT09IHZlcnRleEJ1ZmZlciApIHtcblxuXHRcdFx0XHRjb25zdCBidWZmZXIgPSB0aGlzLmdldCggdmVydGV4QnVmZmVyICkuYnVmZmVyO1xuXHRcdFx0XHRwYXNzRW5jb2RlckdQVS5zZXRWZXJ0ZXhCdWZmZXIoIGksIGJ1ZmZlciApO1xuXG5cdFx0XHRcdGN1cnJlbnRTZXRzLmF0dHJpYnV0ZXNbIGkgXSA9IHZlcnRleEJ1ZmZlcjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gb2NjbHVzaW9uIHF1ZXJpZXMgLSBoYW5kbGUgbXVsdGlwbGUgY29uc2VjdXRpdmUgZHJhdyBjYWxscyBmb3IgYW4gb2JqZWN0XG5cblx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLm9jY2x1c2lvblF1ZXJ5U2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGxhc3RPYmplY3QgPSByZW5kZXJDb250ZXh0RGF0YS5sYXN0T2NjbHVzaW9uT2JqZWN0O1xuXG5cdFx0XHRpZiAoIGxhc3RPYmplY3QgIT09IG9iamVjdCApIHtcblxuXHRcdFx0XHRpZiAoIGxhc3RPYmplY3QgIT09IG51bGwgJiYgbGFzdE9iamVjdC5vY2NsdXNpb25UZXN0ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0cGFzc0VuY29kZXJHUFUuZW5kT2NjbHVzaW9uUXVlcnkoKTtcblx0XHRcdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeUluZGV4ICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9iamVjdC5vY2NsdXNpb25UZXN0ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0cGFzc0VuY29kZXJHUFUuYmVnaW5PY2NsdXNpb25RdWVyeSggcmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlJbmRleCApO1xuXHRcdFx0XHRcdHJlbmRlckNvbnRleHREYXRhLm9jY2x1c2lvblF1ZXJ5T2JqZWN0c1sgcmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlJbmRleCBdID0gb2JqZWN0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5sYXN0T2NjbHVzaW9uT2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBkcmF3XG5cblx0XHRpZiAoIG9iamVjdC5pc0JhdGNoZWRNZXNoID09PSB0cnVlICkge1xuXG5cdFx0XHRjb25zdCBzdGFydHMgPSBvYmplY3QuX211bHRpRHJhd1N0YXJ0cztcblx0XHRcdGNvbnN0IGNvdW50cyA9IG9iamVjdC5fbXVsdGlEcmF3Q291bnRzO1xuXHRcdFx0Y29uc3QgZHJhd0NvdW50ID0gb2JqZWN0Ll9tdWx0aURyYXdDb3VudDtcblx0XHRcdGNvbnN0IGRyYXdJbnN0YW5jZXMgPSBvYmplY3QuX211bHRpRHJhd0luc3RhbmNlcztcblxuXHRcdFx0Y29uc3QgYnl0ZXNQZXJFbGVtZW50ID0gaGFzSW5kZXggPyBpbmRleC5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCA6IDE7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRyYXdDb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjb3VudCA9IGRyYXdJbnN0YW5jZXMgPyBkcmF3SW5zdGFuY2VzWyBpIF0gOiAxO1xuXHRcdFx0XHRjb25zdCBmaXJzdEluc3RhbmNlID0gY291bnQgPiAxID8gMCA6IGk7XG5cblx0XHRcdFx0cGFzc0VuY29kZXJHUFUuZHJhd0luZGV4ZWQoIGNvdW50c1sgaSBdLCBjb3VudCwgc3RhcnRzWyBpIF0gLyBieXRlc1BlckVsZW1lbnQsIDAsIGZpcnN0SW5zdGFuY2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggaGFzSW5kZXggPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IHsgdmVydGV4Q291bnQ6IGluZGV4Q291bnQsIGluc3RhbmNlQ291bnQsIGZpcnN0VmVydGV4OiBmaXJzdEluZGV4IH0gPSBkcmF3UGFyYW1zO1xuXG5cdFx0XHRjb25zdCBpbmRpcmVjdCA9IHJlbmRlck9iamVjdC5nZXRJbmRpcmVjdCgpO1xuXG5cdFx0XHRpZiAoIGluZGlyZWN0ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuZ2V0KCBpbmRpcmVjdCApLmJ1ZmZlcjtcblxuXHRcdFx0XHRwYXNzRW5jb2RlckdQVS5kcmF3SW5kZXhlZEluZGlyZWN0KCBidWZmZXIsIDAgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRwYXNzRW5jb2RlckdQVS5kcmF3SW5kZXhlZCggaW5kZXhDb3VudCwgaW5zdGFuY2VDb3VudCwgZmlyc3RJbmRleCwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGluZm8udXBkYXRlKCBvYmplY3QsIGluZGV4Q291bnQsIGluc3RhbmNlQ291bnQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHsgdmVydGV4Q291bnQsIGluc3RhbmNlQ291bnQsIGZpcnN0VmVydGV4IH0gPSBkcmF3UGFyYW1zO1xuXG5cdFx0XHRjb25zdCBpbmRpcmVjdCA9IHJlbmRlck9iamVjdC5nZXRJbmRpcmVjdCgpO1xuXG5cdFx0XHRpZiAoIGluZGlyZWN0ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuZ2V0KCBpbmRpcmVjdCApLmJ1ZmZlcjtcblxuXHRcdFx0XHRwYXNzRW5jb2RlckdQVS5kcmF3SW5kaXJlY3QoIGJ1ZmZlciwgMCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHBhc3NFbmNvZGVyR1BVLmRyYXcoIHZlcnRleENvdW50LCBpbnN0YW5jZUNvdW50LCBmaXJzdFZlcnRleCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGluZm8udXBkYXRlKCBvYmplY3QsIHZlcnRleENvdW50LCBpbnN0YW5jZUNvdW50ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIGNhY2hlIGtleVxuXG5cdG5lZWRzUmVuZGVyVXBkYXRlKCByZW5kZXJPYmplY3QgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gdGhpcy5nZXQoIHJlbmRlck9iamVjdCApO1xuXG5cdFx0Y29uc3QgeyBvYmplY3QsIG1hdGVyaWFsIH0gPSByZW5kZXJPYmplY3Q7XG5cblx0XHRjb25zdCB1dGlscyA9IHRoaXMudXRpbHM7XG5cblx0XHRjb25zdCBzYW1wbGVDb3VudCA9IHV0aWxzLmdldFNhbXBsZUNvdW50UmVuZGVyQ29udGV4dCggcmVuZGVyT2JqZWN0LmNvbnRleHQgKTtcblx0XHRjb25zdCBjb2xvclNwYWNlID0gdXRpbHMuZ2V0Q3VycmVudENvbG9yU3BhY2UoIHJlbmRlck9iamVjdC5jb250ZXh0ICk7XG5cdFx0Y29uc3QgY29sb3JGb3JtYXQgPSB1dGlscy5nZXRDdXJyZW50Q29sb3JGb3JtYXQoIHJlbmRlck9iamVjdC5jb250ZXh0ICk7XG5cdFx0Y29uc3QgZGVwdGhTdGVuY2lsRm9ybWF0ID0gdXRpbHMuZ2V0Q3VycmVudERlcHRoU3RlbmNpbEZvcm1hdCggcmVuZGVyT2JqZWN0LmNvbnRleHQgKTtcblx0XHRjb25zdCBwcmltaXRpdmVUb3BvbG9neSA9IHV0aWxzLmdldFByaW1pdGl2ZVRvcG9sb2d5KCBvYmplY3QsIG1hdGVyaWFsICk7XG5cblx0XHRsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdGlmICggZGF0YS5tYXRlcmlhbCAhPT0gbWF0ZXJpYWwgfHwgZGF0YS5tYXRlcmlhbFZlcnNpb24gIT09IG1hdGVyaWFsLnZlcnNpb24gfHxcblx0XHRcdGRhdGEudHJhbnNwYXJlbnQgIT09IG1hdGVyaWFsLnRyYW5zcGFyZW50IHx8IGRhdGEuYmxlbmRpbmcgIT09IG1hdGVyaWFsLmJsZW5kaW5nIHx8IGRhdGEucHJlbXVsdGlwbGllZEFscGhhICE9PSBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEgfHxcblx0XHRcdGRhdGEuYmxlbmRTcmMgIT09IG1hdGVyaWFsLmJsZW5kU3JjIHx8IGRhdGEuYmxlbmREc3QgIT09IG1hdGVyaWFsLmJsZW5kRHN0IHx8IGRhdGEuYmxlbmRFcXVhdGlvbiAhPT0gbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiB8fFxuXHRcdFx0ZGF0YS5ibGVuZFNyY0FscGhhICE9PSBtYXRlcmlhbC5ibGVuZFNyY0FscGhhIHx8IGRhdGEuYmxlbmREc3RBbHBoYSAhPT0gbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSB8fCBkYXRhLmJsZW5kRXF1YXRpb25BbHBoYSAhPT0gbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhIHx8XG5cdFx0XHRkYXRhLmNvbG9yV3JpdGUgIT09IG1hdGVyaWFsLmNvbG9yV3JpdGUgfHwgZGF0YS5kZXB0aFdyaXRlICE9PSBtYXRlcmlhbC5kZXB0aFdyaXRlIHx8IGRhdGEuZGVwdGhUZXN0ICE9PSBtYXRlcmlhbC5kZXB0aFRlc3QgfHwgZGF0YS5kZXB0aEZ1bmMgIT09IG1hdGVyaWFsLmRlcHRoRnVuYyB8fFxuXHRcdFx0ZGF0YS5zdGVuY2lsV3JpdGUgIT09IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZSB8fCBkYXRhLnN0ZW5jaWxGdW5jICE9PSBtYXRlcmlhbC5zdGVuY2lsRnVuYyB8fFxuXHRcdFx0ZGF0YS5zdGVuY2lsRmFpbCAhPT0gbWF0ZXJpYWwuc3RlbmNpbEZhaWwgfHwgZGF0YS5zdGVuY2lsWkZhaWwgIT09IG1hdGVyaWFsLnN0ZW5jaWxaRmFpbCB8fCBkYXRhLnN0ZW5jaWxaUGFzcyAhPT0gbWF0ZXJpYWwuc3RlbmNpbFpQYXNzIHx8XG5cdFx0XHRkYXRhLnN0ZW5jaWxGdW5jTWFzayAhPT0gbWF0ZXJpYWwuc3RlbmNpbEZ1bmNNYXNrIHx8IGRhdGEuc3RlbmNpbFdyaXRlTWFzayAhPT0gbWF0ZXJpYWwuc3RlbmNpbFdyaXRlTWFzayB8fFxuXHRcdFx0ZGF0YS5zaWRlICE9PSBtYXRlcmlhbC5zaWRlIHx8IGRhdGEuYWxwaGFUb0NvdmVyYWdlICE9PSBtYXRlcmlhbC5hbHBoYVRvQ292ZXJhZ2UgfHxcblx0XHRcdGRhdGEuc2FtcGxlQ291bnQgIT09IHNhbXBsZUNvdW50IHx8IGRhdGEuY29sb3JTcGFjZSAhPT0gY29sb3JTcGFjZSB8fFxuXHRcdFx0ZGF0YS5jb2xvckZvcm1hdCAhPT0gY29sb3JGb3JtYXQgfHwgZGF0YS5kZXB0aFN0ZW5jaWxGb3JtYXQgIT09IGRlcHRoU3RlbmNpbEZvcm1hdCB8fFxuXHRcdFx0ZGF0YS5wcmltaXRpdmVUb3BvbG9neSAhPT0gcHJpbWl0aXZlVG9wb2xvZ3kgfHxcblx0XHRcdGRhdGEuY2xpcHBpbmdDb250ZXh0Q2FjaGVLZXkgIT09IHJlbmRlck9iamVjdC5jbGlwcGluZ0NvbnRleHRDYWNoZUtleVxuXHRcdCkge1xuXG5cdFx0XHRkYXRhLm1hdGVyaWFsID0gbWF0ZXJpYWw7IGRhdGEubWF0ZXJpYWxWZXJzaW9uID0gbWF0ZXJpYWwudmVyc2lvbjtcblx0XHRcdGRhdGEudHJhbnNwYXJlbnQgPSBtYXRlcmlhbC50cmFuc3BhcmVudDsgZGF0YS5ibGVuZGluZyA9IG1hdGVyaWFsLmJsZW5kaW5nOyBkYXRhLnByZW11bHRpcGxpZWRBbHBoYSA9IG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRcdGRhdGEuYmxlbmRTcmMgPSBtYXRlcmlhbC5ibGVuZFNyYzsgZGF0YS5ibGVuZERzdCA9IG1hdGVyaWFsLmJsZW5kRHN0OyBkYXRhLmJsZW5kRXF1YXRpb24gPSBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uO1xuXHRcdFx0ZGF0YS5ibGVuZFNyY0FscGhhID0gbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYTsgZGF0YS5ibGVuZERzdEFscGhhID0gbWF0ZXJpYWwuYmxlbmREc3RBbHBoYTsgZGF0YS5ibGVuZEVxdWF0aW9uQWxwaGEgPSBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGE7XG5cdFx0XHRkYXRhLmNvbG9yV3JpdGUgPSBtYXRlcmlhbC5jb2xvcldyaXRlO1xuXHRcdFx0ZGF0YS5kZXB0aFdyaXRlID0gbWF0ZXJpYWwuZGVwdGhXcml0ZTsgZGF0YS5kZXB0aFRlc3QgPSBtYXRlcmlhbC5kZXB0aFRlc3Q7IGRhdGEuZGVwdGhGdW5jID0gbWF0ZXJpYWwuZGVwdGhGdW5jO1xuXHRcdFx0ZGF0YS5zdGVuY2lsV3JpdGUgPSBtYXRlcmlhbC5zdGVuY2lsV3JpdGU7IGRhdGEuc3RlbmNpbEZ1bmMgPSBtYXRlcmlhbC5zdGVuY2lsRnVuYztcblx0XHRcdGRhdGEuc3RlbmNpbEZhaWwgPSBtYXRlcmlhbC5zdGVuY2lsRmFpbDsgZGF0YS5zdGVuY2lsWkZhaWwgPSBtYXRlcmlhbC5zdGVuY2lsWkZhaWw7IGRhdGEuc3RlbmNpbFpQYXNzID0gbWF0ZXJpYWwuc3RlbmNpbFpQYXNzO1xuXHRcdFx0ZGF0YS5zdGVuY2lsRnVuY01hc2sgPSBtYXRlcmlhbC5zdGVuY2lsRnVuY01hc2s7IGRhdGEuc3RlbmNpbFdyaXRlTWFzayA9IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2s7XG5cdFx0XHRkYXRhLnNpZGUgPSBtYXRlcmlhbC5zaWRlOyBkYXRhLmFscGhhVG9Db3ZlcmFnZSA9IG1hdGVyaWFsLmFscGhhVG9Db3ZlcmFnZTtcblx0XHRcdGRhdGEuc2FtcGxlQ291bnQgPSBzYW1wbGVDb3VudDtcblx0XHRcdGRhdGEuY29sb3JTcGFjZSA9IGNvbG9yU3BhY2U7XG5cdFx0XHRkYXRhLmNvbG9yRm9ybWF0ID0gY29sb3JGb3JtYXQ7XG5cdFx0XHRkYXRhLmRlcHRoU3RlbmNpbEZvcm1hdCA9IGRlcHRoU3RlbmNpbEZvcm1hdDtcblx0XHRcdGRhdGEucHJpbWl0aXZlVG9wb2xvZ3kgPSBwcmltaXRpdmVUb3BvbG9neTtcblx0XHRcdGRhdGEuY2xpcHBpbmdDb250ZXh0Q2FjaGVLZXkgPSByZW5kZXJPYmplY3QuY2xpcHBpbmdDb250ZXh0Q2FjaGVLZXk7XG5cblx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZWVkc1VwZGF0ZTtcblxuXHR9XG5cblx0Z2V0UmVuZGVyQ2FjaGVLZXkoIHJlbmRlck9iamVjdCApIHtcblxuXHRcdGNvbnN0IHsgb2JqZWN0LCBtYXRlcmlhbCB9ID0gcmVuZGVyT2JqZWN0O1xuXG5cdFx0Y29uc3QgdXRpbHMgPSB0aGlzLnV0aWxzO1xuXHRcdGNvbnN0IHJlbmRlckNvbnRleHQgPSByZW5kZXJPYmplY3QuY29udGV4dDtcblxuXHRcdHJldHVybiBbXG5cdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCwgbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSxcblx0XHRcdG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCwgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbixcblx0XHRcdG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSxcblx0XHRcdG1hdGVyaWFsLmNvbG9yV3JpdGUsXG5cdFx0XHRtYXRlcmlhbC5kZXB0aFdyaXRlLCBtYXRlcmlhbC5kZXB0aFRlc3QsIG1hdGVyaWFsLmRlcHRoRnVuYyxcblx0XHRcdG1hdGVyaWFsLnN0ZW5jaWxXcml0ZSwgbWF0ZXJpYWwuc3RlbmNpbEZ1bmMsXG5cdFx0XHRtYXRlcmlhbC5zdGVuY2lsRmFpbCwgbWF0ZXJpYWwuc3RlbmNpbFpGYWlsLCBtYXRlcmlhbC5zdGVuY2lsWlBhc3MsXG5cdFx0XHRtYXRlcmlhbC5zdGVuY2lsRnVuY01hc2ssIG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2ssXG5cdFx0XHRtYXRlcmlhbC5zaWRlLFxuXHRcdFx0dXRpbHMuZ2V0U2FtcGxlQ291bnRSZW5kZXJDb250ZXh0KCByZW5kZXJDb250ZXh0ICksXG5cdFx0XHR1dGlscy5nZXRDdXJyZW50Q29sb3JTcGFjZSggcmVuZGVyQ29udGV4dCApLCB1dGlscy5nZXRDdXJyZW50Q29sb3JGb3JtYXQoIHJlbmRlckNvbnRleHQgKSwgdXRpbHMuZ2V0Q3VycmVudERlcHRoU3RlbmNpbEZvcm1hdCggcmVuZGVyQ29udGV4dCApLFxuXHRcdFx0dXRpbHMuZ2V0UHJpbWl0aXZlVG9wb2xvZ3koIG9iamVjdCwgbWF0ZXJpYWwgKSxcblx0XHRcdHJlbmRlck9iamVjdC5nZXRHZW9tZXRyeUNhY2hlS2V5KCksXG5cdFx0XHRyZW5kZXJPYmplY3QuY2xpcHBpbmdDb250ZXh0Q2FjaGVLZXlcblx0XHRdLmpvaW4oKTtcblxuXHR9XG5cblx0Ly8gdGV4dHVyZXNcblxuXHRjcmVhdGVTYW1wbGVyKCB0ZXh0dXJlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMuY3JlYXRlU2FtcGxlciggdGV4dHVyZSApO1xuXG5cdH1cblxuXHRkZXN0cm95U2FtcGxlciggdGV4dHVyZSApIHtcblxuXHRcdHRoaXMudGV4dHVyZVV0aWxzLmRlc3Ryb3lTYW1wbGVyKCB0ZXh0dXJlICk7XG5cblx0fVxuXG5cdGNyZWF0ZURlZmF1bHRUZXh0dXJlKCB0ZXh0dXJlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMuY3JlYXRlRGVmYXVsdFRleHR1cmUoIHRleHR1cmUgKTtcblxuXHR9XG5cblx0Y3JlYXRlVGV4dHVyZSggdGV4dHVyZSwgb3B0aW9ucyApIHtcblxuXHRcdHRoaXMudGV4dHVyZVV0aWxzLmNyZWF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKTtcblxuXHR9XG5cblx0dXBkYXRlVGV4dHVyZSggdGV4dHVyZSwgb3B0aW9ucyApIHtcblxuXHRcdHRoaXMudGV4dHVyZVV0aWxzLnVwZGF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMuZ2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICk7XG5cblx0fVxuXG5cdGRlc3Ryb3lUZXh0dXJlKCB0ZXh0dXJlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMuZGVzdHJveVRleHR1cmUoIHRleHR1cmUgKTtcblxuXHR9XG5cblx0Y29weVRleHR1cmVUb0J1ZmZlciggdGV4dHVyZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZmFjZUluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudGV4dHVyZVV0aWxzLmNvcHlUZXh0dXJlVG9CdWZmZXIoIHRleHR1cmUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZhY2VJbmRleCApO1xuXG5cdH1cblxuXG5cdGluaXRUaW1lc3RhbXBRdWVyeSggcmVuZGVyQ29udGV4dCwgZGVzY3JpcHRvciApIHtcblxuXHRcdGlmICggISB0aGlzLnRyYWNrVGltZXN0YW1wICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dCApO1xuXG5cdFx0aWYgKCAhIHJlbmRlckNvbnRleHREYXRhLnRpbWVTdGFtcFF1ZXJ5U2V0ICkge1xuXG5cblx0XHRcdGNvbnN0IHR5cGUgPSByZW5kZXJDb250ZXh0LmlzQ29tcHV0ZU5vZGUgPyAnY29tcHV0ZScgOiAncmVuZGVyJztcblx0XHRcdGNvbnN0IHRpbWVTdGFtcFF1ZXJ5U2V0ID0gdGhpcy5kZXZpY2UuY3JlYXRlUXVlcnlTZXQoIHsgdHlwZTogJ3RpbWVzdGFtcCcsIGNvdW50OiAyLCBsYWJlbDogYHRpbWVzdGFtcF8ke3R5cGV9XyR7cmVuZGVyQ29udGV4dC5pZH1gIH0gKTtcblxuXHRcdFx0Y29uc3QgdGltZXN0YW1wV3JpdGVzID0ge1xuXHRcdFx0XHRxdWVyeVNldDogdGltZVN0YW1wUXVlcnlTZXQsXG5cdFx0XHRcdGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6IDAsIC8vIFdyaXRlIHRpbWVzdGFtcCBpbiBpbmRleCAwIHdoZW4gcGFzcyBiZWdpbnMuXG5cdFx0XHRcdGVuZE9mUGFzc1dyaXRlSW5kZXg6IDEsIC8vIFdyaXRlIHRpbWVzdGFtcCBpbiBpbmRleCAxIHdoZW4gcGFzcyBlbmRzLlxuXHRcdFx0fTtcblxuXHRcdFx0T2JqZWN0LmFzc2lnbiggZGVzY3JpcHRvciwgeyB0aW1lc3RhbXBXcml0ZXMgfSApO1xuXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS50aW1lU3RhbXBRdWVyeVNldCA9IHRpbWVTdGFtcFF1ZXJ5U2V0O1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyB0aW1lc3RhbXAgdXRpbHNcblxuXHRwcmVwYXJlVGltZXN0YW1wQnVmZmVyKCByZW5kZXJDb250ZXh0LCBlbmNvZGVyICkge1xuXG5cdFx0aWYgKCAhIHRoaXMudHJhY2tUaW1lc3RhbXAgKSByZXR1cm47XG5cblx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0ICk7XG5cblxuXHRcdGNvbnN0IHNpemUgPSAyICogQmlnSW50NjRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEuY3VycmVudFRpbWVzdGFtcFF1ZXJ5QnVmZmVycyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50VGltZXN0YW1wUXVlcnlCdWZmZXJzID0ge1xuXHRcdFx0XHRyZXNvbHZlQnVmZmVyOiB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoIHtcblx0XHRcdFx0XHRsYWJlbDogJ3RpbWVzdGFtcCByZXNvbHZlIGJ1ZmZlcicsXG5cdFx0XHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdFx0XHR1c2FnZTogR1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDLFxuXHRcdFx0XHR9ICksXG5cdFx0XHRcdHJlc3VsdEJ1ZmZlcjogdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKCB7XG5cdFx0XHRcdFx0bGFiZWw6ICd0aW1lc3RhbXAgcmVzdWx0IGJ1ZmZlcicsXG5cdFx0XHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdFx0XHR1c2FnZTogR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgfCBHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRCxcblx0XHRcdFx0fSApXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgeyByZXNvbHZlQnVmZmVyLCByZXN1bHRCdWZmZXIgfSA9IHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRUaW1lc3RhbXBRdWVyeUJ1ZmZlcnM7XG5cblxuXHRcdGVuY29kZXIucmVzb2x2ZVF1ZXJ5U2V0KCByZW5kZXJDb250ZXh0RGF0YS50aW1lU3RhbXBRdWVyeVNldCwgMCwgMiwgcmVzb2x2ZUJ1ZmZlciwgMCApO1xuXG5cdFx0aWYgKCByZXN1bHRCdWZmZXIubWFwU3RhdGUgPT09ICd1bm1hcHBlZCcgKSB7XG5cblx0XHRcdGVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKCByZXNvbHZlQnVmZmVyLCAwLCByZXN1bHRCdWZmZXIsIDAsIHNpemUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0YXN5bmMgcmVzb2x2ZVRpbWVzdGFtcEFzeW5jKCByZW5kZXJDb250ZXh0LCB0eXBlID0gJ3JlbmRlcicgKSB7XG5cblx0XHRpZiAoICEgdGhpcy50cmFja1RpbWVzdGFtcCApIHJldHVybjtcblxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcblxuXHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEuY3VycmVudFRpbWVzdGFtcFF1ZXJ5QnVmZmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgeyByZXN1bHRCdWZmZXIgfSA9IHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRUaW1lc3RhbXBRdWVyeUJ1ZmZlcnM7XG5cblx0XHRhd2FpdCB0aGlzLmRldmljZS5xdWV1ZS5vblN1Ym1pdHRlZFdvcmtEb25lKCk7XG5cblx0XHRpZiAoIHJlc3VsdEJ1ZmZlci5tYXBTdGF0ZSA9PT0gJ3VubWFwcGVkJyApIHtcblxuXHRcdFx0cmVzdWx0QnVmZmVyLm1hcEFzeW5jKCBHUFVNYXBNb2RlLlJFQUQgKS50aGVuKCAoKSA9PiB7XG5cblx0XHRcdFx0Y29uc3QgdGltZXMgPSBuZXcgQmlnVWludDY0QXJyYXkoIHJlc3VsdEJ1ZmZlci5nZXRNYXBwZWRSYW5nZSgpICk7XG5cdFx0XHRcdGNvbnN0IGR1cmF0aW9uID0gTnVtYmVyKCB0aW1lc1sgMSBdIC0gdGltZXNbIDAgXSApIC8gMTAwMDAwMDtcblxuXG5cdFx0XHRcdHRoaXMucmVuZGVyZXIuaW5mby51cGRhdGVUaW1lc3RhbXAoIHR5cGUsIGR1cmF0aW9uICk7XG5cblx0XHRcdFx0cmVzdWx0QnVmZmVyLnVubWFwKCk7XG5cblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBub2RlIGJ1aWxkZXJcblxuXHRjcmVhdGVOb2RlQnVpbGRlciggb2JqZWN0LCByZW5kZXJlciApIHtcblxuXHRcdHJldHVybiBuZXcgV0dTTE5vZGVCdWlsZGVyKCBvYmplY3QsIHJlbmRlcmVyICk7XG5cblx0fVxuXG5cdC8vIHByb2dyYW1cblxuXHRjcmVhdGVQcm9ncmFtKCBwcm9ncmFtICkge1xuXG5cdFx0Y29uc3QgcHJvZ3JhbUdQVSA9IHRoaXMuZ2V0KCBwcm9ncmFtICk7XG5cblx0XHRwcm9ncmFtR1BVLm1vZHVsZSA9IHtcblx0XHRcdG1vZHVsZTogdGhpcy5kZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKCB7IGNvZGU6IHByb2dyYW0uY29kZSwgbGFiZWw6IHByb2dyYW0uc3RhZ2UgfSApLFxuXHRcdFx0ZW50cnlQb2ludDogJ21haW4nXG5cdFx0fTtcblxuXHR9XG5cblx0ZGVzdHJveVByb2dyYW0oIHByb2dyYW0gKSB7XG5cblx0XHR0aGlzLmRlbGV0ZSggcHJvZ3JhbSApO1xuXG5cdH1cblxuXHQvLyBwaXBlbGluZXNcblxuXHRjcmVhdGVSZW5kZXJQaXBlbGluZSggcmVuZGVyT2JqZWN0LCBwcm9taXNlcyApIHtcblxuXHRcdHRoaXMucGlwZWxpbmVVdGlscy5jcmVhdGVSZW5kZXJQaXBlbGluZSggcmVuZGVyT2JqZWN0LCBwcm9taXNlcyApO1xuXG5cdH1cblxuXHRjcmVhdGVDb21wdXRlUGlwZWxpbmUoIGNvbXB1dGVQaXBlbGluZSwgYmluZGluZ3MgKSB7XG5cblx0XHR0aGlzLnBpcGVsaW5lVXRpbHMuY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKCBjb21wdXRlUGlwZWxpbmUsIGJpbmRpbmdzICk7XG5cblx0fVxuXG5cdGJlZ2luQnVuZGxlKCByZW5kZXJDb250ZXh0ICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dCApO1xuXG5cdFx0cmVuZGVyQ29udGV4dERhdGEuX2N1cnJlbnRQYXNzID0gcmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3M7XG5cdFx0cmVuZGVyQ29udGV4dERhdGEuX2N1cnJlbnRTZXRzID0gcmVuZGVyQ29udGV4dERhdGEuY3VycmVudFNldHM7XG5cblx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50U2V0cyA9IHsgYXR0cmlidXRlczoge30sIGJpbmRpbmdHcm91cHM6IFtdLCBwaXBlbGluZTogbnVsbCwgaW5kZXg6IG51bGwgfTtcblx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50UGFzcyA9IHRoaXMucGlwZWxpbmVVdGlscy5jcmVhdGVCdW5kbGVFbmNvZGVyKCByZW5kZXJDb250ZXh0ICk7XG5cblx0fVxuXG5cdGZpbmlzaEJ1bmRsZSggcmVuZGVyQ29udGV4dCwgYnVuZGxlICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dCApO1xuXG5cdFx0Y29uc3QgYnVuZGxlRW5jb2RlciA9IHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRQYXNzO1xuXHRcdGNvbnN0IGJ1bmRsZUdQVSA9IGJ1bmRsZUVuY29kZXIuZmluaXNoKCk7XG5cblx0XHR0aGlzLmdldCggYnVuZGxlICkuYnVuZGxlR1BVID0gYnVuZGxlR1BVO1xuXG5cdFx0Ly8gcmVzdG9yZSByZW5kZXIgcGFzcyBzdGF0ZVxuXG5cdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudFNldHMgPSByZW5kZXJDb250ZXh0RGF0YS5fY3VycmVudFNldHM7XG5cdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3MgPSByZW5kZXJDb250ZXh0RGF0YS5fY3VycmVudFBhc3M7XG5cblx0fVxuXG5cdGFkZEJ1bmRsZSggcmVuZGVyQ29udGV4dCwgYnVuZGxlICkge1xuXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dCApO1xuXG5cdFx0cmVuZGVyQ29udGV4dERhdGEucmVuZGVyQnVuZGxlcy5wdXNoKCB0aGlzLmdldCggYnVuZGxlICkuYnVuZGxlR1BVICk7XG5cblx0fVxuXG5cdC8vIGJpbmRpbmdzXG5cblx0Y3JlYXRlQmluZGluZ3MoIGJpbmRHcm91cCwgYmluZGluZ3MsIGNhY2hlSW5kZXgsIHZlcnNpb24gKSB7XG5cblx0XHR0aGlzLmJpbmRpbmdVdGlscy5jcmVhdGVCaW5kaW5ncyggYmluZEdyb3VwLCBiaW5kaW5ncywgY2FjaGVJbmRleCwgdmVyc2lvbiApO1xuXG5cdH1cblxuXHR1cGRhdGVCaW5kaW5ncyggYmluZEdyb3VwLCBiaW5kaW5ncywgY2FjaGVJbmRleCwgdmVyc2lvbiApIHtcblxuXHRcdHRoaXMuYmluZGluZ1V0aWxzLmNyZWF0ZUJpbmRpbmdzKCBiaW5kR3JvdXAsIGJpbmRpbmdzLCBjYWNoZUluZGV4LCB2ZXJzaW9uICk7XG5cblx0fVxuXG5cdHVwZGF0ZUJpbmRpbmcoIGJpbmRpbmcgKSB7XG5cblx0XHR0aGlzLmJpbmRpbmdVdGlscy51cGRhdGVCaW5kaW5nKCBiaW5kaW5nICk7XG5cblx0fVxuXG5cdC8vIGF0dHJpYnV0ZXNcblxuXHRjcmVhdGVJbmRleEF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0dGhpcy5hdHRyaWJ1dGVVdGlscy5jcmVhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgR1BVQnVmZmVyVXNhZ2UuSU5ERVggfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUICk7XG5cblx0fVxuXG5cdGNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0dGhpcy5hdHRyaWJ1dGVVdGlscy5jcmVhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgR1BVQnVmZmVyVXNhZ2UuVkVSVEVYIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCApO1xuXG5cdH1cblxuXHRjcmVhdGVTdG9yYWdlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHR0aGlzLmF0dHJpYnV0ZVV0aWxzLmNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFIHwgR1BVQnVmZmVyVXNhZ2UuVkVSVEVYIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCApO1xuXG5cdH1cblxuXHRjcmVhdGVJbmRpcmVjdFN0b3JhZ2VBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuXHRcdHRoaXMuYXR0cmlidXRlVXRpbHMuY3JlYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5JTkRJUkVDVCB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgKTtcblxuXHR9XG5cblx0dXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHR0aGlzLmF0dHJpYnV0ZVV0aWxzLnVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICk7XG5cblx0fVxuXG5cdGRlc3Ryb3lBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuXHRcdHRoaXMuYXR0cmlidXRlVXRpbHMuZGVzdHJveUF0dHJpYnV0ZSggYXR0cmlidXRlICk7XG5cblx0fVxuXG5cdC8vIGNhbnZhc1xuXG5cdHVwZGF0ZVNpemUoKSB7XG5cblx0XHR0aGlzLmNvbG9yQnVmZmVyID0gdGhpcy50ZXh0dXJlVXRpbHMuZ2V0Q29sb3JCdWZmZXIoKTtcblx0XHR0aGlzLmRlZmF1bHRSZW5kZXJQYXNzZGVzY3JpcHRvciA9IG51bGw7XG5cblx0fVxuXG5cdC8vIHV0aWxzIHB1YmxpY1xuXG5cdGdldE1heEFuaXNvdHJvcHkoKSB7XG5cblx0XHRyZXR1cm4gMTY7XG5cblx0fVxuXG5cdGhhc0ZlYXR1cmUoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKCBuYW1lICk7XG5cblx0fVxuXG5cdGNvcHlUZXh0dXJlVG9UZXh0dXJlKCBzcmNUZXh0dXJlLCBkc3RUZXh0dXJlLCBzcmNSZWdpb24gPSBudWxsLCBkc3RQb3NpdGlvbiA9IG51bGwsIGxldmVsID0gMCApIHtcblxuXHRcdGxldCBkc3RYID0gMDtcblx0XHRsZXQgZHN0WSA9IDA7XG5cdFx0bGV0IGRzdExheWVyID0gMDtcblxuXHRcdGxldCBzcmNYID0gMDtcblx0XHRsZXQgc3JjWSA9IDA7XG5cdFx0bGV0IHNyY0xheWVyID0gMDtcblxuXHRcdGxldCBzcmNXaWR0aCA9IHNyY1RleHR1cmUuaW1hZ2Uud2lkdGg7XG5cdFx0bGV0IHNyY0hlaWdodCA9IHNyY1RleHR1cmUuaW1hZ2UuaGVpZ2h0O1xuXG5cdFx0aWYgKCBzcmNSZWdpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdHNyY1ggPSBzcmNSZWdpb24ueDtcblx0XHRcdHNyY1kgPSBzcmNSZWdpb24ueTtcblx0XHRcdHNyY0xheWVyID0gc3JjUmVnaW9uLnogfHwgMDtcblx0XHRcdHNyY1dpZHRoID0gc3JjUmVnaW9uLndpZHRoO1xuXHRcdFx0c3JjSGVpZ2h0ID0gc3JjUmVnaW9uLmhlaWdodDtcblxuXHRcdH1cblxuXHRcdGlmICggZHN0UG9zaXRpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdGRzdFggPSBkc3RQb3NpdGlvbi54O1xuXHRcdFx0ZHN0WSA9IGRzdFBvc2l0aW9uLnk7XG5cdFx0XHRkc3RMYXllciA9IGRzdFBvc2l0aW9uLnogfHwgMDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGVuY29kZXIgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlciggeyBsYWJlbDogJ2NvcHlUZXh0dXJlVG9UZXh0dXJlXycgKyBzcmNUZXh0dXJlLmlkICsgJ18nICsgZHN0VGV4dHVyZS5pZCB9ICk7XG5cblx0XHRjb25zdCBzb3VyY2VHUFUgPSB0aGlzLmdldCggc3JjVGV4dHVyZSApLnRleHR1cmU7XG5cdFx0Y29uc3QgZGVzdGluYXRpb25HUFUgPSB0aGlzLmdldCggZHN0VGV4dHVyZSApLnRleHR1cmU7XG5cblx0XHRlbmNvZGVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlKFxuXHRcdFx0e1xuXHRcdFx0XHR0ZXh0dXJlOiBzb3VyY2VHUFUsXG5cdFx0XHRcdG1pcExldmVsOiBsZXZlbCxcblx0XHRcdFx0b3JpZ2luOiB7IHg6IHNyY1gsIHk6IHNyY1ksIHo6IHNyY0xheWVyIH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHRleHR1cmU6IGRlc3RpbmF0aW9uR1BVLFxuXHRcdFx0XHRtaXBMZXZlbDogbGV2ZWwsXG5cdFx0XHRcdG9yaWdpbjogeyB4OiBkc3RYLCB5OiBkc3RZLCB6OiBkc3RMYXllciB9XG5cdFx0XHR9LFxuXHRcdFx0W1xuXHRcdFx0XHRzcmNXaWR0aCxcblx0XHRcdFx0c3JjSGVpZ2h0LFxuXHRcdFx0XHQxXG5cdFx0XHRdXG5cdFx0KTtcblxuXHRcdHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdCggWyBlbmNvZGVyLmZpbmlzaCgpIF0gKTtcblxuXHR9XG5cblx0Y29weUZyYW1lYnVmZmVyVG9UZXh0dXJlKCB0ZXh0dXJlLCByZW5kZXJDb250ZXh0LCByZWN0YW5nbGUgKSB7XG5cblx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0ICk7XG5cblx0XHRsZXQgc291cmNlR1BVID0gbnVsbDtcblxuXHRcdGlmICggcmVuZGVyQ29udGV4dC5yZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdGlmICggdGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcblxuXHRcdFx0XHRzb3VyY2VHUFUgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dC5kZXB0aFRleHR1cmUgKS50ZXh0dXJlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHNvdXJjZUdQVSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0LnRleHR1cmVzWyAwIF0gKS50ZXh0dXJlO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIHRleHR1cmUuaXNEZXB0aFRleHR1cmUgKSB7XG5cblx0XHRcdFx0c291cmNlR1BVID0gdGhpcy50ZXh0dXJlVXRpbHMuZ2V0RGVwdGhCdWZmZXIoIHJlbmRlckNvbnRleHQuZGVwdGgsIHJlbmRlckNvbnRleHQuc3RlbmNpbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHNvdXJjZUdQVSA9IHRoaXMuY29udGV4dC5nZXRDdXJyZW50VGV4dHVyZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBkZXN0aW5hdGlvbkdQVSA9IHRoaXMuZ2V0KCB0ZXh0dXJlICkudGV4dHVyZTtcblxuXHRcdGlmICggc291cmNlR1BVLmZvcm1hdCAhPT0gZGVzdGluYXRpb25HUFUuZm9ybWF0ICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnV2ViR1BVQmFja2VuZDogY29weUZyYW1lYnVmZmVyVG9UZXh0dXJlOiBTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGZvcm1hdHMgZG8gbm90IG1hdGNoLicsIHNvdXJjZUdQVS5mb3JtYXQsIGRlc3RpbmF0aW9uR1BVLmZvcm1hdCApO1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRsZXQgZW5jb2RlcjtcblxuXHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3MgKSB7XG5cblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRQYXNzLmVuZCgpO1xuXG5cdFx0XHRlbmNvZGVyID0gcmVuZGVyQ29udGV4dERhdGEuZW5jb2RlcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGVuY29kZXIgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlciggeyBsYWJlbDogJ2NvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZV8nICsgdGV4dHVyZS5pZCB9ICk7XG5cblx0XHR9XG5cblx0XHRlbmNvZGVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlKFxuXHRcdFx0e1xuXHRcdFx0XHR0ZXh0dXJlOiBzb3VyY2VHUFUsXG5cdFx0XHRcdG9yaWdpbjogWyByZWN0YW5nbGUueCwgcmVjdGFuZ2xlLnksIDAgXSxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHRleHR1cmU6IGRlc3RpbmF0aW9uR1BVXG5cdFx0XHR9LFxuXHRcdFx0W1xuXHRcdFx0XHRyZWN0YW5nbGUueixcblx0XHRcdFx0cmVjdGFuZ2xlLndcblx0XHRcdF1cblx0XHQpO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyApIHRoaXMudGV4dHVyZVV0aWxzLmdlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSApO1xuXG5cdFx0aWYgKCByZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50UGFzcyApIHtcblxuXHRcdFx0Y29uc3QgeyBkZXNjcmlwdG9yIH0gPSByZW5kZXJDb250ZXh0RGF0YTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZGVzY3JpcHRvci5jb2xvckF0dGFjaG1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRkZXNjcmlwdG9yLmNvbG9yQXR0YWNobWVudHNbIGkgXS5sb2FkT3AgPSBHUFVMb2FkT3AuTG9hZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHJlbmRlckNvbnRleHQuZGVwdGggKSBkZXNjcmlwdG9yLmRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuZGVwdGhMb2FkT3AgPSBHUFVMb2FkT3AuTG9hZDtcblx0XHRcdGlmICggcmVuZGVyQ29udGV4dC5zdGVuY2lsICkgZGVzY3JpcHRvci5kZXB0aFN0ZW5jaWxBdHRhY2htZW50LnN0ZW5jaWxMb2FkT3AgPSBHUFVMb2FkT3AuTG9hZDtcblxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3MgPSBlbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyggZGVzY3JpcHRvciApO1xuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudFNldHMgPSB7IGF0dHJpYnV0ZXM6IHt9LCBiaW5kaW5nR3JvdXBzOiBbXSwgcGlwZWxpbmU6IG51bGwsIGluZGV4OiBudWxsIH07XG5cblx0XHRcdGlmICggcmVuZGVyQ29udGV4dC52aWV3cG9ydCApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZVZpZXdwb3J0KCByZW5kZXJDb250ZXh0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByZW5kZXJDb250ZXh0LnNjaXNzb3IgKSB7XG5cblx0XHRcdFx0Y29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZW5kZXJDb250ZXh0LnNjaXNzb3JWYWx1ZTtcblxuXHRcdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50UGFzcy5zZXRTY2lzc29yUmVjdCggeCwgeSwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoIFsgZW5jb2Rlci5maW5pc2goKSBdICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdlYkdQVUJhY2tlbmQ7XG4iLCJpbXBvcnQgeyBTcG90TGlnaHQgfSBmcm9tICcuLi9TcG90TGlnaHQuanMnO1xuXG5jbGFzcyBJRVNTcG90TGlnaHQgZXh0ZW5kcyBTcG90TGlnaHQge1xuXG5cdGNvbnN0cnVjdG9yKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIHBlbnVtYnJhLCBkZWNheSApIHtcblxuXHRcdHN1cGVyKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIHBlbnVtYnJhLCBkZWNheSApO1xuXG5cdFx0dGhpcy5pZXNNYXAgPSBudWxsO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLmllc01hcCA9IHNvdXJjZS5pZXNNYXA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSUVTU3BvdExpZ2h0O1xuIiwiaW1wb3J0IE5vZGVMaWJyYXJ5IGZyb20gJy4uLy4uL2NvbW1vbi9ub2Rlcy9Ob2RlTGlicmFyeS5qcyc7XG5cbi8vIExpZ2h0c1xuaW1wb3J0IHsgUG9pbnRMaWdodCB9IGZyb20gJy4uLy4uLy4uL2xpZ2h0cy9Qb2ludExpZ2h0LmpzJztcbmltcG9ydCB7IFBvaW50TGlnaHROb2RlIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvTm9kZXMuanMnO1xuaW1wb3J0IHsgRGlyZWN0aW9uYWxMaWdodCB9IGZyb20gJy4uLy4uLy4uL2xpZ2h0cy9EaXJlY3Rpb25hbExpZ2h0LmpzJztcbmltcG9ydCB7IERpcmVjdGlvbmFsTGlnaHROb2RlIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvTm9kZXMuanMnO1xuaW1wb3J0IHsgUmVjdEFyZWFMaWdodCB9IGZyb20gJy4uLy4uLy4uL2xpZ2h0cy9SZWN0QXJlYUxpZ2h0LmpzJztcbmltcG9ydCB7IFJlY3RBcmVhTGlnaHROb2RlIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvTm9kZXMuanMnO1xuaW1wb3J0IHsgU3BvdExpZ2h0IH0gZnJvbSAnLi4vLi4vLi4vbGlnaHRzL1Nwb3RMaWdodC5qcyc7XG5pbXBvcnQgeyBTcG90TGlnaHROb2RlIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvTm9kZXMuanMnO1xuaW1wb3J0IHsgQW1iaWVudExpZ2h0IH0gZnJvbSAnLi4vLi4vLi4vbGlnaHRzL0FtYmllbnRMaWdodC5qcyc7XG5pbXBvcnQgeyBBbWJpZW50TGlnaHROb2RlIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvTm9kZXMuanMnO1xuaW1wb3J0IHsgSGVtaXNwaGVyZUxpZ2h0IH0gZnJvbSAnLi4vLi4vLi4vbGlnaHRzL0hlbWlzcGhlcmVMaWdodC5qcyc7XG5pbXBvcnQgeyBIZW1pc3BoZXJlTGlnaHROb2RlIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvTm9kZXMuanMnO1xuaW1wb3J0IHsgTGlnaHRQcm9iZSB9IGZyb20gJy4uLy4uLy4uL2xpZ2h0cy9MaWdodFByb2JlLmpzJztcbmltcG9ydCB7IExpZ2h0UHJvYmVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvTm9kZXMuanMnO1xuaW1wb3J0IElFU1Nwb3RMaWdodCBmcm9tICcuLi8uLi8uLi9saWdodHMvd2ViZ3B1L0lFU1Nwb3RMaWdodC5qcyc7XG5pbXBvcnQgeyBJRVNTcG90TGlnaHROb2RlIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvTm9kZXMuanMnO1xuXG4vLyBUb25lIE1hcHBpbmdcbmltcG9ydCB7IExpbmVhclRvbmVNYXBwaW5nLCBSZWluaGFyZFRvbmVNYXBwaW5nLCBDaW5lb25Ub25lTWFwcGluZywgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nLCBBZ1hUb25lTWFwcGluZywgTmV1dHJhbFRvbmVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGxpbmVhclRvbmVNYXBwaW5nLCByZWluaGFyZFRvbmVNYXBwaW5nLCBjaW5lb25Ub25lTWFwcGluZywgYWNlc0ZpbG1pY1RvbmVNYXBwaW5nLCBhZ3hUb25lTWFwcGluZywgbmV1dHJhbFRvbmVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvZGlzcGxheS9Ub25lTWFwcGluZ0Z1bmN0aW9ucy5qcyc7XG5cbmNsYXNzIEJhc2ljTm9kZUxpYnJhcnkgZXh0ZW5kcyBOb2RlTGlicmFyeSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5hZGRMaWdodCggUG9pbnRMaWdodE5vZGUsIFBvaW50TGlnaHQgKTtcblx0XHR0aGlzLmFkZExpZ2h0KCBEaXJlY3Rpb25hbExpZ2h0Tm9kZSwgRGlyZWN0aW9uYWxMaWdodCApO1xuXHRcdHRoaXMuYWRkTGlnaHQoIFJlY3RBcmVhTGlnaHROb2RlLCBSZWN0QXJlYUxpZ2h0ICk7XG5cdFx0dGhpcy5hZGRMaWdodCggU3BvdExpZ2h0Tm9kZSwgU3BvdExpZ2h0ICk7XG5cdFx0dGhpcy5hZGRMaWdodCggQW1iaWVudExpZ2h0Tm9kZSwgQW1iaWVudExpZ2h0ICk7XG5cdFx0dGhpcy5hZGRMaWdodCggSGVtaXNwaGVyZUxpZ2h0Tm9kZSwgSGVtaXNwaGVyZUxpZ2h0ICk7XG5cdFx0dGhpcy5hZGRMaWdodCggTGlnaHRQcm9iZU5vZGUsIExpZ2h0UHJvYmUgKTtcblx0XHR0aGlzLmFkZExpZ2h0KCBJRVNTcG90TGlnaHROb2RlLCBJRVNTcG90TGlnaHQgKTtcblxuXHRcdHRoaXMuYWRkVG9uZU1hcHBpbmcoIGxpbmVhclRvbmVNYXBwaW5nLCBMaW5lYXJUb25lTWFwcGluZyApO1xuXHRcdHRoaXMuYWRkVG9uZU1hcHBpbmcoIHJlaW5oYXJkVG9uZU1hcHBpbmcsIFJlaW5oYXJkVG9uZU1hcHBpbmcgKTtcblx0XHR0aGlzLmFkZFRvbmVNYXBwaW5nKCBjaW5lb25Ub25lTWFwcGluZywgQ2luZW9uVG9uZU1hcHBpbmcgKTtcblx0XHR0aGlzLmFkZFRvbmVNYXBwaW5nKCBhY2VzRmlsbWljVG9uZU1hcHBpbmcsIEFDRVNGaWxtaWNUb25lTWFwcGluZyApO1xuXHRcdHRoaXMuYWRkVG9uZU1hcHBpbmcoIGFneFRvbmVNYXBwaW5nLCBBZ1hUb25lTWFwcGluZyApO1xuXHRcdHRoaXMuYWRkVG9uZU1hcHBpbmcoIG5ldXRyYWxUb25lTWFwcGluZywgTmV1dHJhbFRvbmVNYXBwaW5nICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2ljTm9kZUxpYnJhcnk7XG4iLCJpbXBvcnQgUmVuZGVyZXIgZnJvbSAnLi4vY29tbW9uL1JlbmRlcmVyLmpzJztcbmltcG9ydCBXZWJHTEJhY2tlbmQgZnJvbSAnLi4vd2ViZ2wtZmFsbGJhY2svV2ViR0xCYWNrZW5kLmpzJztcbmltcG9ydCBXZWJHUFVCYWNrZW5kIGZyb20gJy4vV2ViR1BVQmFja2VuZC5qcyc7XG5pbXBvcnQgQmFzaWNOb2RlTGlicmFyeSBmcm9tICcuL25vZGVzL0Jhc2ljTm9kZUxpYnJhcnkuanMnO1xuXG5jbGFzcyBXZWJHUFVSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyA9IHt9ICkge1xuXG5cdFx0bGV0IEJhY2tlbmRDbGFzcztcblxuXHRcdGlmICggcGFyYW1ldGVycy5mb3JjZVdlYkdMICkge1xuXG5cdFx0XHRCYWNrZW5kQ2xhc3MgPSBXZWJHTEJhY2tlbmQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRCYWNrZW5kQ2xhc3MgPSBXZWJHUFVCYWNrZW5kO1xuXG5cdFx0XHRwYXJhbWV0ZXJzLmdldEZhbGxiYWNrID0gKCkgPT4ge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdQVVJlbmRlcmVyOiBXZWJHUFUgaXMgbm90IGF2YWlsYWJsZSwgcnVubmluZyB1bmRlciBXZWJHTDIgYmFja2VuZC4nICk7XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBXZWJHTEJhY2tlbmQoIHBhcmFtZXRlcnMgKTtcblxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGJhY2tlbmQgPSBuZXcgQmFja2VuZENsYXNzKCBwYXJhbWV0ZXJzICk7XG5cblx0XHRzdXBlciggYmFja2VuZCwgcGFyYW1ldGVycyApO1xuXG5cdFx0dGhpcy5saWJyYXJ5ID0gbmV3IEJhc2ljTm9kZUxpYnJhcnkoKTtcblxuXHRcdHRoaXMuaXNXZWJHUFVSZW5kZXJlciA9IHRydWU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdlYkdQVVJlbmRlcmVyO1xuIiwiaW1wb3J0IHsgR3JvdXAgfSBmcm9tICcuLi8uLi9vYmplY3RzL0dyb3VwLmpzJztcblxuY2xhc3MgQnVuZGxlR3JvdXAgZXh0ZW5kcyBHcm91cCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0J1bmRsZUdyb3VwID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdCdW5kbGVHcm91cCc7XG5cblx0XHR0aGlzLnN0YXRpYyA9IHRydWU7XG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblxuXHR9XG5cblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1bmRsZUdyb3VwO1xuIiwiaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuLi8uLi9tYXRlcmlhbHMvbm9kZXMvTm9kZU1hdGVyaWFsLmpzJztcbmltcG9ydCB7IHZlYzQsIHJlbmRlck91dHB1dCB9IGZyb20gJy4uLy4uL25vZGVzL1RTTC5qcyc7XG5pbXBvcnQgeyBMaW5lYXJTUkdCQ29sb3JTcGFjZSwgTm9Ub25lTWFwcGluZyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgUXVhZE1lc2ggZnJvbSAnLi4vLi4vcmVuZGVyZXJzL2NvbW1vbi9RdWFkTWVzaC5qcyc7XG5cbmNvbnN0IF9tYXRlcmlhbCA9IC8qQF9fUFVSRV9fKi8gbmV3IE5vZGVNYXRlcmlhbCgpO1xuY29uc3QgX3F1YWRNZXNoID0gLypAX19QVVJFX18qLyBuZXcgUXVhZE1lc2goIF9tYXRlcmlhbCApO1xuXG5jbGFzcyBQb3N0UHJvY2Vzc2luZyB7XG5cblx0Y29uc3RydWN0b3IoIHJlbmRlcmVyLCBvdXRwdXROb2RlID0gdmVjNCggMCwgMCwgMSwgMSApICkge1xuXG5cdFx0dGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXHRcdHRoaXMub3V0cHV0Tm9kZSA9IG91dHB1dE5vZGU7XG5cblx0XHR0aGlzLm91dHB1dENvbG9yVHJhbnNmb3JtID0gdHJ1ZTtcblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0X21hdGVyaWFsLm5hbWUgPSAnUG9zdFByb2Nlc3NpbmcnO1xuXG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuXG5cdFx0Y29uc3QgdG9uZU1hcHBpbmcgPSByZW5kZXJlci50b25lTWFwcGluZztcblx0XHRjb25zdCBvdXRwdXRDb2xvclNwYWNlID0gcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZTtcblxuXHRcdHJlbmRlcmVyLnRvbmVNYXBwaW5nID0gTm9Ub25lTWFwcGluZztcblx0XHRyZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID0gTGluZWFyU1JHQkNvbG9yU3BhY2U7XG5cblx0XHQvL1xuXG5cdFx0X3F1YWRNZXNoLnJlbmRlciggcmVuZGVyZXIgKTtcblxuXHRcdC8vXG5cblx0XHRyZW5kZXJlci50b25lTWFwcGluZyA9IHRvbmVNYXBwaW5nO1xuXHRcdHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPSBvdXRwdXRDb2xvclNwYWNlO1xuXG5cdH1cblxuXHR1cGRhdGUoKSB7XG5cblx0XHRpZiAoIHRoaXMubmVlZHNVcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcblxuXHRcdFx0Y29uc3QgdG9uZU1hcHBpbmcgPSByZW5kZXJlci50b25lTWFwcGluZztcblx0XHRcdGNvbnN0IG91dHB1dENvbG9yU3BhY2UgPSByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlO1xuXG5cdFx0XHRfcXVhZE1lc2gubWF0ZXJpYWwuZnJhZ21lbnROb2RlID0gdGhpcy5vdXRwdXRDb2xvclRyYW5zZm9ybSA9PT0gdHJ1ZSA/IHJlbmRlck91dHB1dCggdGhpcy5vdXRwdXROb2RlLCB0b25lTWFwcGluZywgb3V0cHV0Q29sb3JTcGFjZSApIDogdGhpcy5vdXRwdXROb2RlLmNvbnRleHQoIHsgdG9uZU1hcHBpbmcsIG91dHB1dENvbG9yU3BhY2UgfSApO1xuXHRcdFx0X3F1YWRNZXNoLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRhc3luYyByZW5kZXJBc3luYygpIHtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cblx0XHRjb25zdCB0b25lTWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xuXHRcdGNvbnN0IG91dHB1dENvbG9yU3BhY2UgPSByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlO1xuXG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXHRcdHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPSBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcblxuXHRcdC8vXG5cblx0XHRhd2FpdCBfcXVhZE1lc2gucmVuZGVyQXN5bmMoIHJlbmRlcmVyICk7XG5cblx0XHQvL1xuXG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSB0b25lTWFwcGluZztcblx0XHRyZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID0gb3V0cHV0Q29sb3JTcGFjZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9zdFByb2Nlc3Npbmc7XG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL21hdGgvQ29sb3IuanMnO1xuXG4vLyByZW5kZXJlciBzdGF0ZVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVJlbmRlcmVyU3RhdGUoIHJlbmRlcmVyLCBzdGF0ZSA9IHt9ICkge1xuXG5cdHN0YXRlLnRvbmVNYXBwaW5nID0gcmVuZGVyZXIudG9uZU1hcHBpbmc7XG5cdHN0YXRlLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSByZW5kZXJlci50b25lTWFwcGluZ0V4cG9zdXJlO1xuXHRzdGF0ZS5vdXRwdXRDb2xvclNwYWNlID0gcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZTtcblx0c3RhdGUucmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdHN0YXRlLmFjdGl2ZUN1YmVGYWNlID0gcmVuZGVyZXIuZ2V0QWN0aXZlQ3ViZUZhY2UoKTtcblx0c3RhdGUuYWN0aXZlTWlwbWFwTGV2ZWwgPSByZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpO1xuXHRzdGF0ZS5yZW5kZXJPYmplY3RGdW5jdGlvbiA9IHJlbmRlcmVyLmdldFJlbmRlck9iamVjdEZ1bmN0aW9uKCk7XG5cdHN0YXRlLnBpeGVsUmF0aW8gPSByZW5kZXJlci5nZXRQaXhlbFJhdGlvKCk7XG5cdHN0YXRlLm1ydCA9IHJlbmRlcmVyLmdldE1SVCgpO1xuXHRzdGF0ZS5jbGVhckNvbG9yID0gcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvciggc3RhdGUuY2xlYXJDb2xvciB8fCBuZXcgQ29sb3IoKSApO1xuXHRzdGF0ZS5jbGVhckFscGhhID0gcmVuZGVyZXIuZ2V0Q2xlYXJBbHBoYSgpO1xuXHRzdGF0ZS5hdXRvQ2xlYXIgPSByZW5kZXJlci5hdXRvQ2xlYXI7XG5cdHN0YXRlLnNjaXNzb3JUZXN0ID0gcmVuZGVyZXIuZ2V0U2Npc3NvclRlc3QoKTtcblxuXHRyZXR1cm4gc3RhdGU7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0UmVuZGVyZXJTdGF0ZSggcmVuZGVyZXIsIHN0YXRlICkge1xuXG5cdHN0YXRlID0gc2F2ZVJlbmRlcmVyU3RhdGUoIHJlbmRlcmVyLCBzdGF0ZSApO1xuXG5cdHJlbmRlcmVyLnNldE1SVCggbnVsbCApO1xuXHRyZW5kZXJlci5zZXRSZW5kZXJPYmplY3RGdW5jdGlvbiggbnVsbCApO1xuXHRyZW5kZXJlci5zZXRDbGVhckNvbG9yKCAweDAwMDAwMCwgMSApO1xuXHRyZW5kZXJlci5hdXRvQ2xlYXIgPSB0cnVlO1xuXG5cdHJldHVybiBzdGF0ZTtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZVJlbmRlcmVyU3RhdGUoIHJlbmRlcmVyLCBzdGF0ZSApIHtcblxuXHRyZW5kZXJlci50b25lTWFwcGluZyA9IHN0YXRlLnRvbmVNYXBwaW5nO1xuXHRyZW5kZXJlci50b25lTWFwcGluZ0V4cG9zdXJlID0gc3RhdGUudG9uZU1hcHBpbmdFeHBvc3VyZTtcblx0cmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA9IHN0YXRlLm91dHB1dENvbG9yU3BhY2U7XG5cdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc3RhdGUucmVuZGVyVGFyZ2V0LCBzdGF0ZS5hY3RpdmVDdWJlRmFjZSwgc3RhdGUuYWN0aXZlTWlwbWFwTGV2ZWwgKTtcblx0cmVuZGVyZXIuc2V0UmVuZGVyT2JqZWN0RnVuY3Rpb24oIHN0YXRlLnJlbmRlck9iamVjdEZ1bmN0aW9uICk7XG5cdHJlbmRlcmVyLnNldFBpeGVsUmF0aW8oIHN0YXRlLnBpeGVsUmF0aW8gKTtcblx0cmVuZGVyZXIuc2V0TVJUKCBzdGF0ZS5tcnQgKTtcblx0cmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggc3RhdGUuY2xlYXJDb2xvciwgc3RhdGUuY2xlYXJBbHBoYSApO1xuXHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBzdGF0ZS5hdXRvQ2xlYXI7XG5cdHJlbmRlcmVyLnNldFNjaXNzb3JUZXN0KCBzdGF0ZS5zY2lzc29yVGVzdCApO1xuXG59XG5cbi8vIHJlbmRlcmVyIGFuZCBzY2VuZSBzdGF0ZVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVJlbmRlcmVyQW5kU2NlbmVTdGF0ZSggcmVuZGVyZXIsIHNjZW5lLCBzdGF0ZSA9IHt9ICkge1xuXG5cdHN0YXRlID0gc2F2ZVJlbmRlcmVyU3RhdGUoIHJlbmRlcmVyLCBzdGF0ZSApO1xuXHRzdGF0ZS5iYWNrZ3JvdW5kID0gc2NlbmUuYmFja2dyb3VuZDtcblx0c3RhdGUuYmFja2dyb3VuZE5vZGUgPSBzY2VuZS5iYWNrZ3JvdW5kTm9kZTtcblx0c3RhdGUub3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0cmV0dXJuIHN0YXRlO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldFJlbmRlcmVyQW5kU2NlbmVTdGF0ZSggcmVuZGVyZXIsIHNjZW5lLCBzdGF0ZSApIHtcblxuXHRzdGF0ZSA9IHNhdmVSZW5kZXJlckFuZFNjZW5lU3RhdGUoIHJlbmRlcmVyLCBzY2VuZSwgc3RhdGUgKTtcblxuXHRzY2VuZS5iYWNrZ3JvdW5kID0gbnVsbDtcblx0c2NlbmUuYmFja2dyb3VuZE5vZGUgPSBudWxsO1xuXHRzY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcblxuXHRyZXR1cm4gc3RhdGU7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVSZW5kZXJlckFuZFNjZW5lU3RhdGUoIHJlbmRlcmVyLCBzY2VuZSwgc3RhdGUgKSB7XG5cblx0cmVzdG9yZVJlbmRlcmVyU3RhdGUoIHJlbmRlcmVyLCBzdGF0ZSApO1xuXG5cdHNjZW5lLmJhY2tncm91bmQgPSBzdGF0ZS5iYWNrZ3JvdW5kO1xuXHRzY2VuZS5iYWNrZ3JvdW5kTm9kZSA9IHN0YXRlLmJhY2tncm91bmROb2RlO1xuXHRzY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gc3RhdGUub3ZlcnJpZGVNYXRlcmlhbDtcblxufVxuIiwiaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uL3RleHR1cmVzL1RleHR1cmUuanMnO1xuaW1wb3J0IHsgTGluZWFyRmlsdGVyIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcblxuY2xhc3MgU3RvcmFnZVRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaW1hZ2UgPSB7IHdpZHRoLCBoZWlnaHQgfTtcblxuXHRcdHRoaXMubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXHRcdHRoaXMubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXG5cdFx0dGhpcy5pc1N0b3JhZ2VUZXh0dXJlID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZVRleHR1cmU7XG4iLCJpbXBvcnQgU3RvcmFnZUJ1ZmZlckF0dHJpYnV0ZSBmcm9tICcuL1N0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUuanMnO1xuXG5jbGFzcyBJbmRpcmVjdFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBTdG9yYWdlQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdFx0c3VwZXIoIGFycmF5LCBpdGVtU2l6ZSwgVWludDMyQXJyYXkgKTtcblxuXHRcdHRoaXMuaXNJbmRpcmVjdFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJbmRpcmVjdFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGU7XG4iLCJpbXBvcnQgeyBub2RlT2JqZWN0LCBmbG9hdCB9IGZyb20gJy4uLy4uL25vZGVzL3RzbC9UU0xCYXNlLmpzJztcblxuaW1wb3J0IHsgTG9hZGVyIH0gZnJvbSAnLi4vTG9hZGVyLmpzJztcbmltcG9ydCB7IEZpbGVMb2FkZXIgfSBmcm9tICcuLi8uLi9sb2FkZXJzL0ZpbGVMb2FkZXIuanMnO1xuXG5jbGFzcyBOb2RlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0XHR0aGlzLnRleHR1cmVzID0ge307XG5cdFx0dGhpcy5ub2RlcyA9IHt9O1xuXG5cdH1cblxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgKCB0ZXh0ICkgPT4ge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggdGhpcy5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fVxuXG5cdHBhcnNlTm9kZXMoIGpzb24gKSB7XG5cblx0XHRjb25zdCBub2RlcyA9IHt9O1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IG5vZGVKU09OIG9mIGpzb24gKSB7XG5cblx0XHRcdFx0Y29uc3QgeyB1dWlkLCB0eXBlIH0gPSBub2RlSlNPTjtcblxuXHRcdFx0XHRub2Rlc1sgdXVpZCBdID0gdGhpcy5jcmVhdGVOb2RlRnJvbVR5cGUoIHR5cGUgKTtcblx0XHRcdFx0bm9kZXNbIHV1aWQgXS51dWlkID0gdXVpZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtZXRhID0geyBub2RlcywgdGV4dHVyZXM6IHRoaXMudGV4dHVyZXMgfTtcblxuXHRcdFx0Zm9yICggY29uc3Qgbm9kZUpTT04gb2YganNvbiApIHtcblxuXHRcdFx0XHRub2RlSlNPTi5tZXRhID0gbWV0YTtcblxuXHRcdFx0XHRjb25zdCBub2RlID0gbm9kZXNbIG5vZGVKU09OLnV1aWQgXTtcblx0XHRcdFx0bm9kZS5kZXNlcmlhbGl6ZSggbm9kZUpTT04gKTtcblxuXHRcdFx0XHRkZWxldGUgbm9kZUpTT04ubWV0YTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vZGVzO1xuXG5cdH1cblxuXHRwYXJzZSgganNvbiApIHtcblxuXHRcdGNvbnN0IG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGVGcm9tVHlwZSgganNvbi50eXBlICk7XG5cdFx0bm9kZS51dWlkID0ganNvbi51dWlkO1xuXG5cdFx0Y29uc3Qgbm9kZXMgPSB0aGlzLnBhcnNlTm9kZXMoIGpzb24ubm9kZXMgKTtcblx0XHRjb25zdCBtZXRhID0geyBub2RlcywgdGV4dHVyZXM6IHRoaXMudGV4dHVyZXMgfTtcblxuXHRcdGpzb24ubWV0YSA9IG1ldGE7XG5cblx0XHRub2RlLmRlc2VyaWFsaXplKCBqc29uICk7XG5cblx0XHRkZWxldGUganNvbi5tZXRhO1xuXG5cdFx0cmV0dXJuIG5vZGU7XG5cblx0fVxuXG5cdHNldFRleHR1cmVzKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudGV4dHVyZXMgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0Tm9kZXMoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5ub2RlcyA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjcmVhdGVOb2RlRnJvbVR5cGUoIHR5cGUgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9kZXNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTm9kZUxvYWRlcjogTm9kZSB0eXBlIG5vdCBmb3VuZDonLCB0eXBlICk7XG5cdFx0XHRyZXR1cm4gZmxvYXQoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlT2JqZWN0KCBuZXcgdGhpcy5ub2Rlc1sgdHlwZSBdKCkgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTm9kZUxvYWRlcjtcbiIsImltcG9ydCB7IE1hdGVyaWFsTG9hZGVyIH0gZnJvbSAnLi4vLi4vbG9hZGVycy9NYXRlcmlhbExvYWRlci5qcyc7XG5cbmNsYXNzIE5vZGVNYXRlcmlhbExvYWRlciBleHRlbmRzIE1hdGVyaWFsTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0XHR0aGlzLm5vZGVzID0ge307XG5cdFx0dGhpcy5ub2RlTWF0ZXJpYWxzID0ge307XG5cblx0fVxuXG5cdHBhcnNlKCBqc29uICkge1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBzdXBlci5wYXJzZSgganNvbiApO1xuXG5cdFx0Y29uc3Qgbm9kZXMgPSB0aGlzLm5vZGVzO1xuXHRcdGNvbnN0IGlucHV0Tm9kZXMgPSBqc29uLmlucHV0Tm9kZXM7XG5cblx0XHRmb3IgKCBjb25zdCBwcm9wZXJ0eSBpbiBpbnB1dE5vZGVzICkge1xuXG5cdFx0XHRjb25zdCB1dWlkID0gaW5wdXROb2Rlc1sgcHJvcGVydHkgXTtcblxuXHRcdFx0bWF0ZXJpYWxbIHByb3BlcnR5IF0gPSBub2Rlc1sgdXVpZCBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdH1cblxuXHRzZXROb2RlcyggdmFsdWUgKSB7XG5cblx0XHR0aGlzLm5vZGVzID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldE5vZGVNYXRlcmlhbHMoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5ub2RlTWF0ZXJpYWxzID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNyZWF0ZU1hdGVyaWFsRnJvbVR5cGUoIHR5cGUgKSB7XG5cblx0XHRjb25zdCBtYXRlcmlhbENsYXNzID0gdGhpcy5ub2RlTWF0ZXJpYWxzWyB0eXBlIF07XG5cblx0XHRpZiAoIG1hdGVyaWFsQ2xhc3MgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBtYXRlcmlhbENsYXNzKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc3VwZXIuY3JlYXRlTWF0ZXJpYWxGcm9tVHlwZSggdHlwZSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlTWF0ZXJpYWxMb2FkZXI7XG4iLCJpbXBvcnQgTm9kZUxvYWRlciBmcm9tICcuL05vZGVMb2FkZXIuanMnO1xuaW1wb3J0IE5vZGVNYXRlcmlhbExvYWRlciBmcm9tICcuL05vZGVNYXRlcmlhbExvYWRlci5qcyc7XG5cbmltcG9ydCB7IE9iamVjdExvYWRlciB9IGZyb20gJy4uLy4uL2xvYWRlcnMvT2JqZWN0TG9hZGVyLmpzJztcblxuY2xhc3MgTm9kZU9iamVjdExvYWRlciBleHRlbmRzIE9iamVjdExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdFx0dGhpcy5ub2RlcyA9IHt9O1xuXHRcdHRoaXMubm9kZU1hdGVyaWFscyA9IHt9O1xuXG5cdFx0dGhpcy5fbm9kZXNKU09OID0gbnVsbDtcblxuXHR9XG5cblx0c2V0Tm9kZXMoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5ub2RlcyA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXROb2RlTWF0ZXJpYWxzKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMubm9kZU1hdGVyaWFscyA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRwYXJzZSgganNvbiwgb25Mb2FkICkge1xuXG5cdFx0dGhpcy5fbm9kZXNKU09OID0ganNvbi5ub2RlcztcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci5wYXJzZSgganNvbiwgb25Mb2FkICk7XG5cblx0XHR0aGlzLl9ub2Rlc0pTT04gPSBudWxsOyAvLyBkaXNwb3NlXG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0cGFyc2VOb2RlcygganNvbiwgdGV4dHVyZXMgKSB7XG5cblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgbG9hZGVyID0gbmV3IE5vZGVMb2FkZXIoKTtcblx0XHRcdGxvYWRlci5zZXROb2RlcyggdGhpcy5ub2RlcyApO1xuXHRcdFx0bG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xuXG5cdFx0XHRyZXR1cm4gbG9hZGVyLnBhcnNlTm9kZXMoIGpzb24gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB7fTtcblxuXHR9XG5cblx0cGFyc2VNYXRlcmlhbHMoIGpzb24sIHRleHR1cmVzICkge1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWxzID0ge307XG5cblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZXMgPSB0aGlzLnBhcnNlTm9kZXMoIHRoaXMuX25vZGVzSlNPTiwgdGV4dHVyZXMgKTtcblxuXHRcdFx0Y29uc3QgbG9hZGVyID0gbmV3IE5vZGVNYXRlcmlhbExvYWRlcigpO1xuXHRcdFx0bG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xuXHRcdFx0bG9hZGVyLnNldE5vZGVzKCBub2RlcyApO1xuXHRcdFx0bG9hZGVyLnNldE5vZGVNYXRlcmlhbHMoIHRoaXMubm9kZU1hdGVyaWFscyApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGpzb25bIGkgXTtcblxuXHRcdFx0XHRtYXRlcmlhbHNbIGRhdGEudXVpZCBdID0gbG9hZGVyLnBhcnNlKCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRlcmlhbHM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVPYmplY3RMb2FkZXI7XG4iLCJpbXBvcnQgeyBHcm91cCB9IGZyb20gJy4vR3JvdXAuanMnO1xuXG5jbGFzcyBDbGlwcGluZ0dyb3VwIGV4dGVuZHMgR3JvdXAge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNDbGlwcGluZ0dyb3VwID0gdHJ1ZTtcblx0XHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gW107XG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBmYWxzZTtcblx0XHR0aGlzLmNsaXBTaGFkb3dzID0gZmFsc2U7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IENsaXBwaW5nR3JvdXAgfTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3BaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFTztBQUNBO0FBQ0E7O0FBRUE7O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7O0FBRUE7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3Ulk7QUFDWjtBQUNBO0FBQ0E7O0FBRVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFWTtBQUNBO0FBQ0E7QUFDQTs7QUMzQlo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBT0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNsaUJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNsQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2hFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN6REE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUMxREE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQzlHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDM0RBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDOURBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2xGQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN0QkE7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRU87O0FBRVA7O0FBRU87O0FBRVA7O0FBRUE7O0FBRU87QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVPOztBQVFQOztBQUVBOztBQUVPOztBQUVBOztBQUVBOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVPOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDQTtBQUNBOztBQUVQO0FBQ0E7O0FDanBCQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUlPO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQ3REUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUM1R0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FBRVA7O0FDL0hBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FDMUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQzFUQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSU87QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRU87QUFDQTs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xaQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FBRVA7O0FBRUE7O0FBRU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUN4SkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTztBQUNBOztBQUVQO0FBQ0E7O0FDekVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FDbEVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FBRVA7O0FDeEdPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7OztBQzdGQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUNyS1A7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FDM0JQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTztBQUNBOztBQUVQOztBQzFEQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87QUFDQTs7QUFFQTtBQUNBOztBQUVQOztBQ2hLQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQUVQOztBQzdGQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FBRVA7O0FDOUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FBRVA7O0FDN0NBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87QUFDQTs7QUFFUDtBQUNBOztBQzFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQ3BDQTtBQUNBOztBQUVQOztBQ0RBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQUVQOztBQzNEQTtBQUNBOzs7QUF3Qk87O0FBRVA7O0FBRUE7O0FDMUJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUMxSEE7O0FDQ1A7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQy9CUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FDM0NQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTztBQUNBOztBQUVQOztBQUVPOztBQzliQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJTztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3BFTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTztBQUNBOztBQ3BDQTs7QUFFQTs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFQTs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFQTs7QUFFUDs7QUFFQTs7O0FBR087O0FBRUE7O0FBRVA7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDckZPOztBQ0dBO0FBQ0E7O0FBRUE7QUFDQTs7QUNIUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUMzRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUNoQ1A7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUFFUDs7QUFFTzs7QUFFUDtBQUNBOztBQUVBOztBQ25KQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87QUFDQTs7QUMzTVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FDeENBOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJQOztBQUVPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTs7QUFFQTtBQUNBOztBQUVBOztBQUVQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FDWkE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUNsR1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBSU87O0FDckVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQ2xiQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQ3RDUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FDeklQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQ2ZQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FDbkhQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87QUFDQTs7QUMxTFA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPO0FBQ0E7QUFDQTs7QUFFUDs7QUFFTzs7QUFFUDtBQUNBOztBQUVBOztBQ2pNQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FDcFFQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3RCQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNyQkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUNoRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDaEJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTs7QUFFTztBQUNBO0FBQ0E7O0FBRVA7O0FBRU87QUFDQTtBQUNBO0FBQ0E7O0FBRVA7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FDM0tBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUlPO0FBQ0E7O0FDMUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQzFCUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUlBOztBQUVBO0FBQ087O0FBRVA7QUFDTzs7QUFFUDs7QUFFQTtBQUNPOztBQUVQO0FBQ087O0FBRVA7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVPO0FBQ0E7QUFDQTs7QUFFUDs7QUN4S0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FDZlA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBSU87QUFDQTtBQUNBOztBQ3RMUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDeHJCQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDckpBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3BCQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDbERBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQ3JCUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDbmNPO0FBQ0E7O0FDTVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDckNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FDdkJQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ2xFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRU87O0FDNUpQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3hCQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM3QkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDUEE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDakVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3hFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUNYQTs7QUFFQTs7QUFFQTs7QUNJQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQzVEQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNuQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3hFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQ2JBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUNYQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FDUkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDbkRBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDeENBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDdG5CQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3JSQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUNwT1A7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FDOUhBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDOUZBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDL09BOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQzVFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDM0NBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQzlCQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQ3ZCUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNqREE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNuQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQ25EUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM3SEE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDdkJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2hDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQzNGUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN6R0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDM0RlOztBQUVmOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3hEQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFZTs7QUFFZjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDMWFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FDdkdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDbkRPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTzs7QUFFUDs7QUFFTztBQUNBOztBQ1RQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQzFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN4UUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUMzSEE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDUkE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUNYQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNkQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNaQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM1VEE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDdk5BOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDNU5BOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNsQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDNURBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDdERBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDM1dBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQy9CQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUMvQlA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBSU87O0FDMUdQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDckJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUMzREE7O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUNsRkE7O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQ1RBO0FBQ087QUFDQTtBQUNBO0FBQ0E7O0FDUFA7OztBQUtPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlBOztBQUVPOztBQ2pHQTtBQUNBO0FBQ0E7O0FBRVA7O0FBRU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFTzs7QUFFUDtBQUNBOztBQUVBOztBQUVPOztBQUVQO0FBQ0E7O0FBRUE7O0FDMUJPO0FBQ0E7QUFDQTtBQUNBOztBQ0ZBOztBQUVQOztBQUVBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQ2JPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQ3pDTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDVEE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUNyQ1A7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTztBQUNBOztBQy9DUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRU87O0FDalVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDekNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FBRUE7O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQ3RGQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNaQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNYQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUNsRlA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQUVBOztBQUVQOztBQUVBOztBQUVBOztBQ3ZMTzs7QUFFUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHTzs7QUFFUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQ3JCQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FDdEVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQ3JCUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFJTztBQUNBO0FBQ0E7O0FDcEZQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FBRUE7O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FDN0dBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQ3BCUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUM1SUE7O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFTzs7QUFFUDtBQUNBOztBQUVBOztBQUVPOztBQUVQO0FBQ0E7O0FBRUE7O0FDM0ZPOztBQUVQOztBQUVBOztBQUVPOztBQUVQOztBQUVBOztBQUVPOztBQUVQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDM0ZBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FDcEJQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUlPO0FBQ0E7QUFDQTs7QUNqWFA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUN6R1A7O0FBRU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUFFQTtBQUNBO0FBQ0E7O0FDcEZQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFTztBQUNBOztBQzVHUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUlPOztBQ3BLUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQ3BmUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQzdDUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQ2hDUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUlPOztBQ3ZCUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUNySFA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFJQTs7QUFFTztBQUNBO0FBQ0E7QUFDQTs7QUM3RlA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJQTs7QUFFTztBQUNBO0FBQ0E7O0FDbENQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBSU87O0FDOUZQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7O0FBRU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUFFTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUMvRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUNqUFA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUN2a0JQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDekhPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQ0hBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQOztBQUVBOztBQUVPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFJTzs7QUNwUEE7O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUNoRk87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQ2JBO0FBQ0E7Ozs7QUFVTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVBOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVBOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVBOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQzl5Q1A7QUFDQTs7O0FBTU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7OztBQU1POztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDTztBQUNBOztBQUVQO0FBQ087QUFDQTs7QUFFQTs7QUFFQTs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFQTtBQUNQO0FBQ087QUFDQTs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFTztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FDOURQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUNqQkE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDekJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDU0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3JKQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNiQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3ZEQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDWkE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3BDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQ1RBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2RBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNaQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQzFCQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUNySUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDMUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQ3h5QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUlBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNuOUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN0TEE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNYQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUN6QkE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN4RkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDNUZBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2hDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNiQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDL0NBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2xEQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNSQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNoQkE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2xKQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNEQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUMvZ0JBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDdEtBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDWkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ25DQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNuR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDaHdEQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNwQkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDTEE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDakNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ1ZBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDbEJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDMVZBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDakNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ25EQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDemdDQTtBQUNBO0FBQ0E7O0FBUUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ25NQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDNVBBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDeHdCQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN2UUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDbjdCQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ25DQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2pDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FDWkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3hIQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDMXBETztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQW1DTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQVFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFVQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ2JBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDakJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ1hBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNwQkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM5VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDdnNDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDaktBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ1NBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUM5OUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQzNUQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQ3ZWQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDem9CQTtBQUNBO0FBQ0E7OztBQWVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3RqREE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDM0NBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3JDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2xCQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQ3JGQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNsRkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNoQkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDUEE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDN0hBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDdkRBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNyRkE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7In0=
